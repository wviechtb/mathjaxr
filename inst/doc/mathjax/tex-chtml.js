/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 74:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ SystemExternal)
/* harmony export */ });
/* harmony import */ var _variables_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(714);
/* harmony import */ var _lib_external_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);


const windowSupported = (() => !(typeof window === 'undefined'))();
const documentSupported = (() => windowSupported && !(typeof window.document === 'undefined'))();
const webworker = (() => !(typeof DedicatedWorkerGlobalScope === 'undefined'))();
const nodeRequire = () => {
    try {
        return eval('require');
    }
    catch (_err) {
        return (_file) => null;
    }
};
const SystemExternal = {
    extRequire(library) {
        if (typeof process !== 'undefined' && typeof require !== 'undefined') {
            return nodeRequire()(library);
        }
        return null;
    },
    windowSupported: windowSupported,
    documentSupported: documentSupported,
    webworker: webworker,
    xmldom: _lib_external_js__WEBPACK_IMPORTED_MODULE_1__/* .xmldom */ .Gb,
    document: _lib_external_js__WEBPACK_IMPORTED_MODULE_1__/* .document */ .Al,
    fs: documentSupported || webworker ? null : nodeRequire()('fs'),
    url: _variables_js__WEBPACK_IMPORTED_MODULE_0__/* .Variables */ .u.url,
    jsonPath: (function () {
        if (documentSupported || webworker) {
            return _variables_js__WEBPACK_IMPORTED_MODULE_0__/* .Variables */ .u.url;
        }
        if (process.env.SRE_JSON_PATH || global.SRE_JSON_PATH) {
            return process.env.SRE_JSON_PATH || global.SRE_JSON_PATH;
        }
        try {
            const path = nodeRequire().resolve('speech-rule-engine');
            return path.replace(/sre\.js$/, '') + 'mathmaps';
        }
        catch (_err) {
        }
        try {
            const path = nodeRequire().resolve('.');
            return path.replace(/sre\.js$/, '') + 'mathmaps';
        }
        catch (_err) {
        }
        return typeof __dirname !== 'undefined'
            ? __dirname + (__dirname.match(/lib?$/) ? '/mathmaps' : '/lib/mathmaps')
            : process.cwd() + '/lib/mathmaps';
    })(),
    xpath: _lib_external_js__WEBPACK_IMPORTED_MODULE_1__/* .xpath */ .Oe
};
//# sourceMappingURL=system_external.js.map

/***/ }),

/***/ 159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var freeze = (__webpack_require__(870).freeze);

/**
 * The entities that are predefined in every XML document.
 *
 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML
 *      Wikipedia
 */
exports.XML_ENTITIES = freeze({
	amp: '&',
	apos: "'",
	gt: '>',
	lt: '<',
	quot: '"',
});

/**
 * A map of all entities that are detected in an HTML document.
 * They contain all entries from `XML_ENTITIES`.
 *
 * @see {@link XML_ENTITIES}
 * @see {@link DOMParser.parseFromString}
 * @see {@link DOMImplementation.prototype.createHTMLDocument}
 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5)
 *      Spec
 * @see https://html.spec.whatwg.org/entities.json JSON
 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML
 *      Wikipedia (HTML)
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML
 *      Wikpedia (XHTML)
 */
exports.HTML_ENTITIES = freeze({
	Aacute: '\u00C1',
	aacute: '\u00E1',
	Abreve: '\u0102',
	abreve: '\u0103',
	ac: '\u223E',
	acd: '\u223F',
	acE: '\u223E\u0333',
	Acirc: '\u00C2',
	acirc: '\u00E2',
	acute: '\u00B4',
	Acy: '\u0410',
	acy: '\u0430',
	AElig: '\u00C6',
	aelig: '\u00E6',
	af: '\u2061',
	Afr: '\uD835\uDD04',
	afr: '\uD835\uDD1E',
	Agrave: '\u00C0',
	agrave: '\u00E0',
	alefsym: '\u2135',
	aleph: '\u2135',
	Alpha: '\u0391',
	alpha: '\u03B1',
	Amacr: '\u0100',
	amacr: '\u0101',
	amalg: '\u2A3F',
	AMP: '\u0026',
	amp: '\u0026',
	And: '\u2A53',
	and: '\u2227',
	andand: '\u2A55',
	andd: '\u2A5C',
	andslope: '\u2A58',
	andv: '\u2A5A',
	ang: '\u2220',
	ange: '\u29A4',
	angle: '\u2220',
	angmsd: '\u2221',
	angmsdaa: '\u29A8',
	angmsdab: '\u29A9',
	angmsdac: '\u29AA',
	angmsdad: '\u29AB',
	angmsdae: '\u29AC',
	angmsdaf: '\u29AD',
	angmsdag: '\u29AE',
	angmsdah: '\u29AF',
	angrt: '\u221F',
	angrtvb: '\u22BE',
	angrtvbd: '\u299D',
	angsph: '\u2222',
	angst: '\u00C5',
	angzarr: '\u237C',
	Aogon: '\u0104',
	aogon: '\u0105',
	Aopf: '\uD835\uDD38',
	aopf: '\uD835\uDD52',
	ap: '\u2248',
	apacir: '\u2A6F',
	apE: '\u2A70',
	ape: '\u224A',
	apid: '\u224B',
	apos: '\u0027',
	ApplyFunction: '\u2061',
	approx: '\u2248',
	approxeq: '\u224A',
	Aring: '\u00C5',
	aring: '\u00E5',
	Ascr: '\uD835\uDC9C',
	ascr: '\uD835\uDCB6',
	Assign: '\u2254',
	ast: '\u002A',
	asymp: '\u2248',
	asympeq: '\u224D',
	Atilde: '\u00C3',
	atilde: '\u00E3',
	Auml: '\u00C4',
	auml: '\u00E4',
	awconint: '\u2233',
	awint: '\u2A11',
	backcong: '\u224C',
	backepsilon: '\u03F6',
	backprime: '\u2035',
	backsim: '\u223D',
	backsimeq: '\u22CD',
	Backslash: '\u2216',
	Barv: '\u2AE7',
	barvee: '\u22BD',
	Barwed: '\u2306',
	barwed: '\u2305',
	barwedge: '\u2305',
	bbrk: '\u23B5',
	bbrktbrk: '\u23B6',
	bcong: '\u224C',
	Bcy: '\u0411',
	bcy: '\u0431',
	bdquo: '\u201E',
	becaus: '\u2235',
	Because: '\u2235',
	because: '\u2235',
	bemptyv: '\u29B0',
	bepsi: '\u03F6',
	bernou: '\u212C',
	Bernoullis: '\u212C',
	Beta: '\u0392',
	beta: '\u03B2',
	beth: '\u2136',
	between: '\u226C',
	Bfr: '\uD835\uDD05',
	bfr: '\uD835\uDD1F',
	bigcap: '\u22C2',
	bigcirc: '\u25EF',
	bigcup: '\u22C3',
	bigodot: '\u2A00',
	bigoplus: '\u2A01',
	bigotimes: '\u2A02',
	bigsqcup: '\u2A06',
	bigstar: '\u2605',
	bigtriangledown: '\u25BD',
	bigtriangleup: '\u25B3',
	biguplus: '\u2A04',
	bigvee: '\u22C1',
	bigwedge: '\u22C0',
	bkarow: '\u290D',
	blacklozenge: '\u29EB',
	blacksquare: '\u25AA',
	blacktriangle: '\u25B4',
	blacktriangledown: '\u25BE',
	blacktriangleleft: '\u25C2',
	blacktriangleright: '\u25B8',
	blank: '\u2423',
	blk12: '\u2592',
	blk14: '\u2591',
	blk34: '\u2593',
	block: '\u2588',
	bne: '\u003D\u20E5',
	bnequiv: '\u2261\u20E5',
	bNot: '\u2AED',
	bnot: '\u2310',
	Bopf: '\uD835\uDD39',
	bopf: '\uD835\uDD53',
	bot: '\u22A5',
	bottom: '\u22A5',
	bowtie: '\u22C8',
	boxbox: '\u29C9',
	boxDL: '\u2557',
	boxDl: '\u2556',
	boxdL: '\u2555',
	boxdl: '\u2510',
	boxDR: '\u2554',
	boxDr: '\u2553',
	boxdR: '\u2552',
	boxdr: '\u250C',
	boxH: '\u2550',
	boxh: '\u2500',
	boxHD: '\u2566',
	boxHd: '\u2564',
	boxhD: '\u2565',
	boxhd: '\u252C',
	boxHU: '\u2569',
	boxHu: '\u2567',
	boxhU: '\u2568',
	boxhu: '\u2534',
	boxminus: '\u229F',
	boxplus: '\u229E',
	boxtimes: '\u22A0',
	boxUL: '\u255D',
	boxUl: '\u255C',
	boxuL: '\u255B',
	boxul: '\u2518',
	boxUR: '\u255A',
	boxUr: '\u2559',
	boxuR: '\u2558',
	boxur: '\u2514',
	boxV: '\u2551',
	boxv: '\u2502',
	boxVH: '\u256C',
	boxVh: '\u256B',
	boxvH: '\u256A',
	boxvh: '\u253C',
	boxVL: '\u2563',
	boxVl: '\u2562',
	boxvL: '\u2561',
	boxvl: '\u2524',
	boxVR: '\u2560',
	boxVr: '\u255F',
	boxvR: '\u255E',
	boxvr: '\u251C',
	bprime: '\u2035',
	Breve: '\u02D8',
	breve: '\u02D8',
	brvbar: '\u00A6',
	Bscr: '\u212C',
	bscr: '\uD835\uDCB7',
	bsemi: '\u204F',
	bsim: '\u223D',
	bsime: '\u22CD',
	bsol: '\u005C',
	bsolb: '\u29C5',
	bsolhsub: '\u27C8',
	bull: '\u2022',
	bullet: '\u2022',
	bump: '\u224E',
	bumpE: '\u2AAE',
	bumpe: '\u224F',
	Bumpeq: '\u224E',
	bumpeq: '\u224F',
	Cacute: '\u0106',
	cacute: '\u0107',
	Cap: '\u22D2',
	cap: '\u2229',
	capand: '\u2A44',
	capbrcup: '\u2A49',
	capcap: '\u2A4B',
	capcup: '\u2A47',
	capdot: '\u2A40',
	CapitalDifferentialD: '\u2145',
	caps: '\u2229\uFE00',
	caret: '\u2041',
	caron: '\u02C7',
	Cayleys: '\u212D',
	ccaps: '\u2A4D',
	Ccaron: '\u010C',
	ccaron: '\u010D',
	Ccedil: '\u00C7',
	ccedil: '\u00E7',
	Ccirc: '\u0108',
	ccirc: '\u0109',
	Cconint: '\u2230',
	ccups: '\u2A4C',
	ccupssm: '\u2A50',
	Cdot: '\u010A',
	cdot: '\u010B',
	cedil: '\u00B8',
	Cedilla: '\u00B8',
	cemptyv: '\u29B2',
	cent: '\u00A2',
	CenterDot: '\u00B7',
	centerdot: '\u00B7',
	Cfr: '\u212D',
	cfr: '\uD835\uDD20',
	CHcy: '\u0427',
	chcy: '\u0447',
	check: '\u2713',
	checkmark: '\u2713',
	Chi: '\u03A7',
	chi: '\u03C7',
	cir: '\u25CB',
	circ: '\u02C6',
	circeq: '\u2257',
	circlearrowleft: '\u21BA',
	circlearrowright: '\u21BB',
	circledast: '\u229B',
	circledcirc: '\u229A',
	circleddash: '\u229D',
	CircleDot: '\u2299',
	circledR: '\u00AE',
	circledS: '\u24C8',
	CircleMinus: '\u2296',
	CirclePlus: '\u2295',
	CircleTimes: '\u2297',
	cirE: '\u29C3',
	cire: '\u2257',
	cirfnint: '\u2A10',
	cirmid: '\u2AEF',
	cirscir: '\u29C2',
	ClockwiseContourIntegral: '\u2232',
	CloseCurlyDoubleQuote: '\u201D',
	CloseCurlyQuote: '\u2019',
	clubs: '\u2663',
	clubsuit: '\u2663',
	Colon: '\u2237',
	colon: '\u003A',
	Colone: '\u2A74',
	colone: '\u2254',
	coloneq: '\u2254',
	comma: '\u002C',
	commat: '\u0040',
	comp: '\u2201',
	compfn: '\u2218',
	complement: '\u2201',
	complexes: '\u2102',
	cong: '\u2245',
	congdot: '\u2A6D',
	Congruent: '\u2261',
	Conint: '\u222F',
	conint: '\u222E',
	ContourIntegral: '\u222E',
	Copf: '\u2102',
	copf: '\uD835\uDD54',
	coprod: '\u2210',
	Coproduct: '\u2210',
	COPY: '\u00A9',
	copy: '\u00A9',
	copysr: '\u2117',
	CounterClockwiseContourIntegral: '\u2233',
	crarr: '\u21B5',
	Cross: '\u2A2F',
	cross: '\u2717',
	Cscr: '\uD835\uDC9E',
	cscr: '\uD835\uDCB8',
	csub: '\u2ACF',
	csube: '\u2AD1',
	csup: '\u2AD0',
	csupe: '\u2AD2',
	ctdot: '\u22EF',
	cudarrl: '\u2938',
	cudarrr: '\u2935',
	cuepr: '\u22DE',
	cuesc: '\u22DF',
	cularr: '\u21B6',
	cularrp: '\u293D',
	Cup: '\u22D3',
	cup: '\u222A',
	cupbrcap: '\u2A48',
	CupCap: '\u224D',
	cupcap: '\u2A46',
	cupcup: '\u2A4A',
	cupdot: '\u228D',
	cupor: '\u2A45',
	cups: '\u222A\uFE00',
	curarr: '\u21B7',
	curarrm: '\u293C',
	curlyeqprec: '\u22DE',
	curlyeqsucc: '\u22DF',
	curlyvee: '\u22CE',
	curlywedge: '\u22CF',
	curren: '\u00A4',
	curvearrowleft: '\u21B6',
	curvearrowright: '\u21B7',
	cuvee: '\u22CE',
	cuwed: '\u22CF',
	cwconint: '\u2232',
	cwint: '\u2231',
	cylcty: '\u232D',
	Dagger: '\u2021',
	dagger: '\u2020',
	daleth: '\u2138',
	Darr: '\u21A1',
	dArr: '\u21D3',
	darr: '\u2193',
	dash: '\u2010',
	Dashv: '\u2AE4',
	dashv: '\u22A3',
	dbkarow: '\u290F',
	dblac: '\u02DD',
	Dcaron: '\u010E',
	dcaron: '\u010F',
	Dcy: '\u0414',
	dcy: '\u0434',
	DD: '\u2145',
	dd: '\u2146',
	ddagger: '\u2021',
	ddarr: '\u21CA',
	DDotrahd: '\u2911',
	ddotseq: '\u2A77',
	deg: '\u00B0',
	Del: '\u2207',
	Delta: '\u0394',
	delta: '\u03B4',
	demptyv: '\u29B1',
	dfisht: '\u297F',
	Dfr: '\uD835\uDD07',
	dfr: '\uD835\uDD21',
	dHar: '\u2965',
	dharl: '\u21C3',
	dharr: '\u21C2',
	DiacriticalAcute: '\u00B4',
	DiacriticalDot: '\u02D9',
	DiacriticalDoubleAcute: '\u02DD',
	DiacriticalGrave: '\u0060',
	DiacriticalTilde: '\u02DC',
	diam: '\u22C4',
	Diamond: '\u22C4',
	diamond: '\u22C4',
	diamondsuit: '\u2666',
	diams: '\u2666',
	die: '\u00A8',
	DifferentialD: '\u2146',
	digamma: '\u03DD',
	disin: '\u22F2',
	div: '\u00F7',
	divide: '\u00F7',
	divideontimes: '\u22C7',
	divonx: '\u22C7',
	DJcy: '\u0402',
	djcy: '\u0452',
	dlcorn: '\u231E',
	dlcrop: '\u230D',
	dollar: '\u0024',
	Dopf: '\uD835\uDD3B',
	dopf: '\uD835\uDD55',
	Dot: '\u00A8',
	dot: '\u02D9',
	DotDot: '\u20DC',
	doteq: '\u2250',
	doteqdot: '\u2251',
	DotEqual: '\u2250',
	dotminus: '\u2238',
	dotplus: '\u2214',
	dotsquare: '\u22A1',
	doublebarwedge: '\u2306',
	DoubleContourIntegral: '\u222F',
	DoubleDot: '\u00A8',
	DoubleDownArrow: '\u21D3',
	DoubleLeftArrow: '\u21D0',
	DoubleLeftRightArrow: '\u21D4',
	DoubleLeftTee: '\u2AE4',
	DoubleLongLeftArrow: '\u27F8',
	DoubleLongLeftRightArrow: '\u27FA',
	DoubleLongRightArrow: '\u27F9',
	DoubleRightArrow: '\u21D2',
	DoubleRightTee: '\u22A8',
	DoubleUpArrow: '\u21D1',
	DoubleUpDownArrow: '\u21D5',
	DoubleVerticalBar: '\u2225',
	DownArrow: '\u2193',
	Downarrow: '\u21D3',
	downarrow: '\u2193',
	DownArrowBar: '\u2913',
	DownArrowUpArrow: '\u21F5',
	DownBreve: '\u0311',
	downdownarrows: '\u21CA',
	downharpoonleft: '\u21C3',
	downharpoonright: '\u21C2',
	DownLeftRightVector: '\u2950',
	DownLeftTeeVector: '\u295E',
	DownLeftVector: '\u21BD',
	DownLeftVectorBar: '\u2956',
	DownRightTeeVector: '\u295F',
	DownRightVector: '\u21C1',
	DownRightVectorBar: '\u2957',
	DownTee: '\u22A4',
	DownTeeArrow: '\u21A7',
	drbkarow: '\u2910',
	drcorn: '\u231F',
	drcrop: '\u230C',
	Dscr: '\uD835\uDC9F',
	dscr: '\uD835\uDCB9',
	DScy: '\u0405',
	dscy: '\u0455',
	dsol: '\u29F6',
	Dstrok: '\u0110',
	dstrok: '\u0111',
	dtdot: '\u22F1',
	dtri: '\u25BF',
	dtrif: '\u25BE',
	duarr: '\u21F5',
	duhar: '\u296F',
	dwangle: '\u29A6',
	DZcy: '\u040F',
	dzcy: '\u045F',
	dzigrarr: '\u27FF',
	Eacute: '\u00C9',
	eacute: '\u00E9',
	easter: '\u2A6E',
	Ecaron: '\u011A',
	ecaron: '\u011B',
	ecir: '\u2256',
	Ecirc: '\u00CA',
	ecirc: '\u00EA',
	ecolon: '\u2255',
	Ecy: '\u042D',
	ecy: '\u044D',
	eDDot: '\u2A77',
	Edot: '\u0116',
	eDot: '\u2251',
	edot: '\u0117',
	ee: '\u2147',
	efDot: '\u2252',
	Efr: '\uD835\uDD08',
	efr: '\uD835\uDD22',
	eg: '\u2A9A',
	Egrave: '\u00C8',
	egrave: '\u00E8',
	egs: '\u2A96',
	egsdot: '\u2A98',
	el: '\u2A99',
	Element: '\u2208',
	elinters: '\u23E7',
	ell: '\u2113',
	els: '\u2A95',
	elsdot: '\u2A97',
	Emacr: '\u0112',
	emacr: '\u0113',
	empty: '\u2205',
	emptyset: '\u2205',
	EmptySmallSquare: '\u25FB',
	emptyv: '\u2205',
	EmptyVerySmallSquare: '\u25AB',
	emsp: '\u2003',
	emsp13: '\u2004',
	emsp14: '\u2005',
	ENG: '\u014A',
	eng: '\u014B',
	ensp: '\u2002',
	Eogon: '\u0118',
	eogon: '\u0119',
	Eopf: '\uD835\uDD3C',
	eopf: '\uD835\uDD56',
	epar: '\u22D5',
	eparsl: '\u29E3',
	eplus: '\u2A71',
	epsi: '\u03B5',
	Epsilon: '\u0395',
	epsilon: '\u03B5',
	epsiv: '\u03F5',
	eqcirc: '\u2256',
	eqcolon: '\u2255',
	eqsim: '\u2242',
	eqslantgtr: '\u2A96',
	eqslantless: '\u2A95',
	Equal: '\u2A75',
	equals: '\u003D',
	EqualTilde: '\u2242',
	equest: '\u225F',
	Equilibrium: '\u21CC',
	equiv: '\u2261',
	equivDD: '\u2A78',
	eqvparsl: '\u29E5',
	erarr: '\u2971',
	erDot: '\u2253',
	Escr: '\u2130',
	escr: '\u212F',
	esdot: '\u2250',
	Esim: '\u2A73',
	esim: '\u2242',
	Eta: '\u0397',
	eta: '\u03B7',
	ETH: '\u00D0',
	eth: '\u00F0',
	Euml: '\u00CB',
	euml: '\u00EB',
	euro: '\u20AC',
	excl: '\u0021',
	exist: '\u2203',
	Exists: '\u2203',
	expectation: '\u2130',
	ExponentialE: '\u2147',
	exponentiale: '\u2147',
	fallingdotseq: '\u2252',
	Fcy: '\u0424',
	fcy: '\u0444',
	female: '\u2640',
	ffilig: '\uFB03',
	fflig: '\uFB00',
	ffllig: '\uFB04',
	Ffr: '\uD835\uDD09',
	ffr: '\uD835\uDD23',
	filig: '\uFB01',
	FilledSmallSquare: '\u25FC',
	FilledVerySmallSquare: '\u25AA',
	fjlig: '\u0066\u006A',
	flat: '\u266D',
	fllig: '\uFB02',
	fltns: '\u25B1',
	fnof: '\u0192',
	Fopf: '\uD835\uDD3D',
	fopf: '\uD835\uDD57',
	ForAll: '\u2200',
	forall: '\u2200',
	fork: '\u22D4',
	forkv: '\u2AD9',
	Fouriertrf: '\u2131',
	fpartint: '\u2A0D',
	frac12: '\u00BD',
	frac13: '\u2153',
	frac14: '\u00BC',
	frac15: '\u2155',
	frac16: '\u2159',
	frac18: '\u215B',
	frac23: '\u2154',
	frac25: '\u2156',
	frac34: '\u00BE',
	frac35: '\u2157',
	frac38: '\u215C',
	frac45: '\u2158',
	frac56: '\u215A',
	frac58: '\u215D',
	frac78: '\u215E',
	frasl: '\u2044',
	frown: '\u2322',
	Fscr: '\u2131',
	fscr: '\uD835\uDCBB',
	gacute: '\u01F5',
	Gamma: '\u0393',
	gamma: '\u03B3',
	Gammad: '\u03DC',
	gammad: '\u03DD',
	gap: '\u2A86',
	Gbreve: '\u011E',
	gbreve: '\u011F',
	Gcedil: '\u0122',
	Gcirc: '\u011C',
	gcirc: '\u011D',
	Gcy: '\u0413',
	gcy: '\u0433',
	Gdot: '\u0120',
	gdot: '\u0121',
	gE: '\u2267',
	ge: '\u2265',
	gEl: '\u2A8C',
	gel: '\u22DB',
	geq: '\u2265',
	geqq: '\u2267',
	geqslant: '\u2A7E',
	ges: '\u2A7E',
	gescc: '\u2AA9',
	gesdot: '\u2A80',
	gesdoto: '\u2A82',
	gesdotol: '\u2A84',
	gesl: '\u22DB\uFE00',
	gesles: '\u2A94',
	Gfr: '\uD835\uDD0A',
	gfr: '\uD835\uDD24',
	Gg: '\u22D9',
	gg: '\u226B',
	ggg: '\u22D9',
	gimel: '\u2137',
	GJcy: '\u0403',
	gjcy: '\u0453',
	gl: '\u2277',
	gla: '\u2AA5',
	glE: '\u2A92',
	glj: '\u2AA4',
	gnap: '\u2A8A',
	gnapprox: '\u2A8A',
	gnE: '\u2269',
	gne: '\u2A88',
	gneq: '\u2A88',
	gneqq: '\u2269',
	gnsim: '\u22E7',
	Gopf: '\uD835\uDD3E',
	gopf: '\uD835\uDD58',
	grave: '\u0060',
	GreaterEqual: '\u2265',
	GreaterEqualLess: '\u22DB',
	GreaterFullEqual: '\u2267',
	GreaterGreater: '\u2AA2',
	GreaterLess: '\u2277',
	GreaterSlantEqual: '\u2A7E',
	GreaterTilde: '\u2273',
	Gscr: '\uD835\uDCA2',
	gscr: '\u210A',
	gsim: '\u2273',
	gsime: '\u2A8E',
	gsiml: '\u2A90',
	Gt: '\u226B',
	GT: '\u003E',
	gt: '\u003E',
	gtcc: '\u2AA7',
	gtcir: '\u2A7A',
	gtdot: '\u22D7',
	gtlPar: '\u2995',
	gtquest: '\u2A7C',
	gtrapprox: '\u2A86',
	gtrarr: '\u2978',
	gtrdot: '\u22D7',
	gtreqless: '\u22DB',
	gtreqqless: '\u2A8C',
	gtrless: '\u2277',
	gtrsim: '\u2273',
	gvertneqq: '\u2269\uFE00',
	gvnE: '\u2269\uFE00',
	Hacek: '\u02C7',
	hairsp: '\u200A',
	half: '\u00BD',
	hamilt: '\u210B',
	HARDcy: '\u042A',
	hardcy: '\u044A',
	hArr: '\u21D4',
	harr: '\u2194',
	harrcir: '\u2948',
	harrw: '\u21AD',
	Hat: '\u005E',
	hbar: '\u210F',
	Hcirc: '\u0124',
	hcirc: '\u0125',
	hearts: '\u2665',
	heartsuit: '\u2665',
	hellip: '\u2026',
	hercon: '\u22B9',
	Hfr: '\u210C',
	hfr: '\uD835\uDD25',
	HilbertSpace: '\u210B',
	hksearow: '\u2925',
	hkswarow: '\u2926',
	hoarr: '\u21FF',
	homtht: '\u223B',
	hookleftarrow: '\u21A9',
	hookrightarrow: '\u21AA',
	Hopf: '\u210D',
	hopf: '\uD835\uDD59',
	horbar: '\u2015',
	HorizontalLine: '\u2500',
	Hscr: '\u210B',
	hscr: '\uD835\uDCBD',
	hslash: '\u210F',
	Hstrok: '\u0126',
	hstrok: '\u0127',
	HumpDownHump: '\u224E',
	HumpEqual: '\u224F',
	hybull: '\u2043',
	hyphen: '\u2010',
	Iacute: '\u00CD',
	iacute: '\u00ED',
	ic: '\u2063',
	Icirc: '\u00CE',
	icirc: '\u00EE',
	Icy: '\u0418',
	icy: '\u0438',
	Idot: '\u0130',
	IEcy: '\u0415',
	iecy: '\u0435',
	iexcl: '\u00A1',
	iff: '\u21D4',
	Ifr: '\u2111',
	ifr: '\uD835\uDD26',
	Igrave: '\u00CC',
	igrave: '\u00EC',
	ii: '\u2148',
	iiiint: '\u2A0C',
	iiint: '\u222D',
	iinfin: '\u29DC',
	iiota: '\u2129',
	IJlig: '\u0132',
	ijlig: '\u0133',
	Im: '\u2111',
	Imacr: '\u012A',
	imacr: '\u012B',
	image: '\u2111',
	ImaginaryI: '\u2148',
	imagline: '\u2110',
	imagpart: '\u2111',
	imath: '\u0131',
	imof: '\u22B7',
	imped: '\u01B5',
	Implies: '\u21D2',
	in: '\u2208',
	incare: '\u2105',
	infin: '\u221E',
	infintie: '\u29DD',
	inodot: '\u0131',
	Int: '\u222C',
	int: '\u222B',
	intcal: '\u22BA',
	integers: '\u2124',
	Integral: '\u222B',
	intercal: '\u22BA',
	Intersection: '\u22C2',
	intlarhk: '\u2A17',
	intprod: '\u2A3C',
	InvisibleComma: '\u2063',
	InvisibleTimes: '\u2062',
	IOcy: '\u0401',
	iocy: '\u0451',
	Iogon: '\u012E',
	iogon: '\u012F',
	Iopf: '\uD835\uDD40',
	iopf: '\uD835\uDD5A',
	Iota: '\u0399',
	iota: '\u03B9',
	iprod: '\u2A3C',
	iquest: '\u00BF',
	Iscr: '\u2110',
	iscr: '\uD835\uDCBE',
	isin: '\u2208',
	isindot: '\u22F5',
	isinE: '\u22F9',
	isins: '\u22F4',
	isinsv: '\u22F3',
	isinv: '\u2208',
	it: '\u2062',
	Itilde: '\u0128',
	itilde: '\u0129',
	Iukcy: '\u0406',
	iukcy: '\u0456',
	Iuml: '\u00CF',
	iuml: '\u00EF',
	Jcirc: '\u0134',
	jcirc: '\u0135',
	Jcy: '\u0419',
	jcy: '\u0439',
	Jfr: '\uD835\uDD0D',
	jfr: '\uD835\uDD27',
	jmath: '\u0237',
	Jopf: '\uD835\uDD41',
	jopf: '\uD835\uDD5B',
	Jscr: '\uD835\uDCA5',
	jscr: '\uD835\uDCBF',
	Jsercy: '\u0408',
	jsercy: '\u0458',
	Jukcy: '\u0404',
	jukcy: '\u0454',
	Kappa: '\u039A',
	kappa: '\u03BA',
	kappav: '\u03F0',
	Kcedil: '\u0136',
	kcedil: '\u0137',
	Kcy: '\u041A',
	kcy: '\u043A',
	Kfr: '\uD835\uDD0E',
	kfr: '\uD835\uDD28',
	kgreen: '\u0138',
	KHcy: '\u0425',
	khcy: '\u0445',
	KJcy: '\u040C',
	kjcy: '\u045C',
	Kopf: '\uD835\uDD42',
	kopf: '\uD835\uDD5C',
	Kscr: '\uD835\uDCA6',
	kscr: '\uD835\uDCC0',
	lAarr: '\u21DA',
	Lacute: '\u0139',
	lacute: '\u013A',
	laemptyv: '\u29B4',
	lagran: '\u2112',
	Lambda: '\u039B',
	lambda: '\u03BB',
	Lang: '\u27EA',
	lang: '\u27E8',
	langd: '\u2991',
	langle: '\u27E8',
	lap: '\u2A85',
	Laplacetrf: '\u2112',
	laquo: '\u00AB',
	Larr: '\u219E',
	lArr: '\u21D0',
	larr: '\u2190',
	larrb: '\u21E4',
	larrbfs: '\u291F',
	larrfs: '\u291D',
	larrhk: '\u21A9',
	larrlp: '\u21AB',
	larrpl: '\u2939',
	larrsim: '\u2973',
	larrtl: '\u21A2',
	lat: '\u2AAB',
	lAtail: '\u291B',
	latail: '\u2919',
	late: '\u2AAD',
	lates: '\u2AAD\uFE00',
	lBarr: '\u290E',
	lbarr: '\u290C',
	lbbrk: '\u2772',
	lbrace: '\u007B',
	lbrack: '\u005B',
	lbrke: '\u298B',
	lbrksld: '\u298F',
	lbrkslu: '\u298D',
	Lcaron: '\u013D',
	lcaron: '\u013E',
	Lcedil: '\u013B',
	lcedil: '\u013C',
	lceil: '\u2308',
	lcub: '\u007B',
	Lcy: '\u041B',
	lcy: '\u043B',
	ldca: '\u2936',
	ldquo: '\u201C',
	ldquor: '\u201E',
	ldrdhar: '\u2967',
	ldrushar: '\u294B',
	ldsh: '\u21B2',
	lE: '\u2266',
	le: '\u2264',
	LeftAngleBracket: '\u27E8',
	LeftArrow: '\u2190',
	Leftarrow: '\u21D0',
	leftarrow: '\u2190',
	LeftArrowBar: '\u21E4',
	LeftArrowRightArrow: '\u21C6',
	leftarrowtail: '\u21A2',
	LeftCeiling: '\u2308',
	LeftDoubleBracket: '\u27E6',
	LeftDownTeeVector: '\u2961',
	LeftDownVector: '\u21C3',
	LeftDownVectorBar: '\u2959',
	LeftFloor: '\u230A',
	leftharpoondown: '\u21BD',
	leftharpoonup: '\u21BC',
	leftleftarrows: '\u21C7',
	LeftRightArrow: '\u2194',
	Leftrightarrow: '\u21D4',
	leftrightarrow: '\u2194',
	leftrightarrows: '\u21C6',
	leftrightharpoons: '\u21CB',
	leftrightsquigarrow: '\u21AD',
	LeftRightVector: '\u294E',
	LeftTee: '\u22A3',
	LeftTeeArrow: '\u21A4',
	LeftTeeVector: '\u295A',
	leftthreetimes: '\u22CB',
	LeftTriangle: '\u22B2',
	LeftTriangleBar: '\u29CF',
	LeftTriangleEqual: '\u22B4',
	LeftUpDownVector: '\u2951',
	LeftUpTeeVector: '\u2960',
	LeftUpVector: '\u21BF',
	LeftUpVectorBar: '\u2958',
	LeftVector: '\u21BC',
	LeftVectorBar: '\u2952',
	lEg: '\u2A8B',
	leg: '\u22DA',
	leq: '\u2264',
	leqq: '\u2266',
	leqslant: '\u2A7D',
	les: '\u2A7D',
	lescc: '\u2AA8',
	lesdot: '\u2A7F',
	lesdoto: '\u2A81',
	lesdotor: '\u2A83',
	lesg: '\u22DA\uFE00',
	lesges: '\u2A93',
	lessapprox: '\u2A85',
	lessdot: '\u22D6',
	lesseqgtr: '\u22DA',
	lesseqqgtr: '\u2A8B',
	LessEqualGreater: '\u22DA',
	LessFullEqual: '\u2266',
	LessGreater: '\u2276',
	lessgtr: '\u2276',
	LessLess: '\u2AA1',
	lesssim: '\u2272',
	LessSlantEqual: '\u2A7D',
	LessTilde: '\u2272',
	lfisht: '\u297C',
	lfloor: '\u230A',
	Lfr: '\uD835\uDD0F',
	lfr: '\uD835\uDD29',
	lg: '\u2276',
	lgE: '\u2A91',
	lHar: '\u2962',
	lhard: '\u21BD',
	lharu: '\u21BC',
	lharul: '\u296A',
	lhblk: '\u2584',
	LJcy: '\u0409',
	ljcy: '\u0459',
	Ll: '\u22D8',
	ll: '\u226A',
	llarr: '\u21C7',
	llcorner: '\u231E',
	Lleftarrow: '\u21DA',
	llhard: '\u296B',
	lltri: '\u25FA',
	Lmidot: '\u013F',
	lmidot: '\u0140',
	lmoust: '\u23B0',
	lmoustache: '\u23B0',
	lnap: '\u2A89',
	lnapprox: '\u2A89',
	lnE: '\u2268',
	lne: '\u2A87',
	lneq: '\u2A87',
	lneqq: '\u2268',
	lnsim: '\u22E6',
	loang: '\u27EC',
	loarr: '\u21FD',
	lobrk: '\u27E6',
	LongLeftArrow: '\u27F5',
	Longleftarrow: '\u27F8',
	longleftarrow: '\u27F5',
	LongLeftRightArrow: '\u27F7',
	Longleftrightarrow: '\u27FA',
	longleftrightarrow: '\u27F7',
	longmapsto: '\u27FC',
	LongRightArrow: '\u27F6',
	Longrightarrow: '\u27F9',
	longrightarrow: '\u27F6',
	looparrowleft: '\u21AB',
	looparrowright: '\u21AC',
	lopar: '\u2985',
	Lopf: '\uD835\uDD43',
	lopf: '\uD835\uDD5D',
	loplus: '\u2A2D',
	lotimes: '\u2A34',
	lowast: '\u2217',
	lowbar: '\u005F',
	LowerLeftArrow: '\u2199',
	LowerRightArrow: '\u2198',
	loz: '\u25CA',
	lozenge: '\u25CA',
	lozf: '\u29EB',
	lpar: '\u0028',
	lparlt: '\u2993',
	lrarr: '\u21C6',
	lrcorner: '\u231F',
	lrhar: '\u21CB',
	lrhard: '\u296D',
	lrm: '\u200E',
	lrtri: '\u22BF',
	lsaquo: '\u2039',
	Lscr: '\u2112',
	lscr: '\uD835\uDCC1',
	Lsh: '\u21B0',
	lsh: '\u21B0',
	lsim: '\u2272',
	lsime: '\u2A8D',
	lsimg: '\u2A8F',
	lsqb: '\u005B',
	lsquo: '\u2018',
	lsquor: '\u201A',
	Lstrok: '\u0141',
	lstrok: '\u0142',
	Lt: '\u226A',
	LT: '\u003C',
	lt: '\u003C',
	ltcc: '\u2AA6',
	ltcir: '\u2A79',
	ltdot: '\u22D6',
	lthree: '\u22CB',
	ltimes: '\u22C9',
	ltlarr: '\u2976',
	ltquest: '\u2A7B',
	ltri: '\u25C3',
	ltrie: '\u22B4',
	ltrif: '\u25C2',
	ltrPar: '\u2996',
	lurdshar: '\u294A',
	luruhar: '\u2966',
	lvertneqq: '\u2268\uFE00',
	lvnE: '\u2268\uFE00',
	macr: '\u00AF',
	male: '\u2642',
	malt: '\u2720',
	maltese: '\u2720',
	Map: '\u2905',
	map: '\u21A6',
	mapsto: '\u21A6',
	mapstodown: '\u21A7',
	mapstoleft: '\u21A4',
	mapstoup: '\u21A5',
	marker: '\u25AE',
	mcomma: '\u2A29',
	Mcy: '\u041C',
	mcy: '\u043C',
	mdash: '\u2014',
	mDDot: '\u223A',
	measuredangle: '\u2221',
	MediumSpace: '\u205F',
	Mellintrf: '\u2133',
	Mfr: '\uD835\uDD10',
	mfr: '\uD835\uDD2A',
	mho: '\u2127',
	micro: '\u00B5',
	mid: '\u2223',
	midast: '\u002A',
	midcir: '\u2AF0',
	middot: '\u00B7',
	minus: '\u2212',
	minusb: '\u229F',
	minusd: '\u2238',
	minusdu: '\u2A2A',
	MinusPlus: '\u2213',
	mlcp: '\u2ADB',
	mldr: '\u2026',
	mnplus: '\u2213',
	models: '\u22A7',
	Mopf: '\uD835\uDD44',
	mopf: '\uD835\uDD5E',
	mp: '\u2213',
	Mscr: '\u2133',
	mscr: '\uD835\uDCC2',
	mstpos: '\u223E',
	Mu: '\u039C',
	mu: '\u03BC',
	multimap: '\u22B8',
	mumap: '\u22B8',
	nabla: '\u2207',
	Nacute: '\u0143',
	nacute: '\u0144',
	nang: '\u2220\u20D2',
	nap: '\u2249',
	napE: '\u2A70\u0338',
	napid: '\u224B\u0338',
	napos: '\u0149',
	napprox: '\u2249',
	natur: '\u266E',
	natural: '\u266E',
	naturals: '\u2115',
	nbsp: '\u00A0',
	nbump: '\u224E\u0338',
	nbumpe: '\u224F\u0338',
	ncap: '\u2A43',
	Ncaron: '\u0147',
	ncaron: '\u0148',
	Ncedil: '\u0145',
	ncedil: '\u0146',
	ncong: '\u2247',
	ncongdot: '\u2A6D\u0338',
	ncup: '\u2A42',
	Ncy: '\u041D',
	ncy: '\u043D',
	ndash: '\u2013',
	ne: '\u2260',
	nearhk: '\u2924',
	neArr: '\u21D7',
	nearr: '\u2197',
	nearrow: '\u2197',
	nedot: '\u2250\u0338',
	NegativeMediumSpace: '\u200B',
	NegativeThickSpace: '\u200B',
	NegativeThinSpace: '\u200B',
	NegativeVeryThinSpace: '\u200B',
	nequiv: '\u2262',
	nesear: '\u2928',
	nesim: '\u2242\u0338',
	NestedGreaterGreater: '\u226B',
	NestedLessLess: '\u226A',
	NewLine: '\u000A',
	nexist: '\u2204',
	nexists: '\u2204',
	Nfr: '\uD835\uDD11',
	nfr: '\uD835\uDD2B',
	ngE: '\u2267\u0338',
	nge: '\u2271',
	ngeq: '\u2271',
	ngeqq: '\u2267\u0338',
	ngeqslant: '\u2A7E\u0338',
	nges: '\u2A7E\u0338',
	nGg: '\u22D9\u0338',
	ngsim: '\u2275',
	nGt: '\u226B\u20D2',
	ngt: '\u226F',
	ngtr: '\u226F',
	nGtv: '\u226B\u0338',
	nhArr: '\u21CE',
	nharr: '\u21AE',
	nhpar: '\u2AF2',
	ni: '\u220B',
	nis: '\u22FC',
	nisd: '\u22FA',
	niv: '\u220B',
	NJcy: '\u040A',
	njcy: '\u045A',
	nlArr: '\u21CD',
	nlarr: '\u219A',
	nldr: '\u2025',
	nlE: '\u2266\u0338',
	nle: '\u2270',
	nLeftarrow: '\u21CD',
	nleftarrow: '\u219A',
	nLeftrightarrow: '\u21CE',
	nleftrightarrow: '\u21AE',
	nleq: '\u2270',
	nleqq: '\u2266\u0338',
	nleqslant: '\u2A7D\u0338',
	nles: '\u2A7D\u0338',
	nless: '\u226E',
	nLl: '\u22D8\u0338',
	nlsim: '\u2274',
	nLt: '\u226A\u20D2',
	nlt: '\u226E',
	nltri: '\u22EA',
	nltrie: '\u22EC',
	nLtv: '\u226A\u0338',
	nmid: '\u2224',
	NoBreak: '\u2060',
	NonBreakingSpace: '\u00A0',
	Nopf: '\u2115',
	nopf: '\uD835\uDD5F',
	Not: '\u2AEC',
	not: '\u00AC',
	NotCongruent: '\u2262',
	NotCupCap: '\u226D',
	NotDoubleVerticalBar: '\u2226',
	NotElement: '\u2209',
	NotEqual: '\u2260',
	NotEqualTilde: '\u2242\u0338',
	NotExists: '\u2204',
	NotGreater: '\u226F',
	NotGreaterEqual: '\u2271',
	NotGreaterFullEqual: '\u2267\u0338',
	NotGreaterGreater: '\u226B\u0338',
	NotGreaterLess: '\u2279',
	NotGreaterSlantEqual: '\u2A7E\u0338',
	NotGreaterTilde: '\u2275',
	NotHumpDownHump: '\u224E\u0338',
	NotHumpEqual: '\u224F\u0338',
	notin: '\u2209',
	notindot: '\u22F5\u0338',
	notinE: '\u22F9\u0338',
	notinva: '\u2209',
	notinvb: '\u22F7',
	notinvc: '\u22F6',
	NotLeftTriangle: '\u22EA',
	NotLeftTriangleBar: '\u29CF\u0338',
	NotLeftTriangleEqual: '\u22EC',
	NotLess: '\u226E',
	NotLessEqual: '\u2270',
	NotLessGreater: '\u2278',
	NotLessLess: '\u226A\u0338',
	NotLessSlantEqual: '\u2A7D\u0338',
	NotLessTilde: '\u2274',
	NotNestedGreaterGreater: '\u2AA2\u0338',
	NotNestedLessLess: '\u2AA1\u0338',
	notni: '\u220C',
	notniva: '\u220C',
	notnivb: '\u22FE',
	notnivc: '\u22FD',
	NotPrecedes: '\u2280',
	NotPrecedesEqual: '\u2AAF\u0338',
	NotPrecedesSlantEqual: '\u22E0',
	NotReverseElement: '\u220C',
	NotRightTriangle: '\u22EB',
	NotRightTriangleBar: '\u29D0\u0338',
	NotRightTriangleEqual: '\u22ED',
	NotSquareSubset: '\u228F\u0338',
	NotSquareSubsetEqual: '\u22E2',
	NotSquareSuperset: '\u2290\u0338',
	NotSquareSupersetEqual: '\u22E3',
	NotSubset: '\u2282\u20D2',
	NotSubsetEqual: '\u2288',
	NotSucceeds: '\u2281',
	NotSucceedsEqual: '\u2AB0\u0338',
	NotSucceedsSlantEqual: '\u22E1',
	NotSucceedsTilde: '\u227F\u0338',
	NotSuperset: '\u2283\u20D2',
	NotSupersetEqual: '\u2289',
	NotTilde: '\u2241',
	NotTildeEqual: '\u2244',
	NotTildeFullEqual: '\u2247',
	NotTildeTilde: '\u2249',
	NotVerticalBar: '\u2224',
	npar: '\u2226',
	nparallel: '\u2226',
	nparsl: '\u2AFD\u20E5',
	npart: '\u2202\u0338',
	npolint: '\u2A14',
	npr: '\u2280',
	nprcue: '\u22E0',
	npre: '\u2AAF\u0338',
	nprec: '\u2280',
	npreceq: '\u2AAF\u0338',
	nrArr: '\u21CF',
	nrarr: '\u219B',
	nrarrc: '\u2933\u0338',
	nrarrw: '\u219D\u0338',
	nRightarrow: '\u21CF',
	nrightarrow: '\u219B',
	nrtri: '\u22EB',
	nrtrie: '\u22ED',
	nsc: '\u2281',
	nsccue: '\u22E1',
	nsce: '\u2AB0\u0338',
	Nscr: '\uD835\uDCA9',
	nscr: '\uD835\uDCC3',
	nshortmid: '\u2224',
	nshortparallel: '\u2226',
	nsim: '\u2241',
	nsime: '\u2244',
	nsimeq: '\u2244',
	nsmid: '\u2224',
	nspar: '\u2226',
	nsqsube: '\u22E2',
	nsqsupe: '\u22E3',
	nsub: '\u2284',
	nsubE: '\u2AC5\u0338',
	nsube: '\u2288',
	nsubset: '\u2282\u20D2',
	nsubseteq: '\u2288',
	nsubseteqq: '\u2AC5\u0338',
	nsucc: '\u2281',
	nsucceq: '\u2AB0\u0338',
	nsup: '\u2285',
	nsupE: '\u2AC6\u0338',
	nsupe: '\u2289',
	nsupset: '\u2283\u20D2',
	nsupseteq: '\u2289',
	nsupseteqq: '\u2AC6\u0338',
	ntgl: '\u2279',
	Ntilde: '\u00D1',
	ntilde: '\u00F1',
	ntlg: '\u2278',
	ntriangleleft: '\u22EA',
	ntrianglelefteq: '\u22EC',
	ntriangleright: '\u22EB',
	ntrianglerighteq: '\u22ED',
	Nu: '\u039D',
	nu: '\u03BD',
	num: '\u0023',
	numero: '\u2116',
	numsp: '\u2007',
	nvap: '\u224D\u20D2',
	nVDash: '\u22AF',
	nVdash: '\u22AE',
	nvDash: '\u22AD',
	nvdash: '\u22AC',
	nvge: '\u2265\u20D2',
	nvgt: '\u003E\u20D2',
	nvHarr: '\u2904',
	nvinfin: '\u29DE',
	nvlArr: '\u2902',
	nvle: '\u2264\u20D2',
	nvlt: '\u003C\u20D2',
	nvltrie: '\u22B4\u20D2',
	nvrArr: '\u2903',
	nvrtrie: '\u22B5\u20D2',
	nvsim: '\u223C\u20D2',
	nwarhk: '\u2923',
	nwArr: '\u21D6',
	nwarr: '\u2196',
	nwarrow: '\u2196',
	nwnear: '\u2927',
	Oacute: '\u00D3',
	oacute: '\u00F3',
	oast: '\u229B',
	ocir: '\u229A',
	Ocirc: '\u00D4',
	ocirc: '\u00F4',
	Ocy: '\u041E',
	ocy: '\u043E',
	odash: '\u229D',
	Odblac: '\u0150',
	odblac: '\u0151',
	odiv: '\u2A38',
	odot: '\u2299',
	odsold: '\u29BC',
	OElig: '\u0152',
	oelig: '\u0153',
	ofcir: '\u29BF',
	Ofr: '\uD835\uDD12',
	ofr: '\uD835\uDD2C',
	ogon: '\u02DB',
	Ograve: '\u00D2',
	ograve: '\u00F2',
	ogt: '\u29C1',
	ohbar: '\u29B5',
	ohm: '\u03A9',
	oint: '\u222E',
	olarr: '\u21BA',
	olcir: '\u29BE',
	olcross: '\u29BB',
	oline: '\u203E',
	olt: '\u29C0',
	Omacr: '\u014C',
	omacr: '\u014D',
	Omega: '\u03A9',
	omega: '\u03C9',
	Omicron: '\u039F',
	omicron: '\u03BF',
	omid: '\u29B6',
	ominus: '\u2296',
	Oopf: '\uD835\uDD46',
	oopf: '\uD835\uDD60',
	opar: '\u29B7',
	OpenCurlyDoubleQuote: '\u201C',
	OpenCurlyQuote: '\u2018',
	operp: '\u29B9',
	oplus: '\u2295',
	Or: '\u2A54',
	or: '\u2228',
	orarr: '\u21BB',
	ord: '\u2A5D',
	order: '\u2134',
	orderof: '\u2134',
	ordf: '\u00AA',
	ordm: '\u00BA',
	origof: '\u22B6',
	oror: '\u2A56',
	orslope: '\u2A57',
	orv: '\u2A5B',
	oS: '\u24C8',
	Oscr: '\uD835\uDCAA',
	oscr: '\u2134',
	Oslash: '\u00D8',
	oslash: '\u00F8',
	osol: '\u2298',
	Otilde: '\u00D5',
	otilde: '\u00F5',
	Otimes: '\u2A37',
	otimes: '\u2297',
	otimesas: '\u2A36',
	Ouml: '\u00D6',
	ouml: '\u00F6',
	ovbar: '\u233D',
	OverBar: '\u203E',
	OverBrace: '\u23DE',
	OverBracket: '\u23B4',
	OverParenthesis: '\u23DC',
	par: '\u2225',
	para: '\u00B6',
	parallel: '\u2225',
	parsim: '\u2AF3',
	parsl: '\u2AFD',
	part: '\u2202',
	PartialD: '\u2202',
	Pcy: '\u041F',
	pcy: '\u043F',
	percnt: '\u0025',
	period: '\u002E',
	permil: '\u2030',
	perp: '\u22A5',
	pertenk: '\u2031',
	Pfr: '\uD835\uDD13',
	pfr: '\uD835\uDD2D',
	Phi: '\u03A6',
	phi: '\u03C6',
	phiv: '\u03D5',
	phmmat: '\u2133',
	phone: '\u260E',
	Pi: '\u03A0',
	pi: '\u03C0',
	pitchfork: '\u22D4',
	piv: '\u03D6',
	planck: '\u210F',
	planckh: '\u210E',
	plankv: '\u210F',
	plus: '\u002B',
	plusacir: '\u2A23',
	plusb: '\u229E',
	pluscir: '\u2A22',
	plusdo: '\u2214',
	plusdu: '\u2A25',
	pluse: '\u2A72',
	PlusMinus: '\u00B1',
	plusmn: '\u00B1',
	plussim: '\u2A26',
	plustwo: '\u2A27',
	pm: '\u00B1',
	Poincareplane: '\u210C',
	pointint: '\u2A15',
	Popf: '\u2119',
	popf: '\uD835\uDD61',
	pound: '\u00A3',
	Pr: '\u2ABB',
	pr: '\u227A',
	prap: '\u2AB7',
	prcue: '\u227C',
	prE: '\u2AB3',
	pre: '\u2AAF',
	prec: '\u227A',
	precapprox: '\u2AB7',
	preccurlyeq: '\u227C',
	Precedes: '\u227A',
	PrecedesEqual: '\u2AAF',
	PrecedesSlantEqual: '\u227C',
	PrecedesTilde: '\u227E',
	preceq: '\u2AAF',
	precnapprox: '\u2AB9',
	precneqq: '\u2AB5',
	precnsim: '\u22E8',
	precsim: '\u227E',
	Prime: '\u2033',
	prime: '\u2032',
	primes: '\u2119',
	prnap: '\u2AB9',
	prnE: '\u2AB5',
	prnsim: '\u22E8',
	prod: '\u220F',
	Product: '\u220F',
	profalar: '\u232E',
	profline: '\u2312',
	profsurf: '\u2313',
	prop: '\u221D',
	Proportion: '\u2237',
	Proportional: '\u221D',
	propto: '\u221D',
	prsim: '\u227E',
	prurel: '\u22B0',
	Pscr: '\uD835\uDCAB',
	pscr: '\uD835\uDCC5',
	Psi: '\u03A8',
	psi: '\u03C8',
	puncsp: '\u2008',
	Qfr: '\uD835\uDD14',
	qfr: '\uD835\uDD2E',
	qint: '\u2A0C',
	Qopf: '\u211A',
	qopf: '\uD835\uDD62',
	qprime: '\u2057',
	Qscr: '\uD835\uDCAC',
	qscr: '\uD835\uDCC6',
	quaternions: '\u210D',
	quatint: '\u2A16',
	quest: '\u003F',
	questeq: '\u225F',
	QUOT: '\u0022',
	quot: '\u0022',
	rAarr: '\u21DB',
	race: '\u223D\u0331',
	Racute: '\u0154',
	racute: '\u0155',
	radic: '\u221A',
	raemptyv: '\u29B3',
	Rang: '\u27EB',
	rang: '\u27E9',
	rangd: '\u2992',
	range: '\u29A5',
	rangle: '\u27E9',
	raquo: '\u00BB',
	Rarr: '\u21A0',
	rArr: '\u21D2',
	rarr: '\u2192',
	rarrap: '\u2975',
	rarrb: '\u21E5',
	rarrbfs: '\u2920',
	rarrc: '\u2933',
	rarrfs: '\u291E',
	rarrhk: '\u21AA',
	rarrlp: '\u21AC',
	rarrpl: '\u2945',
	rarrsim: '\u2974',
	Rarrtl: '\u2916',
	rarrtl: '\u21A3',
	rarrw: '\u219D',
	rAtail: '\u291C',
	ratail: '\u291A',
	ratio: '\u2236',
	rationals: '\u211A',
	RBarr: '\u2910',
	rBarr: '\u290F',
	rbarr: '\u290D',
	rbbrk: '\u2773',
	rbrace: '\u007D',
	rbrack: '\u005D',
	rbrke: '\u298C',
	rbrksld: '\u298E',
	rbrkslu: '\u2990',
	Rcaron: '\u0158',
	rcaron: '\u0159',
	Rcedil: '\u0156',
	rcedil: '\u0157',
	rceil: '\u2309',
	rcub: '\u007D',
	Rcy: '\u0420',
	rcy: '\u0440',
	rdca: '\u2937',
	rdldhar: '\u2969',
	rdquo: '\u201D',
	rdquor: '\u201D',
	rdsh: '\u21B3',
	Re: '\u211C',
	real: '\u211C',
	realine: '\u211B',
	realpart: '\u211C',
	reals: '\u211D',
	rect: '\u25AD',
	REG: '\u00AE',
	reg: '\u00AE',
	ReverseElement: '\u220B',
	ReverseEquilibrium: '\u21CB',
	ReverseUpEquilibrium: '\u296F',
	rfisht: '\u297D',
	rfloor: '\u230B',
	Rfr: '\u211C',
	rfr: '\uD835\uDD2F',
	rHar: '\u2964',
	rhard: '\u21C1',
	rharu: '\u21C0',
	rharul: '\u296C',
	Rho: '\u03A1',
	rho: '\u03C1',
	rhov: '\u03F1',
	RightAngleBracket: '\u27E9',
	RightArrow: '\u2192',
	Rightarrow: '\u21D2',
	rightarrow: '\u2192',
	RightArrowBar: '\u21E5',
	RightArrowLeftArrow: '\u21C4',
	rightarrowtail: '\u21A3',
	RightCeiling: '\u2309',
	RightDoubleBracket: '\u27E7',
	RightDownTeeVector: '\u295D',
	RightDownVector: '\u21C2',
	RightDownVectorBar: '\u2955',
	RightFloor: '\u230B',
	rightharpoondown: '\u21C1',
	rightharpoonup: '\u21C0',
	rightleftarrows: '\u21C4',
	rightleftharpoons: '\u21CC',
	rightrightarrows: '\u21C9',
	rightsquigarrow: '\u219D',
	RightTee: '\u22A2',
	RightTeeArrow: '\u21A6',
	RightTeeVector: '\u295B',
	rightthreetimes: '\u22CC',
	RightTriangle: '\u22B3',
	RightTriangleBar: '\u29D0',
	RightTriangleEqual: '\u22B5',
	RightUpDownVector: '\u294F',
	RightUpTeeVector: '\u295C',
	RightUpVector: '\u21BE',
	RightUpVectorBar: '\u2954',
	RightVector: '\u21C0',
	RightVectorBar: '\u2953',
	ring: '\u02DA',
	risingdotseq: '\u2253',
	rlarr: '\u21C4',
	rlhar: '\u21CC',
	rlm: '\u200F',
	rmoust: '\u23B1',
	rmoustache: '\u23B1',
	rnmid: '\u2AEE',
	roang: '\u27ED',
	roarr: '\u21FE',
	robrk: '\u27E7',
	ropar: '\u2986',
	Ropf: '\u211D',
	ropf: '\uD835\uDD63',
	roplus: '\u2A2E',
	rotimes: '\u2A35',
	RoundImplies: '\u2970',
	rpar: '\u0029',
	rpargt: '\u2994',
	rppolint: '\u2A12',
	rrarr: '\u21C9',
	Rrightarrow: '\u21DB',
	rsaquo: '\u203A',
	Rscr: '\u211B',
	rscr: '\uD835\uDCC7',
	Rsh: '\u21B1',
	rsh: '\u21B1',
	rsqb: '\u005D',
	rsquo: '\u2019',
	rsquor: '\u2019',
	rthree: '\u22CC',
	rtimes: '\u22CA',
	rtri: '\u25B9',
	rtrie: '\u22B5',
	rtrif: '\u25B8',
	rtriltri: '\u29CE',
	RuleDelayed: '\u29F4',
	ruluhar: '\u2968',
	rx: '\u211E',
	Sacute: '\u015A',
	sacute: '\u015B',
	sbquo: '\u201A',
	Sc: '\u2ABC',
	sc: '\u227B',
	scap: '\u2AB8',
	Scaron: '\u0160',
	scaron: '\u0161',
	sccue: '\u227D',
	scE: '\u2AB4',
	sce: '\u2AB0',
	Scedil: '\u015E',
	scedil: '\u015F',
	Scirc: '\u015C',
	scirc: '\u015D',
	scnap: '\u2ABA',
	scnE: '\u2AB6',
	scnsim: '\u22E9',
	scpolint: '\u2A13',
	scsim: '\u227F',
	Scy: '\u0421',
	scy: '\u0441',
	sdot: '\u22C5',
	sdotb: '\u22A1',
	sdote: '\u2A66',
	searhk: '\u2925',
	seArr: '\u21D8',
	searr: '\u2198',
	searrow: '\u2198',
	sect: '\u00A7',
	semi: '\u003B',
	seswar: '\u2929',
	setminus: '\u2216',
	setmn: '\u2216',
	sext: '\u2736',
	Sfr: '\uD835\uDD16',
	sfr: '\uD835\uDD30',
	sfrown: '\u2322',
	sharp: '\u266F',
	SHCHcy: '\u0429',
	shchcy: '\u0449',
	SHcy: '\u0428',
	shcy: '\u0448',
	ShortDownArrow: '\u2193',
	ShortLeftArrow: '\u2190',
	shortmid: '\u2223',
	shortparallel: '\u2225',
	ShortRightArrow: '\u2192',
	ShortUpArrow: '\u2191',
	shy: '\u00AD',
	Sigma: '\u03A3',
	sigma: '\u03C3',
	sigmaf: '\u03C2',
	sigmav: '\u03C2',
	sim: '\u223C',
	simdot: '\u2A6A',
	sime: '\u2243',
	simeq: '\u2243',
	simg: '\u2A9E',
	simgE: '\u2AA0',
	siml: '\u2A9D',
	simlE: '\u2A9F',
	simne: '\u2246',
	simplus: '\u2A24',
	simrarr: '\u2972',
	slarr: '\u2190',
	SmallCircle: '\u2218',
	smallsetminus: '\u2216',
	smashp: '\u2A33',
	smeparsl: '\u29E4',
	smid: '\u2223',
	smile: '\u2323',
	smt: '\u2AAA',
	smte: '\u2AAC',
	smtes: '\u2AAC\uFE00',
	SOFTcy: '\u042C',
	softcy: '\u044C',
	sol: '\u002F',
	solb: '\u29C4',
	solbar: '\u233F',
	Sopf: '\uD835\uDD4A',
	sopf: '\uD835\uDD64',
	spades: '\u2660',
	spadesuit: '\u2660',
	spar: '\u2225',
	sqcap: '\u2293',
	sqcaps: '\u2293\uFE00',
	sqcup: '\u2294',
	sqcups: '\u2294\uFE00',
	Sqrt: '\u221A',
	sqsub: '\u228F',
	sqsube: '\u2291',
	sqsubset: '\u228F',
	sqsubseteq: '\u2291',
	sqsup: '\u2290',
	sqsupe: '\u2292',
	sqsupset: '\u2290',
	sqsupseteq: '\u2292',
	squ: '\u25A1',
	Square: '\u25A1',
	square: '\u25A1',
	SquareIntersection: '\u2293',
	SquareSubset: '\u228F',
	SquareSubsetEqual: '\u2291',
	SquareSuperset: '\u2290',
	SquareSupersetEqual: '\u2292',
	SquareUnion: '\u2294',
	squarf: '\u25AA',
	squf: '\u25AA',
	srarr: '\u2192',
	Sscr: '\uD835\uDCAE',
	sscr: '\uD835\uDCC8',
	ssetmn: '\u2216',
	ssmile: '\u2323',
	sstarf: '\u22C6',
	Star: '\u22C6',
	star: '\u2606',
	starf: '\u2605',
	straightepsilon: '\u03F5',
	straightphi: '\u03D5',
	strns: '\u00AF',
	Sub: '\u22D0',
	sub: '\u2282',
	subdot: '\u2ABD',
	subE: '\u2AC5',
	sube: '\u2286',
	subedot: '\u2AC3',
	submult: '\u2AC1',
	subnE: '\u2ACB',
	subne: '\u228A',
	subplus: '\u2ABF',
	subrarr: '\u2979',
	Subset: '\u22D0',
	subset: '\u2282',
	subseteq: '\u2286',
	subseteqq: '\u2AC5',
	SubsetEqual: '\u2286',
	subsetneq: '\u228A',
	subsetneqq: '\u2ACB',
	subsim: '\u2AC7',
	subsub: '\u2AD5',
	subsup: '\u2AD3',
	succ: '\u227B',
	succapprox: '\u2AB8',
	succcurlyeq: '\u227D',
	Succeeds: '\u227B',
	SucceedsEqual: '\u2AB0',
	SucceedsSlantEqual: '\u227D',
	SucceedsTilde: '\u227F',
	succeq: '\u2AB0',
	succnapprox: '\u2ABA',
	succneqq: '\u2AB6',
	succnsim: '\u22E9',
	succsim: '\u227F',
	SuchThat: '\u220B',
	Sum: '\u2211',
	sum: '\u2211',
	sung: '\u266A',
	Sup: '\u22D1',
	sup: '\u2283',
	sup1: '\u00B9',
	sup2: '\u00B2',
	sup3: '\u00B3',
	supdot: '\u2ABE',
	supdsub: '\u2AD8',
	supE: '\u2AC6',
	supe: '\u2287',
	supedot: '\u2AC4',
	Superset: '\u2283',
	SupersetEqual: '\u2287',
	suphsol: '\u27C9',
	suphsub: '\u2AD7',
	suplarr: '\u297B',
	supmult: '\u2AC2',
	supnE: '\u2ACC',
	supne: '\u228B',
	supplus: '\u2AC0',
	Supset: '\u22D1',
	supset: '\u2283',
	supseteq: '\u2287',
	supseteqq: '\u2AC6',
	supsetneq: '\u228B',
	supsetneqq: '\u2ACC',
	supsim: '\u2AC8',
	supsub: '\u2AD4',
	supsup: '\u2AD6',
	swarhk: '\u2926',
	swArr: '\u21D9',
	swarr: '\u2199',
	swarrow: '\u2199',
	swnwar: '\u292A',
	szlig: '\u00DF',
	Tab: '\u0009',
	target: '\u2316',
	Tau: '\u03A4',
	tau: '\u03C4',
	tbrk: '\u23B4',
	Tcaron: '\u0164',
	tcaron: '\u0165',
	Tcedil: '\u0162',
	tcedil: '\u0163',
	Tcy: '\u0422',
	tcy: '\u0442',
	tdot: '\u20DB',
	telrec: '\u2315',
	Tfr: '\uD835\uDD17',
	tfr: '\uD835\uDD31',
	there4: '\u2234',
	Therefore: '\u2234',
	therefore: '\u2234',
	Theta: '\u0398',
	theta: '\u03B8',
	thetasym: '\u03D1',
	thetav: '\u03D1',
	thickapprox: '\u2248',
	thicksim: '\u223C',
	ThickSpace: '\u205F\u200A',
	thinsp: '\u2009',
	ThinSpace: '\u2009',
	thkap: '\u2248',
	thksim: '\u223C',
	THORN: '\u00DE',
	thorn: '\u00FE',
	Tilde: '\u223C',
	tilde: '\u02DC',
	TildeEqual: '\u2243',
	TildeFullEqual: '\u2245',
	TildeTilde: '\u2248',
	times: '\u00D7',
	timesb: '\u22A0',
	timesbar: '\u2A31',
	timesd: '\u2A30',
	tint: '\u222D',
	toea: '\u2928',
	top: '\u22A4',
	topbot: '\u2336',
	topcir: '\u2AF1',
	Topf: '\uD835\uDD4B',
	topf: '\uD835\uDD65',
	topfork: '\u2ADA',
	tosa: '\u2929',
	tprime: '\u2034',
	TRADE: '\u2122',
	trade: '\u2122',
	triangle: '\u25B5',
	triangledown: '\u25BF',
	triangleleft: '\u25C3',
	trianglelefteq: '\u22B4',
	triangleq: '\u225C',
	triangleright: '\u25B9',
	trianglerighteq: '\u22B5',
	tridot: '\u25EC',
	trie: '\u225C',
	triminus: '\u2A3A',
	TripleDot: '\u20DB',
	triplus: '\u2A39',
	trisb: '\u29CD',
	tritime: '\u2A3B',
	trpezium: '\u23E2',
	Tscr: '\uD835\uDCAF',
	tscr: '\uD835\uDCC9',
	TScy: '\u0426',
	tscy: '\u0446',
	TSHcy: '\u040B',
	tshcy: '\u045B',
	Tstrok: '\u0166',
	tstrok: '\u0167',
	twixt: '\u226C',
	twoheadleftarrow: '\u219E',
	twoheadrightarrow: '\u21A0',
	Uacute: '\u00DA',
	uacute: '\u00FA',
	Uarr: '\u219F',
	uArr: '\u21D1',
	uarr: '\u2191',
	Uarrocir: '\u2949',
	Ubrcy: '\u040E',
	ubrcy: '\u045E',
	Ubreve: '\u016C',
	ubreve: '\u016D',
	Ucirc: '\u00DB',
	ucirc: '\u00FB',
	Ucy: '\u0423',
	ucy: '\u0443',
	udarr: '\u21C5',
	Udblac: '\u0170',
	udblac: '\u0171',
	udhar: '\u296E',
	ufisht: '\u297E',
	Ufr: '\uD835\uDD18',
	ufr: '\uD835\uDD32',
	Ugrave: '\u00D9',
	ugrave: '\u00F9',
	uHar: '\u2963',
	uharl: '\u21BF',
	uharr: '\u21BE',
	uhblk: '\u2580',
	ulcorn: '\u231C',
	ulcorner: '\u231C',
	ulcrop: '\u230F',
	ultri: '\u25F8',
	Umacr: '\u016A',
	umacr: '\u016B',
	uml: '\u00A8',
	UnderBar: '\u005F',
	UnderBrace: '\u23DF',
	UnderBracket: '\u23B5',
	UnderParenthesis: '\u23DD',
	Union: '\u22C3',
	UnionPlus: '\u228E',
	Uogon: '\u0172',
	uogon: '\u0173',
	Uopf: '\uD835\uDD4C',
	uopf: '\uD835\uDD66',
	UpArrow: '\u2191',
	Uparrow: '\u21D1',
	uparrow: '\u2191',
	UpArrowBar: '\u2912',
	UpArrowDownArrow: '\u21C5',
	UpDownArrow: '\u2195',
	Updownarrow: '\u21D5',
	updownarrow: '\u2195',
	UpEquilibrium: '\u296E',
	upharpoonleft: '\u21BF',
	upharpoonright: '\u21BE',
	uplus: '\u228E',
	UpperLeftArrow: '\u2196',
	UpperRightArrow: '\u2197',
	Upsi: '\u03D2',
	upsi: '\u03C5',
	upsih: '\u03D2',
	Upsilon: '\u03A5',
	upsilon: '\u03C5',
	UpTee: '\u22A5',
	UpTeeArrow: '\u21A5',
	upuparrows: '\u21C8',
	urcorn: '\u231D',
	urcorner: '\u231D',
	urcrop: '\u230E',
	Uring: '\u016E',
	uring: '\u016F',
	urtri: '\u25F9',
	Uscr: '\uD835\uDCB0',
	uscr: '\uD835\uDCCA',
	utdot: '\u22F0',
	Utilde: '\u0168',
	utilde: '\u0169',
	utri: '\u25B5',
	utrif: '\u25B4',
	uuarr: '\u21C8',
	Uuml: '\u00DC',
	uuml: '\u00FC',
	uwangle: '\u29A7',
	vangrt: '\u299C',
	varepsilon: '\u03F5',
	varkappa: '\u03F0',
	varnothing: '\u2205',
	varphi: '\u03D5',
	varpi: '\u03D6',
	varpropto: '\u221D',
	vArr: '\u21D5',
	varr: '\u2195',
	varrho: '\u03F1',
	varsigma: '\u03C2',
	varsubsetneq: '\u228A\uFE00',
	varsubsetneqq: '\u2ACB\uFE00',
	varsupsetneq: '\u228B\uFE00',
	varsupsetneqq: '\u2ACC\uFE00',
	vartheta: '\u03D1',
	vartriangleleft: '\u22B2',
	vartriangleright: '\u22B3',
	Vbar: '\u2AEB',
	vBar: '\u2AE8',
	vBarv: '\u2AE9',
	Vcy: '\u0412',
	vcy: '\u0432',
	VDash: '\u22AB',
	Vdash: '\u22A9',
	vDash: '\u22A8',
	vdash: '\u22A2',
	Vdashl: '\u2AE6',
	Vee: '\u22C1',
	vee: '\u2228',
	veebar: '\u22BB',
	veeeq: '\u225A',
	vellip: '\u22EE',
	Verbar: '\u2016',
	verbar: '\u007C',
	Vert: '\u2016',
	vert: '\u007C',
	VerticalBar: '\u2223',
	VerticalLine: '\u007C',
	VerticalSeparator: '\u2758',
	VerticalTilde: '\u2240',
	VeryThinSpace: '\u200A',
	Vfr: '\uD835\uDD19',
	vfr: '\uD835\uDD33',
	vltri: '\u22B2',
	vnsub: '\u2282\u20D2',
	vnsup: '\u2283\u20D2',
	Vopf: '\uD835\uDD4D',
	vopf: '\uD835\uDD67',
	vprop: '\u221D',
	vrtri: '\u22B3',
	Vscr: '\uD835\uDCB1',
	vscr: '\uD835\uDCCB',
	vsubnE: '\u2ACB\uFE00',
	vsubne: '\u228A\uFE00',
	vsupnE: '\u2ACC\uFE00',
	vsupne: '\u228B\uFE00',
	Vvdash: '\u22AA',
	vzigzag: '\u299A',
	Wcirc: '\u0174',
	wcirc: '\u0175',
	wedbar: '\u2A5F',
	Wedge: '\u22C0',
	wedge: '\u2227',
	wedgeq: '\u2259',
	weierp: '\u2118',
	Wfr: '\uD835\uDD1A',
	wfr: '\uD835\uDD34',
	Wopf: '\uD835\uDD4E',
	wopf: '\uD835\uDD68',
	wp: '\u2118',
	wr: '\u2240',
	wreath: '\u2240',
	Wscr: '\uD835\uDCB2',
	wscr: '\uD835\uDCCC',
	xcap: '\u22C2',
	xcirc: '\u25EF',
	xcup: '\u22C3',
	xdtri: '\u25BD',
	Xfr: '\uD835\uDD1B',
	xfr: '\uD835\uDD35',
	xhArr: '\u27FA',
	xharr: '\u27F7',
	Xi: '\u039E',
	xi: '\u03BE',
	xlArr: '\u27F8',
	xlarr: '\u27F5',
	xmap: '\u27FC',
	xnis: '\u22FB',
	xodot: '\u2A00',
	Xopf: '\uD835\uDD4F',
	xopf: '\uD835\uDD69',
	xoplus: '\u2A01',
	xotime: '\u2A02',
	xrArr: '\u27F9',
	xrarr: '\u27F6',
	Xscr: '\uD835\uDCB3',
	xscr: '\uD835\uDCCD',
	xsqcup: '\u2A06',
	xuplus: '\u2A04',
	xutri: '\u25B3',
	xvee: '\u22C1',
	xwedge: '\u22C0',
	Yacute: '\u00DD',
	yacute: '\u00FD',
	YAcy: '\u042F',
	yacy: '\u044F',
	Ycirc: '\u0176',
	ycirc: '\u0177',
	Ycy: '\u042B',
	ycy: '\u044B',
	yen: '\u00A5',
	Yfr: '\uD835\uDD1C',
	yfr: '\uD835\uDD36',
	YIcy: '\u0407',
	yicy: '\u0457',
	Yopf: '\uD835\uDD50',
	yopf: '\uD835\uDD6A',
	Yscr: '\uD835\uDCB4',
	yscr: '\uD835\uDCCE',
	YUcy: '\u042E',
	yucy: '\u044E',
	Yuml: '\u0178',
	yuml: '\u00FF',
	Zacute: '\u0179',
	zacute: '\u017A',
	Zcaron: '\u017D',
	zcaron: '\u017E',
	Zcy: '\u0417',
	zcy: '\u0437',
	Zdot: '\u017B',
	zdot: '\u017C',
	zeetrf: '\u2128',
	ZeroWidthSpace: '\u200B',
	Zeta: '\u0396',
	zeta: '\u03B6',
	Zfr: '\u2128',
	zfr: '\uD835\uDD37',
	ZHcy: '\u0416',
	zhcy: '\u0436',
	zigrarr: '\u21DD',
	Zopf: '\u2124',
	zopf: '\uD835\uDD6B',
	Zscr: '\uD835\uDCB5',
	zscr: '\uD835\uDCCF',
	zwj: '\u200D',
	zwnj: '\u200C',
});

/**
 * @deprecated
 * Use `HTML_ENTITIES` instead.
 * @see {@link HTML_ENTITIES}
 */
exports.entityMap = exports.HTML_ENTITIES;


/***/ }),

/***/ 268:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
var _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
var wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1___namespace_cache;
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Al: () => (/* binding */ document),
/* harmony export */   Gb: () => (/* binding */ xmldom),
/* harmony export */   Oe: () => (/* binding */ xpath)
/* harmony export */ });
/* harmony import */ var _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(546);
/* harmony import */ var wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(999);


const xmldom = /*#__PURE__*/ (_xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0__, 2)));
const document = new xmldom.DOMImplementation().createDocument('', '');
const install = (/*#__PURE__*/ (wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1__, 2))) === null || /*#__PURE__*/ (wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1__, 2))) === void 0 ? void 0 : wicked_good_xpath__WEBPACK_IMPORTED_MODULE_1__.install) || window.wgxpath.install;
const Xpath = (function () {
    const win = { document: {}, XPathResult: {} };
    install(win);
    win.document.XPathResult = win.XPathResult;
    return win.document;
})();
const xpath = {
    currentDocument: document,
    evaluate: Xpath.evaluate,
    result: Xpath.XPathResult,
    createNSResolver: Xpath.createNSResolver
};
//# sourceMappingURL=lib_external.js.map

/***/ }),

/***/ 546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var conventions = __webpack_require__(870);
exports.assign = conventions.assign;
exports.hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
exports.isHTMLMimeType = conventions.isHTMLMimeType;
exports.isValidMimeType = conventions.isValidMimeType;
exports.MIME_TYPE = conventions.MIME_TYPE;
exports.NAMESPACE = conventions.NAMESPACE;

var errors = __webpack_require__(767);
exports.DOMException = errors.DOMException;
exports.DOMExceptionName = errors.DOMExceptionName;
exports.ExceptionCode = errors.ExceptionCode;
exports.ParseError = errors.ParseError;

var dom = __webpack_require__(786);
exports.Attr = dom.Attr;
exports.CDATASection = dom.CDATASection;
exports.CharacterData = dom.CharacterData;
exports.Comment = dom.Comment;
exports.Document = dom.Document;
exports.DocumentFragment = dom.DocumentFragment;
exports.DocumentType = dom.DocumentType;
exports.DOMImplementation = dom.DOMImplementation;
exports.Element = dom.Element;
exports.Entity = dom.Entity;
exports.EntityReference = dom.EntityReference;
exports.LiveNodeList = dom.LiveNodeList;
exports.NamedNodeMap = dom.NamedNodeMap;
exports.Node = dom.Node;
exports.NodeList = dom.NodeList;
exports.Notation = dom.Notation;
exports.ProcessingInstruction = dom.ProcessingInstruction;
exports.Text = dom.Text;
exports.XMLSerializer = dom.XMLSerializer;

var domParser = __webpack_require__(576);
exports.DOMParser = domParser.DOMParser;
exports.normalizeLineEndings = domParser.normalizeLineEndings;
exports.onErrorStopParsing = domParser.onErrorStopParsing;
exports.onWarningStopParsing = domParser.onWarningStopParsing;


/***/ }),

/***/ 576:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var conventions = __webpack_require__(870);
var dom = __webpack_require__(786);
var errors = __webpack_require__(767);
var entities = __webpack_require__(159);
var sax = __webpack_require__(802);

var DOMImplementation = dom.DOMImplementation;

var hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
var isHTMLMimeType = conventions.isHTMLMimeType;
var isValidMimeType = conventions.isValidMimeType;
var MIME_TYPE = conventions.MIME_TYPE;
var NAMESPACE = conventions.NAMESPACE;
var ParseError = errors.ParseError;

var XMLReader = sax.XMLReader;

/**
 * Normalizes line ending according to <https://www.w3.org/TR/xml11/#sec-line-ends>,
 * including some Unicode "newline" characters:
 *
 * > XML parsed entities are often stored in computer files which,
 * > for editing convenience, are organized into lines.
 * > These lines are typically separated by some combination
 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
 * >
 * > To simplify the tasks of applications, the XML processor must behave
 * > as if it normalized all line breaks in external parsed entities (including the document entity)
 * > on input, before parsing, by translating the following to a single #xA character:
 * >
 * > 1. the two-character sequence #xD #xA,
 * > 2. the two-character sequence #xD #x85,
 * > 3. the single character #x85,
 * > 4. the single character #x2028,
 * > 5. the single character #x2029,
 * > 6. any #xD character that is not immediately followed by #xA or #x85.
 *
 * @param {string} input
 * @returns {string}
 * @prettierignore
 */
function normalizeLineEndings(input) {
	return input.replace(/\r[\n\u0085]/g, '\n').replace(/[\r\u0085\u2028\u2029]/g, '\n');
}

/**
 * @typedef Locator
 * @property {number} [columnNumber]
 * @property {number} [lineNumber]
 */

/**
 * @typedef DOMParserOptions
 * @property {typeof assign} [assign]
 * The method to use instead of `conventions.assign`, which is used to copy values from
 * `options` before they are used for parsing.
 * @property {typeof DOMHandler} [domHandler]
 * For internal testing: The class for creating an instance for handling events from the SAX
 * parser.
 * *****Warning: By configuring a faulty implementation, the specified behavior can completely
 * be broken.*****.
 * @property {Function} [errorHandler]
 * DEPRECATED! use `onError` instead.
 * @property {function(level:ErrorLevel, message:string, context: DOMHandler):void}
 * [onError]
 * A function invoked for every error that occurs during parsing.
 *
 * If it is not provided, all errors are reported to `console.error`
 * and only `fatalError`s are thrown as a `ParseError`,
 * which prevents any further processing.
 * If the provided method throws, a `ParserError` is thrown,
 * which prevents any further processing.
 *
 * Be aware that many `warning`s are considered an error that prevents further processing in
 * most implementations.
 * @property {boolean} [locator=true]
 * Configures if the nodes created during parsing will have a `lineNumber` and a `columnNumber`
 * attribute describing their location in the XML string.
 * Default is true.
 * @property {(string) => string} [normalizeLineEndings]
 * used to replace line endings before parsing, defaults to exported `normalizeLineEndings`,
 * which normalizes line endings according to <https://www.w3.org/TR/xml11/#sec-line-ends>,
 * including some Unicode "newline" characters.
 * @property {Object} [xmlns]
 * The XML namespaces that should be assumed when parsing.
 * The default namespace can be provided by the key that is the empty string.
 * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,
 * the default namespace that will be used,
 * will be overridden according to the specification.
 * @see {@link normalizeLineEndings}
 */

/**
 * The DOMParser interface provides the ability to parse XML or HTML source code from a string
 * into a DOM `Document`.
 *
 * ***xmldom is different from the spec in that it allows an `options` parameter,
 * to control the behavior***.
 *
 * @class
 * @param {DOMParserOptions} [options]
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
 */
function DOMParser(options) {
	options = options || {};
	if (options.locator === undefined) {
		options.locator = true;
	}

	/**
	 * The method to use instead of `conventions.assign`, which is used to copy values from
	 * `options`
	 * before they are used for parsing.
	 *
	 * @type {conventions.assign}
	 * @private
	 * @see {@link conventions.assign}
	 * @readonly
	 */
	this.assign = options.assign || conventions.assign;

	/**
	 * For internal testing: The class for creating an instance for handling events from the SAX
	 * parser.
	 * *****Warning: By configuring a faulty implementation, the specified behavior can completely
	 * be broken*****.
	 *
	 * @type {typeof DOMHandler}
	 * @private
	 * @readonly
	 */
	this.domHandler = options.domHandler || DOMHandler;

	/**
	 * A function that is invoked for every error that occurs during parsing.
	 *
	 * If it is not provided, all errors are reported to `console.error`
	 * and only `fatalError`s are thrown as a `ParseError`,
	 * which prevents any further processing.
	 * If the provided method throws, a `ParserError` is thrown,
	 * which prevents any further processing.
	 *
	 * Be aware that many `warning`s are considered an error that prevents further processing in
	 * most implementations.
	 *
	 * @type {function(level:ErrorLevel, message:string, context: DOMHandler):void}
	 * @see {@link onErrorStopParsing}
	 * @see {@link onWarningStopParsing}
	 */
	this.onError = options.onError || options.errorHandler;
	if (options.errorHandler && typeof options.errorHandler !== 'function') {
		throw new TypeError('errorHandler object is no longer supported, switch to onError!');
	} else if (options.errorHandler) {
		options.errorHandler('warning', 'The `errorHandler` option has been deprecated, use `onError` instead!', this);
	}

	/**
	 * used to replace line endings before parsing, defaults to `normalizeLineEndings`
	 *
	 * @type {(string) => string}
	 * @readonly
	 */
	this.normalizeLineEndings = options.normalizeLineEndings || normalizeLineEndings;

	/**
	 * Configures if the nodes created during parsing will have a `lineNumber` and a
	 * `columnNumber`
	 * attribute describing their location in the XML string.
	 * Default is true.
	 *
	 * @type {boolean}
	 * @readonly
	 */
	this.locator = !!options.locator;

	/**
	 * The default namespace can be provided by the key that is the empty string.
	 * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,
	 * the default namespace that will be used,
	 * will be overridden according to the specification.
	 *
	 * @type {Readonly<Object>}
	 * @readonly
	 */
	this.xmlns = this.assign(Object.create(null), options.xmlns);
}

/**
 * Parses `source` using the options in the way configured by the `DOMParserOptions` of `this`
 * `DOMParser`. If `mimeType` is `text/html` an HTML `Document` is created,
 * otherwise an XML `Document` is created.
 *
 * __It behaves different from the description in the living standard__:
 * - Uses the `options` passed to the `DOMParser` constructor to modify the behavior.
 * - Any unexpected input is reported to `onError` with either a `warning`,
 * `error` or `fatalError` level.
 * - Any `fatalError` throws a `ParseError` which prevents further processing.
 * - Any error thrown by `onError` is converted to a `ParseError` which prevents further
 * processing - If no `Document` was created during parsing it is reported as a `fatalError`.
 * *****Warning: By configuring a faulty DOMHandler implementation,
 * the specified behavior can completely be broken*****.
 *
 * @param {string} source
 * The XML mime type only allows string input!
 * @param {string} [mimeType='application/xml']
 * the mimeType or contentType of the document to be created determines the `type` of document
 * created (XML or HTML)
 * @returns {Document}
 * The `Document` node.
 * @throws {ParseError}
 * for any `fatalError` or anything that is thrown by `onError`
 * @throws {TypeError}
 * for any invalid `mimeType`
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString
 * @see https://html.spec.whatwg.org/#dom-domparser-parsefromstring-dev
 */
DOMParser.prototype.parseFromString = function (source, mimeType) {
	if (!isValidMimeType(mimeType)) {
		throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + mimeType + '" is not valid.');
	}
	var defaultNSMap = this.assign(Object.create(null), this.xmlns);
	var entityMap = entities.XML_ENTITIES;
	var defaultNamespace = defaultNSMap[''] || null;
	if (hasDefaultHTMLNamespace(mimeType)) {
		entityMap = entities.HTML_ENTITIES;
		defaultNamespace = NAMESPACE.HTML;
	} else if (mimeType === MIME_TYPE.XML_SVG_IMAGE) {
		defaultNamespace = NAMESPACE.SVG;
	}
	defaultNSMap[''] = defaultNamespace;
	defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;

	var domBuilder = new this.domHandler({
		mimeType: mimeType,
		defaultNamespace: defaultNamespace,
		onError: this.onError,
	});
	var locator = this.locator ? {} : undefined;
	if (this.locator) {
		domBuilder.setDocumentLocator(locator);
	}

	var sax = new XMLReader();
	sax.errorHandler = domBuilder;
	sax.domBuilder = domBuilder;
	var isXml = !conventions.isHTMLMimeType(mimeType);
	if (isXml && typeof source !== 'string') {
		sax.errorHandler.fatalError('source is not a string');
	}
	sax.parse(this.normalizeLineEndings(String(source)), defaultNSMap, entityMap);
	if (!domBuilder.doc.documentElement) {
		sax.errorHandler.fatalError('missing root element');
	}
	return domBuilder.doc;
};

/**
 * @typedef DOMHandlerOptions
 * @property {string} [mimeType=MIME_TYPE.XML_APPLICATION]
 * @property {string | null} [defaultNamespace=null]
 */
/**
 * The class that is used to handle events from the SAX parser to create the related DOM
 * elements.
 *
 * Some methods are only implemented as an empty function,
 * since they are (at least currently) not relevant for xmldom.
 *
 * @class
 * @param {DOMHandlerOptions} [options]
 * @see http://www.saxproject.org/apidoc/org/xml/sax/ext/DefaultHandler2.html
 */
function DOMHandler(options) {
	var opt = options || {};
	/**
	 * The mime type is used to determine if the DOM handler will create an XML or HTML document.
	 * Only if it is set to `text/html` it will create an HTML document.
	 * It defaults to MIME_TYPE.XML_APPLICATION.
	 *
	 * @type {string}
	 * @see {@link MIME_TYPE}
	 * @readonly
	 */
	this.mimeType = opt.mimeType || MIME_TYPE.XML_APPLICATION;

	/**
	 * The namespace to use to create an XML document.
	 * For the following reasons this is required:
	 * - The SAX API for `startDocument` doesn't offer any way to pass a namespace,
	 * since at that point there is no way for the parser to know what the default namespace from
	 * the document will be.
	 * - When creating using `DOMImplementation.createDocument` it is required to pass a
	 * namespace,
	 * to determine the correct `Document.contentType`, which should match `this.mimeType`.
	 * - When parsing an XML document with the `application/xhtml+xml` mimeType,
	 * the HTML namespace needs to be the default namespace.
	 *
	 * @type {string | null}
	 * @private
	 * @readonly
	 */
	this.defaultNamespace = opt.defaultNamespace || null;

	/**
	 * @type {boolean}
	 * @private
	 */
	this.cdata = false;

	/**
	 * The last `Element` that was created by `startElement`.
	 * `endElement` sets it to the `currentElement.parentNode`.
	 *
	 * Note: The sax parser currently sets it to white space text nodes between tags.
	 *
	 * @type {Element | Node | undefined}
	 * @private
	 */
	this.currentElement = undefined;

	/**
	 * The Document that is created as part of `startDocument`,
	 * and returned by `DOMParser.parseFromString`.
	 *
	 * @type {Document | undefined}
	 * @readonly
	 */
	this.doc = undefined;

	/**
	 * The locator is stored as part of setDocumentLocator.
	 * It is controlled and mutated by the SAX parser to store the current parsing position.
	 * It is used by DOMHandler to set `columnNumber` and `lineNumber`
	 * on the DOM nodes.
	 *
	 * @type {Readonly<Locator> | undefined}
	 * @private
	 * @readonly (the
	 * sax parser currently sometimes set's it)
	 */
	this.locator = undefined;
	/**
	 * @type {function (level:ErrorLevel ,message:string, context:DOMHandler):void}
	 * @readonly
	 */
	this.onError = opt.onError;
}

function position(locator, node) {
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}

DOMHandler.prototype = {
	/**
	 * Either creates an XML or an HTML document and stores it under `this.doc`.
	 * If it is an XML document, `this.defaultNamespace` is used to create it,
	 * and it will not contain any `childNodes`.
	 * If it is an HTML document, it will be created without any `childNodes`.
	 *
	 * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */
	startDocument: function () {
		var impl = new DOMImplementation();
		this.doc = isHTMLMimeType(this.mimeType) ? impl.createHTMLDocument(false) : impl.createDocument(this.defaultNamespace, '');
	},
	startElement: function (namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
		var el = doc.createElementNS(namespaceURI, qName || localName);
		var len = attrs.length;
		appendElement(this, el);
		this.currentElement = el;

		this.locator && position(this.locator, el);
		for (var i = 0; i < len; i++) {
			var namespaceURI = attrs.getURI(i);
			var value = attrs.getValue(i);
			var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator && position(attrs.getLocator(i), attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr);
		}
	},
	endElement: function (namespaceURI, localName, qName) {
		this.currentElement = this.currentElement.parentNode;
	},
	startPrefixMapping: function (prefix, uri) {},
	endPrefixMapping: function (prefix) {},
	processingInstruction: function (target, data) {
		var ins = this.doc.createProcessingInstruction(target, data);
		this.locator && position(this.locator, ins);
		appendElement(this, ins);
	},
	ignorableWhitespace: function (ch, start, length) {},
	characters: function (chars, start, length) {
		chars = _toString.apply(this, arguments);
		//console.log(chars)
		if (chars) {
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if (this.currentElement) {
				this.currentElement.appendChild(charNode);
			} else if (/^\s*$/.test(chars)) {
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator, charNode);
		}
	},
	skippedEntity: function (name) {},
	endDocument: function () {
		this.doc.normalize();
	},
	/**
	 * Stores the locator to be able to set the `columnNumber` and `lineNumber`
	 * on the created DOM nodes.
	 *
	 * @param {Locator} locator
	 */
	setDocumentLocator: function (locator) {
		if (locator) {
			locator.lineNumber = 0;
		}
		this.locator = locator;
	},
	//LexicalHandler
	comment: function (chars, start, length) {
		chars = _toString.apply(this, arguments);
		var comm = this.doc.createComment(chars);
		this.locator && position(this.locator, comm);
		appendElement(this, comm);
	},

	startCDATA: function () {
		//used in characters() methods
		this.cdata = true;
	},
	endCDATA: function () {
		this.cdata = false;
	},

	startDTD: function (name, publicId, systemId, internalSubset) {
		var impl = this.doc.implementation;
		if (impl && impl.createDocumentType) {
			var dt = impl.createDocumentType(name, publicId, systemId, internalSubset);
			this.locator && position(this.locator, dt);
			appendElement(this, dt);
			this.doc.doctype = dt;
		}
	},
	reportError: function (level, message) {
		if (typeof this.onError === 'function') {
			try {
				this.onError(level, message, this);
			} catch (e) {
				throw new ParseError('Reporting ' + level + ' "' + message + '" caused ' + e, this.locator);
			}
		} else {
			console.error('[xmldom ' + level + ']\t' + message, _locator(this.locator));
		}
	},
	/**
	 * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning: function (message) {
		this.reportError('warning', message);
	},
	error: function (message) {
		this.reportError('error', message);
	},
	/**
	 * This function reports a fatal error and throws a ParseError.
	 *
	 * @param {string} message
	 * - The message to be used for reporting and throwing the error.
	 * @returns {never}
	 * This function always throws an error and never returns a value.
	 * @throws {ParseError}
	 * Always throws a ParseError with the provided message.
	 */
	fatalError: function (message) {
		this.reportError('fatalError', message);
		throw new ParseError(message, this.locator);
	},
};

function _locator(l) {
	if (l) {
		return '\n@#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';
	}
}

function _toString(chars, start, length) {
	if (typeof chars == 'string') {
		return chars.substr(start, length);
	} else {
		//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if (chars.length >= start + length || start) {
			return new java.lang.String(chars, start, length) + '';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
'endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl'.replace(
	/\w+/g,
	function (key) {
		DOMHandler.prototype[key] = function () {
			return null;
		};
	}
);

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement(handler, node) {
	if (!handler.currentElement) {
		handler.doc.appendChild(node);
	} else {
		handler.currentElement.appendChild(node);
	}
}

/**
 * A method that prevents any further parsing when an `error`
 * with level `error` is reported during parsing.
 *
 * @see {@link DOMParserOptions.onError}
 * @see {@link onWarningStopParsing}
 */
function onErrorStopParsing(level) {
	if (level === 'error') throw 'onErrorStopParsing';
}

/**
 * A method that prevents any further parsing when any `error` is reported during parsing.
 *
 * @see {@link DOMParserOptions.onError}
 * @see {@link onErrorStopParsing}
 */
function onWarningStopParsing() {
	throw 'onWarningStopParsing';
}

exports.__DOMHandler = DOMHandler;
exports.DOMParser = DOMParser;
exports.normalizeLineEndings = normalizeLineEndings;
exports.onErrorStopParsing = onErrorStopParsing;
exports.onWarningStopParsing = onWarningStopParsing;


/***/ }),

/***/ 714:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ Variables)
/* harmony export */ });
class Variables {
    static ensureLocale(loc, def) {
        if (!Variables.LOCALES.get(loc)) {
            console.error(`Locale ${loc} does not exist! Using` +
                ` ${Variables.LOCALES.get(def)} instead.`);
            return def;
        }
        return loc;
    }
}
Variables.VERSION = '5.0.0-beta.1';
Variables.LOCALES = new Map([
    ['af', 'Africaans'],
    ['ca', 'Catalan'],
    ['da', 'Danish'],
    ['de', 'German'],
    ['en', 'English'],
    ['es', 'Spanish'],
    ['euro', 'Euro'],
    ['fr', 'French'],
    ['hi', 'Hindi'],
    ['it', 'Italian'],
    ['ko', 'Korean'],
    ['nb', 'Bokml'],
    ['nn', 'Nynorsk'],
    ['sv', 'Swedish'],
    ['nemeth', 'Nemeth']
]);
Variables.mathjaxVersion = '4.0.0';
Variables.url = 'https://cdn.jsdelivr.net/npm/speech-rule-engine@' +
    Variables.VERSION +
    '/lib/mathmaps';
//# sourceMappingURL=variables.js.map

/***/ }),

/***/ 731:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Detects relevant unicode support for regular expressions in the runtime.
 * Should the runtime not accepts the flag `u` or unicode ranges,
 * character classes without unicode handling will be used.
 *
 * @param {typeof RegExp} [RegExpImpl=RegExp]
 * For testing: the RegExp class.
 * @returns {boolean}
 * @see https://node.green/#ES2015-syntax-RegExp--y--and--u--flags
 */
function detectUnicodeSupport(RegExpImpl) {
	try {
		if (typeof RegExpImpl !== 'function') {
			RegExpImpl = RegExp;
		}
		// eslint-disable-next-line es5/no-unicode-regex,es5/no-unicode-code-point-escape
		var match = new RegExpImpl('\u{1d306}', 'u').exec('');
		return !!match && match[0].length === 2;
	} catch (error) {}
	return false;
}
var UNICODE_SUPPORT = detectUnicodeSupport();

/**
 * Removes `[`, `]` and any trailing quantifiers from the source of a RegExp.
 *
 * @param {RegExp} regexp
 */
function chars(regexp) {
	if (regexp.source[0] !== '[') {
		throw new Error(regexp + ' can not be used with chars');
	}
	return regexp.source.slice(1, regexp.source.lastIndexOf(']'));
}

/**
 * Creates a new character list regular expression,
 * by removing `search` from the source of `regexp`.
 *
 * @param {RegExp} regexp
 * @param {string} search
 * The character(s) to remove.
 * @returns {RegExp}
 */
function chars_without(regexp, search) {
	if (regexp.source[0] !== '[') {
		throw new Error('/' + regexp.source + '/ can not be used with chars_without');
	}
	if (!search || typeof search !== 'string') {
		throw new Error(JSON.stringify(search) + ' is not a valid search');
	}
	if (regexp.source.indexOf(search) === -1) {
		throw new Error('"' + search + '" is not is /' + regexp.source + '/');
	}
	if (search === '-' && regexp.source.indexOf(search) !== 1) {
		throw new Error('"' + search + '" is not at the first postion of /' + regexp.source + '/');
	}
	return new RegExp(regexp.source.replace(search, ''), UNICODE_SUPPORT ? 'u' : '');
}

/**
 * Combines and Regular expressions correctly by using `RegExp.source`.
 *
 * @param {...(RegExp | string)[]} args
 * @returns {RegExp}
 */
function reg(args) {
	var self = this;
	return new RegExp(
		Array.prototype.slice
			.call(arguments)
			.map(function (part) {
				var isStr = typeof part === 'string';
				if (isStr && self === undefined && part === '|') {
					throw new Error('use regg instead of reg to wrap expressions with `|`!');
				}
				return isStr ? part : part.source;
			})
			.join(''),
		UNICODE_SUPPORT ? 'mu' : 'm'
	);
}

/**
 * Like `reg` but wraps the expression in `(?:`,`)` to create a non tracking group.
 *
 * @param {...(RegExp | string)[]} args
 * @returns {RegExp}
 */
function regg(args) {
	if (arguments.length === 0) {
		throw new Error('no parameters provided');
	}
	return reg.apply(regg, ['(?:'].concat(Array.prototype.slice.call(arguments), [')']));
}

// /**
//  * Append ^ to the beginning of the expression.
//  * @param {...(RegExp | string)[]} args
//  * @returns {RegExp}
//  */
// function reg_start(args) {
// 	if (arguments.length === 0) {
// 		throw new Error('no parameters provided');
// 	}
// 	return reg.apply(reg_start, ['^'].concat(Array.prototype.slice.call(arguments)));
// }

// https://www.w3.org/TR/xml/#document
// `[1] document ::= prolog element Misc*`
// https://www.w3.org/TR/xml11/#NT-document
// `[1] document ::= ( prolog element Misc* ) - ( Char* RestrictedChar Char* )`

/**
 * A character usually appearing in wrongly converted strings.
 *
 * @type {string}
 * @see https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
 * @see https://nodejs.dev/en/api/v18/buffer/#buffers-and-character-encodings
 * @see https://www.unicode.org/faq/utf_bom.html#BOM
 * @readonly
 */
var UNICODE_REPLACEMENT_CHARACTER = '\uFFFD';
// https://www.w3.org/TR/xml/#NT-Char
// any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
// `[2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]`
// https://www.w3.org/TR/xml11/#NT-Char
// `[2] Char ::= [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]`
// https://www.w3.org/TR/xml11/#NT-RestrictedChar
// `[2a] RestrictedChar ::= [#x1-#x8] | [#xB-#xC] | [#xE-#x1F] | [#x7F-#x84] | [#x86-#x9F]`
// https://www.w3.org/TR/xml11/#charsets
var Char = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/; // without \u10000-\uEFFFF
if (UNICODE_SUPPORT) {
	// eslint-disable-next-line es5/no-unicode-code-point-escape
	Char = reg('[', chars(Char), '\\u{10000}-\\u{10FFFF}', ']');
}

var _SChar = /[\x20\x09\x0D\x0A]/;
var SChar_s = chars(_SChar);
// https://www.w3.org/TR/xml11/#NT-S
// `[3] S ::= (#x20 | #x9 | #xD | #xA)+`
var S = reg(_SChar, '+');
// optional whitespace described as `S?` in the grammar,
// simplified to 0-n occurrences of the character class
// instead of 0-1 occurrences of a non-capturing group around S
var S_OPT = reg(_SChar, '*');

// https://www.w3.org/TR/xml11/#NT-NameStartChar
// `[4] NameStartChar ::= ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]`
var NameStartChar =
	/[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/; // without \u10000-\uEFFFF
if (UNICODE_SUPPORT) {
	// eslint-disable-next-line es5/no-unicode-code-point-escape
	NameStartChar = reg('[', chars(NameStartChar), '\\u{10000}-\\u{10FFFF}', ']');
}
var NameStartChar_s = chars(NameStartChar);

// https://www.w3.org/TR/xml11/#NT-NameChar
// `[4a] NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]`
var NameChar = reg('[', NameStartChar_s, chars(/[-.0-9\xB7]/), chars(/[\u0300-\u036F\u203F-\u2040]/), ']');
// https://www.w3.org/TR/xml11/#NT-Name
// `[5] Name ::= NameStartChar (NameChar)*`
var Name = reg(NameStartChar, NameChar, '*');
/*
https://www.w3.org/TR/xml11/#NT-Names
`[6] Names ::= Name (#x20 Name)*`
*/

// https://www.w3.org/TR/xml11/#NT-Nmtoken
// `[7] Nmtoken ::= (NameChar)+`
var Nmtoken = reg(NameChar, '+');
/*
https://www.w3.org/TR/xml11/#NT-Nmtokens
`[8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*`
var Nmtokens = reg(Nmtoken, regg(/\x20/, Nmtoken), '*');
*/

// https://www.w3.org/TR/xml11/#NT-EntityRef
// `[68] EntityRef ::= '&' Name ';'` [WFC: Entity Declared] [VC: Entity Declared] [WFC: Parsed Entity] [WFC: No Recursion]
var EntityRef = reg('&', Name, ';');
// https://www.w3.org/TR/xml11/#NT-CharRef
// `[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'` [WFC: Legal Character]
var CharRef = regg(/&#[0-9]+;|&#x[0-9a-fA-F]+;/);

/*
https://www.w3.org/TR/xml11/#NT-Reference
- `[67] Reference ::= EntityRef | CharRef`
- `[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'` [WFC: Legal Character]
- `[68] EntityRef ::= '&' Name ';'` [WFC: Entity Declared] [VC: Entity Declared] [WFC: Parsed Entity] [WFC: No Recursion]
*/
var Reference = regg(EntityRef, '|', CharRef);

// https://www.w3.org/TR/xml11/#NT-PEReference
// `[69] PEReference ::= '%' Name ';'`
// [VC: Entity Declared] [WFC: No Recursion] [WFC: In DTD]
var PEReference = reg('%', Name, ';');

// https://www.w3.org/TR/xml11/#NT-EntityValue
// `[9] EntityValue ::= '"' ([^%&"] | PEReference | Reference)* '"' | "'" ([^%&'] | PEReference | Reference)* "'"`
var EntityValue = regg(
	reg('"', regg(/[^%&"]/, '|', PEReference, '|', Reference), '*', '"'),
	'|',
	reg("'", regg(/[^%&']/, '|', PEReference, '|', Reference), '*', "'")
);

// https://www.w3.org/TR/xml11/#NT-AttValue
// `[10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"`
var AttValue = regg('"', regg(/[^<&"]/, '|', Reference), '*', '"', '|', "'", regg(/[^<&']/, '|', Reference), '*', "'");

// https://www.w3.org/TR/xml-names/#ns-decl
// https://www.w3.org/TR/xml-names/#ns-qualnames
// NameStartChar without ":"
var NCNameStartChar = chars_without(NameStartChar, ':');
// https://www.w3.org/TR/xml-names/#orphans
// `[5] NCNameChar ::= NameChar - ':'`
// An XML NameChar, minus the ":"
var NCNameChar = chars_without(NameChar, ':');
// https://www.w3.org/TR/xml-names/#NT-NCName
// `[4] NCName ::= Name - (Char* ':' Char*)`
// An XML Name, minus the ":"
var NCName = reg(NCNameStartChar, NCNameChar, '*');

/**
https://www.w3.org/TR/xml-names/#ns-qualnames

```
[7] QName ::= PrefixedName | UnprefixedName
				  === (NCName ':' NCName) | NCName
				  === NCName (':' NCName)?
[8] PrefixedName ::= Prefix ':' LocalPart
								 === NCName ':' NCName
[9] UnprefixedName ::= LocalPart
									 === NCName
[10] Prefix ::= NCName
[11] LocalPart ::= NCName
```
*/
var QName = reg(NCName, regg(':', NCName), '?');
var QName_exact = reg('^', QName, '$');
var QName_group = reg('(', QName, ')');

// https://www.w3.org/TR/xml11/#NT-SystemLiteral
// `[11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")`
var SystemLiteral = regg(/"[^"]*"|'[^']*'/);

/*
 https://www.w3.org/TR/xml11/#NT-PI
 ```
 [17] PITarget    ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
 [16] PI    ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
 ```
 target /xml/i is not excluded!
*/
var PI = reg(/^<\?/, '(', Name, ')', regg(S, '(', Char, '*?)'), '?', /\?>/);

// https://www.w3.org/TR/xml11/#NT-PubidChar
// `[13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]`
var PubidChar = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/;

// https://www.w3.org/TR/xml11/#NT-PubidLiteral
// `[12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"`
var PubidLiteral = regg('"', PubidChar, '*"', '|', "'", chars_without(PubidChar, "'"), "*'");

// https://www.w3.org/TR/xml11/#NT-CharData
// `[14] CharData    ::= [^<&]* - ([^<&]* ']]>' [^<&]*)`

var COMMENT_START = '<!--';
var COMMENT_END = '-->';
// https://www.w3.org/TR/xml11/#NT-Comment
// `[15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'`
var Comment = reg(COMMENT_START, regg(chars_without(Char, '-'), '|', reg('-', chars_without(Char, '-'))), '*', COMMENT_END);

var PCDATA = '#PCDATA';
// https://www.w3.org/TR/xml11/#NT-Mixed
// `[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'`
// https://www.w3.org/TR/xml-names/#NT-Mixed
// `[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? QName)* S? ')*' | '(' S? '#PCDATA' S? ')'`
// [VC: Proper Group/PE Nesting] [VC: No Duplicate Types]
var Mixed = regg(
	reg(/\(/, S_OPT, PCDATA, regg(S_OPT, /\|/, S_OPT, QName), '*', S_OPT, /\)\*/),
	'|',
	reg(/\(/, S_OPT, PCDATA, S_OPT, /\)/)
);

var _children_quantity = /[?*+]?/;
/*
 `[49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')'` [VC: Proper Group/PE Nesting]
 `[50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'` [VC: Proper Group/PE Nesting]
 simplification to solve circular referencing, but doesn't check validity constraint "Proper Group/PE Nesting"
 var _choice_or_seq = reg('[', NameChar_s, SChar_s, chars(_children_quantity), '()|,]*');
 ```
 [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
         === (Name | '(' S? cp ( S? '|' S? cp )+ S? ')' | '(' S? cp ( S? ',' S? cp )* S? ')') ('?' | '*' | '+')?
         !== (Name | [_choice_or_seq]*) ('?' | '*' | '+')?
 ```
 simplification to solve circular referencing, but doesn't check validity constraint "Proper Group/PE Nesting"
 var cp = reg(regg(Name, '|', _choice_or_seq), _children_quantity);
*/
/*
Inefficient regular expression (High)
This part of the regular expression may cause exponential backtracking on strings starting with '(|' and containing many repetitions of '|'.
https://github.com/xmldom/xmldom/security/code-scanning/91
var choice = regg(/\(/, S_OPT, cp, regg(S_OPT, /\|/, S_OPT, cp), '+', S_OPT, /\)/);
*/
/*
Inefficient regular expression (High)
This part of the regular expression may cause exponential backtracking on strings starting with '(,' and containing many repetitions of ','.
https://github.com/xmldom/xmldom/security/code-scanning/92
var seq = regg(/\(/, S_OPT, cp, regg(S_OPT, /,/, S_OPT, cp), '*', S_OPT, /\)/);
*/

// `[47] children ::= (choice | seq) ('?' | '*' | '+')?`
// simplification to solve circular referencing, but doesn't check validity constraint "Proper Group/PE Nesting"
var children = reg(/\([^>]+\)/, _children_quantity /*regg(choice, '|', seq), _children_quantity*/);

// https://www.w3.org/TR/xml11/#NT-contentspec
// `[46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children`
var contentspec = regg('EMPTY', '|', 'ANY', '|', Mixed, '|', children);

var ELEMENTDECL_START = '<!ELEMENT';
// https://www.w3.org/TR/xml11/#NT-elementdecl
// `[45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'`
// https://www.w3.org/TR/xml-names/#NT-elementdecl
// `[17] elementdecl ::= '<!ELEMENT' S QName S contentspec S? '>'`
// because of https://www.w3.org/TR/xml11/#NT-PEReference
// since xmldom is not supporting replacements of PEReferences in the DTD
// this also supports PEReference in the possible places
var elementdecl = reg(ELEMENTDECL_START, S, regg(QName, '|', PEReference), S, regg(contentspec, '|', PEReference), S_OPT, '>');

// https://www.w3.org/TR/xml11/#NT-NotationType
// `[58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'`
// [VC: Notation Attributes] [VC: One Notation Per Element Type] [VC: No Notation on Empty Element] [VC: No Duplicate Tokens]
var NotationType = reg('NOTATION', S, /\(/, S_OPT, Name, regg(S_OPT, /\|/, S_OPT, Name), '*', S_OPT, /\)/);
// https://www.w3.org/TR/xml11/#NT-Enumeration
// `[59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'`
// [VC: Enumeration] [VC: No Duplicate Tokens]
var Enumeration = reg(/\(/, S_OPT, Nmtoken, regg(S_OPT, /\|/, S_OPT, Nmtoken), '*', S_OPT, /\)/);

// https://www.w3.org/TR/xml11/#NT-EnumeratedType
// `[57] EnumeratedType ::= NotationType | Enumeration`
var EnumeratedType = regg(NotationType, '|', Enumeration);

/*
```
[55] StringType ::= 'CDATA'
[56] TokenizedType ::= 'ID' [VC: ID] [VC: One ID per Element Type] [VC: ID Attribute Default]
   | 'IDREF' [VC: IDREF]
   | 'IDREFS' [VC: IDREF]
	 | 'ENTITY' [VC: Entity Name]
	 | 'ENTITIES' [VC: Entity Name]
	 | 'NMTOKEN' [VC: Name Token]
	 | 'NMTOKENS' [VC: Name Token]
 [54] AttType ::= StringType | TokenizedType | EnumeratedType
```*/
var AttType = regg(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, '|', EnumeratedType);

// `[60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)`
// [WFC: No < in Attribute Values] [WFC: No External Entity References]
// [VC: Fixed Attribute Default] [VC: Required Attribute] [VC: Attribute Default Value Syntactically Correct]
var DefaultDecl = regg(/#REQUIRED|#IMPLIED/, '|', regg(regg('#FIXED', S), '?', AttValue));

// https://www.w3.org/TR/xml11/#NT-AttDef
// [53] AttDef ::= S Name S AttType S DefaultDecl
// https://www.w3.org/TR/xml-names/#NT-AttDef
// [1] NSAttName ::= PrefixedAttName | DefaultAttName
// [2] PrefixedAttName ::= 'xmlns:' NCName [NSC: Reserved Prefixes and Namespace Names]
// [3] DefaultAttName ::= 'xmlns'
// [21] AttDef ::= S (QName | NSAttName) S AttType S DefaultDecl
// 						 === S Name S AttType S DefaultDecl
// xmldom is not distinguishing between QName and NSAttName on this level
// to support XML without namespaces in DTD we can not restrict it to QName
var AttDef = regg(S, Name, S, AttType, S, DefaultDecl);

var ATTLIST_DECL_START = '<!ATTLIST';
// https://www.w3.org/TR/xml11/#NT-AttlistDecl
// `[52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'`
// https://www.w3.org/TR/xml-names/#NT-AttlistDecl
// `[20] AttlistDecl ::= '<!ATTLIST' S QName AttDef* S? '>'`
// to support XML without namespaces in DTD we can not restrict it to QName
var AttlistDecl = reg(ATTLIST_DECL_START, S, Name, AttDef, '*', S_OPT, '>');

// https://html.spec.whatwg.org/multipage/urls-and-fetching.html#about:legacy-compat
var ABOUT_LEGACY_COMPAT = 'about:legacy-compat';
var ABOUT_LEGACY_COMPAT_SystemLiteral = regg('"' + ABOUT_LEGACY_COMPAT + '"', '|', "'" + ABOUT_LEGACY_COMPAT + "'");
var SYSTEM = 'SYSTEM';
var PUBLIC = 'PUBLIC';
// https://www.w3.org/TR/xml11/#NT-ExternalID
// `[75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral`
var ExternalID = regg(regg(SYSTEM, S, SystemLiteral), '|', regg(PUBLIC, S, PubidLiteral, S, SystemLiteral));
var ExternalID_match = reg(
	'^',
	regg(
		regg(SYSTEM, S, '(?<SystemLiteralOnly>', SystemLiteral, ')'),
		'|',
		regg(PUBLIC, S, '(?<PubidLiteral>', PubidLiteral, ')', S, '(?<SystemLiteral>', SystemLiteral, ')')
	)
);

// https://www.w3.org/TR/xml11/#NT-NDataDecl
// `[76] NDataDecl ::= S 'NDATA' S Name` [VC: Notation Declared]
var NDataDecl = regg(S, 'NDATA', S, Name);

// https://www.w3.org/TR/xml11/#NT-EntityDef
// `[73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)`
var EntityDef = regg(EntityValue, '|', regg(ExternalID, NDataDecl, '?'));

var ENTITY_DECL_START = '<!ENTITY';
// https://www.w3.org/TR/xml11/#NT-GEDecl
// `[71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'`
var GEDecl = reg(ENTITY_DECL_START, S, Name, S, EntityDef, S_OPT, '>');
// https://www.w3.org/TR/xml11/#NT-PEDef
// `[74] PEDef ::= EntityValue | ExternalID`
var PEDef = regg(EntityValue, '|', ExternalID);
// https://www.w3.org/TR/xml11/#NT-PEDecl
// `[72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'`
var PEDecl = reg(ENTITY_DECL_START, S, '%', S, Name, S, PEDef, S_OPT, '>');
// https://www.w3.org/TR/xml11/#NT-EntityDecl
// `[70] EntityDecl ::= GEDecl | PEDecl`
var EntityDecl = regg(GEDecl, '|', PEDecl);

// https://www.w3.org/TR/xml11/#NT-PublicID
// `[83] PublicID    ::= 'PUBLIC' S PubidLiteral`
var PublicID = reg(PUBLIC, S, PubidLiteral);
// https://www.w3.org/TR/xml11/#NT-NotationDecl
// `[82] NotationDecl    ::= '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'` [VC: Unique Notation Name]
var NotationDecl = reg('<!NOTATION', S, Name, S, regg(ExternalID, '|', PublicID), S_OPT, '>');

// https://www.w3.org/TR/xml11/#NT-Eq
// `[25] Eq ::= S? '=' S?`
var Eq = reg(S_OPT, '=', S_OPT);
// https://www.w3.org/TR/xml/#NT-VersionNum
// `[26] VersionNum ::= '1.' [0-9]+`
// https://www.w3.org/TR/xml11/#NT-VersionNum
// `[26] VersionNum ::= '1.1'`
var VersionNum = /1[.]\d+/;
// https://www.w3.org/TR/xml11/#NT-VersionInfo
// `[24] VersionInfo ::= S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')`
var VersionInfo = reg(S, 'version', Eq, regg("'", VersionNum, "'", '|', '"', VersionNum, '"'));
// https://www.w3.org/TR/xml11/#NT-EncName
// `[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*`
var EncName = /[A-Za-z][-A-Za-z0-9._]*/;
// https://www.w3.org/TR/xml11/#NT-EncDecl
// `[80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )`
var EncodingDecl = regg(S, 'encoding', Eq, regg('"', EncName, '"', '|', "'", EncName, "'"));
// https://www.w3.org/TR/xml11/#NT-SDDecl
// `[32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"'))`
var SDDecl = regg(S, 'standalone', Eq, regg("'", regg('yes', '|', 'no'), "'", '|', '"', regg('yes', '|', 'no'), '"'));
// https://www.w3.org/TR/xml11/#NT-XMLDecl
// [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
var XMLDecl = reg(/^<\?xml/, VersionInfo, EncodingDecl, '?', SDDecl, '?', S_OPT, /\?>/);

/*
 https://www.w3.org/TR/xml/#NT-markupdecl
 https://www.w3.org/TR/xml11/#NT-markupdecl
 `[29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment`
 var markupdecl = regg(elementdecl, '|', AttlistDecl, '|', EntityDecl, '|', NotationDecl, '|', PI_unsafe, '|', Comment);
*/
/*
 https://www.w3.org/TR/xml-names/#NT-doctypedecl
`[28a] DeclSep   ::= PEReference | S`
 https://www.w3.org/TR/xml11/#NT-intSubset
```
 [28b] intSubset ::= (markupdecl | DeclSep)*
                 === (markupdecl | PEReference | S)*
```
 [WFC: PE Between Declarations]
 var intSubset = reg(regg(markupdecl, '|', PEReference, '|', S), '*');
*/
var DOCTYPE_DECL_START = '<!DOCTYPE';
/*
 https://www.w3.org/TR/xml11/#NT-doctypedecl
 `[28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'`
 https://www.afterwardsw3.org/TR/xml-names/#NT-doctypedecl
 `[16] doctypedecl ::= '<!DOCTYPE' S QName (S ExternalID)? S? ('[' (markupdecl | PEReference | S)* ']' S?)? '>'`
 var doctypedecl = reg('<!DOCTYPE', S, Name, regg(S, ExternalID), '?', S_OPT, regg(/\[/, intSubset, /]/, S_OPT), '?', '>');
*/

var CDATA_START = '<![CDATA[';
var CDATA_END = ']]>';
var CDStart = /<!\[CDATA\[/;
var CDEnd = /\]\]>/;
var CData = reg(Char, '*?', CDEnd);
/*
 https://www.w3.org/TR/xml/#dt-cdsection
 `[18]   	CDSect	   ::=   	CDStart CData CDEnd`
 `[19]   	CDStart	   ::=   	'<![CDATA['`
 `[20]   	CData	   ::=   	(Char* - (Char* ']]>' Char*))`
 `[21]   	CDEnd	   ::=   	']]>'`
*/
var CDSect = reg(CDStart, CData);

// unit tested
exports.chars = chars;
exports.chars_without = chars_without;
exports.detectUnicodeSupport = detectUnicodeSupport;
exports.reg = reg;
exports.regg = regg;
exports.ABOUT_LEGACY_COMPAT = ABOUT_LEGACY_COMPAT;
exports.ABOUT_LEGACY_COMPAT_SystemLiteral = ABOUT_LEGACY_COMPAT_SystemLiteral;
exports.AttlistDecl = AttlistDecl;
exports.CDATA_START = CDATA_START;
exports.CDATA_END = CDATA_END;
exports.CDSect = CDSect;
exports.Char = Char;
exports.Comment = Comment;
exports.COMMENT_START = COMMENT_START;
exports.COMMENT_END = COMMENT_END;
exports.DOCTYPE_DECL_START = DOCTYPE_DECL_START;
exports.elementdecl = elementdecl;
exports.EntityDecl = EntityDecl;
exports.EntityValue = EntityValue;
exports.ExternalID = ExternalID;
exports.ExternalID_match = ExternalID_match;
exports.Name = Name;
exports.NotationDecl = NotationDecl;
exports.Reference = Reference;
exports.PEReference = PEReference;
exports.PI = PI;
exports.PUBLIC = PUBLIC;
exports.PubidLiteral = PubidLiteral;
exports.QName = QName;
exports.QName_exact = QName_exact;
exports.QName_group = QName_group;
exports.S = S;
exports.SChar_s = SChar_s;
exports.S_OPT = S_OPT;
exports.SYSTEM = SYSTEM;
exports.SystemLiteral = SystemLiteral;
exports.UNICODE_REPLACEMENT_CHARACTER = UNICODE_REPLACEMENT_CHARACTER;
exports.UNICODE_SUPPORT = UNICODE_SUPPORT;
exports.XMLDecl = XMLDecl;


/***/ }),

/***/ 767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var conventions = __webpack_require__(870);

function extendError(constructor, writableName) {
	constructor.prototype = Object.create(Error.prototype, {
		constructor: { value: constructor },
		name: { value: constructor.name, enumerable: true, writable: writableName },
	});
}

var DOMExceptionName = conventions.freeze({
	/**
	 * the default value as defined by the spec
	 */
	Error: 'Error',
	/**
	 * @deprecated
	 * Use RangeError instead.
	 */
	IndexSizeError: 'IndexSizeError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	DomstringSizeError: 'DomstringSizeError',
	HierarchyRequestError: 'HierarchyRequestError',
	WrongDocumentError: 'WrongDocumentError',
	InvalidCharacterError: 'InvalidCharacterError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	NoDataAllowedError: 'NoDataAllowedError',
	NoModificationAllowedError: 'NoModificationAllowedError',
	NotFoundError: 'NotFoundError',
	NotSupportedError: 'NotSupportedError',
	InUseAttributeError: 'InUseAttributeError',
	InvalidStateError: 'InvalidStateError',
	SyntaxError: 'SyntaxError',
	InvalidModificationError: 'InvalidModificationError',
	NamespaceError: 'NamespaceError',
	/**
	 * @deprecated
	 * Use TypeError for invalid arguments,
	 * "NotSupportedError" DOMException for unsupported operations,
	 * and "NotAllowedError" DOMException for denied requests instead.
	 */
	InvalidAccessError: 'InvalidAccessError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	ValidationError: 'ValidationError',
	/**
	 * @deprecated
	 * Use TypeError instead.
	 */
	TypeMismatchError: 'TypeMismatchError',
	SecurityError: 'SecurityError',
	NetworkError: 'NetworkError',
	AbortError: 'AbortError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	URLMismatchError: 'URLMismatchError',
	QuotaExceededError: 'QuotaExceededError',
	TimeoutError: 'TimeoutError',
	InvalidNodeTypeError: 'InvalidNodeTypeError',
	DataCloneError: 'DataCloneError',
	EncodingError: 'EncodingError',
	NotReadableError: 'NotReadableError',
	UnknownError: 'UnknownError',
	ConstraintError: 'ConstraintError',
	DataError: 'DataError',
	TransactionInactiveError: 'TransactionInactiveError',
	ReadOnlyError: 'ReadOnlyError',
	VersionError: 'VersionError',
	OperationError: 'OperationError',
	NotAllowedError: 'NotAllowedError',
	OptOutError: 'OptOutError',
});
var DOMExceptionNames = Object.keys(DOMExceptionName);

function isValidDomExceptionCode(value) {
	return typeof value === 'number' && value >= 1 && value <= 25;
}
function endsWithError(value) {
	return typeof value === 'string' && value.substring(value.length - DOMExceptionName.Error.length) === DOMExceptionName.Error;
}
/**
 * DOM operations only raise exceptions in "exceptional" circumstances, i.e., when an operation
 * is impossible to perform (either for logical reasons, because data is lost, or because the
 * implementation has become unstable). In general, DOM methods return specific error values in
 * ordinary processing situations, such as out-of-bound errors when using NodeList.
 *
 * Implementations should raise other exceptions under other circumstances. For example,
 * implementations should raise an implementation-dependent exception if a null argument is
 * passed when null was not expected.
 *
 * This implementation supports the following usages:
 * 1. according to the living standard (both arguments are optional):
 * ```
 * new DOMException("message (can be empty)", DOMExceptionNames.HierarchyRequestError)
 * ```
 * 2. according to previous xmldom implementation (only the first argument is required):
 * ```
 * new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "optional message")
 * ```
 * both result in the proper name being set.
 *
 * @class DOMException
 * @param {number | string} messageOrCode
 * The reason why an operation is not acceptable.
 * If it is a number, it is used to determine the `name`, see
 * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-258A00AF ExceptionCode}
 * @param {string | keyof typeof DOMExceptionName | Error} [nameOrMessage]
 * The `name` to use for the error.
 * If `messageOrCode` is a number, this arguments is used as the `message` instead.
 * @augments Error
 * @see https://webidl.spec.whatwg.org/#idl-DOMException
 * @see https://webidl.spec.whatwg.org/#dfn-error-names-table
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-17189187
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException(messageOrCode, nameOrMessage) {
	// support old way of passing arguments: first argument is a valid number
	if (isValidDomExceptionCode(messageOrCode)) {
		this.name = DOMExceptionNames[messageOrCode];
		this.message = nameOrMessage || '';
	} else {
		this.message = messageOrCode;
		this.name = endsWithError(nameOrMessage) ? nameOrMessage : DOMExceptionName.Error;
	}
	if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
}
extendError(DOMException, true);
Object.defineProperties(DOMException.prototype, {
	code: {
		enumerable: true,
		get: function () {
			var code = DOMExceptionNames.indexOf(this.name);
			if (isValidDomExceptionCode(code)) return code;
			return 0;
		},
	},
});

var ExceptionCode = {
	INDEX_SIZE_ERR: 1,
	DOMSTRING_SIZE_ERR: 2,
	HIERARCHY_REQUEST_ERR: 3,
	WRONG_DOCUMENT_ERR: 4,
	INVALID_CHARACTER_ERR: 5,
	NO_DATA_ALLOWED_ERR: 6,
	NO_MODIFICATION_ALLOWED_ERR: 7,
	NOT_FOUND_ERR: 8,
	NOT_SUPPORTED_ERR: 9,
	INUSE_ATTRIBUTE_ERR: 10,
	INVALID_STATE_ERR: 11,
	SYNTAX_ERR: 12,
	INVALID_MODIFICATION_ERR: 13,
	NAMESPACE_ERR: 14,
	INVALID_ACCESS_ERR: 15,
	VALIDATION_ERR: 16,
	TYPE_MISMATCH_ERR: 17,
	SECURITY_ERR: 18,
	NETWORK_ERR: 19,
	ABORT_ERR: 20,
	URL_MISMATCH_ERR: 21,
	QUOTA_EXCEEDED_ERR: 22,
	TIMEOUT_ERR: 23,
	INVALID_NODE_TYPE_ERR: 24,
	DATA_CLONE_ERR: 25,
};

var entries = Object.entries(ExceptionCode);
for (var i = 0; i < entries.length; i++) {
	var key = entries[i][0];
	DOMException[key] = entries[i][1];
}

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @class
 * @param {string} message
 * @param {any} [locator]
 */
function ParseError(message, locator) {
	this.message = message;
	this.locator = locator;
	if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
}
extendError(ParseError);

exports.DOMException = DOMException;
exports.DOMExceptionName = DOMExceptionName;
exports.ExceptionCode = ExceptionCode;
exports.ParseError = ParseError;


/***/ }),

/***/ 786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var conventions = __webpack_require__(870);
var find = conventions.find;
var hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
var hasOwn = conventions.hasOwn;
var isHTMLMimeType = conventions.isHTMLMimeType;
var isHTMLRawTextElement = conventions.isHTMLRawTextElement;
var isHTMLVoidElement = conventions.isHTMLVoidElement;
var MIME_TYPE = conventions.MIME_TYPE;
var NAMESPACE = conventions.NAMESPACE;

/**
 * Private DOM Constructor symbol
 *
 * Internal symbol used for construction of all classes whose constructors should be private.
 * Currently used for checks in `Node`, `Document`, `Element`, `Attr`, `CharacterData`, `Text`, `Comment`,
 * `CDATASection`, `DocumentType`, `Notation`, `Entity`, `EntityReference`, `DocumentFragment`, `ProcessingInstruction`
 * so the constructor can't be used from outside the module.
 */
var PDC = Symbol();

var errors = __webpack_require__(767);
var DOMException = errors.DOMException;
var DOMExceptionName = errors.DOMExceptionName;

var g = __webpack_require__(731);

/**
 * Checks if the given symbol equals the Private DOM Constructor symbol (PDC)
 * and throws an Illegal constructor exception when the symbols don't match.
 * This ensures that the constructor remains private and can't be used outside this module.
 */
function checkSymbol(symbol) {
	if (symbol !== PDC) {
		throw new TypeError('Illegal constructor');
	}
}

/**
 * A prerequisite for `[].filter`, to drop elements that are empty.
 *
 * @param {string} input
 * The string to be checked.
 * @returns {boolean}
 * Returns `true` if the input string is not empty, `false` otherwise.
 */
function notEmptyString(input) {
	return input !== '';
}
/**
 * Splits a string on ASCII whitespace characters (U+0009 TAB, U+000A LF, U+000C FF, U+000D CR,
 * U+0020 SPACE).
 * It follows the definition from the infra specification from WHATWG.
 *
 * @param {string} input
 * The string to be split.
 * @returns {string[]}
 * An array of the split strings. The array can be empty if the input string is empty or only
 * contains whitespace characters.
 * @see {@link https://infra.spec.whatwg.org/#split-on-ascii-whitespace}
 * @see {@link https://infra.spec.whatwg.org/#ascii-whitespace}
 */
function splitOnASCIIWhitespace(input) {
	// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
	return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
}

/**
 * Adds element as a key to current if it is not already present.
 *
 * @param {Record<string, boolean | undefined>} current
 * The current record object to which the element will be added as a key.
 * The object's keys are string types and values are either boolean or undefined.
 * @param {string} element
 * The string to be added as a key to the current record.
 * @returns {Record<string, boolean | undefined>}
 * The updated record object after the addition of the new element.
 */
function orderedSetReducer(current, element) {
	if (!hasOwn(current, element)) {
		current[element] = true;
	}
	return current;
}

/**
 * Converts a string into an ordered set by splitting the input on ASCII whitespace and
 * ensuring uniqueness of elements.
 * This follows the definition of an ordered set from the infra specification by WHATWG.
 *
 * @param {string} input
 * The input string to be transformed into an ordered set.
 * @returns {string[]}
 * An array of unique strings obtained from the input, preserving the original order.
 * The array can be empty if the input string is empty or only contains whitespace characters.
 * @see {@link https://infra.spec.whatwg.org/#ordered-set}
 */
function toOrderedSet(input) {
	if (!input) return [];
	var list = splitOnASCIIWhitespace(input);
	return Object.keys(list.reduce(orderedSetReducer, {}));
}

/**
 * Uses `list.indexOf` to implement a function that behaves like `Array.prototype.includes`.
 * This function is used in environments where `Array.prototype.includes` may not be available.
 *
 * @param {any[]} list
 * The array in which to search for the element.
 * @returns {function(any): boolean}
 * A function that accepts an element and returns a boolean indicating whether the element is
 * included in the provided list.
 */
function arrayIncludes(list) {
	return function (element) {
		return list && list.indexOf(element) !== -1;
	};
}

/**
 * Validates a qualified name based on the criteria provided in the DOM specification by
 * WHATWG.
 *
 * @param {string} qualifiedName
 * The qualified name to be validated.
 * @throws {DOMException}
 * With code {@link DOMException.INVALID_CHARACTER_ERR} if the qualified name contains an
 * invalid character.
 * @see {@link https://dom.spec.whatwg.org/#validate}
 */
function validateQualifiedName(qualifiedName) {
	if (!g.QName_exact.test(qualifiedName)) {
		throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + qualifiedName + '"');
	}
}

/**
 * Validates a qualified name and the namespace associated with it,
 * based on the criteria provided in the DOM specification by WHATWG.
 *
 * @param {string | null} namespace
 * The namespace to be validated. It can be a string or null.
 * @param {string} qualifiedName
 * The qualified name to be validated.
 * @returns {[namespace: string | null, prefix: string | null, localName: string]}
 * Returns a tuple with the namespace,
 * prefix and local name of the qualified name.
 * @throws {DOMException}
 * Throws a DOMException if the qualified name or the namespace is not valid.
 * @see {@link https://dom.spec.whatwg.org/#validate-and-extract}
 */
function validateAndExtract(namespace, qualifiedName) {
	validateQualifiedName(qualifiedName);
	namespace = namespace || null;
	/**
	 * @type {string | null}
	 */
	var prefix = null;
	var localName = qualifiedName;
	if (qualifiedName.indexOf(':') >= 0) {
		var splitResult = qualifiedName.split(':');
		prefix = splitResult[0];
		localName = splitResult[1];
	}
	if (prefix !== null && namespace === null) {
		throw new DOMException(DOMException.NAMESPACE_ERR, 'prefix is non-null and namespace is null');
	}
	if (prefix === 'xml' && namespace !== conventions.NAMESPACE.XML) {
		throw new DOMException(DOMException.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
	}
	if ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== conventions.NAMESPACE.XMLNS) {
		throw new DOMException(
			DOMException.NAMESPACE_ERR,
			'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
		);
	}
	if (namespace === conventions.NAMESPACE.XMLNS && prefix !== 'xmlns' && qualifiedName !== 'xmlns') {
		throw new DOMException(
			DOMException.NAMESPACE_ERR,
			'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
		);
	}
	return [namespace, prefix, localName];
}

/**
 * Copies properties from one object to another.
 * It only copies the object's own (not inherited) properties.
 *
 * @param {Object} src
 * The source object from which properties are copied.
 * @param {Object} dest
 * The destination object to which properties are copied.
 */
function copy(src, dest) {
	for (var p in src) {
		if (hasOwn(src, p)) {
			dest[p] = src[p];
		}
	}
}

/**
 * Extends a class with the properties and methods of a super class.
 * It uses a form of prototypal inheritance, and establishes the `constructor` property
 * correctly(?).
 *
 * It is not clear to the current maintainers if this implementation is making sense,
 * since it creates an intermediate prototype function,
 * which all properties of `Super` are copied onto using `_copy`.
 *
 * @param {Object} Class
 * The class that is to be extended.
 * @param {Object} Super
 * The super class from which properties and methods are inherited.
 * @private
 */
function _extends(Class, Super) {
	var pt = Class.prototype;
	if (!(pt instanceof Super)) {
		function t() {}
		t.prototype = Super.prototype;
		t = new t();
		copy(pt, t);
		Class.prototype = pt = t;
	}
	if (pt.constructor != Class) {
		if (typeof Class != 'function') {
			console.error('unknown Class:' + Class);
		}
		pt.constructor = Class;
	}
}

var NodeType = {};
var ELEMENT_NODE = (NodeType.ELEMENT_NODE = 1);
var ATTRIBUTE_NODE = (NodeType.ATTRIBUTE_NODE = 2);
var TEXT_NODE = (NodeType.TEXT_NODE = 3);
var CDATA_SECTION_NODE = (NodeType.CDATA_SECTION_NODE = 4);
var ENTITY_REFERENCE_NODE = (NodeType.ENTITY_REFERENCE_NODE = 5);
var ENTITY_NODE = (NodeType.ENTITY_NODE = 6);
var PROCESSING_INSTRUCTION_NODE = (NodeType.PROCESSING_INSTRUCTION_NODE = 7);
var COMMENT_NODE = (NodeType.COMMENT_NODE = 8);
var DOCUMENT_NODE = (NodeType.DOCUMENT_NODE = 9);
var DOCUMENT_TYPE_NODE = (NodeType.DOCUMENT_TYPE_NODE = 10);
var DOCUMENT_FRAGMENT_NODE = (NodeType.DOCUMENT_FRAGMENT_NODE = 11);
var NOTATION_NODE = (NodeType.NOTATION_NODE = 12);

var DocumentPosition = conventions.freeze({
	DOCUMENT_POSITION_DISCONNECTED: 1,
	DOCUMENT_POSITION_PRECEDING: 2,
	DOCUMENT_POSITION_FOLLOWING: 4,
	DOCUMENT_POSITION_CONTAINS: 8,
	DOCUMENT_POSITION_CONTAINED_BY: 16,
	DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32,
});

//helper functions for compareDocumentPosition
/**
 * Finds the common ancestor in two parent chains.
 *
 * @param {Node[]} a
 * The first parent chain.
 * @param {Node[]} b
 * The second parent chain.
 * @returns {Node}
 * The common ancestor node if it exists. If there is no common ancestor, the function will
 * return `null`.
 */
function commonAncestor(a, b) {
	if (b.length < a.length) return commonAncestor(b, a);
	var c = null;
	for (var n in a) {
		if (a[n] !== b[n]) return c;
		c = a[n];
	}
	return c;
}

/**
 * Assigns a unique identifier to a document to ensure consistency while comparing unrelated
 * nodes.
 *
 * @param {Document} doc
 * The document to which a unique identifier is to be assigned.
 * @returns {string}
 * The unique identifier of the document. If the document already had a unique identifier, the
 * function will return the existing one.
 */
function docGUID(doc) {
	if (!doc.guid) doc.guid = Math.random();
	return doc.guid;
}
//-- end of helper functions

/**
 * The NodeList interface provides the abstraction of an ordered collection of nodes,
 * without defining or constraining how this collection is implemented.
 * NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 * You can also access the items of the NodeList with a `for...of` loop.
 *
 * @class NodeList
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * @constructs NodeList
 */
function NodeList() {}
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1
	 * inclusive.
	 *
	 * @type {number}
	 */
	length: 0,
	/**
	 * Returns the item at `index`. If index is greater than or equal to the number of nodes in
	 * the list, this returns null.
	 *
	 * @param index
	 * Unsigned long Index into the collection.
	 * @returns {Node | null}
	 * The node at position `index` in the NodeList,
	 * or null if that is not a valid index.
	 */
	item: function (index) {
		return index >= 0 && index < this.length ? this[index] : null;
	},
	/**
	 * Returns a string representation of the NodeList.
	 *
	 * @param {unknown} nodeFilter
	 * __A filter function? Not implemented according to the spec?__.
	 * @returns {string}
	 * A string representation of the NodeList.
	 */
	toString: function (nodeFilter) {
		for (var buf = [], i = 0; i < this.length; i++) {
			serializeToString(this[i], buf, nodeFilter);
		}
		return buf.join('');
	},
	/**
	 * Filters the NodeList based on a predicate.
	 *
	 * @param {function(Node): boolean} predicate
	 * - A predicate function to filter the NodeList.
	 * @returns {Node[]}
	 * An array of nodes that satisfy the predicate.
	 * @private
	 */
	filter: function (predicate) {
		return Array.prototype.filter.call(this, predicate);
	},
	/**
	 * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
	 * not present.
	 *
	 * @param {Node} item
	 * - The Node item to locate in the NodeList.
	 * @returns {number}
	 * The first index of the node in the NodeList; -1 if not found.
	 * @private
	 */
	indexOf: function (item) {
		return Array.prototype.indexOf.call(this, item);
	},
};
NodeList.prototype[Symbol.iterator] = function () {
	var me = this;
	var index = 0;

	return {
		next: function () {
			if (index < me.length) {
				return {
					value: me[index++],
					done: false,
				};
			} else {
				return {
					done: true,
				};
			}
		},
		return: function () {
			return {
				done: true,
			};
		},
	};
};

/**
 * Represents a live collection of nodes that is automatically updated when its associated
 * document changes.
 *
 * @class LiveNodeList
 * @param {Node} node
 * The associated node.
 * @param {function} refresh
 * The function to refresh the live node list.
 * @augments NodeList
 * @constructs LiveNodeList
 */
function LiveNodeList(node, refresh) {
	this._node = node;
	this._refresh = refresh;
	_updateLiveList(this);
}
/**
 * Updates the live node list.
 *
 * @param {LiveNodeList} list
 * The live node list to update.
 * @private
 */
function _updateLiveList(list) {
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if (list._inc !== inc) {
		var ls = list._refresh(list._node);
		__set__(list, 'length', ls.length);
		if (!list.$$length || ls.length < list.$$length) {
			for (var i = ls.length; i in list; i++) {
				if (hasOwn(list, i)) {
					delete list[i];
				}
			}
		}
		copy(ls, list);
		list._inc = inc;
	}
}
/**
 * Returns the node at position `index` in the LiveNodeList, or null if that is not a valid
 * index.
 *
 * @param {number} i
 * Index into the collection.
 * @returns {Node | null}
 * The node at position `index` in the LiveNodeList, or null if that is not a valid index.
 */
LiveNodeList.prototype.item = function (i) {
	_updateLiveList(this);
	return this[i] || null;
};

_extends(LiveNodeList, NodeList);

/**
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes
 * that can be accessed by name.
 * Note that NamedNodeMap does not inherit from NodeList;
 * NamedNodeMaps are not maintained in any particular order.
 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal
 * index,
 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
 * and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities
 *
 * This implementation only supports property indices, but does not support named properties,
 * as specified in the living standard.
 *
 * @class NamedNodeMap
 * @see https://dom.spec.whatwg.org/#interface-namednodemap
 * @see https://webidl.spec.whatwg.org/#dfn-supported-property-names
 * @constructs NamedNodeMap
 */
function NamedNodeMap() {}
/**
 * Returns the index of a node within the list.
 *
 * @param {Array} list
 * The list of nodes.
 * @param {Node} node
 * The node to find.
 * @returns {number}
 * The index of the node within the list, or -1 if not found.
 * @private
 */
function _findNodeIndex(list, node) {
	var i = 0;
	while (i < list.length) {
		if (list[i] === node) {
			return i;
		}
		i++;
	}
}
/**
 * Adds a new attribute to the list and updates the owner element of the attribute.
 *
 * @param {Element} el
 * The element which will become the owner of the new attribute.
 * @param {NamedNodeMap} list
 * The list to which the new attribute will be added.
 * @param {Attr} newAttr
 * The new attribute to be added.
 * @param {Attr} oldAttr
 * The old attribute to be replaced, or null if no attribute is to be replaced.
 * @returns {void}
 * @private
 */
function _addNamedNode(el, list, newAttr, oldAttr) {
	if (oldAttr) {
		list[_findNodeIndex(list, oldAttr)] = newAttr;
	} else {
		list[list.length] = newAttr;
		list.length++;
	}
	if (el) {
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if (doc) {
			oldAttr && _onRemoveAttribute(doc, el, oldAttr);
			_onAddAttribute(doc, el, newAttr);
		}
	}
}
/**
 * Removes an attribute from the list and updates the owner element of the attribute.
 *
 * @param {Element} el
 * The element which is the current owner of the attribute.
 * @param {NamedNodeMap} list
 * The list from which the attribute will be removed.
 * @param {Attr} attr
 * The attribute to be removed.
 * @returns {void}
 * @private
 */
function _removeNamedNode(el, list, attr) {
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list, attr);
	if (i >= 0) {
		var lastIndex = list.length - 1;
		while (i <= lastIndex) {
			list[i] = list[++i];
		}
		list.length = lastIndex;
		if (el) {
			var doc = el.ownerDocument;
			if (doc) {
				_onRemoveAttribute(doc, el, attr);
			}
			attr.ownerElement = null;
		}
	}
}
NamedNodeMap.prototype = {
	length: 0,
	item: NodeList.prototype.item,

	/**
	 * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
	 * document.
	 *
	 * @param {string} localName
	 * The local name of the attribute.
	 * @returns {Attr | null}
	 * The attribute with the given local name, or null if no such attribute exists.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
	 */
	getNamedItem: function (localName) {
		if (this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace()) {
			localName = localName.toLowerCase();
		}
		var i = 0;
		while (i < this.length) {
			var attr = this[i];
			if (attr.nodeName === localName) {
				return attr;
			}
			i++;
		}
		return null;
	},

	/**
	 * Set an attribute.
	 *
	 * @param {Attr} attr
	 * The attribute to set.
	 * @returns {Attr | null}
	 * The old attribute with the same local name and namespace URI as the new one, or null if no
	 * such attribute exists.
	 * @throws {DOMException}
	 * With code:
	 * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
	 * element.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
	 */
	setNamedItem: function (attr) {
		var el = attr.ownerElement;
		if (el && el !== this._ownerElement) {
			throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
		if (oldAttr === attr) {
			return attr;
		}
		_addNamedNode(this._ownerElement, this, attr, oldAttr);
		return oldAttr;
	},

	/**
	 * Set an attribute, replacing an existing attribute with the same local name and namespace
	 * URI if one exists.
	 *
	 * @param {Attr} attr
	 * The attribute to set.
	 * @returns {Attr | null}
	 * The old attribute with the same local name and namespace URI as the new one, or null if no
	 * such attribute exists.
	 * @throws {DOMException}
	 * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
	 * attribute of another element.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
	 */
	setNamedItemNS: function (attr) {
		return this.setNamedItem(attr);
	},

	/**
	 * Removes an attribute specified by the local name.
	 *
	 * @param {string} localName
	 * The local name of the attribute to be removed.
	 * @returns {Attr}
	 * The attribute node that was removed.
	 * @throws {DOMException}
	 * With code:
	 * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
	 * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
	 */
	removeNamedItem: function (localName) {
		var attr = this.getNamedItem(localName);
		if (!attr) {
			throw new DOMException(DOMException.NOT_FOUND_ERR, localName);
		}
		_removeNamedNode(this._ownerElement, this, attr);
		return attr;
	},

	/**
	 * Removes an attribute specified by the namespace and local name.
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI of the attribute to be removed.
	 * @param {string} localName
	 * The local name of the attribute to be removed.
	 * @returns {Attr}
	 * The attribute node that was removed.
	 * @throws {DOMException}
	 * With code:
	 * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
	 * name is found.
	 * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
	 */
	removeNamedItemNS: function (namespaceURI, localName) {
		var attr = this.getNamedItemNS(namespaceURI, localName);
		if (!attr) {
			throw new DOMException(DOMException.NOT_FOUND_ERR, namespaceURI ? namespaceURI + ' : ' + localName : localName);
		}
		_removeNamedNode(this._ownerElement, this, attr);
		return attr;
	},

	/**
	 * Get an attribute by namespace and local name.
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI of the attribute.
	 * @param {string} localName
	 * The local name of the attribute.
	 * @returns {Attr | null}
	 * The attribute with the given namespace URI and local name, or null if no such attribute
	 * exists.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
	 */
	getNamedItemNS: function (namespaceURI, localName) {
		if (!namespaceURI) {
			namespaceURI = null;
		}
		var i = 0;
		while (i < this.length) {
			var node = this[i];
			if (node.localName === localName && node.namespaceURI === namespaceURI) {
				return node;
			}
			i++;
		}
		return null;
	},
};
NamedNodeMap.prototype[Symbol.iterator] = function () {
	var me = this;
	var index = 0;

	return {
		next: function () {
			if (index < me.length) {
				return {
					value: me[index++],
					done: false,
				};
			} else {
				return {
					done: true,
				};
			}
		},
		return: function () {
			return {
				done: true,
			};
		},
	};
};

/**
 * The DOMImplementation interface provides a number of methods for performing operations that
 * are independent of any particular instance of the document object model.
 *
 * The DOMImplementation interface represents an object providing methods which are not
 * dependent on any particular document.
 * Such an object is returned by the `Document.implementation` property.
 *
 * **The individual methods describe the differences compared to the specs**.
 *
 * @class DOMImplementation
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core
 *      (Initial)
 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
 * @constructs DOMImplementation
 */
function DOMImplementation() {}

DOMImplementation.prototype = {
	/**
	 * Test if the DOM implementation implements a specific feature and version, as specified in
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
	 *
	 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
	 * feature is supported. The different implementations fairly diverged in what kind of
	 * features were reported. The latest version of the spec settled to force this method to
	 * always return true, where the functionality was accurate and in use.
	 *
	 * @deprecated
	 * It is deprecated and modern browsers return true in all cases.
	 * @function DOMImplementation#hasFeature
	 * @param {string} feature
	 * The name of the feature to test.
	 * @param {string} [version]
	 * This is the version number of the feature to test.
	 * @returns {boolean}
	 * Always returns true.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
	 */
	hasFeature: function (feature, version) {
		return true;
	},
	/**
	 * Creates a DOM Document object of the specified type with its document element. Note that
	 * based on the {@link DocumentType}
	 * given to create the document, the implementation may instantiate specialized
	 * {@link Document} objects that support additional features than the "Core", such as "HTML"
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
	 * On the other hand, setting the {@link DocumentType} after the document was created makes
	 * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
	 * such as createHTMLDocument
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
	 * can be used to obtain specific types of {@link Document} objects.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - There is no interface/class `XMLDocument`, it returns a `Document`
	 * instance (with it's `type` set to `'xml'`).
	 * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 *
	 * @function DOMImplementation.createDocument
	 * @param {string | null} namespaceURI
	 * The
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
	 * of the document element to create or null.
	 * @param {string | null} qualifiedName
	 * The
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
	 * of the document element to be created or null.
	 * @param {DocumentType | null} [doctype=null]
	 * The type of document to be created or null. When doctype is not null, its
	 * {@link Node#ownerDocument} attribute is set to the document being created. Default is
	 * `null`
	 * @returns {Document}
	 * A new {@link Document} object with its document element. If the NamespaceURI,
	 * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
	 * document element.
	 * @throws {DOMException}
	 * With code:
	 *
	 * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
	 * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
	 * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
	 * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
	 * is different from null, or if the qualifiedName has a prefix that is "xml" and the
	 * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
	 * or if the DOM implementation does not support the "XML" feature but a non-null namespace
	 * URI was provided, since namespaces were defined by XML.
	 * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
	 * or was created from a different implementation.
	 * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
	 * "XML" and the language exposed through the Document does not support XML Namespaces (such
	 * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
	 * @since DOM Level 2.
	 * @see {@link #createHTMLDocument}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
	 *      Level 3 Core
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
	 *      Level 2 Core (initial)
	 */
	createDocument: function (namespaceURI, qualifiedName, doctype) {
		var contentType = MIME_TYPE.XML_APPLICATION;
		if (namespaceURI === NAMESPACE.HTML) {
			contentType = MIME_TYPE.XML_XHTML_APPLICATION;
		} else if (namespaceURI === NAMESPACE.SVG) {
			contentType = MIME_TYPE.XML_SVG_IMAGE;
		}
		var doc = new Document(PDC, { contentType: contentType });
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype || null;
		if (doctype) {
			doc.appendChild(doctype);
		}
		if (qualifiedName) {
			var root = doc.createElementNS(namespaceURI, qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	/**
	 * Creates an empty DocumentType node. Entity declarations and notations are not made
	 * available. Entity reference expansions and default attribute additions do not occur.
	 *
	 * **This behavior is slightly different from the one in the specs**:
	 * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 * - `publicId` and `systemId` contain the raw data including any possible quotes,
	 *   so they can always be serialized back to the original value
	 * - `internalSubset` contains the raw string between `[` and `]` if present,
	 *   but is not parsed or validated in any form.
	 *
	 * @function DOMImplementation#createDocumentType
	 * @param {string} qualifiedName
	 * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
	 * name} of the document type to be created.
	 * @param {string} [publicId]
	 * The external subset public identifier.
	 * @param {string} [systemId]
	 * The external subset system identifier.
	 * @param {string} [internalSubset]
	 * the internal subset or an empty string if it is not present
	 * @returns {DocumentType}
	 * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
	 * @throws {DOMException}
	 * With code:
	 *
	 * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
	 * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
	 * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
	 * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
	 * "XML" and the language exposed through the Document does not support XML Namespaces (such
	 * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
	 * @since DOM Level 2.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
	 *      MDN
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
	 *      Standard
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
	 *      Level 3 Core
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
	 *      Level 2 Core
	 * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
	 * @prettierignore
	 */
	createDocumentType: function (qualifiedName, publicId, systemId, internalSubset) {
		validateQualifiedName(qualifiedName);
		var node = new DocumentType(PDC);
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId || '';
		node.systemId = systemId || '';
		node.internalSubset = internalSubset || '';
		node.childNodes = new NodeList();

		return node;
	},
	/**
	 * Returns an HTML document, that might already have a basic DOM structure.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
	 * omitted)
	 * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 *
	 * @param {string | false} [title]
	 * A string containing the title to give the new HTML document.
	 * @returns {Document}
	 * The HTML document.
	 * @since WHATWG Living Standard.
	 * @see {@link #createDocument}
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
	 * @see https://dom.spec.whatwg.org/#html-document
	 */
	createHTMLDocument: function (title) {
		var doc = new Document(PDC, { contentType: MIME_TYPE.HTML });
		doc.implementation = this;
		doc.childNodes = new NodeList();
		if (title !== false) {
			doc.doctype = this.createDocumentType('html');
			doc.doctype.ownerDocument = doc;
			doc.appendChild(doc.doctype);
			var htmlNode = doc.createElement('html');
			doc.appendChild(htmlNode);
			var headNode = doc.createElement('head');
			htmlNode.appendChild(headNode);
			if (typeof title === 'string') {
				var titleNode = doc.createElement('title');
				titleNode.appendChild(doc.createTextNode(title));
				headNode.appendChild(titleNode);
			}
			htmlNode.appendChild(doc.createElement('body'));
		}
		return doc;
	},
};

/**
 * The DOM Node interface is an abstract base class upon which many other DOM API objects are
 * based, thus letting those object types to be used similarly and often interchangeably. As an
 * abstract class, there is no such thing as a plain Node object. All objects that implement
 * Node functionality are based on one of its subclasses. Most notable are Document, Element,
 * and DocumentFragment.
 *
 * In addition, every kind of DOM node is represented by an interface based on Node. These
 * include Attr, CharacterData (which Text, Comment, CDATASection and ProcessingInstruction are
 * all based on), and DocumentType.
 *
 * In some cases, a particular feature of the base Node interface may not apply to one of its
 * child interfaces; in that case, the inheriting node may return null or throw an exception,
 * depending on circumstances. For example, attempting to add children to a node type that
 * cannot have children will throw an exception.
 *
 * **This behavior is slightly different from the in the specs**:
 * - unimplemented interfaces: `EventTarget`
 *
 * @class
 * @abstract
 * @param {Symbol} symbol
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 * @see https://dom.spec.whatwg.org/#node
 * @prettierignore
 */
function Node(symbol) {
	checkSymbol(symbol);
}

Node.prototype = {
	/**
	 * The first child of this node.
	 *
	 * @type {Node | null}
	 */
	firstChild: null,
	/**
	 * The last child of this node.
	 *
	 * @type {Node | null}
	 */
	lastChild: null,
	/**
	 * The previous sibling of this node.
	 *
	 * @type {Node | null}
	 */
	previousSibling: null,
	/**
	 * The next sibling of this node.
	 *
	 * @type {Node | null}
	 */
	nextSibling: null,
	/**
	 * The parent node of this node.
	 *
	 * @type {Node | null}
	 */
	parentNode: null,
	/**
	 * The parent element of this node.
	 *
	 * @type {Element | null}
	 */
	get parentElement() {
		return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
	},
	/**
	 * The child nodes of this node.
	 *
	 * @type {NodeList}
	 */
	childNodes: null,
	/**
	 * The document object associated with this node.
	 *
	 * @type {Document | null}
	 */
	ownerDocument: null,
	/**
	 * The value of this node.
	 *
	 * @type {string | null}
	 */
	nodeValue: null,
	/**
	 * The namespace URI of this node.
	 *
	 * @type {string | null}
	 */
	namespaceURI: null,
	/**
	 * The prefix of the namespace for this node.
	 *
	 * @type {string | null}
	 */
	prefix: null,
	/**
	 * The local part of the qualified name of this node.
	 *
	 * @type {string | null}
	 */
	localName: null,
	/**
	 * The baseURI is currently always `about:blank`,
	 * since that's what happens when you create a document from scratch.
	 *
	 * @type {'about:blank'}
	 */
	baseURI: 'about:blank',
	/**
	 * Is true if this node is part of a document.
	 *
	 * @type {boolean}
	 */
	get isConnected() {
		var rootNode = this.getRootNode();
		return rootNode && rootNode.nodeType === rootNode.DOCUMENT_NODE;
	},
	/**
	 * Checks whether `other` is an inclusive descendant of this node.
	 *
	 * @param {Node | null | undefined} other
	 * The node to check.
	 * @returns {boolean}
	 * True if `other` is an inclusive descendant of this node; false otherwise.
	 * @see https://dom.spec.whatwg.org/#dom-node-contains
	 */
	contains: function (other) {
		if (!other) return false;
		var parent = other;
		do {
			if (this === parent) return true;
			parent = other.parentNode;
		} while (parent);
		return false;
	},
	/**
	 * @typedef GetRootNodeOptions
	 * @property {boolean} [composed=false]
	 */
	/**
	 * Searches for the root node of this node.
	 *
	 * **This behavior is slightly different from the in the specs**:
	 * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
	 *
	 * @param {GetRootNodeOptions} [options]
	 * @returns {Node}
	 * Root node.
	 * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
	 * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
	 */
	getRootNode: function (options) {
		var parent = this;
		do {
			if (!parent.parentNode) {
				return parent;
			}
			parent = parent.parentNode;
		} while (parent);
	},
	/**
	 * Checks whether the given node is equal to this node.
	 *
	 * @param {Node} [otherNode]
	 * @see https://dom.spec.whatwg.org/#concept-node-equals
	 */
	isEqualNode: function (otherNode) {
		if (!otherNode) return false;

		if (this.nodeType !== otherNode.nodeType) return false;

		switch (this.nodeType) {
			case this.DOCUMENT_TYPE_NODE:
				if (this.name !== otherNode.name) return false;
				if (this.publicId !== otherNode.publicId) return false;
				if (this.systemId !== otherNode.systemId) return false;
				break;
			case this.ELEMENT_NODE:
				if (this.namespaceURI !== otherNode.namespaceURI) return false;
				if (this.prefix !== otherNode.prefix) return false;
				if (this.localName !== otherNode.localName) return false;
				if (this.attributes.length !== otherNode.attributes.length) return false;
				for (var i = 0; i < this.attributes.length; i++) {
					var attr = this.attributes.item(i);
					if (!attr.isEqualNode(otherNode.getAttributeNodeNS(attr.namespaceURI, attr.localName))) {
						return false;
					}
				}
				break;
			case this.ATTRIBUTE_NODE:
				if (this.namespaceURI !== otherNode.namespaceURI) return false;
				if (this.localName !== otherNode.localName) return false;
				if (this.value !== otherNode.value) return false;

				break;
			case this.PROCESSING_INSTRUCTION_NODE:
				if (this.target !== otherNode.target || this.data !== otherNode.data) {
					return false;
				}
				break;
			case this.TEXT_NODE:
			case this.COMMENT_NODE:
				if (this.data !== otherNode.data) return false;
				break;
		}

		if (this.childNodes.length !== otherNode.childNodes.length) {
			return false;
		}

		for (var i = 0; i < this.childNodes.length; i++) {
			if (!this.childNodes[i].isEqualNode(otherNode.childNodes[i])) {
				return false;
			}
		}

		return true;
	},
	/**
	 * Checks whether or not the given node is this node.
	 *
	 * @param {Node} [otherNode]
	 */
	isSameNode: function (otherNode) {
		return this === otherNode;
	},
	/**
	 * Inserts a node before a reference node as a child of this node.
	 *
	 * @param {Node} newChild
	 * The new child node to be inserted.
	 * @param {Node | null} refChild
	 * The reference node before which newChild will be inserted.
	 * @returns {Node}
	 * The new child node successfully inserted.
	 * @throws {DOMException}
	 * Throws a DOMException if inserting the node would result in a DOM tree that is not
	 * well-formed, or if `child` is provided but is not a child of `parent`.
	 * See {@link _insertBefore} for more details.
	 * @since Modified in DOM L2
	 */
	insertBefore: function (newChild, refChild) {
		return _insertBefore(this, newChild, refChild);
	},
	/**
	 * Replaces an old child node with a new child node within this node.
	 *
	 * @param {Node} newChild
	 * The new node that is to replace the old node.
	 * If it already exists in the DOM, it is removed from its original position.
	 * @param {Node} oldChild
	 * The existing child node to be replaced.
	 * @returns {Node}
	 * Returns the replaced child node.
	 * @throws {DOMException}
	 * Throws a DOMException if replacing the node would result in a DOM tree that is not
	 * well-formed, or if `oldChild` is not a child of `this`.
	 * This can also occur if the pre-replacement validity assertion fails.
	 * See {@link _insertBefore}, {@link Node.removeChild}, and
	 * {@link assertPreReplacementValidityInDocument} for more details.
	 * @see https://dom.spec.whatwg.org/#concept-node-replace
	 */
	replaceChild: function (newChild, oldChild) {
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		if (oldChild) {
			this.removeChild(oldChild);
		}
	},
	/**
	 * Removes an existing child node from this node.
	 *
	 * @param {Node} oldChild
	 * The child node to be removed.
	 * @returns {Node}
	 * Returns the removed child node.
	 * @throws {DOMException}
	 * Throws a DOMException if `oldChild` is not a child of `this`.
	 * See {@link _removeChild} for more details.
	 */
	removeChild: function (oldChild) {
		return _removeChild(this, oldChild);
	},
	/**
	 * Appends a child node to this node.
	 *
	 * @param {Node} newChild
	 * The child node to be appended to this node.
	 * If it already exists in the DOM, it is removed from its original position.
	 * @returns {Node}
	 * Returns the appended child node.
	 * @throws {DOMException}
	 * Throws a DOMException if appending the node would result in a DOM tree that is not
	 * well-formed, or if `newChild` is not a valid Node.
	 * See {@link insertBefore} for more details.
	 */
	appendChild: function (newChild) {
		return this.insertBefore(newChild, null);
	},
	/**
	 * Determines whether this node has any child nodes.
	 *
	 * @returns {boolean}
	 * Returns true if this node has any child nodes, and false otherwise.
	 */
	hasChildNodes: function () {
		return this.firstChild != null;
	},
	/**
	 * Creates a copy of the calling node.
	 *
	 * @param {boolean} deep
	 * If true, the contents of the node are recursively copied.
	 * If false, only the node itself (and its attributes, if it is an element) are copied.
	 * @returns {Node}
	 * Returns the newly created copy of the node.
	 * @throws {DOMException}
	 * May throw a DOMException if operations within {@link Element#setAttributeNode} or
	 * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
	 * specific constraints.
	 * @see {@link cloneNode}
	 */
	cloneNode: function (deep) {
		return cloneNode(this.ownerDocument || this, this, deep);
	},
	/**
	 * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
	 * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
	 *
	 * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
	 * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
	 * nodes.
	 *
	 * This method operates recursively, so it also normalizes any and all descendent nodes within
	 * the subtree.
	 *
	 * @throws {DOMException}
	 * May throw a DOMException if operations within removeChild or appendData (which are
	 * potentially invoked in this method) do not meet their specific constraints.
	 * @since Modified in DOM Level 2
	 * @see {@link Node.removeChild}
	 * @see {@link CharacterData.appendData}
	 */
	normalize: function () {
		var child = this.firstChild;
		while (child) {
			var next = child.nextSibling;
			if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
				this.removeChild(next);
				child.appendData(next.data);
			} else {
				child.normalize();
				child = next;
			}
		}
	},
	/**
	 * Checks whether the DOM implementation implements a specific feature and its version.
	 *
	 * @deprecated
	 * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
	 * @param {string} feature
	 * The package name of the feature to test. This is the same name that can be passed to the
	 * method `hasFeature` on `DOMImplementation`.
	 * @param {string} version
	 * This is the version number of the package name to test.
	 * @returns {boolean}
	 * Returns true in all cases in the current implementation.
	 * @since Introduced in DOM Level 2
	 * @see {@link DOMImplementation.hasFeature}
	 */
	isSupported: function (feature, version) {
		return this.ownerDocument.implementation.hasFeature(feature, version);
	},
	/**
	 * Look up the prefix associated to the given namespace URI, starting from this node.
	 * **The default namespace declarations are ignored by this method.**
	 * See Namespace Prefix Lookup for details on the algorithm used by this method.
	 *
	 * **This behavior is different from the in the specs**:
	 * - no node type specific handling
	 * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI for which to find the associated prefix.
	 * @returns {string | null}
	 * The associated prefix, if found; otherwise, null.
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
	 * @see https://github.com/xmldom/xmldom/issues/322
	 * @prettierignore
	 */
	lookupPrefix: function (namespaceURI) {
		var el = this;
		while (el) {
			var map = el._nsMap;
			//console.dir(map)
			if (map) {
				for (var n in map) {
					if (hasOwn(map, n) && map[n] === namespaceURI) {
						return n;
					}
				}
			}
			el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
		}
		return null;
	},
	/**
	 * This function is used to look up the namespace URI associated with the given prefix,
	 * starting from this node.
	 *
	 * **This behavior is different from the in the specs**:
	 * - no node type specific handling
	 * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
	 *
	 * @param {string | null} prefix
	 * The prefix for which to find the associated namespace URI.
	 * @returns {string | null}
	 * The associated namespace URI, if found; otherwise, null.
	 * @since DOM Level 3
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
	 * @prettierignore
	 */
	lookupNamespaceURI: function (prefix) {
		var el = this;
		while (el) {
			var map = el._nsMap;
			//console.dir(map)
			if (map) {
				if (hasOwn(map, prefix)) {
					return map[prefix];
				}
			}
			el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
		}
		return null;
	},
	/**
	 * Determines whether the given namespace URI is the default namespace.
	 *
	 * The function works by looking up the prefix associated with the given namespace URI. If no
	 * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
	 * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
	 * the default.
	 *
	 * **This behavior is different from the in the specs**:
	 * - no node type specific handling
	 * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI to be checked.
	 * @returns {boolean}
	 * Returns true if the given namespace URI is the default namespace, false otherwise.
	 * @since DOM Level 3
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
	 * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
	 * @prettierignore
	 */
	isDefaultNamespace: function (namespaceURI) {
		var prefix = this.lookupPrefix(namespaceURI);
		return prefix == null;
	},
	/**
	 * Compares the reference node with a node with regard to their position in the document and
	 * according to the document order.
	 *
	 * @param {Node} other
	 * The node to compare the reference node to.
	 * @returns {number}
	 * Returns how the node is positioned relatively to the reference node according to the
	 * bitmask. 0 if reference node and given node are the same.
	 * @since DOM Level 3
	 * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
	 * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
	 */
	compareDocumentPosition: function (other) {
		if (this === other) return 0;
		var node1 = other;
		var node2 = this;
		var attr1 = null;
		var attr2 = null;
		if (node1 instanceof Attr) {
			attr1 = node1;
			node1 = attr1.ownerElement;
		}
		if (node2 instanceof Attr) {
			attr2 = node2;
			node2 = attr2.ownerElement;
			if (attr1 && node1 && node2 === node1) {
				for (var i = 0, attr; (attr = node2.attributes[i]); i++) {
					if (attr === attr1)
						return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
					if (attr === attr2)
						return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
				}
			}
		}
		if (!node1 || !node2 || node2.ownerDocument !== node1.ownerDocument) {
			return (
				DocumentPosition.DOCUMENT_POSITION_DISCONNECTED +
				DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC +
				(docGUID(node2.ownerDocument) > docGUID(node1.ownerDocument)
					? DocumentPosition.DOCUMENT_POSITION_FOLLOWING
					: DocumentPosition.DOCUMENT_POSITION_PRECEDING)
			);
		}
		if (attr2 && node1 === node2) {
			return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
		}
		if (attr1 && node1 === node2) {
			return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
		}

		var chain1 = [];
		var ancestor1 = node1.parentNode;
		while (ancestor1) {
			if (!attr2 && ancestor1 === node2) {
				return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
			}
			chain1.push(ancestor1);
			ancestor1 = ancestor1.parentNode;
		}
		chain1.reverse();

		var chain2 = [];
		var ancestor2 = node2.parentNode;
		while (ancestor2) {
			if (!attr1 && ancestor2 === node1) {
				return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
			}
			chain2.push(ancestor2);
			ancestor2 = ancestor2.parentNode;
		}
		chain2.reverse();

		var ca = commonAncestor(chain1, chain2);
		for (var n in ca.childNodes) {
			var child = ca.childNodes[n];
			if (child === node2) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
			if (child === node1) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
			if (chain2.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
			if (chain1.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
		}
		return 0;
	},
};

/**
 * Encodes special XML characters to their corresponding entities.
 *
 * @param {string} c
 * The character to be encoded.
 * @returns {string}
 * The encoded character.
 * @private
 */
function _xmlEncoder(c) {
	return (
		(c == '<' && '&lt;') || (c == '>' && '&gt;') || (c == '&' && '&amp;') || (c == '"' && '&quot;') || '&#' + c.charCodeAt() + ';'
	);
}

copy(NodeType, Node);
copy(NodeType, Node.prototype);
copy(DocumentPosition, Node);
copy(DocumentPosition, Node.prototype);

/**
 * @param callback
 * Return true for continue,false for break.
 * @returns
 * boolean true: break visit;
 */
function _visitNode(node, callback) {
	if (callback(node)) {
		return true;
	}
	if ((node = node.firstChild)) {
		do {
			if (_visitNode(node, callback)) {
				return true;
			}
		} while ((node = node.nextSibling));
	}
}

/**
 * @typedef DocumentOptions
 * @property {string} [contentType=MIME_TYPE.XML_APPLICATION]
 */
/**
 * The Document interface describes the common properties and methods for any kind of document.
 *
 * It should usually be created using `new DOMImplementation().createDocument(...)`
 * or `new DOMImplementation().createHTMLDocument(...)`.
 *
 * The constructor is considered a private API and offers to initially set the `contentType`
 * property via it's options parameter.
 *
 * @class
 * @param {Symbol} symbol
 * @param {DocumentOptions} [options]
 * @augments Node
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document
 * @see https://dom.spec.whatwg.org/#interface-document
 */
function Document(symbol, options) {
	checkSymbol(symbol);

	var opt = options || {};
	this.ownerDocument = this;
	/**
	 * The mime type of the document is determined at creation time and can not be modified.
	 *
	 * @type {string}
	 * @see https://dom.spec.whatwg.org/#concept-document-content-type
	 * @see {@link DOMImplementation}
	 * @see {@link MIME_TYPE}
	 * @readonly
	 */
	this.contentType = opt.contentType || MIME_TYPE.XML_APPLICATION;
	/**
	 * @type {'html' | 'xml'}
	 * @see https://dom.spec.whatwg.org/#concept-document-type
	 * @see {@link DOMImplementation}
	 * @readonly
	 */
	this.type = isHTMLMimeType(this.contentType) ? 'html' : 'xml';
}

/**
 * Updates the namespace mapping of an element when a new attribute is added.
 *
 * @param {Document} doc
 * The document that the element belongs to.
 * @param {Element} el
 * The element to which the attribute is being added.
 * @param {Attr} newAttr
 * The new attribute being added.
 * @private
 */
function _onAddAttribute(doc, el, newAttr) {
	doc && doc._inc++;
	var ns = newAttr.namespaceURI;
	if (ns === NAMESPACE.XMLNS) {
		//update namespace
		el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;
	}
}

/**
 * Updates the namespace mapping of an element when an attribute is removed.
 *
 * @param {Document} doc
 * The document that the element belongs to.
 * @param {Element} el
 * The element from which the attribute is being removed.
 * @param {Attr} newAttr
 * The attribute being removed.
 * @param {boolean} remove
 * Indicates whether the attribute is to be removed.
 * @private
 */
function _onRemoveAttribute(doc, el, newAttr, remove) {
	doc && doc._inc++;
	var ns = newAttr.namespaceURI;
	if (ns === NAMESPACE.XMLNS) {
		//update namespace
		delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];
	}
}

/**
 * Updates `parent.childNodes`, adjusting the indexed items and its `length`.
 * If `newChild` is provided and has no nextSibling, it will be appended.
 * Otherwise, it's assumed that an item has been removed or inserted,
 * and `parent.firstNode` and its `.nextSibling` to re-indexing all child nodes of `parent`.
 *
 * @param {Document} doc
 * The parent document of `el`.
 * @param {Node} parent
 * The parent node whose childNodes list needs to be updated.
 * @param {Node} [newChild]
 * The new child node to be appended. If not provided, the function assumes a node has been
 * removed.
 * @private
 */
function _onUpdateChild(doc, parent, newChild) {
	if (doc && doc._inc) {
		doc._inc++;
		var childNodes = parent.childNodes;
		// assumes nextSibling and previousSibling were already configured upfront
		if (newChild && !newChild.nextSibling) {
			// if an item has been appended, we only need to update the last index and the length
			childNodes[childNodes.length++] = newChild;
		} else {
			// otherwise we need to reindex all items,
			// which can take a while when processing nodes with a lot of children
			var child = parent.firstChild;
			var i = 0;
			while (child) {
				childNodes[i++] = child;
				child = child.nextSibling;
			}
			childNodes.length = i;
			delete childNodes[childNodes.length];
		}
	}
}

/**
 * Removes the connections between `parentNode` and `child`
 * and any existing `child.previousSibling` or `child.nextSibling`.
 *
 * @param {Node} parentNode
 * The parent node from which the child node is to be removed.
 * @param {Node} child
 * The child node to be removed from the parentNode.
 * @returns {Node}
 * Returns the child node that was removed.
 * @throws {DOMException}
 * With code:
 * - {@link DOMException.NOT_FOUND_ERR} If the parentNode is not the parent of the child node.
 * @private
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 */
function _removeChild(parentNode, child) {
	if (parentNode !== child.parentNode) {
		throw new DOMException(DOMException.NOT_FOUND_ERR, "child's parent is not parent");
	}
	var oldPreviousSibling = child.previousSibling;
	var oldNextSibling = child.nextSibling;
	if (oldPreviousSibling) {
		oldPreviousSibling.nextSibling = oldNextSibling;
	} else {
		parentNode.firstChild = oldNextSibling;
	}
	if (oldNextSibling) {
		oldNextSibling.previousSibling = oldPreviousSibling;
	} else {
		parentNode.lastChild = oldPreviousSibling;
	}
	_onUpdateChild(parentNode.ownerDocument, parentNode);
	child.parentNode = null;
	child.previousSibling = null;
	child.nextSibling = null;
	return child;
}

/**
 * Returns `true` if `node` can be a parent for insertion.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function hasValidParentNodeType(node) {
	return (
		node &&
		(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
	);
}

/**
 * Returns `true` if `node` can be inserted according to it's `nodeType`.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function hasInsertableNodeType(node) {
	return (
		node &&
		(node.nodeType === Node.CDATA_SECTION_NODE ||
			node.nodeType === Node.COMMENT_NODE ||
			node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
			node.nodeType === Node.DOCUMENT_TYPE_NODE ||
			node.nodeType === Node.ELEMENT_NODE ||
			node.nodeType === Node.PROCESSING_INSTRUCTION_NODE ||
			node.nodeType === Node.TEXT_NODE)
	);
}

/**
 * Returns true if `node` is a DOCTYPE node.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isDocTypeNode(node) {
	return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
}

/**
 * Returns true if the node is an element.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isElementNode(node) {
	return node && node.nodeType === Node.ELEMENT_NODE;
}
/**
 * Returns true if `node` is a text node.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isTextNode(node) {
	return node && node.nodeType === Node.TEXT_NODE;
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Document} doc
 * The document node.
 * @param {Node} child
 * The node that would become the nextSibling if the element would be inserted.
 * @returns {boolean}
 * `true` if an element can be inserted before child.
 * @private
 */
function isElementInsertionPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];
	if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Node} doc
 * The document node.
 * @param {Node} child
 * The node that would become the nextSibling if the element would be inserted.
 * @returns {boolean}
 * `true` if an element can be inserted before child.
 * @private
 */
function isElementReplacementPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];

	function hasElementChildThatIsNotChild(node) {
		return isElementNode(node) && node !== child;
	}

	if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Asserts pre-insertion validity of a node into a parent before a child.
 * Throws errors for invalid node combinations that would result in an ill-formed DOM.
 *
 * @param {Node} parent
 * The parent node to insert `node` into.
 * @param {Node} node
 * The node to insert.
 * @param {Node | null} child
 * The node that should become the `nextSibling` of `node`. If null, no sibling is considered.
 * @throws {DOMException}
 * With code:
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `parent` is not a Document,
 * DocumentFragment, or Element node.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a host-including inclusive
 * ancestor of `parent`. (Currently not implemented)
 * - {@link DOMException.NOT_FOUND_ERR} If `child` is non-null and its `parent` is not
 * `parent`.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is not a DocumentFragment,
 * DocumentType, Element, or CharacterData node.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If either `node` is a Text node and `parent` is
 * a document, or if `node` is a doctype and `parent` is not a document.
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidity1to5(parent, node, child) {
	// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
	if (!hasValidParentNodeType(parent)) {
		throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
	}
	// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
	// not implemented!
	// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
	if (child && child.parentNode !== parent) {
		throw new DOMException(DOMException.NOT_FOUND_ERR, 'child not in parent');
	}
	if (
		// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
		!hasInsertableNodeType(node) ||
		// 5. If either `node` is a Text node and `parent` is a document,
		// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
		// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
		// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
		(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
	) {
		throw new DOMException(
			DOMException.HIERARCHY_REQUEST_ERR,
			'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
		);
	}
}

/**
 * Asserts pre-insertion validity of a node into a document before a child.
 * Throws errors for invalid node combinations that would result in an ill-formed DOM.
 *
 * @param {Document} parent
 * The parent node to insert `node` into.
 * @param {Node} node
 * The node to insert.
 * @param {Node | undefined} child
 * The node that should become the `nextSibling` of `node`. If undefined, no sibling is
 * considered.
 * @returns {Node}
 * @throws {DOMException}
 * With code:
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with more than
 * one element child or has a Text node child.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with one
 * element child and either `parent` has an element child, `child` is a doctype, or `child` is
 * non-null and a doctype is following `child`.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is an Element and `parent` has an
 * element child, `child` is a doctype, or `child` is non-null and a doctype is following
 * `child`.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentType and `parent` has a
 * doctype child, `child` is non-null and an element is preceding `child`, or `child` is null
 * and `parent` has an element child.
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If node has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child,
		// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child, `child` is a doctype,
		// or `child` is non-null and a doctype is following `child`.
		if (!isElementInsertionPossible(parent, child)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		// `parent` has a doctype child,
		if (find(parentChildNodes, isDocTypeNode)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// `child` is non-null and an element is preceding `child`,
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
		// or `child` is null and `parent` has an element child.
		if (!child && parentElementChild) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
		}
	}
}

/**
 * @param {Document} parent
 * The parent node to insert `node` into.
 * @param {Node} node
 * The node to insert.
 * @param {Node | undefined} child
 * the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws {DOMException}
 * For several node combinations that would create a DOM that is not well-formed.
 * @throws {DOMException}
 * If `child` is provided but is not a child of `parent`.
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreReplacementValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If `node` has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child that is not `child` or a doctype is following `child`.
		if (!isElementReplacementPossible(parent, child)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		function hasDoctypeChildThatIsNotChild(node) {
			return isDocTypeNode(node) && node !== child;
		}

		// `parent` has a doctype child that is not `child`,
		if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// or an element is preceding `child`.
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
	}
}

/**
 * Inserts a node into a parent node before a child node.
 *
 * @param {Node} parent
 * The parent node to insert the node into.
 * @param {Node} node
 * The node to insert into the parent.
 * @param {Node | null} child
 * The node that should become the next sibling of the node.
 * If null, the function inserts the node at the end of the children of the parent node.
 * @param {Function} [_inDocumentAssertion]
 * An optional function to check pre-insertion validity if parent is a document node.
 * Defaults to {@link assertPreInsertionValidityInDocument}
 * @returns {Node}
 * Returns the inserted node.
 * @throws {DOMException}
 * Throws a DOMException if inserting the node would result in a DOM tree that is not
 * well-formed. See {@link assertPreInsertionValidity1to5},
 * {@link assertPreInsertionValidityInDocument}.
 * @throws {DOMException}
 * Throws a DOMException if child is provided but is not a child of the parent. See
 * {@link Node.removeChild}
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function _insertBefore(parent, node, child, _inDocumentAssertion) {
	// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
	assertPreInsertionValidity1to5(parent, node, child);

	// If parent is a document, and any of the statements below, switched on the interface node implements,
	// are true, then throw a "HierarchyRequestError" DOMException.
	if (parent.nodeType === Node.DOCUMENT_NODE) {
		(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
	}

	var cp = node.parentNode;
	if (cp) {
		cp.removeChild(node); //remove and update
	}
	if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
		var newFirst = node.firstChild;
		if (newFirst == null) {
			return node;
		}
		var newLast = node.lastChild;
	} else {
		newFirst = newLast = node;
	}
	var pre = child ? child.previousSibling : parent.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = child;

	if (pre) {
		pre.nextSibling = newFirst;
	} else {
		parent.firstChild = newFirst;
	}
	if (child == null) {
		parent.lastChild = newLast;
	} else {
		child.previousSibling = newLast;
	}
	do {
		newFirst.parentNode = parent;
	} while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
	_onUpdateChild(parent.ownerDocument || parent, parent, node);
	if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
		node.firstChild = node.lastChild = null;
	}

	return node;
}

Document.prototype = {
	/**
	 * The implementation that created this document.
	 *
	 * @type DOMImplementation
	 * @readonly
	 */
	implementation: null,
	nodeName: '#document',
	nodeType: DOCUMENT_NODE,
	/**
	 * The DocumentType node of the document.
	 *
	 * @type DocumentType
	 * @readonly
	 */
	doctype: null,
	documentElement: null,
	_inc: 1,

	insertBefore: function (newChild, refChild) {
		//raises
		if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
			var child = newChild.firstChild;
			while (child) {
				var next = child.nextSibling;
				this.insertBefore(child, refChild);
				child = next;
			}
			return newChild;
		}
		_insertBefore(this, newChild, refChild);
		newChild.ownerDocument = this;
		if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
			this.documentElement = newChild;
		}

		return newChild;
	},
	removeChild: function (oldChild) {
		var removed = _removeChild(this, oldChild);
		if (removed === this.documentElement) {
			this.documentElement = null;
		}
		return removed;
	},
	replaceChild: function (newChild, oldChild) {
		//raises
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		newChild.ownerDocument = this;
		if (oldChild) {
			this.removeChild(oldChild);
		}
		if (isElementNode(newChild)) {
			this.documentElement = newChild;
		}
	},
	// Introduced in DOM Level 2:
	importNode: function (importedNode, deep) {
		return importNode(this, importedNode, deep);
	},
	// Introduced in DOM Level 2:
	getElementById: function (id) {
		var rtv = null;
		_visitNode(this.documentElement, function (node) {
			if (node.nodeType == ELEMENT_NODE) {
				if (node.getAttribute('id') == id) {
					rtv = node;
					return true;
				}
			}
		});
		return rtv;
	},

	/**
	 * Creates a new `Element` that is owned by this `Document`.
	 * In HTML Documents `localName` is the lower cased `tagName`,
	 * otherwise no transformation is being applied.
	 * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
	 *
	 * __This implementation differs from the specification:__ - The provided name is not checked
	 * against the `Name` production,
	 * so no related error will be thrown.
	 * - There is no interface `HTMLElement`, it is always an `Element`.
	 * - There is no support for a second argument to indicate using custom elements.
	 *
	 * @param {string} tagName
	 * @returns {Element}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
	 * @see https://dom.spec.whatwg.org/#dom-document-createelement
	 * @see https://dom.spec.whatwg.org/#concept-create-element
	 */
	createElement: function (tagName) {
		var node = new Element(PDC);
		node.ownerDocument = this;
		if (this.type === 'html') {
			tagName = tagName.toLowerCase();
		}
		if (hasDefaultHTMLNamespace(this.contentType)) {
			node.namespaceURI = NAMESPACE.HTML;
		}
		node.nodeName = tagName;
		node.tagName = tagName;
		node.localName = tagName;
		node.childNodes = new NodeList();
		var attrs = (node.attributes = new NamedNodeMap());
		attrs._ownerElement = node;
		return node;
	},
	/**
	 * @returns {DocumentFragment}
	 */
	createDocumentFragment: function () {
		var node = new DocumentFragment(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	createTextNode: function (data) {
		var node = new Text(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.appendData(data);
		return node;
	},
	/**
	 * @param {string} data
	 * @returns {Comment}
	 */
	createComment: function (data) {
		var node = new Comment(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.appendData(data);
		return node;
	},
	/**
	 * @param {string} data
	 * @returns {CDATASection}
	 */
	createCDATASection: function (data) {
		var node = new CDATASection(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.appendData(data);
		return node;
	},
	/**
	 * @param {string} target
	 * @param {string} data
	 * @returns {ProcessingInstruction}
	 */
	createProcessingInstruction: function (target, data) {
		var node = new ProcessingInstruction(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.nodeName = node.target = target;
		node.nodeValue = node.data = data;
		return node;
	},
	/**
	 * Creates an `Attr` node that is owned by this document.
	 * In HTML Documents `localName` is the lower cased `name`,
	 * otherwise no transformation is being applied.
	 *
	 * __This implementation differs from the specification:__ - The provided name is not checked
	 * against the `Name` production,
	 * so no related error will be thrown.
	 *
	 * @param {string} name
	 * @returns {Attr}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
	 * @see https://dom.spec.whatwg.org/#dom-document-createattribute
	 */
	createAttribute: function (name) {
		if (!g.QName_exact.test(name)) {
			throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in name "' + name + '"');
		}
		if (this.type === 'html') {
			name = name.toLowerCase();
		}
		return this._createAttribute(name);
	},
	_createAttribute: function (name) {
		var node = new Attr(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.name = name;
		node.nodeName = name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	/**
	 * Creates an EntityReference object.
	 * The current implementation does not fill the `childNodes` with those of the corresponding
	 * `Entity`
	 *
	 * @deprecated
	 * In DOM Level 4.
	 * @param {string} name
	 * The name of the entity to reference. No namespace well-formedness checks are performed.
	 * @returns {EntityReference}
	 * @throws {DOMException}
	 * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
	 * @throws {DOMException}
	 * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
	 */
	createEntityReference: function (name) {
		if (!g.Name.test(name)) {
			throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'not a valid xml name "' + name + '"');
		}
		if (this.type === 'html') {
			throw new DOMException('document is an html document', DOMExceptionName.NotSupportedError);
		}

		var node = new EntityReference(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.nodeName = name;
		return node;
	},
	// Introduced in DOM Level 2:
	/**
	 * @param {string} namespaceURI
	 * @param {string} qualifiedName
	 * @returns {Element}
	 */
	createElementNS: function (namespaceURI, qualifiedName) {
		var validated = validateAndExtract(namespaceURI, qualifiedName);
		var node = new Element(PDC);
		var attrs = (node.attributes = new NamedNodeMap());
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = validated[0];
		node.prefix = validated[1];
		node.localName = validated[2];
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	/**
	 * @param {string} namespaceURI
	 * @param {string} qualifiedName
	 * @returns {Attr}
	 */
	createAttributeNS: function (namespaceURI, qualifiedName) {
		var validated = validateAndExtract(namespaceURI, qualifiedName);
		var node = new Attr(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.specified = true;
		node.namespaceURI = validated[0];
		node.prefix = validated[1];
		node.localName = validated[2];
		return node;
	},
};
_extends(Document, Node);

function Element(symbol) {
	checkSymbol(symbol);

	this._nsMap = Object.create(null);
}
Element.prototype = {
	nodeType: ELEMENT_NODE,
	/**
	 * The attributes of this element.
	 *
	 * @type {NamedNodeMap | null}
	 */
	attributes: null,
	getQualifiedName: function () {
		return this.prefix ? this.prefix + ':' + this.localName : this.localName;
	},
	_isInHTMLDocumentAndNamespace: function () {
		return this.ownerDocument.type === 'html' && this.namespaceURI === NAMESPACE.HTML;
	},
	/**
	 * Implementaton of Level2 Core function hasAttributes.
	 *
	 * @returns {boolean}
	 * True if attribute list is not empty.
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
	 */
	hasAttributes: function () {
		return !!(this.attributes && this.attributes.length);
	},
	hasAttribute: function (name) {
		return !!this.getAttributeNode(name);
	},
	/**
	 * Returns elements first attribute whose qualified name is `name`, and `null`
	 * if there is no such attribute.
	 *
	 * @param {string} name
	 * @returns {string | null}
	 */
	getAttribute: function (name) {
		var attr = this.getAttributeNode(name);
		return attr ? attr.value : null;
	},
	getAttributeNode: function (name) {
		if (this._isInHTMLDocumentAndNamespace()) {
			name = name.toLowerCase();
		}
		return this.attributes.getNamedItem(name);
	},
	/**
	 * Sets the value of elements first attribute whose qualified name is qualifiedName to value.
	 *
	 * @param {string} name
	 * @param {string} value
	 */
	setAttribute: function (name, value) {
		if (this._isInHTMLDocumentAndNamespace()) {
			name = name.toLowerCase();
		}
		var attr = this.getAttributeNode(name);
		if (attr) {
			attr.value = attr.nodeValue = '' + value;
		} else {
			attr = this.ownerDocument._createAttribute(name);
			attr.value = attr.nodeValue = '' + value;
			this.setAttributeNode(attr);
		}
	},
	removeAttribute: function (name) {
		var attr = this.getAttributeNode(name);
		attr && this.removeAttributeNode(attr);
	},
	setAttributeNode: function (newAttr) {
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS: function (newAttr) {
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode: function (oldAttr) {
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS: function (namespaceURI, localName) {
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},

	hasAttributeNS: function (namespaceURI, localName) {
		return this.getAttributeNodeNS(namespaceURI, localName) != null;
	},
	/**
	 * Returns elements attribute whose namespace is `namespaceURI` and local name is
	 * `localName`,
	 * or `null` if there is no such attribute.
	 *
	 * @param {string} namespaceURI
	 * @param {string} localName
	 * @returns {string | null}
	 */
	getAttributeNS: function (namespaceURI, localName) {
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr ? attr.value : null;
	},
	/**
	 * Sets the value of elements attribute whose namespace is `namespaceURI` and local name is
	 * `localName` to value.
	 *
	 * @param {string} namespaceURI
	 * @param {string} qualifiedName
	 * @param {string} value
	 * @see https://dom.spec.whatwg.org/#dom-element-setattributens
	 */
	setAttributeNS: function (namespaceURI, qualifiedName, value) {
		var validated = validateAndExtract(namespaceURI, qualifiedName);
		var localName = validated[2];
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		if (attr) {
			attr.value = attr.nodeValue = '' + value;
		} else {
			attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = '' + value;
			this.setAttributeNode(attr);
		}
	},
	getAttributeNodeNS: function (namespaceURI, localName) {
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},

	/**
	 * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
	 *
	 * Returns an empty list if `classNames` is an empty string or only contains HTML white space
	 * characters.
	 *
	 * Warning: This returns a live LiveNodeList.
	 * Changes in the DOM will reflect in the array as the changes occur.
	 * If an element selected by this array no longer qualifies for the selector,
	 * it will automatically be removed. Be aware of this for iteration purposes.
	 *
	 * @param {string} classNames
	 * Is a string representing the class name(s) to match; multiple class names are separated by
	 * (ASCII-)whitespace.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
	 */
	getElementsByClassName: function (classNames) {
		var classNamesSet = toOrderedSet(classNames);
		return new LiveNodeList(this, function (base) {
			var ls = [];
			if (classNamesSet.length > 0) {
				_visitNode(base, function (node) {
					if (node !== base && node.nodeType === ELEMENT_NODE) {
						var nodeClassNames = node.getAttribute('class');
						// can be null if the attribute does not exist
						if (nodeClassNames) {
							// before splitting and iterating just compare them for the most common case
							var matches = classNames === nodeClassNames;
							if (!matches) {
								var nodeClassNamesSet = toOrderedSet(nodeClassNames);
								matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
							}
							if (matches) {
								ls.push(node);
							}
						}
					}
				});
			}
			return ls;
		});
	},

	/**
	 * Returns a LiveNodeList of elements with the given qualifiedName.
	 * Searching for all descendants can be done by passing `*` as `qualifiedName`.
	 *
	 * All descendants of the specified element are searched, but not the element itself.
	 * The returned list is live, which means it updates itself with the DOM tree automatically.
	 * Therefore, there is no need to call `Element.getElementsByTagName()`
	 * with the same element and arguments repeatedly if the DOM changes in between calls.
	 *
	 * When called on an HTML element in an HTML document,
	 * `getElementsByTagName` lower-cases the argument before searching for it.
	 * This is undesirable when trying to match camel-cased SVG elements (such as
	 * `<linearGradient>`) in an HTML document.
	 * Instead, use `Element.getElementsByTagNameNS()`,
	 * which preserves the capitalization of the tag name.
	 *
	 * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
	 * except that it only searches for elements that are descendants of the specified element.
	 *
	 * @param {string} qualifiedName
	 * @returns {LiveNodeList}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
	 */
	getElementsByTagName: function (qualifiedName) {
		var isHTMLDocument = (this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument).type === 'html';
		var lowerQualifiedName = qualifiedName.toLowerCase();
		return new LiveNodeList(this, function (base) {
			var ls = [];
			_visitNode(base, function (node) {
				if (node === base || node.nodeType !== ELEMENT_NODE) {
					return;
				}
				if (qualifiedName === '*') {
					ls.push(node);
				} else {
					var nodeQualifiedName = node.getQualifiedName();
					var matchingQName = isHTMLDocument && node.namespaceURI === NAMESPACE.HTML ? lowerQualifiedName : qualifiedName;
					if (nodeQualifiedName === matchingQName) {
						ls.push(node);
					}
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS: function (namespaceURI, localName) {
		return new LiveNodeList(this, function (base) {
			var ls = [];
			_visitNode(base, function (node) {
				if (
					node !== base &&
					node.nodeType === ELEMENT_NODE &&
					(namespaceURI === '*' || node.namespaceURI === namespaceURI) &&
					(localName === '*' || node.localName == localName)
				) {
					ls.push(node);
				}
			});
			return ls;
		});
	},
};
Document.prototype.getElementsByClassName = Element.prototype.getElementsByClassName;
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;

_extends(Element, Node);
function Attr(symbol) {
	checkSymbol(symbol);

	this.namespaceURI = null;
	this.prefix = null;
	this.ownerElement = null;
}
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr, Node);

function CharacterData(symbol) {
	checkSymbol(symbol);
}
CharacterData.prototype = {
	data: '',
	substringData: function (offset, count) {
		return this.data.substring(offset, offset + count);
	},
	appendData: function (text) {
		text = this.data + text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function (offset, text) {
		this.replaceData(offset, 0, text);
	},
	deleteData: function (offset, count) {
		this.replaceData(offset, count, '');
	},
	replaceData: function (offset, count, text) {
		var start = this.data.substring(0, offset);
		var end = this.data.substring(offset + count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
};
_extends(CharacterData, Node);
function Text(symbol) {
	checkSymbol(symbol);
}
Text.prototype = {
	nodeName: '#text',
	nodeType: TEXT_NODE,
	splitText: function (offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if (this.parentNode) {
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	},
};
_extends(Text, CharacterData);
function Comment(symbol) {
	checkSymbol(symbol);
}
Comment.prototype = {
	nodeName: '#comment',
	nodeType: COMMENT_NODE,
};
_extends(Comment, CharacterData);

function CDATASection(symbol) {
	checkSymbol(symbol);
}
CDATASection.prototype = {
	nodeName: '#cdata-section',
	nodeType: CDATA_SECTION_NODE,
};
_extends(CDATASection, Text);

function DocumentType(symbol) {
	checkSymbol(symbol);
}
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType, Node);

function Notation(symbol) {
	checkSymbol(symbol);
}
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation, Node);

function Entity(symbol) {
	checkSymbol(symbol);
}
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity, Node);

function EntityReference(symbol) {
	checkSymbol(symbol);
}
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference, Node);

function DocumentFragment(symbol) {
	checkSymbol(symbol);
}
DocumentFragment.prototype.nodeName = '#document-fragment';
DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment, Node);

function ProcessingInstruction(symbol) {
	checkSymbol(symbol);
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction, CharacterData);
function XMLSerializer() {}
XMLSerializer.prototype.serializeToString = function (node, nodeFilter) {
	return nodeSerializeToString.call(node, nodeFilter);
};
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(nodeFilter) {
	var buf = [];
	var refNode = (this.nodeType === DOCUMENT_NODE && this.documentElement) || this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;

	if (uri && prefix == null) {
		var prefix = refNode.lookupPrefix(uri);
		if (prefix == null) {
			var visibleNamespaces = [
				{ namespace: uri, prefix: null },
				//{namespace:uri,prefix:''}
			];
		}
	}
	serializeToString(this, buf, nodeFilter, visibleNamespaces);
	return buf.join('');
}

function needNamespaceDefine(node, isHTML, visibleNamespaces) {
	var prefix = node.prefix || '';
	var uri = node.namespaceURI;
	// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
	// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
	// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
	// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
	// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
	// > [...] Furthermore, the attribute value [...] must not be an empty string.
	// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
	if (!uri) {
		return false;
	}
	if ((prefix === 'xml' && uri === NAMESPACE.XML) || uri === NAMESPACE.XMLNS) {
		return false;
	}

	var i = visibleNamespaces.length;
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		if (ns.prefix === prefix) {
			return ns.namespace !== uri;
		}
	}
	return true;
}
/**
 * Literal whitespace other than space that appear in attribute values are serialized as
 * their entity references, so they will be preserved.
 * (In contrast to whitespace literals in the input which are normalized to spaces).
 *
 * Well-formed constraint: No < in Attribute Values:
 * > The replacement text of any entity referred to directly or indirectly
 * > in an attribute value must not contain a <.
 *
 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
 * @see https://www.w3.org/TR/xml11/#NT-AttValue
 * @see https://www.w3.org/TR/xml11/#AVNormalize
 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
 * @prettierignore
 */
function addSerializedAttribute(buf, qualifiedName, value) {
	buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
}

function serializeToString(node, buf, nodeFilter, visibleNamespaces) {
	if (!visibleNamespaces) {
		visibleNamespaces = [];
	}
	var doc = node.nodeType === DOCUMENT_NODE ? node : node.ownerDocument;
	var isHTML = doc.type === 'html';

	if (nodeFilter) {
		node = nodeFilter(node);
		if (node) {
			if (typeof node == 'string') {
				buf.push(node);
				return;
			}
		} else {
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}

	switch (node.nodeType) {
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;

			var prefixedNodeName = nodeName;
			if (!isHTML && !node.prefix && node.namespaceURI) {
				var defaultNS;
				// lookup current default ns from `xmlns` attribute
				for (var ai = 0; ai < attrs.length; ai++) {
					if (attrs.item(ai).name === 'xmlns') {
						defaultNS = attrs.item(ai).value;
						break;
					}
				}
				if (!defaultNS) {
					// lookup current default ns in visibleNamespaces
					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
							defaultNS = namespace.namespace;
							break;
						}
					}
				}
				if (defaultNS !== node.namespaceURI) {
					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.namespace === node.namespaceURI) {
							if (namespace.prefix) {
								prefixedNodeName = namespace.prefix + ':' + nodeName;
							}
							break;
						}
					}
				}
			}

			buf.push('<', prefixedNodeName);

			for (var i = 0; i < len; i++) {
				// add namespaces for attributes
				var attr = attrs.item(i);
				if (attr.prefix == 'xmlns') {
					visibleNamespaces.push({
						prefix: attr.localName,
						namespace: attr.value,
					});
				} else if (attr.nodeName == 'xmlns') {
					visibleNamespaces.push({ prefix: '', namespace: attr.value });
				}
			}

			for (var i = 0; i < len; i++) {
				var attr = attrs.item(i);
				if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
					var prefix = attr.prefix || '';
					var uri = attr.namespaceURI;
					addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);
					visibleNamespaces.push({ prefix: prefix, namespace: uri });
				}
				serializeToString(attr, buf, nodeFilter, visibleNamespaces);
			}

			// add namespace for current node
			if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
				var prefix = node.prefix || '';
				var uri = node.namespaceURI;
				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);
				visibleNamespaces.push({ prefix: prefix, namespace: uri });
			}
			// in XML elements can be closed when they have no children
			var canCloseTag = !child;
			if (canCloseTag && (isHTML || node.namespaceURI === NAMESPACE.HTML)) {
				// in HTML (doc or ns) only void elements can be closed right away
				canCloseTag = isHTMLVoidElement(nodeName);
			}
			if (canCloseTag) {
				buf.push('/>');
			} else {
				buf.push('>');
				//if is cdata child node
				if (isHTML && isHTMLRawTextElement(nodeName)) {
					while (child) {
						if (child.data) {
							buf.push(child.data);
						} else {
							serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
						}
						child = child.nextSibling;
					}
				} else {
					while (child) {
						serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
						child = child.nextSibling;
					}
				}
				buf.push('</', prefixedNodeName, '>');
			}
			// remove added visible namespaces
			//visibleNamespaces.length = startVisibleNamespaces;
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while (child) {
				serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return addSerializedAttribute(buf, node.name, node.value);
		case TEXT_NODE:
			/*
			 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
			 * except when used as markup delimiters, or within a comment, a processing instruction,
			 * or a CDATA section.
			 * If they are needed elsewhere, they must be escaped using either numeric character
			 * references or the strings `&amp;` and `&lt;` respectively.
			 * The right angle bracket (>) may be represented using the string " &gt; ",
			 * and must, for compatibility, be escaped using either `&gt;`,
			 * or a character reference when it appears in the string `]]>` in content,
			 * when that string is not marking the end of a CDATA section.
			 *
			 * In the content of elements, character data is any string of characters which does not
			 * contain the start-delimiter of any markup and does not include the CDATA-section-close
			 * delimiter, `]]>`.
			 *
			 * @see https://www.w3.org/TR/xml/#NT-CharData
			 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
			 */
			return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
		case CDATA_SECTION_NODE:
			return buf.push(g.CDATA_START, node.data, g.CDATA_END);
		case COMMENT_NODE:
			return buf.push(g.COMMENT_START, node.data, g.COMMENT_END);
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push(g.DOCTYPE_DECL_START, ' ', node.name);
			if (pubid) {
				buf.push(' ', g.PUBLIC, ' ', pubid);
				if (sysid && sysid !== '.') {
					buf.push(' ', sysid);
				}
			} else if (sysid && sysid !== '.') {
				buf.push(' ', g.SYSTEM, ' ', sysid);
			}
			if (node.internalSubset) {
				buf.push(' [', node.internalSubset, ']');
			}
			buf.push('>');
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push('<?', node.target, ' ', node.data, '?>');
		case ENTITY_REFERENCE_NODE:
			return buf.push('&', node.nodeName, ';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??', node.nodeName);
	}
}
function importNode(doc, node, deep) {
	var node2;
	switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
		//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE
		//can not hit in level3
		//default:throw e;
	}
	if (!node2) {
		node2 = node.cloneNode(false); //false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if (deep) {
		var child = node.firstChild;
		while (child) {
			node2.appendChild(importNode(doc, child, deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

/**
 * Creates a copy of a node from an existing one.
 *
 * @param {Document} doc
 * The Document object representing the document that the new node will belong to.
 * @param {Node} node
 * The node to clone.
 * @param {boolean} deep
 * If true, the contents of the node are recursively copied.
 * If false, only the node itself (and its attributes, if it is an element) are copied.
 * @returns {Node}
 * Returns the newly created copy of the node.
 * @throws {DOMException}
 * May throw a DOMException if operations within setAttributeNode or appendChild (which are
 * potentially invoked in this function) do not meet their specific constraints.
 */
function cloneNode(doc, node, deep) {
	var node2 = new node.constructor(PDC);
	for (var n in node) {
		if (hasOwn(node, n)) {
			var v = node[n];
			if (typeof v != 'object') {
				if (v != node2[n]) {
					node2[n] = v;
				}
			}
		}
	}
	if (node.childNodes) {
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var attrs2 = (node2.attributes = new NamedNodeMap());
			var len = attrs.length;
			attrs2._ownerElement = node2;
			for (var i = 0; i < len; i++) {
				node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
			}
			break;
		case ATTRIBUTE_NODE:
			deep = true;
	}
	if (deep) {
		var child = node.firstChild;
		while (child) {
			node2.appendChild(cloneNode(doc, child, deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object, key, value) {
	object[key] = value;
}
//do dynamic
try {
	if (Object.defineProperty) {
		Object.defineProperty(LiveNodeList.prototype, 'length', {
			get: function () {
				_updateLiveList(this);
				return this.$$length;
			},
		});

		Object.defineProperty(Node.prototype, 'textContent', {
			get: function () {
				return getTextContent(this);
			},

			set: function (data) {
				switch (this.nodeType) {
					case ELEMENT_NODE:
					case DOCUMENT_FRAGMENT_NODE:
						while (this.firstChild) {
							this.removeChild(this.firstChild);
						}
						if (data || String(data)) {
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;

					default:
						this.data = data;
						this.value = data;
						this.nodeValue = data;
				}
			},
		});

		function getTextContent(node) {
			switch (node.nodeType) {
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					var buf = [];
					node = node.firstChild;
					while (node) {
						if (node.nodeType !== 7 && node.nodeType !== 8) {
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
			}
		}

		__set__ = function (object, key, value) {
			//console.log(value)
			object['$$' + key] = value;
		};
	}
} catch (e) {
	//ie8
}

exports._updateLiveList = _updateLiveList;
exports.Attr = Attr;
exports.CDATASection = CDATASection;
exports.CharacterData = CharacterData;
exports.Comment = Comment;
exports.Document = Document;
exports.DocumentFragment = DocumentFragment;
exports.DocumentType = DocumentType;
exports.DOMImplementation = DOMImplementation;
exports.Element = Element;
exports.Entity = Entity;
exports.EntityReference = EntityReference;
exports.LiveNodeList = LiveNodeList;
exports.NamedNodeMap = NamedNodeMap;
exports.Node = Node;
exports.NodeList = NodeList;
exports.Notation = Notation;
exports.Text = Text;
exports.ProcessingInstruction = ProcessingInstruction;
exports.XMLSerializer = XMLSerializer;


/***/ }),

/***/ 802:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var conventions = __webpack_require__(870);
var g = __webpack_require__(731);
var errors = __webpack_require__(767);

var isHTMLEscapableRawTextElement = conventions.isHTMLEscapableRawTextElement;
var isHTMLMimeType = conventions.isHTMLMimeType;
var isHTMLRawTextElement = conventions.isHTMLRawTextElement;
var hasOwn = conventions.hasOwn;
var NAMESPACE = conventions.NAMESPACE;
var ParseError = errors.ParseError;
var DOMException = errors.DOMException;

//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0; //tag name offerring
var S_ATTR = 1; //attr name offerring
var S_ATTR_SPACE = 2; //attr name end and space offer
var S_EQ = 3; //=space?
var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)
var S_ATTR_END = 5; //attr value end and no space(quot end)
var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7; //closed el<el />

function XMLReader() {}

XMLReader.prototype = {
	parse: function (source, defaultNSMap, entityMap) {
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap, (defaultNSMap = Object.create(null)));
		parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
		domBuilder.endDocument();
	},
};

/**
 * Detecting everything that might be a reference,
 * including those without ending `;`, since those are allowed in HTML.
 * The entityReplacer takes care of verifying and transforming each occurrence,
 * and reports to the errorHandler on those that are not OK,
 * depending on the context.
 */
var ENTITY_REG = /&#?\w+;?/g;

function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
	var isHTML = isHTMLMimeType(domBuilder.mimeType);
	if (source.indexOf(g.UNICODE_REPLACEMENT_CHARACTER) >= 0) {
		errorHandler.warning('Unicode replacement character detected, source encoding issues?');
	}

	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10),
				surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}

	function entityReplacer(a) {
		var complete = a[a.length - 1] === ';' ? a : a + ';';
		if (!isHTML && complete !== a) {
			errorHandler.error('EntityRef: expecting ;');
			return a;
		}
		var match = g.Reference.exec(complete);
		if (!match || match[0].length !== complete.length) {
			errorHandler.error('entity not matching Reference production: ' + a);
			return a;
		}
		var k = complete.slice(1, -1);
		if (hasOwn(entityMap, k)) {
			return entityMap[k];
		} else if (k.charAt(0) === '#') {
			return fixedFromCharCode(parseInt(k.substring(1).replace('x', '0x')));
		} else {
			errorHandler.error('entity not found:' + a);
			return a;
		}
	}

	function appendText(end) {
		//has some bugs
		if (end > start) {
			var xt = source.substring(start, end).replace(ENTITY_REG, entityReplacer);
			locator && position(start);
			domBuilder.characters(xt, 0, end - start);
			start = end;
		}
	}

	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /\r\n?|\n|$/g;
	var locator = domBuilder.locator;

	function position(p, m) {
		while (p >= lineEnd && (m = linePattern.exec(source))) {
			lineStart = lineEnd;
			lineEnd = m.index + m[0].length;
			locator.lineNumber++;
		}
		locator.columnNumber = p - lineStart + 1;
	}

	var parseStack = [{ currentNSMap: defaultNSMapCopy }];
	var unclosedTags = [];
	var start = 0;
	while (true) {
		try {
			var tagStart = source.indexOf('<', start);
			if (tagStart < 0) {
				if (!isHTML && unclosedTags.length > 0) {
					return errorHandler.fatalError('unclosed xml tag(s): ' + unclosedTags.join(', '));
				}
				if (!source.substring(start).match(/^\s*$/)) {
					var doc = domBuilder.doc;
					var text = doc.createTextNode(source.substring(start));
					if (doc.documentElement) {
						return errorHandler.error('Extra content at the end of the document');
					}
					doc.appendChild(text);
					domBuilder.currentElement = text;
				}
				return;
			}
			if (tagStart > start) {
				var fromSource = source.substring(start, tagStart);
				if (!isHTML && unclosedTags.length === 0) {
					fromSource = fromSource.replace(new RegExp(g.S_OPT.source, 'g'), '');
					fromSource && errorHandler.error("Unexpected content outside root element: '" + fromSource + "'");
				}
				appendText(tagStart);
			}
			switch (source.charAt(tagStart + 1)) {
				case '/':
					var end = source.indexOf('>', tagStart + 2);
					var tagNameRaw = source.substring(tagStart + 2, end > 0 ? end : undefined);
					if (!tagNameRaw) {
						return errorHandler.fatalError('end tag name missing');
					}
					var tagNameMatch = end > 0 && g.reg('^', g.QName_group, g.S_OPT, '$').exec(tagNameRaw);
					if (!tagNameMatch) {
						return errorHandler.fatalError('end tag name contains invalid characters: "' + tagNameRaw + '"');
					}
					if (!domBuilder.currentElement && !domBuilder.doc.documentElement) {
						// not enough information to provide a helpful error message,
						// but parsing will throw since there is no root element
						return;
					}
					var currentTagName =
						unclosedTags[unclosedTags.length - 1] ||
						domBuilder.currentElement.tagName ||
						domBuilder.doc.documentElement.tagName ||
						'';
					if (currentTagName !== tagNameMatch[1]) {
						var tagNameLower = tagNameMatch[1].toLowerCase();
						if (!isHTML || currentTagName.toLowerCase() !== tagNameLower) {
							return errorHandler.fatalError('Opening and ending tag mismatch: "' + currentTagName + '" != "' + tagNameRaw + '"');
						}
					}
					var config = parseStack.pop();
					unclosedTags.pop();
					var localNSMap = config.localNSMap;
					domBuilder.endElement(config.uri, config.localName, currentTagName);
					if (localNSMap) {
						for (var prefix in localNSMap) {
							if (hasOwn(localNSMap, prefix)) {
								domBuilder.endPrefixMapping(prefix);
							}
						}
					}

					end++;
					break;
				// end element
				case '?': // <?...?>
					locator && position(tagStart);
					end = parseProcessingInstruction(source, tagStart, domBuilder, errorHandler);
					break;
				case '!': // <!doctype,<![CDATA,<!--
					locator && position(tagStart);
					end = parseDoctypeCommentOrCData(source, tagStart, domBuilder, errorHandler, isHTML);
					break;
				default:
					locator && position(tagStart);
					var el = new ElementAttributes();
					var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
					//elStartEnd
					var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler, isHTML);
					var len = el.length;

					if (!el.closed) {
						if (isHTML && conventions.isHTMLVoidElement(el.tagName)) {
							el.closed = true;
						} else {
							unclosedTags.push(el.tagName);
						}
					}
					if (locator && len) {
						var locator2 = copyLocator(locator, {});
						//try{//attribute position fixed
						for (var i = 0; i < len; i++) {
							var a = el[i];
							position(a.offset);
							a.locator = copyLocator(locator, {});
						}
						domBuilder.locator = locator2;
						if (appendElement(el, domBuilder, currentNSMap)) {
							parseStack.push(el);
						}
						domBuilder.locator = locator;
					} else {
						if (appendElement(el, domBuilder, currentNSMap)) {
							parseStack.push(el);
						}
					}

					if (isHTML && !el.closed) {
						end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
					} else {
						end++;
					}
			}
		} catch (e) {
			if (e instanceof ParseError) {
				throw e;
			} else if (e instanceof DOMException) {
				throw new ParseError(e.name + ': ' + e.message, domBuilder.locator, e);
			}
			errorHandler.error('element parse error: ' + e);
			end = -1;
		}
		if (end > start) {
			start = end;
		} else {
			//Possible sax fallback here, risk of positional error
			appendText(Math.max(tagStart, start) + 1);
		}
	}
}

function copyLocator(f, t) {
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @returns
 * end of the elementStartPart(end of elementEndPart for selfClosed el)
 * @see {@link #appendElement}
 */
function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler, isHTML) {
	/**
	 * @param {string} qname
	 * @param {string} value
	 * @param {number} startIndex
	 */
	function addAttribute(qname, value, startIndex) {
		if (hasOwn(el.attributeNames, qname)) {
			return errorHandler.fatalError('Attribute ' + qname + ' redefined');
		}
		if (!isHTML && value.indexOf('<') >= 0) {
			return errorHandler.fatalError("Unescaped '<' not allowed in attributes values");
		}
		el.addValue(
			qname,
			// @see https://www.w3.org/TR/xml/#AVNormalize
			// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
			// - recursive replacement of (DTD) entity references
			// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
			value.replace(/[\t\n\r]/g, ' ').replace(ENTITY_REG, entityReplacer),
			startIndex
		);
	}

	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG; //status
	while (true) {
		var c = source.charAt(p);
		switch (c) {
			case '=':
				if (s === S_ATTR) {
					//attrName
					attrName = source.slice(start, p);
					s = S_EQ;
				} else if (s === S_ATTR_SPACE) {
					s = S_EQ;
				} else {
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName'); // No known test case
				}
				break;
			case "'":
			case '"':
				if (
					s === S_EQ ||
					s === S_ATTR //|| s == S_ATTR_SPACE
				) {
					//equal
					if (s === S_ATTR) {
						errorHandler.warning('attribute value must after "="');
						attrName = source.slice(start, p);
					}
					start = p + 1;
					p = source.indexOf(c, start);
					if (p > 0) {
						value = source.slice(start, p);
						addAttribute(attrName, value, start - 1);
						s = S_ATTR_END;
					} else {
						//fatalError: no end quot match
						throw new Error("attribute value no end '" + c + "' match");
					}
				} else if (s == S_ATTR_NOQUOT_VALUE) {
					value = source.slice(start, p);
					addAttribute(attrName, value, start);
					errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
					start = p + 1;
					s = S_ATTR_END;
				} else {
					//fatalError: no equal before
					throw new Error('attribute value must after "="'); // No known test case
				}
				break;
			case '/':
				switch (s) {
					case S_TAG:
						el.setTagName(source.slice(start, p));
					case S_ATTR_END:
					case S_TAG_SPACE:
					case S_TAG_CLOSE:
						s = S_TAG_CLOSE;
						el.closed = true;
					case S_ATTR_NOQUOT_VALUE:
					case S_ATTR:
						break;
					case S_ATTR_SPACE:
						el.closed = true;
						break;
					//case S_EQ:
					default:
						throw new Error("attribute invalid close char('/')"); // No known test case
				}
				break;
			case '': //end document
				errorHandler.error('unexpected end of input');
				if (s == S_TAG) {
					el.setTagName(source.slice(start, p));
				}
				return p;
			case '>':
				switch (s) {
					case S_TAG:
						el.setTagName(source.slice(start, p));
					case S_ATTR_END:
					case S_TAG_SPACE:
					case S_TAG_CLOSE:
						break; //normal
					case S_ATTR_NOQUOT_VALUE: //Compatible state
					case S_ATTR:
						value = source.slice(start, p);
						if (value.slice(-1) === '/') {
							el.closed = true;
							value = value.slice(0, -1);
						}
					case S_ATTR_SPACE:
						if (s === S_ATTR_SPACE) {
							value = attrName;
						}
						if (s == S_ATTR_NOQUOT_VALUE) {
							errorHandler.warning('attribute "' + value + '" missed quot(")!');
							addAttribute(attrName, value, start);
						} else {
							if (!isHTML) {
								errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
							}
							addAttribute(value, value, start);
						}
						break;
					case S_EQ:
						if (!isHTML) {
							return errorHandler.fatalError('AttValue: \' or " expected');
						}
				}
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if (c <= ' ') {
					//space
					switch (s) {
						case S_TAG:
							el.setTagName(source.slice(start, p)); //tagName
							s = S_TAG_SPACE;
							break;
						case S_ATTR:
							attrName = source.slice(start, p);
							s = S_ATTR_SPACE;
							break;
						case S_ATTR_NOQUOT_VALUE:
							var value = source.slice(start, p);
							errorHandler.warning('attribute "' + value + '" missed quot(")!!');
							addAttribute(attrName, value, start);
						case S_ATTR_END:
							s = S_TAG_SPACE;
							break;
						//case S_TAG_SPACE:
						//case S_EQ:
						//case S_ATTR_SPACE:
						//	void();break;
						//case S_TAG_CLOSE:
						//ignore warning
					}
				} else {
					//not space
					//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
					//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
					switch (s) {
						//case S_TAG:void();break;
						//case S_ATTR:void();break;
						//case S_ATTR_NOQUOT_VALUE:void();break;
						case S_ATTR_SPACE:
							if (!isHTML) {
								errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
							}
							addAttribute(attrName, attrName, start);
							start = p;
							s = S_ATTR;
							break;
						case S_ATTR_END:
							errorHandler.warning('attribute space is required"' + attrName + '"!!');
						case S_TAG_SPACE:
							s = S_ATTR;
							start = p;
							break;
						case S_EQ:
							s = S_ATTR_NOQUOT_VALUE;
							start = p;
							break;
						case S_TAG_CLOSE:
							throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
		} //end outer switch
		p++;
	}
}

/**
 * @returns
 * `true` if a new namespace has been defined.
 */
function appendElement(el, domBuilder, currentNSMap) {
	var tagName = el.tagName;
	var localNSMap = null;
	var i = el.length;
	while (i--) {
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if (nsp > 0) {
			var prefix = (a.prefix = qName.slice(0, nsp));
			var localName = qName.slice(nsp + 1);
			var nsPrefix = prefix === 'xmlns' && localName;
		} else {
			localName = qName;
			prefix = null;
			nsPrefix = qName === 'xmlns' && '';
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName;
		//prefix == null for no ns prefix attribute
		if (nsPrefix !== false) {
			//hack!!
			if (localNSMap == null) {
				localNSMap = Object.create(null);
				_copy(currentNSMap, (currentNSMap = Object.create(null)));
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = NAMESPACE.XMLNS;
			domBuilder.startPrefixMapping(nsPrefix, value);
		}
	}
	var i = el.length;
	while (i--) {
		a = el[i];
		if (a.prefix) {
			//no prefix attribute has no namespace
			if (a.prefix === 'xml') {
				a.uri = NAMESPACE.XML;
			}
			if (a.prefix !== 'xmlns') {
				a.uri = currentNSMap[a.prefix];
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if (nsp > 0) {
		prefix = el.prefix = tagName.slice(0, nsp);
		localName = el.localName = tagName.slice(nsp + 1);
	} else {
		prefix = null; //important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = (el.uri = currentNSMap[prefix || '']);
	domBuilder.startElement(ns, localName, tagName, el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if (el.closed) {
		domBuilder.endElement(ns, localName, tagName);
		if (localNSMap) {
			for (prefix in localNSMap) {
				if (hasOwn(localNSMap, prefix)) {
					domBuilder.endPrefixMapping(prefix);
				}
			}
		}
	} else {
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}

function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
	// https://html.spec.whatwg.org/#raw-text-elements
	// https://html.spec.whatwg.org/#escapable-raw-text-elements
	// https://html.spec.whatwg.org/#cdata-rcdata-restrictions:raw-text-elements
	// TODO: https://html.spec.whatwg.org/#cdata-rcdata-restrictions
	var isEscapableRaw = isHTMLEscapableRawTextElement(tagName);
	if (isEscapableRaw || isHTMLRawTextElement(tagName)) {
		var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
		var text = source.substring(elStartEnd + 1, elEndStart);

		if (isEscapableRaw) {
			text = text.replace(ENTITY_REG, entityReplacer);
		}
		domBuilder.characters(text, 0, text.length);
		return elEndStart;
	}
	return elStartEnd + 1;
}

function _copy(source, target) {
	for (var n in source) {
		if (hasOwn(source, n)) {
			target[n] = source[n];
		}
	}
}

/**
 * @typedef ParseUtils
 * @property {function(relativeIndex: number?): string | undefined} char
 * Provides look ahead access to a singe character relative to the current index.
 * @property {function(): number} getIndex
 * Provides read-only access to the current index.
 * @property {function(reg: RegExp): string | null} getMatch
 * Applies the provided regular expression enforcing that it starts at the current index and
 * returns the complete matching string,
 * and moves the current index by the length of the matching string.
 * @property {function(): string} getSource
 * Provides read-only access to the complete source.
 * @property {function(places: number?): void} skip
 * moves the current index by places (defaults to 1)
 * @property {function(): number} skipBlanks
 * Moves the current index by the amount of white space that directly follows the current index
 * and returns the amount of whitespace chars skipped (0..n),
 * or -1 if the end of the source was reached.
 * @property {function(): string} substringFromIndex
 * creates a substring from the current index to the end of `source`
 * @property {function(compareWith: string): boolean} substringStartsWith
 * Checks if `source` contains `compareWith`, starting from the current index.
 * @property {function(compareWith: string): boolean} substringStartsWithCaseInsensitive
 * Checks if `source` contains `compareWith`, starting from the current index,
 * comparing the upper case of both sides.
 * @see {@link parseUtils}
 */

/**
 * A temporary scope for parsing and look ahead operations in `source`,
 * starting from index `start`.
 *
 * Some operations move the current index by a number of positions,
 * after which `getIndex` returns the new index.
 *
 * @param {string} source
 * @param {number} start
 * @returns {ParseUtils}
 */
function parseUtils(source, start) {
	var index = start;

	function char(n) {
		n = n || 0;
		return source.charAt(index + n);
	}

	function skip(n) {
		n = n || 1;
		index += n;
	}

	function skipBlanks() {
		var blanks = 0;
		while (index < source.length) {
			var c = char();
			if (c !== ' ' && c !== '\n' && c !== '\t' && c !== '\r') {
				return blanks;
			}
			blanks++;
			skip();
		}
		return -1;
	}
	function substringFromIndex() {
		return source.substring(index);
	}
	function substringStartsWith(text) {
		return source.substring(index, index + text.length) === text;
	}
	function substringStartsWithCaseInsensitive(text) {
		return source.substring(index, index + text.length).toUpperCase() === text.toUpperCase();
	}

	function getMatch(args) {
		var expr = g.reg('^', args);
		var match = expr.exec(substringFromIndex());
		if (match) {
			skip(match[0].length);
			return match[0];
		}
		return null;
	}
	return {
		char: char,
		getIndex: function () {
			return index;
		},
		getMatch: getMatch,
		getSource: function () {
			return source;
		},
		skip: skip,
		skipBlanks: skipBlanks,
		substringFromIndex: substringFromIndex,
		substringStartsWith: substringStartsWith,
		substringStartsWithCaseInsensitive: substringStartsWithCaseInsensitive,
	};
}

/**
 * @param {ParseUtils} p
 * @param {DOMHandler} errorHandler
 * @returns {string}
 */
function parseDoctypeInternalSubset(p, errorHandler) {
	/**
	 * @param {ParseUtils} p
	 * @param {DOMHandler} errorHandler
	 * @returns {string}
	 */
	function parsePI(p, errorHandler) {
		var match = g.PI.exec(p.substringFromIndex());
		if (!match) {
			return errorHandler.fatalError('processing instruction is not well-formed at position ' + p.getIndex());
		}
		if (match[1].toLowerCase() === 'xml') {
			return errorHandler.fatalError(
				'xml declaration is only allowed at the start of the document, but found at position ' + p.getIndex()
			);
		}
		p.skip(match[0].length);
		return match[0];
	}
	// Parse internal subset
	var source = p.getSource();
	if (p.char() === '[') {
		p.skip(1);
		var intSubsetStart = p.getIndex();
		while (p.getIndex() < source.length) {
			p.skipBlanks();
			if (p.char() === ']') {
				var internalSubset = source.substring(intSubsetStart, p.getIndex());
				p.skip(1);
				return internalSubset;
			}
			var current = null;
			// Only in external subset
			// if (char() === '<' && char(1) === '!' && char(2) === '[') {
			// 	parseConditionalSections(p, errorHandler);
			// } else
			if (p.char() === '<' && p.char(1) === '!') {
				switch (p.char(2)) {
					case 'E': // ELEMENT | ENTITY
						if (p.char(3) === 'L') {
							current = p.getMatch(g.elementdecl);
						} else if (p.char(3) === 'N') {
							current = p.getMatch(g.EntityDecl);
						}
						break;
					case 'A': // ATTRIBUTE
						current = p.getMatch(g.AttlistDecl);
						break;
					case 'N': // NOTATION
						current = p.getMatch(g.NotationDecl);
						break;
					case '-': // COMMENT
						current = p.getMatch(g.Comment);
						break;
				}
			} else if (p.char() === '<' && p.char(1) === '?') {
				current = parsePI(p, errorHandler);
			} else if (p.char() === '%') {
				current = p.getMatch(g.PEReference);
			} else {
				return errorHandler.fatalError('Error detected in Markup declaration');
			}
			if (!current) {
				return errorHandler.fatalError('Error in internal subset at position ' + p.getIndex());
			}
		}
		return errorHandler.fatalError('doctype internal subset is not well-formed, missing ]');
	}
}

/**
 * Called when the parser encounters an element starting with '<!'.
 *
 * @param {string} source
 * The xml.
 * @param {number} start
 * the start index of the '<!'
 * @param {DOMHandler} domBuilder
 * @param {DOMHandler} errorHandler
 * @param {boolean} isHTML
 * @returns {number | never}
 * The end index of the element.
 * @throws {ParseError}
 * In case the element is not well-formed.
 */
function parseDoctypeCommentOrCData(source, start, domBuilder, errorHandler, isHTML) {
	var p = parseUtils(source, start);

	switch (isHTML ? p.char(2).toUpperCase() : p.char(2)) {
		case '-':
			// should be a comment
			var comment = p.getMatch(g.Comment);
			if (comment) {
				domBuilder.comment(comment, g.COMMENT_START.length, comment.length - g.COMMENT_START.length - g.COMMENT_END.length);
				return p.getIndex();
			} else {
				return errorHandler.fatalError('comment is not well-formed at position ' + p.getIndex());
			}
		case '[':
			// should be CDATA
			var cdata = p.getMatch(g.CDSect);
			if (cdata) {
				if (!isHTML && !domBuilder.currentElement) {
					return errorHandler.fatalError('CDATA outside of element');
				}
				domBuilder.startCDATA();
				domBuilder.characters(cdata, g.CDATA_START.length, cdata.length - g.CDATA_START.length - g.CDATA_END.length);
				domBuilder.endCDATA();
				return p.getIndex();
			} else {
				return errorHandler.fatalError('Invalid CDATA starting at position ' + start);
			}
		case 'D': {
			// should be DOCTYPE
			if (domBuilder.doc && domBuilder.doc.documentElement) {
				return errorHandler.fatalError('Doctype not allowed inside or after documentElement at position ' + p.getIndex());
			}
			if (isHTML ? !p.substringStartsWithCaseInsensitive(g.DOCTYPE_DECL_START) : !p.substringStartsWith(g.DOCTYPE_DECL_START)) {
				return errorHandler.fatalError('Expected ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());
			}
			p.skip(g.DOCTYPE_DECL_START.length);
			if (p.skipBlanks() < 1) {
				return errorHandler.fatalError('Expected whitespace after ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());
			}

			var doctype = {
				name: undefined,
				publicId: undefined,
				systemId: undefined,
				internalSubset: undefined,
			};
			// Parse the DOCTYPE name
			doctype.name = p.getMatch(g.Name);
			if (!doctype.name)
				return errorHandler.fatalError('doctype name missing or contains unexpected characters at position ' + p.getIndex());

			if (isHTML && doctype.name.toLowerCase() !== 'html') {
				errorHandler.warning('Unexpected DOCTYPE in HTML document at position ' + p.getIndex());
			}
			p.skipBlanks();

			// Check for ExternalID
			if (p.substringStartsWith(g.PUBLIC) || p.substringStartsWith(g.SYSTEM)) {
				var match = g.ExternalID_match.exec(p.substringFromIndex());
				if (!match) {
					return errorHandler.fatalError('doctype external id is not well-formed at position ' + p.getIndex());
				}
				if (match.groups.SystemLiteralOnly !== undefined) {
					doctype.systemId = match.groups.SystemLiteralOnly;
				} else {
					doctype.systemId = match.groups.SystemLiteral;
					doctype.publicId = match.groups.PubidLiteral;
				}
				p.skip(match[0].length);
			} else if (isHTML && p.substringStartsWithCaseInsensitive(g.SYSTEM)) {
				// https://html.spec.whatwg.org/multipage/syntax.html#doctype-legacy-string
				p.skip(g.SYSTEM.length);
				if (p.skipBlanks() < 1) {
					return errorHandler.fatalError('Expected whitespace after ' + g.SYSTEM + ' at position ' + p.getIndex());
				}
				doctype.systemId = p.getMatch(g.ABOUT_LEGACY_COMPAT_SystemLiteral);
				if (!doctype.systemId) {
					return errorHandler.fatalError(
						'Expected ' + g.ABOUT_LEGACY_COMPAT + ' in single or double quotes after ' + g.SYSTEM + ' at position ' + p.getIndex()
					);
				}
			}
			if (isHTML && doctype.systemId && !g.ABOUT_LEGACY_COMPAT_SystemLiteral.test(doctype.systemId)) {
				errorHandler.warning('Unexpected doctype.systemId in HTML document at position ' + p.getIndex());
			}
			if (!isHTML) {
				p.skipBlanks();
				doctype.internalSubset = parseDoctypeInternalSubset(p, errorHandler);
			}
			p.skipBlanks();
			if (p.char() !== '>') {
				return errorHandler.fatalError('doctype not terminated with > at position ' + p.getIndex());
			}
			p.skip(1);
			domBuilder.startDTD(doctype.name, doctype.publicId, doctype.systemId, doctype.internalSubset);
			domBuilder.endDTD();
			return p.getIndex();
		}
		default:
			return errorHandler.fatalError('Not well-formed XML starting with "<!" at position ' + start);
	}
}

function parseProcessingInstruction(source, start, domBuilder, errorHandler) {
	var match = source.substring(start).match(g.PI);
	if (!match) {
		return errorHandler.fatalError('Invalid processing instruction starting at position ' + start);
	}
	if (match[1].toLowerCase() === 'xml') {
		if (start > 0) {
			return errorHandler.fatalError(
				'processing instruction at position ' + start + ' is an xml declaration which is only at the start of the document'
			);
		}
		if (!g.XMLDecl.test(source.substring(start))) {
			return errorHandler.fatalError('xml declaration is not well-formed');
		}
	}
	domBuilder.processingInstruction(match[1], match[2]);
	return start + match[0].length;
}

function ElementAttributes() {
	this.attributeNames = Object.create(null);
}

ElementAttributes.prototype = {
	setTagName: function (tagName) {
		if (!g.QName_exact.test(tagName)) {
			throw new Error('invalid tagName:' + tagName);
		}
		this.tagName = tagName;
	},
	addValue: function (qName, value, offset) {
		if (!g.QName_exact.test(qName)) {
			throw new Error('invalid attribute:' + qName);
		}
		this.attributeNames[qName] = this.length;
		this[this.length++] = { qName: qName, value: value, offset: offset };
	},
	length: 0,
	getLocalName: function (i) {
		return this[i].localName;
	},
	getLocator: function (i) {
		return this[i].locator;
	},
	getQName: function (i) {
		return this[i].qName;
	},
	getURI: function (i) {
		return this[i].uri;
	},
	getValue: function (i) {
		return this[i].value;
	},
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
};

exports.XMLReader = XMLReader;
exports.parseUtils = parseUtils;
exports.parseDoctypeCommentOrCData = parseDoctypeCommentOrCData;


/***/ }),

/***/ 870:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
 *
 * Works with anything that has a `length` property and index access properties,
 * including NodeList.
 *
 * @param {T[] | { length: number; [number]: T }} list
 * @param {function (item: T, index: number, list:T[]):boolean} predicate
 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac
 * Allows injecting a custom implementation in tests (`Array.prototype` by default).
 * @returns {T | undefined}
 * @template {unknown} T
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
 */
function find(list, predicate, ac) {
	if (ac === undefined) {
		ac = Array.prototype;
	}
	if (list && typeof ac.find === 'function') {
		return ac.find.call(list, predicate);
	}
	for (var i = 0; i < list.length; i++) {
		if (hasOwn(list, i)) {
			var item = list[i];
			if (predicate.call(undefined, item, i, list)) {
				return item;
			}
		}
	}
}

/**
 * "Shallow freezes" an object to render it immutable.
 * Uses `Object.freeze` if available,
 * otherwise the immutability is only in the type.
 *
 * Is used to create "enum like" objects.
 *
 * If `Object.getOwnPropertyDescriptors` is available,
 * a new object with all properties of object but without any prototype is created and returned
 * after freezing it.
 *
 * @param {T} object
 * The object to freeze.
 * @param {Pick<ObjectConstructor, 'create' | 'freeze' | 'getOwnPropertyDescriptors'>} [oc=Object]
 * `Object` by default,
 * allows to inject custom object constructor for tests.
 * @returns {Readonly<T>}
 * @template {Object} T
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 * @prettierignore
 */
function freeze(object, oc) {
	if (oc === undefined) {
		oc = Object;
	}
	if (oc && typeof oc.getOwnPropertyDescriptors === 'function') {
		object = oc.create(null, oc.getOwnPropertyDescriptors(object));
	}
	return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;
}

/**
 * Implementation for `Object.hasOwn` but ES5 compatible.
 *
 * @param {any} object
 * @param {string | number} key
 * @returns {boolean}
 */
function hasOwn(object, key) {
	return Object.prototype.hasOwnProperty.call(object, key);
}

/**
 * Since xmldom can not rely on `Object.assign`,
 * it uses/provides a simplified version that is sufficient for its needs.
 *
 * @param {Object} target
 * @param {Object | null | undefined} source
 * @returns {Object}
 * The target with the merged/overridden properties.
 * @throws {TypeError}
 * If target is not an object.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
 */
function assign(target, source) {
	if (target === null || typeof target !== 'object') {
		throw new TypeError('target is not an object');
	}
	for (var key in source) {
		if (hasOwn(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
}

/**
 * A number of attributes are boolean attributes.
 * The presence of a boolean attribute on an element represents the `true` value,
 * and the absence of the attribute represents the `false` value.
 *
 * If the attribute is present, its value must either be the empty string, or a value that is
 * an ASCII case-insensitive match for the attribute's canonical name,
 * with no leading or trailing whitespace.
 *
 * Note: The values `"true"` and `"false"` are not allowed on boolean attributes.
 * To represent a `false` value, the attribute has to be omitted altogether.
 *
 * @see https://html.spec.whatwg.org/#boolean-attributes
 * @see https://html.spec.whatwg.org/#attributes-3
 */
var HTML_BOOLEAN_ATTRIBUTES = freeze({
	allowfullscreen: true,
	async: true,
	autofocus: true,
	autoplay: true,
	checked: true,
	controls: true,
	default: true,
	defer: true,
	disabled: true,
	formnovalidate: true,
	hidden: true,
	ismap: true,
	itemscope: true,
	loop: true,
	multiple: true,
	muted: true,
	nomodule: true,
	novalidate: true,
	open: true,
	playsinline: true,
	readonly: true,
	required: true,
	reversed: true,
	selected: true,
});

/**
 * Check if `name` is matching one of the HTML boolean attribute names.
 * This method doesn't check if such attributes are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} name
 * @returns {boolean}
 * @see {@link HTML_BOOLEAN_ATTRIBUTES}
 * @see https://html.spec.whatwg.org/#boolean-attributes
 * @see https://html.spec.whatwg.org/#attributes-3
 */
function isHTMLBooleanAttribute(name) {
	return hasOwn(HTML_BOOLEAN_ATTRIBUTES, name.toLowerCase());
}

/**
 * Void elements only have a start tag; end tags must not be specified for void elements.
 * These elements should be written as self-closing like this: `<area />`.
 * This should not be confused with optional tags that HTML allows to omit the end tag for
 * (like `li`, `tr` and others), which can have content after them,
 * so they can not be written as self-closing.
 * xmldom does not have any logic for optional end tags cases,
 * and will report them as a warning.
 * Content that would go into the unopened element,
 * will instead be added as a sibling text node.
 *
 * @type {Readonly<{
 * 	area: boolean;
 * 	col: boolean;
 * 	img: boolean;
 * 	wbr: boolean;
 * 	link: boolean;
 * 	hr: boolean;
 * 	source: boolean;
 * 	br: boolean;
 * 	input: boolean;
 * 	param: boolean;
 * 	meta: boolean;
 * 	embed: boolean;
 * 	track: boolean;
 * 	base: boolean;
 * }>}
 * @see https://html.spec.whatwg.org/#void-elements
 * @see https://html.spec.whatwg.org/#optional-tags
 */
var HTML_VOID_ELEMENTS = freeze({
	area: true,
	base: true,
	br: true,
	col: true,
	embed: true,
	hr: true,
	img: true,
	input: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,
});

/**
 * Check if `tagName` is matching one of the HTML void element names.
 * This method doesn't check if such tags are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} tagName
 * @returns {boolean}
 * @see {@link HTML_VOID_ELEMENTS}
 * @see https://html.spec.whatwg.org/#void-elements
 */
function isHTMLVoidElement(tagName) {
	return hasOwn(HTML_VOID_ELEMENTS, tagName.toLowerCase());
}

/**
 * Tag names that are raw text elements according to HTML spec.
 * The value denotes whether they are escapable or not.
 *
 * @see {@link isHTMLEscapableRawTextElement}
 * @see {@link isHTMLRawTextElement}
 * @see https://html.spec.whatwg.org/#raw-text-elements
 * @see https://html.spec.whatwg.org/#escapable-raw-text-elements
 */
var HTML_RAW_TEXT_ELEMENTS = freeze({
	script: false,
	style: false,
	textarea: true,
	title: true,
});

/**
 * Check if `tagName` is matching one of the HTML raw text element names.
 * This method doesn't check if such tags are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} tagName
 * @returns {boolean}
 * @see {@link isHTMLEscapableRawTextElement}
 * @see {@link HTML_RAW_TEXT_ELEMENTS}
 * @see https://html.spec.whatwg.org/#raw-text-elements
 * @see https://html.spec.whatwg.org/#escapable-raw-text-elements
 */
function isHTMLRawTextElement(tagName) {
	var key = tagName.toLowerCase();
	return hasOwn(HTML_RAW_TEXT_ELEMENTS, key) && !HTML_RAW_TEXT_ELEMENTS[key];
}
/**
 * Check if `tagName` is matching one of the HTML escapable raw text element names.
 * This method doesn't check if such tags are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} tagName
 * @returns {boolean}
 * @see {@link isHTMLRawTextElement}
 * @see {@link HTML_RAW_TEXT_ELEMENTS}
 * @see https://html.spec.whatwg.org/#raw-text-elements
 * @see https://html.spec.whatwg.org/#escapable-raw-text-elements
 */
function isHTMLEscapableRawTextElement(tagName) {
	var key = tagName.toLowerCase();
	return hasOwn(HTML_RAW_TEXT_ELEMENTS, key) && HTML_RAW_TEXT_ELEMENTS[key];
}
/**
 * Only returns true if `value` matches MIME_TYPE.HTML, which indicates an HTML document.
 *
 * @param {string} mimeType
 * @returns {mimeType is 'text/html'}
 * @see https://www.iana.org/assignments/media-types/text/html
 * @see https://en.wikipedia.org/wiki/HTML
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
 */
function isHTMLMimeType(mimeType) {
	return mimeType === MIME_TYPE.HTML;
}
/**
 * For both the `text/html` and the `application/xhtml+xml` namespace the spec defines that the
 * HTML namespace is provided as the default.
 *
 * @param {string} mimeType
 * @returns {boolean}
 * @see https://dom.spec.whatwg.org/#dom-document-createelement
 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument
 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
 */
function hasDefaultHTMLNamespace(mimeType) {
	return isHTMLMimeType(mimeType) || mimeType === MIME_TYPE.XML_XHTML_APPLICATION;
}

/**
 * All mime types that are allowed as input to `DOMParser.parseFromString`
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02
 *      MDN
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype
 *      WHATWG HTML Spec
 * @see {@link DOMParser.prototype.parseFromString}
 */
var MIME_TYPE = freeze({
	/**
	 * `text/html`, the only mime type that triggers treating an XML document as HTML.
	 *
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
	 *      WHATWG HTML Spec
	 */
	HTML: 'text/html',

	/**
	 * `application/xml`, the standard mime type for XML documents.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
	 *      registration
	 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_APPLICATION: 'application/xml',

	/**
	 * `text/xml`, an alias for `application/xml`.
	 *
	 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
	 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_TEXT: 'text/xml',

	/**
	 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
	 * but is parsed as an XML document.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
	 *      registration
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
	 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
	 */
	XML_XHTML_APPLICATION: 'application/xhtml+xml',

	/**
	 * `image/svg+xml`,
	 *
	 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
	 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
	 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
	 */
	XML_SVG_IMAGE: 'image/svg+xml',
});
/**
 * @typedef {'application/xhtml+xml' | 'application/xml' | 'image/svg+xml' | 'text/html' | 'text/xml'}
 * MimeType
 */
/**
 * @type {MimeType[]}
 * @private
 * Basically `Object.values`, which is not available in ES5.
 */
var _MIME_TYPES = Object.keys(MIME_TYPE).map(function (key) {
	return MIME_TYPE[key];
});

/**
 * Only returns true if `mimeType` is one of the allowed values for
 * `DOMParser.parseFromString`.
 *
 * @param {string} mimeType
 * @returns {mimeType is 'application/xhtml+xml' | 'application/xml' | 'image/svg+xml' |  'text/html' | 'text/xml'}
 *
 */
function isValidMimeType(mimeType) {
	return _MIME_TYPES.indexOf(mimeType) > -1;
}
/**
 * Namespaces that are used in this code base.
 *
 * @see http://www.w3.org/TR/REC-xml-names
 */
var NAMESPACE = freeze({
	/**
	 * The XHTML namespace.
	 *
	 * @see http://www.w3.org/1999/xhtml
	 */
	HTML: 'http://www.w3.org/1999/xhtml',

	/**
	 * The SVG namespace.
	 *
	 * @see http://www.w3.org/2000/svg
	 */
	SVG: 'http://www.w3.org/2000/svg',

	/**
	 * The `xml:` namespace.
	 *
	 * @see http://www.w3.org/XML/1998/namespace
	 */
	XML: 'http://www.w3.org/XML/1998/namespace',

	/**
	 * The `xmlns:` namespace.
	 *
	 * @see https://www.w3.org/2000/xmlns/
	 */
	XMLNS: 'http://www.w3.org/2000/xmlns/',
});

exports.assign = assign;
exports.find = find;
exports.freeze = freeze;
exports.HTML_BOOLEAN_ATTRIBUTES = HTML_BOOLEAN_ATTRIBUTES;
exports.HTML_RAW_TEXT_ELEMENTS = HTML_RAW_TEXT_ELEMENTS;
exports.HTML_VOID_ELEMENTS = HTML_VOID_ELEMENTS;
exports.hasDefaultHTMLNamespace = hasDefaultHTMLNamespace;
exports.hasOwn = hasOwn;
exports.isHTMLBooleanAttribute = isHTMLBooleanAttribute;
exports.isHTMLRawTextElement = isHTMLRawTextElement;
exports.isHTMLEscapableRawTextElement = isHTMLEscapableRawTextElement;
exports.isHTMLMimeType = isHTMLMimeType;
exports.isHTMLVoidElement = isHTMLVoidElement;
exports.isValidMimeType = isValidMimeType;
exports.MIME_TYPE = MIME_TYPE;
exports.NAMESPACE = NAMESPACE;


/***/ }),

/***/ 999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(){'use strict';var k=this;
function aa(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}function l(a){return"string"==typeof a}function ba(a,b,c){return a.call.apply(a.bind,arguments)}function ca(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}
function da(a,b,c){da=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ba:ca;return da.apply(null,arguments)}function ea(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}
function m(a){var b=n;function c(){}c.prototype=b.prototype;a.G=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.F=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)}};/*

 The MIT License

 Copyright (c) 2007 Cybozu Labs, Inc.
 Copyright (c) 2012 Google Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 IN THE SOFTWARE.
*/
var fa=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")};function q(a,b){return-1!=a.indexOf(b)}function ga(a,b){return a<b?-1:a>b?1:0};var ha=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(l(a))return l(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},r=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=l(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},ia=Array.prototype.filter?function(a,b,c){return Array.prototype.filter.call(a,
b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=l(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var p=g[h];b.call(c,p,h,a)&&(e[f++]=p)}return e},t=Array.prototype.reduce?function(a,b,c,d){d&&(b=da(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;r(a,function(c,g){e=b.call(d,e,c,g,a)});return e},ja=Array.prototype.some?function(a,b,c){return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=l(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;
return!1};function ka(a,b){var c;a:{c=a.length;for(var d=l(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){c=e;break a}c=-1}return 0>c?null:l(a)?a.charAt(c):a[c]}function la(a){return Array.prototype.concat.apply(Array.prototype,arguments)}function ma(a,b,c){return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};var u;a:{var na=k.navigator;if(na){var oa=na.userAgent;if(oa){u=oa;break a}}u=""};var pa=q(u,"Opera")||q(u,"OPR"),v=q(u,"Trident")||q(u,"MSIE"),qa=q(u,"Edge"),ra=q(u,"Gecko")&&!(q(u.toLowerCase(),"webkit")&&!q(u,"Edge"))&&!(q(u,"Trident")||q(u,"MSIE"))&&!q(u,"Edge"),sa=q(u.toLowerCase(),"webkit")&&!q(u,"Edge");function ta(){var a=k.document;return a?a.documentMode:void 0}var ua;
a:{var va="",wa=function(){var a=u;if(ra)return/rv\:([^\);]+)(\)|;)/.exec(a);if(qa)return/Edge\/([\d\.]+)/.exec(a);if(v)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(sa)return/WebKit\/(\S+)/.exec(a);if(pa)return/(?:Version)[ \/]?(\S+)/.exec(a)}();wa&&(va=wa?wa[1]:"");if(v){var xa=ta();if(null!=xa&&xa>parseFloat(va)){ua=String(xa);break a}}ua=va}var ya={};
function za(a){if(!ya[a]){for(var b=0,c=fa(String(ua)).split("."),d=fa(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",h=d[f]||"",p=/(\d*)(\D*)/g,y=/(\d*)(\D*)/g;do{var D=p.exec(g)||["","",""],X=y.exec(h)||["","",""];if(0==D[0].length&&0==X[0].length)break;b=ga(0==D[1].length?0:parseInt(D[1],10),0==X[1].length?0:parseInt(X[1],10))||ga(0==D[2].length,0==X[2].length)||ga(D[2],X[2])}while(0==b)}ya[a]=0<=b}}
var Aa=k.document,Ba=Aa&&v?ta()||("CSS1Compat"==Aa.compatMode?parseInt(ua,10):5):void 0;var w=v&&!(9<=Number(Ba)),Ca=v&&!(8<=Number(Ba));function x(a,b,c,d){this.a=a;this.nodeName=c;this.nodeValue=d;this.nodeType=2;this.parentNode=this.ownerElement=b}function Da(a,b){var c=Ca&&"href"==b.nodeName?a.getAttribute(b.nodeName,2):b.nodeValue;return new x(b,a,b.nodeName,c)};function z(a){var b=null,c=a.nodeType;1==c&&(b=a.textContent,b=void 0==b||null==b?a.innerText:b,b=void 0==b||null==b?"":b);if("string"!=typeof b)if(w&&"title"==a.nodeName.toLowerCase()&&1==c)b=a.text;else if(9==c||1==c){a=9==c?a.documentElement:a.firstChild;for(var c=0,d=[],b="";a;){do 1!=a.nodeType&&(b+=a.nodeValue),w&&"title"==a.nodeName.toLowerCase()&&(b+=a.text),d[c++]=a;while(a=a.firstChild);for(;c&&!(a=d[--c].nextSibling););}}else b=a.nodeValue;return""+b}
function A(a,b,c){if(null===b)return!0;try{if(!a.getAttribute)return!1}catch(d){return!1}Ca&&"class"==b&&(b="className");return null==c?!!a.getAttribute(b):a.getAttribute(b,2)==c}function B(a,b,c,d,e){return(w?Ea:Fa).call(null,a,b,l(c)?c:null,l(d)?d:null,e||new C)}
function Ea(a,b,c,d,e){if(a instanceof E||8==a.b||c&&null===a.b){var f=b.all;if(!f)return e;a=Ga(a);if("*"!=a&&(f=b.getElementsByTagName(a),!f))return e;if(c){for(var g=[],h=0;b=f[h++];)A(b,c,d)&&g.push(b);f=g}for(h=0;b=f[h++];)"*"==a&&"!"==b.tagName||F(e,b);return e}Ha(a,b,c,d,e);return e}
function Fa(a,b,c,d,e){b.getElementsByName&&d&&"name"==c&&!v?(b=b.getElementsByName(d),r(b,function(b){a.a(b)&&F(e,b)})):b.getElementsByClassName&&d&&"class"==c?(b=b.getElementsByClassName(d),r(b,function(b){b.className==d&&a.a(b)&&F(e,b)})):a instanceof G?Ha(a,b,c,d,e):b.getElementsByTagName&&(b=b.getElementsByTagName(a.f()),r(b,function(a){A(a,c,d)&&F(e,a)}));return e}
function Ia(a,b,c,d,e){var f;if((a instanceof E||8==a.b||c&&null===a.b)&&(f=b.childNodes)){var g=Ga(a);if("*"!=g&&(f=ia(f,function(a){return a.tagName&&a.tagName.toLowerCase()==g}),!f))return e;c&&(f=ia(f,function(a){return A(a,c,d)}));r(f,function(a){"*"==g&&("!"==a.tagName||"*"==g&&1!=a.nodeType)||F(e,a)});return e}return Ja(a,b,c,d,e)}function Ja(a,b,c,d,e){for(b=b.firstChild;b;b=b.nextSibling)A(b,c,d)&&a.a(b)&&F(e,b);return e}
function Ha(a,b,c,d,e){for(b=b.firstChild;b;b=b.nextSibling)A(b,c,d)&&a.a(b)&&F(e,b),Ha(a,b,c,d,e)}function Ga(a){if(a instanceof G){if(8==a.b)return"!";if(null===a.b)return"*"}return a.f()};!ra&&!v||v&&9<=Number(Ba)||ra&&za("1.9.1");v&&za("9");function Ka(a,b){if(!a||!b)return!1;if(a.contains&&1==b.nodeType)return a==b||a.contains(b);if("undefined"!=typeof a.compareDocumentPosition)return a==b||!!(a.compareDocumentPosition(b)&16);for(;b&&a!=b;)b=b.parentNode;return b==a}
function La(a,b){if(a==b)return 0;if(a.compareDocumentPosition)return a.compareDocumentPosition(b)&2?1:-1;if(v&&!(9<=Number(Ba))){if(9==a.nodeType)return-1;if(9==b.nodeType)return 1}if("sourceIndex"in a||a.parentNode&&"sourceIndex"in a.parentNode){var c=1==a.nodeType,d=1==b.nodeType;if(c&&d)return a.sourceIndex-b.sourceIndex;var e=a.parentNode,f=b.parentNode;return e==f?Ma(a,b):!c&&Ka(e,b)?-1*Na(a,b):!d&&Ka(f,a)?Na(b,a):(c?a.sourceIndex:e.sourceIndex)-(d?b.sourceIndex:f.sourceIndex)}d=9==a.nodeType?
a:a.ownerDocument||a.document;c=d.createRange();c.selectNode(a);c.collapse(!0);d=d.createRange();d.selectNode(b);d.collapse(!0);return c.compareBoundaryPoints(k.Range.START_TO_END,d)}function Na(a,b){var c=a.parentNode;if(c==b)return-1;for(var d=b;d.parentNode!=c;)d=d.parentNode;return Ma(d,a)}function Ma(a,b){for(var c=b;c=c.previousSibling;)if(c==a)return-1;return 1};function C(){this.b=this.a=null;this.l=0}function Oa(a){this.node=a;this.a=this.b=null}function Pa(a,b){if(!a.a)return b;if(!b.a)return a;for(var c=a.a,d=b.a,e=null,f=null,g=0;c&&d;){var f=c.node,h=d.node;f==h||f instanceof x&&h instanceof x&&f.a==h.a?(f=c,c=c.a,d=d.a):0<La(c.node,d.node)?(f=d,d=d.a):(f=c,c=c.a);(f.b=e)?e.a=f:a.a=f;e=f;g++}for(f=c||d;f;)f.b=e,e=e.a=f,g++,f=f.a;a.b=e;a.l=g;return a}function Qa(a,b){var c=new Oa(b);c.a=a.a;a.b?a.a.b=c:a.a=a.b=c;a.a=c;a.l++}
function F(a,b){var c=new Oa(b);c.b=a.b;a.a?a.b.a=c:a.a=a.b=c;a.b=c;a.l++}function Ra(a){return(a=a.a)?a.node:null}function Sa(a){return(a=Ra(a))?z(a):""}function H(a,b){return new Ta(a,!!b)}function Ta(a,b){this.f=a;this.b=(this.c=b)?a.b:a.a;this.a=null}function I(a){var b=a.b;if(null==b)return null;var c=a.a=b;a.b=a.c?b.b:b.a;return c.node};function n(a){this.i=a;this.b=this.g=!1;this.f=null}function J(a){return"\n  "+a.toString().split("\n").join("\n  ")}function Ua(a,b){a.g=b}function Va(a,b){a.b=b}function K(a,b){var c=a.a(b);return c instanceof C?+Sa(c):+c}function L(a,b){var c=a.a(b);return c instanceof C?Sa(c):""+c}function M(a,b){var c=a.a(b);return c instanceof C?!!c.l:!!c};function N(a,b,c){n.call(this,a.i);this.c=a;this.h=b;this.o=c;this.g=b.g||c.g;this.b=b.b||c.b;this.c==Wa&&(c.b||c.g||4==c.i||0==c.i||!b.f?b.b||b.g||4==b.i||0==b.i||!c.f||(this.f={name:c.f.name,s:b}):this.f={name:b.f.name,s:c})}m(N);
function O(a,b,c,d,e){b=b.a(d);c=c.a(d);var f;if(b instanceof C&&c instanceof C){b=H(b);for(d=I(b);d;d=I(b))for(e=H(c),f=I(e);f;f=I(e))if(a(z(d),z(f)))return!0;return!1}if(b instanceof C||c instanceof C){b instanceof C?(e=b,d=c):(e=c,d=b);f=H(e);for(var g=typeof d,h=I(f);h;h=I(f)){switch(g){case "number":h=+z(h);break;case "boolean":h=!!z(h);break;case "string":h=z(h);break;default:throw Error("Illegal primitive type for comparison.");}if(e==b&&a(h,d)||e==c&&a(d,h))return!0}return!1}return e?"boolean"==
typeof b||"boolean"==typeof c?a(!!b,!!c):"number"==typeof b||"number"==typeof c?a(+b,+c):a(b,c):a(+b,+c)}N.prototype.a=function(a){return this.c.m(this.h,this.o,a)};N.prototype.toString=function(){var a="Binary Expression: "+this.c,a=a+J(this.h);return a+=J(this.o)};function Xa(a,b,c,d){this.a=a;this.w=b;this.i=c;this.m=d}Xa.prototype.toString=function(){return this.a};var Ya={};
function P(a,b,c,d){if(Ya.hasOwnProperty(a))throw Error("Binary operator already created: "+a);a=new Xa(a,b,c,d);return Ya[a.toString()]=a}P("div",6,1,function(a,b,c){return K(a,c)/K(b,c)});P("mod",6,1,function(a,b,c){return K(a,c)%K(b,c)});P("*",6,1,function(a,b,c){return K(a,c)*K(b,c)});P("+",5,1,function(a,b,c){return K(a,c)+K(b,c)});P("-",5,1,function(a,b,c){return K(a,c)-K(b,c)});P("<",4,2,function(a,b,c){return O(function(a,b){return a<b},a,b,c)});
P(">",4,2,function(a,b,c){return O(function(a,b){return a>b},a,b,c)});P("<=",4,2,function(a,b,c){return O(function(a,b){return a<=b},a,b,c)});P(">=",4,2,function(a,b,c){return O(function(a,b){return a>=b},a,b,c)});var Wa=P("=",3,2,function(a,b,c){return O(function(a,b){return a==b},a,b,c,!0)});P("!=",3,2,function(a,b,c){return O(function(a,b){return a!=b},a,b,c,!0)});P("and",2,2,function(a,b,c){return M(a,c)&&M(b,c)});P("or",1,2,function(a,b,c){return M(a,c)||M(b,c)});function Q(a,b,c){this.a=a;this.b=b||1;this.f=c||1};function Za(a,b){if(b.a.length&&4!=a.i)throw Error("Primary expression must evaluate to nodeset if filter has predicate(s).");n.call(this,a.i);this.c=a;this.h=b;this.g=a.g;this.b=a.b}m(Za);Za.prototype.a=function(a){a=this.c.a(a);return $a(this.h,a)};Za.prototype.toString=function(){var a;a="Filter:"+J(this.c);return a+=J(this.h)};function ab(a,b){if(b.length<a.A)throw Error("Function "+a.j+" expects at least"+a.A+" arguments, "+b.length+" given");if(null!==a.v&&b.length>a.v)throw Error("Function "+a.j+" expects at most "+a.v+" arguments, "+b.length+" given");a.B&&r(b,function(b,d){if(4!=b.i)throw Error("Argument "+d+" to function "+a.j+" is not of type Nodeset: "+b);});n.call(this,a.i);this.h=a;this.c=b;Ua(this,a.g||ja(b,function(a){return a.g}));Va(this,a.D&&!b.length||a.C&&!!b.length||ja(b,function(a){return a.b}))}m(ab);
ab.prototype.a=function(a){return this.h.m.apply(null,la(a,this.c))};ab.prototype.toString=function(){var a="Function: "+this.h;if(this.c.length)var b=t(this.c,function(a,b){return a+J(b)},"Arguments:"),a=a+J(b);return a};function bb(a,b,c,d,e,f,g,h,p){this.j=a;this.i=b;this.g=c;this.D=d;this.C=e;this.m=f;this.A=g;this.v=void 0!==h?h:g;this.B=!!p}bb.prototype.toString=function(){return this.j};var cb={};
function R(a,b,c,d,e,f,g,h){if(cb.hasOwnProperty(a))throw Error("Function already created: "+a+".");cb[a]=new bb(a,b,c,d,!1,e,f,g,h)}R("boolean",2,!1,!1,function(a,b){return M(b,a)},1);R("ceiling",1,!1,!1,function(a,b){return Math.ceil(K(b,a))},1);R("concat",3,!1,!1,function(a,b){return t(ma(arguments,1),function(b,d){return b+L(d,a)},"")},2,null);R("contains",2,!1,!1,function(a,b,c){return q(L(b,a),L(c,a))},2);R("count",1,!1,!1,function(a,b){return b.a(a).l},1,1,!0);
R("false",2,!1,!1,function(){return!1},0);R("floor",1,!1,!1,function(a,b){return Math.floor(K(b,a))},1);R("id",4,!1,!1,function(a,b){function c(a){if(w){var b=e.all[a];if(b){if(b.nodeType&&a==b.id)return b;if(b.length)return ka(b,function(b){return a==b.id})}return null}return e.getElementById(a)}var d=a.a,e=9==d.nodeType?d:d.ownerDocument,d=L(b,a).split(/\s+/),f=[];r(d,function(a){a=c(a);!a||0<=ha(f,a)||f.push(a)});f.sort(La);var g=new C;r(f,function(a){F(g,a)});return g},1);
R("lang",2,!1,!1,function(){return!1},1);R("last",1,!0,!1,function(a){if(1!=arguments.length)throw Error("Function last expects ()");return a.f},0);R("local-name",3,!1,!0,function(a,b){var c=b?Ra(b.a(a)):a.a;return c?c.localName||c.nodeName.toLowerCase():""},0,1,!0);R("name",3,!1,!0,function(a,b){var c=b?Ra(b.a(a)):a.a;return c?c.nodeName.toLowerCase():""},0,1,!0);R("namespace-uri",3,!0,!1,function(){return""},0,1,!0);
R("normalize-space",3,!1,!0,function(a,b){return(b?L(b,a):z(a.a)).replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")},0,1);R("not",2,!1,!1,function(a,b){return!M(b,a)},1);R("number",1,!1,!0,function(a,b){return b?K(b,a):+z(a.a)},0,1);R("position",1,!0,!1,function(a){return a.b},0);R("round",1,!1,!1,function(a,b){return Math.round(K(b,a))},1);R("starts-with",2,!1,!1,function(a,b,c){b=L(b,a);a=L(c,a);return 0==b.lastIndexOf(a,0)},2);R("string",3,!1,!0,function(a,b){return b?L(b,a):z(a.a)},0,1);
R("string-length",1,!1,!0,function(a,b){return(b?L(b,a):z(a.a)).length},0,1);R("substring",3,!1,!1,function(a,b,c,d){c=K(c,a);if(isNaN(c)||Infinity==c||-Infinity==c)return"";d=d?K(d,a):Infinity;if(isNaN(d)||-Infinity===d)return"";c=Math.round(c)-1;var e=Math.max(c,0);a=L(b,a);return Infinity==d?a.substring(e):a.substring(e,c+Math.round(d))},2,3);R("substring-after",3,!1,!1,function(a,b,c){b=L(b,a);a=L(c,a);c=b.indexOf(a);return-1==c?"":b.substring(c+a.length)},2);
R("substring-before",3,!1,!1,function(a,b,c){b=L(b,a);a=L(c,a);a=b.indexOf(a);return-1==a?"":b.substring(0,a)},2);R("sum",1,!1,!1,function(a,b){for(var c=H(b.a(a)),d=0,e=I(c);e;e=I(c))d+=+z(e);return d},1,1,!0);R("translate",3,!1,!1,function(a,b,c,d){b=L(b,a);c=L(c,a);var e=L(d,a);a={};for(d=0;d<c.length;d++){var f=c.charAt(d);f in a||(a[f]=e.charAt(d))}c="";for(d=0;d<b.length;d++)f=b.charAt(d),c+=f in a?a[f]:f;return c},3);R("true",2,!1,!1,function(){return!0},0);function G(a,b){this.h=a;this.c=void 0!==b?b:null;this.b=null;switch(a){case "comment":this.b=8;break;case "text":this.b=3;break;case "processing-instruction":this.b=7;break;case "node":break;default:throw Error("Unexpected argument");}}function db(a){return"comment"==a||"text"==a||"processing-instruction"==a||"node"==a}G.prototype.a=function(a){return null===this.b||this.b==a.nodeType};G.prototype.f=function(){return this.h};
G.prototype.toString=function(){var a="Kind Test: "+this.h;null===this.c||(a+=J(this.c));return a};function eb(a){this.b=a;this.a=0}function fb(a){a=a.match(gb);for(var b=0;b<a.length;b++)hb.test(a[b])&&a.splice(b,1);return new eb(a)}var gb=/\$?(?:(?![0-9-\.])(?:\*|[\w-\.]+):)?(?![0-9-\.])(?:\*|[\w-\.]+)|\/\/|\.\.|::|\d+(?:\.\d*)?|\.\d+|"[^"]*"|'[^']*'|[!<>]=|\s+|./g,hb=/^\s/;function S(a,b){return a.b[a.a+(b||0)]}function T(a){return a.b[a.a++]}function ib(a){return a.b.length<=a.a};function jb(a){n.call(this,3);this.c=a.substring(1,a.length-1)}m(jb);jb.prototype.a=function(){return this.c};jb.prototype.toString=function(){return"Literal: "+this.c};function E(a,b){this.j=a.toLowerCase();var c;c="*"==this.j?"*":"http://www.w3.org/1999/xhtml";this.c=b?b.toLowerCase():c}E.prototype.a=function(a){var b=a.nodeType;if(1!=b&&2!=b)return!1;b=void 0!==a.localName?a.localName:a.nodeName;return"*"!=this.j&&this.j!=b.toLowerCase()?!1:"*"==this.c?!0:this.c==(a.namespaceURI?a.namespaceURI.toLowerCase():"http://www.w3.org/1999/xhtml")};E.prototype.f=function(){return this.j};
E.prototype.toString=function(){return"Name Test: "+("http://www.w3.org/1999/xhtml"==this.c?"":this.c+":")+this.j};function kb(a,b){n.call(this,a.i);this.h=a;this.c=b;this.g=a.g;this.b=a.b;if(1==this.c.length){var c=this.c[0];c.u||c.c!=lb||(c=c.o,"*"!=c.f()&&(this.f={name:c.f(),s:null}))}}m(kb);function mb(){n.call(this,4)}m(mb);mb.prototype.a=function(a){var b=new C;a=a.a;9==a.nodeType?F(b,a):F(b,a.ownerDocument);return b};mb.prototype.toString=function(){return"Root Helper Expression"};function nb(){n.call(this,4)}m(nb);nb.prototype.a=function(a){var b=new C;F(b,a.a);return b};nb.prototype.toString=function(){return"Context Helper Expression"};
function ob(a){return"/"==a||"//"==a}kb.prototype.a=function(a){var b=this.h.a(a);if(!(b instanceof C))throw Error("Filter expression must evaluate to nodeset.");a=this.c;for(var c=0,d=a.length;c<d&&b.l;c++){var e=a[c],f=H(b,e.c.a),g;if(e.g||e.c!=pb)if(e.g||e.c!=qb)for(g=I(f),b=e.a(new Q(g));null!=(g=I(f));)g=e.a(new Q(g)),b=Pa(b,g);else g=I(f),b=e.a(new Q(g));else{for(g=I(f);(b=I(f))&&(!g.contains||g.contains(b))&&b.compareDocumentPosition(g)&8;g=b);b=e.a(new Q(g))}}return b};
kb.prototype.toString=function(){var a;a="Path Expression:"+J(this.h);if(this.c.length){var b=t(this.c,function(a,b){return a+J(b)},"Steps:");a+=J(b)}return a};function rb(a){n.call(this,4);this.c=a;Ua(this,ja(this.c,function(a){return a.g}));Va(this,ja(this.c,function(a){return a.b}))}m(rb);rb.prototype.a=function(a){var b=new C;r(this.c,function(c){c=c.a(a);if(!(c instanceof C))throw Error("Path expression must evaluate to NodeSet.");b=Pa(b,c)});return b};rb.prototype.toString=function(){return t(this.c,function(a,b){return a+J(b)},"Union Expression:")};function sb(a,b){this.a=a;this.b=!!b}
function $a(a,b,c){for(c=c||0;c<a.a.length;c++)for(var d=a.a[c],e=H(b),f=b.l,g,h=0;g=I(e);h++){var p=a.b?f-h:h+1;g=d.a(new Q(g,p,f));if("number"==typeof g)p=p==g;else if("string"==typeof g||"boolean"==typeof g)p=!!g;else if(g instanceof C)p=0<g.l;else throw Error("Predicate.evaluate returned an unexpected type.");if(!p){p=e;g=p.f;var y=p.a;if(!y)throw Error("Next must be called at least once before remove.");var D=y.b,y=y.a;D?D.a=y:g.a=y;y?y.b=D:g.b=D;g.l--;p.a=null}}return b}
sb.prototype.toString=function(){return t(this.a,function(a,b){return a+J(b)},"Predicates:")};function U(a,b,c,d){n.call(this,4);this.c=a;this.o=b;this.h=c||new sb([]);this.u=!!d;b=this.h;b=0<b.a.length?b.a[0].f:null;a.b&&b&&(a=b.name,a=w?a.toLowerCase():a,this.f={name:a,s:b.s});a:{a=this.h;for(b=0;b<a.a.length;b++)if(c=a.a[b],c.g||1==c.i||0==c.i){a=!0;break a}a=!1}this.g=a}m(U);
U.prototype.a=function(a){var b=a.a,c=null,c=this.f,d=null,e=null,f=0;c&&(d=c.name,e=c.s?L(c.s,a):null,f=1);if(this.u)if(this.g||this.c!=tb)if(a=H((new U(ub,new G("node"))).a(a)),b=I(a))for(c=this.m(b,d,e,f);null!=(b=I(a));)c=Pa(c,this.m(b,d,e,f));else c=new C;else c=B(this.o,b,d,e),c=$a(this.h,c,f);else c=this.m(a.a,d,e,f);return c};U.prototype.m=function(a,b,c,d){a=this.c.f(this.o,a,b,c);return a=$a(this.h,a,d)};
U.prototype.toString=function(){var a;a="Step:"+J("Operator: "+(this.u?"//":"/"));this.c.j&&(a+=J("Axis: "+this.c));a+=J(this.o);if(this.h.a.length){var b=t(this.h.a,function(a,b){return a+J(b)},"Predicates:");a+=J(b)}return a};function vb(a,b,c,d){this.j=a;this.f=b;this.a=c;this.b=d}vb.prototype.toString=function(){return this.j};var wb={};function V(a,b,c,d){if(wb.hasOwnProperty(a))throw Error("Axis already created: "+a);b=new vb(a,b,c,!!d);return wb[a]=b}
V("ancestor",function(a,b){for(var c=new C,d=b;d=d.parentNode;)a.a(d)&&Qa(c,d);return c},!0);V("ancestor-or-self",function(a,b){var c=new C,d=b;do a.a(d)&&Qa(c,d);while(d=d.parentNode);return c},!0);
var lb=V("attribute",function(a,b){var c=new C,d=a.f();if("style"==d&&w&&b.style)return F(c,new x(b.style,b,"style",b.style.cssText)),c;var e=b.attributes;if(e)if(a instanceof G&&null===a.b||"*"==d)for(var d=0,f;f=e[d];d++)w?f.nodeValue&&F(c,Da(b,f)):F(c,f);else(f=e.getNamedItem(d))&&(w?f.nodeValue&&F(c,Da(b,f)):F(c,f));return c},!1),tb=V("child",function(a,b,c,d,e){return(w?Ia:Ja).call(null,a,b,l(c)?c:null,l(d)?d:null,e||new C)},!1,!0);V("descendant",B,!1,!0);
var ub=V("descendant-or-self",function(a,b,c,d){var e=new C;A(b,c,d)&&a.a(b)&&F(e,b);return B(a,b,c,d,e)},!1,!0),pb=V("following",function(a,b,c,d){var e=new C;do for(var f=b;f=f.nextSibling;)A(f,c,d)&&a.a(f)&&F(e,f),e=B(a,f,c,d,e);while(b=b.parentNode);return e},!1,!0);V("following-sibling",function(a,b){for(var c=new C,d=b;d=d.nextSibling;)a.a(d)&&F(c,d);return c},!1);V("namespace",function(){return new C},!1);
var xb=V("parent",function(a,b){var c=new C;if(9==b.nodeType)return c;if(2==b.nodeType)return F(c,b.ownerElement),c;var d=b.parentNode;a.a(d)&&F(c,d);return c},!1),qb=V("preceding",function(a,b,c,d){var e=new C,f=[];do f.unshift(b);while(b=b.parentNode);for(var g=1,h=f.length;g<h;g++){var p=[];for(b=f[g];b=b.previousSibling;)p.unshift(b);for(var y=0,D=p.length;y<D;y++)b=p[y],A(b,c,d)&&a.a(b)&&F(e,b),e=B(a,b,c,d,e)}return e},!0,!0);
V("preceding-sibling",function(a,b){for(var c=new C,d=b;d=d.previousSibling;)a.a(d)&&Qa(c,d);return c},!0);var yb=V("self",function(a,b){var c=new C;a.a(b)&&F(c,b);return c},!1);function zb(a){n.call(this,1);this.c=a;this.g=a.g;this.b=a.b}m(zb);zb.prototype.a=function(a){return-K(this.c,a)};zb.prototype.toString=function(){return"Unary Expression: -"+J(this.c)};function Ab(a){n.call(this,1);this.c=a}m(Ab);Ab.prototype.a=function(){return this.c};Ab.prototype.toString=function(){return"Number: "+this.c};function Bb(a,b){this.a=a;this.b=b}function Cb(a){for(var b,c=[];;){W(a,"Missing right hand side of binary expression.");b=Db(a);var d=T(a.a);if(!d)break;var e=(d=Ya[d]||null)&&d.w;if(!e){a.a.a--;break}for(;c.length&&e<=c[c.length-1].w;)b=new N(c.pop(),c.pop(),b);c.push(b,d)}for(;c.length;)b=new N(c.pop(),c.pop(),b);return b}function W(a,b){if(ib(a.a))throw Error(b);}function Eb(a,b){var c=T(a.a);if(c!=b)throw Error("Bad token, expected: "+b+" got: "+c);}
function Fb(a){a=T(a.a);if(")"!=a)throw Error("Bad token: "+a);}function Gb(a){a=T(a.a);if(2>a.length)throw Error("Unclosed literal string");return new jb(a)}
function Hb(a){var b,c=[],d;if(ob(S(a.a))){b=T(a.a);d=S(a.a);if("/"==b&&(ib(a.a)||"."!=d&&".."!=d&&"@"!=d&&"*"!=d&&!/(?![0-9])[\w]/.test(d)))return new mb;d=new mb;W(a,"Missing next location step.");b=Ib(a,b);c.push(b)}else{a:{b=S(a.a);d=b.charAt(0);switch(d){case "$":throw Error("Variable reference not allowed in HTML XPath");case "(":T(a.a);b=Cb(a);W(a,'unclosed "("');Eb(a,")");break;case '"':case "'":b=Gb(a);break;default:if(isNaN(+b))if(!db(b)&&/(?![0-9])[\w]/.test(d)&&"("==S(a.a,1)){b=T(a.a);
b=cb[b]||null;T(a.a);for(d=[];")"!=S(a.a);){W(a,"Missing function argument list.");d.push(Cb(a));if(","!=S(a.a))break;T(a.a)}W(a,"Unclosed function argument list.");Fb(a);b=new ab(b,d)}else{b=null;break a}else b=new Ab(+T(a.a))}"["==S(a.a)&&(d=new sb(Jb(a)),b=new Za(b,d))}if(b)if(ob(S(a.a)))d=b;else return b;else b=Ib(a,"/"),d=new nb,c.push(b)}for(;ob(S(a.a));)b=T(a.a),W(a,"Missing next location step."),b=Ib(a,b),c.push(b);return new kb(d,c)}
function Ib(a,b){var c,d,e;if("/"!=b&&"//"!=b)throw Error('Step op should be "/" or "//"');if("."==S(a.a))return d=new U(yb,new G("node")),T(a.a),d;if(".."==S(a.a))return d=new U(xb,new G("node")),T(a.a),d;var f;if("@"==S(a.a))f=lb,T(a.a),W(a,"Missing attribute name");else if("::"==S(a.a,1)){if(!/(?![0-9])[\w]/.test(S(a.a).charAt(0)))throw Error("Bad token: "+T(a.a));c=T(a.a);f=wb[c]||null;if(!f)throw Error("No axis with name: "+c);T(a.a);W(a,"Missing node name")}else f=tb;c=S(a.a);if(/(?![0-9])[\w\*]/.test(c.charAt(0)))if("("==
S(a.a,1)){if(!db(c))throw Error("Invalid node type: "+c);c=T(a.a);if(!db(c))throw Error("Invalid type name: "+c);Eb(a,"(");W(a,"Bad nodetype");e=S(a.a).charAt(0);var g=null;if('"'==e||"'"==e)g=Gb(a);W(a,"Bad nodetype");Fb(a);c=new G(c,g)}else if(c=T(a.a),e=c.indexOf(":"),-1==e)c=new E(c);else{var g=c.substring(0,e),h;if("*"==g)h="*";else if(h=a.b(g),!h)throw Error("Namespace prefix not declared: "+g);c=c.substr(e+1);c=new E(c,h)}else throw Error("Bad token: "+T(a.a));e=new sb(Jb(a),f.a);return d||
new U(f,c,e,"//"==b)}function Jb(a){for(var b=[];"["==S(a.a);){T(a.a);W(a,"Missing predicate expression.");var c=Cb(a);b.push(c);W(a,"Unclosed predicate expression.");Eb(a,"]")}return b}function Db(a){if("-"==S(a.a))return T(a.a),new zb(Db(a));var b=Hb(a);if("|"!=S(a.a))a=b;else{for(b=[b];"|"==T(a.a);)W(a,"Missing next union location path."),b.push(Hb(a));a.a.a--;a=new rb(b)}return a};function Kb(a){switch(a.nodeType){case 1:return ea(Lb,a);case 9:return Kb(a.documentElement);case 11:case 10:case 6:case 12:return Mb;default:return a.parentNode?Kb(a.parentNode):Mb}}function Mb(){return null}function Lb(a,b){if(a.prefix==b)return a.namespaceURI||"http://www.w3.org/1999/xhtml";var c=a.getAttributeNode("xmlns:"+b);return c&&c.specified?c.value||null:a.parentNode&&9!=a.parentNode.nodeType?Lb(a.parentNode,b):null};function Nb(a,b){if(!a.length)throw Error("Empty XPath expression.");var c=fb(a);if(ib(c))throw Error("Invalid XPath expression.");b?"function"==aa(b)||(b=da(b.lookupNamespaceURI,b)):b=function(){return null};var d=Cb(new Bb(c,b));if(!ib(c))throw Error("Bad token: "+T(c));this.evaluate=function(a,b){var c=d.a(new Q(a));return new Y(c,b)}}
function Y(a,b){if(0==b)if(a instanceof C)b=4;else if("string"==typeof a)b=2;else if("number"==typeof a)b=1;else if("boolean"==typeof a)b=3;else throw Error("Unexpected evaluation result.");if(2!=b&&1!=b&&3!=b&&!(a instanceof C))throw Error("value could not be converted to the specified type");this.resultType=b;var c;switch(b){case 2:this.stringValue=a instanceof C?Sa(a):""+a;break;case 1:this.numberValue=a instanceof C?+Sa(a):+a;break;case 3:this.booleanValue=a instanceof C?0<a.l:!!a;break;case 4:case 5:case 6:case 7:var d=
H(a);c=[];for(var e=I(d);e;e=I(d))c.push(e instanceof x?e.a:e);this.snapshotLength=a.l;this.invalidIteratorState=!1;break;case 8:case 9:d=Ra(a);this.singleNodeValue=d instanceof x?d.a:d;break;default:throw Error("Unknown XPathResult type.");}var f=0;this.iterateNext=function(){if(4!=b&&5!=b)throw Error("iterateNext called with wrong result type");return f>=c.length?null:c[f++]};this.snapshotItem=function(a){if(6!=b&&7!=b)throw Error("snapshotItem called with wrong result type");return a>=c.length||
0>a?null:c[a]}}Y.ANY_TYPE=0;Y.NUMBER_TYPE=1;Y.STRING_TYPE=2;Y.BOOLEAN_TYPE=3;Y.UNORDERED_NODE_ITERATOR_TYPE=4;Y.ORDERED_NODE_ITERATOR_TYPE=5;Y.UNORDERED_NODE_SNAPSHOT_TYPE=6;Y.ORDERED_NODE_SNAPSHOT_TYPE=7;Y.ANY_UNORDERED_NODE_TYPE=8;Y.FIRST_ORDERED_NODE_TYPE=9;function Ob(a){this.lookupNamespaceURI=Kb(a)}
function Pb(a,b){var c=a||k,d=c.Document&&c.Document.prototype||c.document;if(!d.evaluate||b)c.XPathResult=Y,d.evaluate=function(a,b,c,d){return(new Nb(a,c)).evaluate(b,d)},d.createExpression=function(a,b){return new Nb(a,b)},d.createNSResolver=function(a){return new Ob(a)}}var Qb=["wgxpath","install"],Z=k;Qb[0]in Z||!Z.execScript||Z.execScript("var "+Qb[0]);for(var Rb;Qb.length&&(Rb=Qb.shift());)Qb.length||void 0===Pb?Z[Rb]?Z=Z[Rb]:Z=Z[Rb]={}:Z[Rb]=Pb;module.exports.install=Pb;module.exports.XPathResultType={ANY_TYPE:0,NUMBER_TYPE:1,STRING_TYPE:2,BOOLEAN_TYPE:3,UNORDERED_NODE_ITERATOR_TYPE:4,ORDERED_NODE_ITERATOR_TYPE:5,UNORDERED_NODE_SNAPSHOT_TYPE:6,ORDERED_NODE_SNAPSHOT_TYPE:7,ANY_UNORDERED_NODE_TYPE:8,FIRST_ORDERED_NODE_TYPE:9};}).call(__webpack_require__.g)


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// NAMESPACE OBJECT: ./mjs/components/global.js
var global_namespaceObject = {};
__webpack_require__.r(global_namespaceObject);
__webpack_require__.d(global_namespaceObject, {
  GLOBAL: () => (GLOBAL),
  MathJax: () => (global_MathJax),
  combineConfig: () => (combineConfig),
  combineDefaults: () => (combineDefaults),
  combineWithMathJax: () => (combineWithMathJax),
  isObject: () => (isObject)
});

// NAMESPACE OBJECT: ./mjs/util/context.js
var context_namespaceObject = {};
__webpack_require__.r(context_namespaceObject);
__webpack_require__.d(context_namespaceObject, {
  context: () => (context),
  hasWindow: () => (hasWindow)
});

// NAMESPACE OBJECT: ./mjs/components/package.js
var package_namespaceObject = {};
__webpack_require__.r(package_namespaceObject);
__webpack_require__.d(package_namespaceObject, {
  Package: () => (Package),
  PackageError: () => (PackageError)
});

// NAMESPACE OBJECT: ./mjs/util/PrioritizedList.js
var PrioritizedList_namespaceObject = {};
__webpack_require__.r(PrioritizedList_namespaceObject);
__webpack_require__.d(PrioritizedList_namespaceObject, {
  PrioritizedList: () => (PrioritizedList)
});

// NAMESPACE OBJECT: ./mjs/util/FunctionList.js
var FunctionList_namespaceObject = {};
__webpack_require__.r(FunctionList_namespaceObject);
__webpack_require__.d(FunctionList_namespaceObject, {
  FunctionList: () => (FunctionList)
});

// NAMESPACE OBJECT: ./mjs/components/loader.js
var loader_namespaceObject = {};
__webpack_require__.r(loader_namespaceObject);
__webpack_require__.d(loader_namespaceObject, {
  CONFIG: () => (CONFIG),
  Loader: () => (Loader),
  MathJax: () => (loader_MathJax),
  PathFilters: () => (PathFilters)
});

// NAMESPACE OBJECT: ./mjs/util/Options.js
var Options_namespaceObject = {};
__webpack_require__.r(Options_namespaceObject);
__webpack_require__.d(Options_namespaceObject, {
  APPEND: () => (APPEND),
  Expandable: () => (Expandable),
  OPTIONS: () => (OPTIONS),
  REMOVE: () => (REMOVE),
  copy: () => (copy),
  defaultOptions: () => (defaultOptions),
  expandable: () => (expandable),
  insert: () => (insert),
  isObject: () => (Options_isObject),
  keys: () => (keys),
  lookup: () => (lookup),
  makeArray: () => (makeArray),
  selectOptions: () => (selectOptions),
  selectOptionsFromKeys: () => (selectOptionsFromKeys),
  separateOptions: () => (separateOptions),
  userOptions: () => (userOptions)
});

// NAMESPACE OBJECT: ./mjs/components/startup.js
var startup_namespaceObject = {};
__webpack_require__.r(startup_namespaceObject);
__webpack_require__.d(startup_namespaceObject, {
  CONFIG: () => (startup_CONFIG),
  MathJax: () => (startup_MathJax),
  Startup: () => (Startup)
});

// NAMESPACE OBJECT: ./mjs/core/DOMAdaptor.js
var DOMAdaptor_namespaceObject = {};
__webpack_require__.r(DOMAdaptor_namespaceObject);
__webpack_require__.d(DOMAdaptor_namespaceObject, {
  AbstractDOMAdaptor: () => (AbstractDOMAdaptor)
});

// NAMESPACE OBJECT: ./mjs/adaptors/HTMLAdaptor.js
var HTMLAdaptor_namespaceObject = {};
__webpack_require__.r(HTMLAdaptor_namespaceObject);
__webpack_require__.d(HTMLAdaptor_namespaceObject, {
  HTMLAdaptor: () => (HTMLAdaptor)
});

// NAMESPACE OBJECT: ./mjs/adaptors/browserAdaptor.js
var browserAdaptor_namespaceObject = {};
__webpack_require__.r(browserAdaptor_namespaceObject);
__webpack_require__.d(browserAdaptor_namespaceObject, {
  browserAdaptor: () => (browserAdaptor)
});

// NAMESPACE OBJECT: ./mjs/core/FindMath.js
var FindMath_namespaceObject = {};
__webpack_require__.r(FindMath_namespaceObject);
__webpack_require__.d(FindMath_namespaceObject, {
  AbstractFindMath: () => (AbstractFindMath)
});

// NAMESPACE OBJECT: ./mjs/core/InputJax.js
var InputJax_namespaceObject = {};
__webpack_require__.r(InputJax_namespaceObject);
__webpack_require__.d(InputJax_namespaceObject, {
  AbstractInputJax: () => (AbstractInputJax)
});

// NAMESPACE OBJECT: ./mjs/core/OutputJax.js
var OutputJax_namespaceObject = {};
__webpack_require__.r(OutputJax_namespaceObject);
__webpack_require__.d(OutputJax_namespaceObject, {
  AbstractOutputJax: () => (AbstractOutputJax)
});

// NAMESPACE OBJECT: ./mjs/util/LinkedList.js
var LinkedList_namespaceObject = {};
__webpack_require__.r(LinkedList_namespaceObject);
__webpack_require__.d(LinkedList_namespaceObject, {
  END: () => (END),
  LinkedList: () => (LinkedList),
  ListItem: () => (ListItem)
});

// NAMESPACE OBJECT: ./mjs/core/MathList.js
var MathList_namespaceObject = {};
__webpack_require__.r(MathList_namespaceObject);
__webpack_require__.d(MathList_namespaceObject, {
  AbstractMathList: () => (AbstractMathList)
});

// NAMESPACE OBJECT: ./mjs/core/MathItem.js
var MathItem_namespaceObject = {};
__webpack_require__.r(MathItem_namespaceObject);
__webpack_require__.d(MathItem_namespaceObject, {
  AbstractMathItem: () => (AbstractMathItem),
  STATE: () => (STATE),
  newState: () => (newState),
  protoItem: () => (protoItem)
});

// NAMESPACE OBJECT: ./mjs/core/Tree/Factory.js
var Factory_namespaceObject = {};
__webpack_require__.r(Factory_namespaceObject);
__webpack_require__.d(Factory_namespaceObject, {
  AbstractFactory: () => (AbstractFactory)
});

// NAMESPACE OBJECT: ./mjs/core/Tree/NodeFactory.js
var NodeFactory_namespaceObject = {};
__webpack_require__.r(NodeFactory_namespaceObject);
__webpack_require__.d(NodeFactory_namespaceObject, {
  AbstractNodeFactory: () => (AbstractNodeFactory)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/Attributes.js
var Attributes_namespaceObject = {};
__webpack_require__.r(Attributes_namespaceObject);
__webpack_require__.d(Attributes_namespaceObject, {
  Attributes: () => (Attributes),
  INHERIT: () => (INHERIT)
});

// NAMESPACE OBJECT: ./mjs/core/Tree/Node.js
var Node_namespaceObject = {};
__webpack_require__.r(Node_namespaceObject);
__webpack_require__.d(Node_namespaceObject, {
  AbstractEmptyNode: () => (AbstractEmptyNode),
  AbstractNode: () => (AbstractNode)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNode.js
var MmlNode_namespaceObject = {};
__webpack_require__.r(MmlNode_namespaceObject);
__webpack_require__.d(MmlNode_namespaceObject, {
  AbstractMmlBaseNode: () => (AbstractMmlBaseNode),
  AbstractMmlEmptyNode: () => (AbstractMmlEmptyNode),
  AbstractMmlLayoutNode: () => (AbstractMmlLayoutNode),
  AbstractMmlNode: () => (AbstractMmlNode),
  AbstractMmlTokenNode: () => (AbstractMmlTokenNode),
  MATHVARIANTS: () => (MATHVARIANTS),
  TEXCLASS: () => (TEXCLASS),
  TEXCLASSNAMES: () => (TEXCLASSNAMES),
  TextNode: () => (TextNode),
  XMLNode: () => (XMLNode),
  indentAttributes: () => (indentAttributes)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/math.js
var math_namespaceObject = {};
__webpack_require__.r(math_namespaceObject);
__webpack_require__.d(math_namespaceObject, {
  MmlMath: () => (MmlMath)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mi.js
var mi_namespaceObject = {};
__webpack_require__.r(mi_namespaceObject);
__webpack_require__.d(mi_namespaceObject, {
  MmlMi: () => (MmlMi)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mn.js
var mn_namespaceObject = {};
__webpack_require__.r(mn_namespaceObject);
__webpack_require__.d(mn_namespaceObject, {
  MmlMn: () => (MmlMn)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/OperatorDictionary.js
var OperatorDictionary_namespaceObject = {};
__webpack_require__.r(OperatorDictionary_namespaceObject);
__webpack_require__.d(OperatorDictionary_namespaceObject, {
  MMLSPACING: () => (MMLSPACING),
  MO: () => (MO),
  OPDEF: () => (OPDEF),
  OPTABLE: () => (OPTABLE),
  RANGES: () => (RANGES),
  getRange: () => (getRange)
});

// NAMESPACE OBJECT: ./mjs/util/string.js
var string_namespaceObject = {};
__webpack_require__.r(string_namespaceObject);
__webpack_require__.d(string_namespaceObject, {
  isPercent: () => (isPercent),
  quotePattern: () => (quotePattern),
  replaceUnicode: () => (replaceUnicode),
  sortLength: () => (sortLength),
  split: () => (split),
  toEntity: () => (toEntity),
  unicodeChars: () => (unicodeChars),
  unicodeString: () => (unicodeString)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mo.js
var mo_namespaceObject = {};
__webpack_require__.r(mo_namespaceObject);
__webpack_require__.d(mo_namespaceObject, {
  MmlMo: () => (MmlMo)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mtext.js
var mtext_namespaceObject = {};
__webpack_require__.r(mtext_namespaceObject);
__webpack_require__.d(mtext_namespaceObject, {
  MmlMtext: () => (MmlMtext)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mspace.js
var mspace_namespaceObject = {};
__webpack_require__.r(mspace_namespaceObject);
__webpack_require__.d(mspace_namespaceObject, {
  MmlMspace: () => (MmlMspace)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/ms.js
var ms_namespaceObject = {};
__webpack_require__.r(ms_namespaceObject);
__webpack_require__.d(ms_namespaceObject, {
  MmlMs: () => (MmlMs)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mrow.js
var mrow_namespaceObject = {};
__webpack_require__.r(mrow_namespaceObject);
__webpack_require__.d(mrow_namespaceObject, {
  MmlInferredMrow: () => (MmlInferredMrow),
  MmlMrow: () => (MmlMrow)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mfrac.js
var mfrac_namespaceObject = {};
__webpack_require__.r(mfrac_namespaceObject);
__webpack_require__.d(mfrac_namespaceObject, {
  MmlMfrac: () => (MmlMfrac)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/msqrt.js
var msqrt_namespaceObject = {};
__webpack_require__.r(msqrt_namespaceObject);
__webpack_require__.d(msqrt_namespaceObject, {
  MmlMsqrt: () => (MmlMsqrt)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mroot.js
var mroot_namespaceObject = {};
__webpack_require__.r(mroot_namespaceObject);
__webpack_require__.d(mroot_namespaceObject, {
  MmlMroot: () => (MmlMroot)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mstyle.js
var mstyle_namespaceObject = {};
__webpack_require__.r(mstyle_namespaceObject);
__webpack_require__.d(mstyle_namespaceObject, {
  MmlMstyle: () => (MmlMstyle)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/merror.js
var merror_namespaceObject = {};
__webpack_require__.r(merror_namespaceObject);
__webpack_require__.d(merror_namespaceObject, {
  MmlMerror: () => (MmlMerror)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mpadded.js
var mpadded_namespaceObject = {};
__webpack_require__.r(mpadded_namespaceObject);
__webpack_require__.d(mpadded_namespaceObject, {
  MmlMpadded: () => (MmlMpadded)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mphantom.js
var mphantom_namespaceObject = {};
__webpack_require__.r(mphantom_namespaceObject);
__webpack_require__.d(mphantom_namespaceObject, {
  MmlMphantom: () => (MmlMphantom)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mfenced.js
var mfenced_namespaceObject = {};
__webpack_require__.r(mfenced_namespaceObject);
__webpack_require__.d(mfenced_namespaceObject, {
  MmlMfenced: () => (MmlMfenced)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/menclose.js
var menclose_namespaceObject = {};
__webpack_require__.r(menclose_namespaceObject);
__webpack_require__.d(menclose_namespaceObject, {
  MmlMenclose: () => (MmlMenclose)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/maction.js
var maction_namespaceObject = {};
__webpack_require__.r(maction_namespaceObject);
__webpack_require__.d(maction_namespaceObject, {
  MmlMaction: () => (MmlMaction)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/msubsup.js
var msubsup_namespaceObject = {};
__webpack_require__.r(msubsup_namespaceObject);
__webpack_require__.d(msubsup_namespaceObject, {
  MmlMsub: () => (MmlMsub),
  MmlMsubsup: () => (MmlMsubsup),
  MmlMsup: () => (MmlMsup)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/munderover.js
var munderover_namespaceObject = {};
__webpack_require__.r(munderover_namespaceObject);
__webpack_require__.d(munderover_namespaceObject, {
  MmlMover: () => (MmlMover),
  MmlMunder: () => (MmlMunder),
  MmlMunderover: () => (MmlMunderover)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mmultiscripts.js
var mmultiscripts_namespaceObject = {};
__webpack_require__.r(mmultiscripts_namespaceObject);
__webpack_require__.d(mmultiscripts_namespaceObject, {
  MmlMmultiscripts: () => (MmlMmultiscripts),
  MmlMprescripts: () => (MmlMprescripts),
  MmlNone: () => (MmlNone)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mtable.js
var mtable_namespaceObject = {};
__webpack_require__.r(mtable_namespaceObject);
__webpack_require__.d(mtable_namespaceObject, {
  MmlMtable: () => (MmlMtable)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mtr.js
var mtr_namespaceObject = {};
__webpack_require__.r(mtr_namespaceObject);
__webpack_require__.d(mtr_namespaceObject, {
  MmlMlabeledtr: () => (MmlMlabeledtr),
  MmlMtr: () => (MmlMtr)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mtd.js
var mtd_namespaceObject = {};
__webpack_require__.r(mtd_namespaceObject);
__webpack_require__.d(mtd_namespaceObject, {
  MmlMtd: () => (MmlMtd)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/maligngroup.js
var maligngroup_namespaceObject = {};
__webpack_require__.r(maligngroup_namespaceObject);
__webpack_require__.d(maligngroup_namespaceObject, {
  MmlMaligngroup: () => (MmlMaligngroup)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/malignmark.js
var malignmark_namespaceObject = {};
__webpack_require__.r(malignmark_namespaceObject);
__webpack_require__.d(malignmark_namespaceObject, {
  MmlMalignmark: () => (MmlMalignmark)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mglyph.js
var mglyph_namespaceObject = {};
__webpack_require__.r(mglyph_namespaceObject);
__webpack_require__.d(mglyph_namespaceObject, {
  MmlMglyph: () => (MmlMglyph)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/semantics.js
var semantics_namespaceObject = {};
__webpack_require__.r(semantics_namespaceObject);
__webpack_require__.d(semantics_namespaceObject, {
  MmlAnnotation: () => (MmlAnnotation),
  MmlAnnotationXML: () => (MmlAnnotationXML),
  MmlSemantics: () => (MmlSemantics)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/TeXAtom.js
var TeXAtom_namespaceObject = {};
__webpack_require__.r(TeXAtom_namespaceObject);
__webpack_require__.d(TeXAtom_namespaceObject, {
  TeXAtom: () => (TeXAtom)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/mathchoice.js
var mathchoice_namespaceObject = {};
__webpack_require__.r(mathchoice_namespaceObject);
__webpack_require__.d(mathchoice_namespaceObject, {
  MathChoice: () => (MathChoice)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlNodes/HtmlNode.js
var HtmlNode_namespaceObject = {};
__webpack_require__.r(HtmlNode_namespaceObject);
__webpack_require__.d(HtmlNode_namespaceObject, {
  HtmlNode: () => (HtmlNode)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MML.js
var MML_namespaceObject = {};
__webpack_require__.r(MML_namespaceObject);
__webpack_require__.d(MML_namespaceObject, {
  MML: () => (MML)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlFactory.js
var MmlFactory_namespaceObject = {};
__webpack_require__.r(MmlFactory_namespaceObject);
__webpack_require__.d(MmlFactory_namespaceObject, {
  MmlFactory: () => (MmlFactory)
});

// NAMESPACE OBJECT: ./mjs/util/BitField.js
var BitField_namespaceObject = {};
__webpack_require__.r(BitField_namespaceObject);
__webpack_require__.d(BitField_namespaceObject, {
  BitField: () => (BitField),
  BitFieldClass: () => (BitFieldClass)
});

// NAMESPACE OBJECT: ./mjs/util/Retries.js
var Retries_namespaceObject = {};
__webpack_require__.r(Retries_namespaceObject);
__webpack_require__.d(Retries_namespaceObject, {
  handleRetriesFor: () => (handleRetriesFor),
  retryAfter: () => (retryAfter)
});

// NAMESPACE OBJECT: ./mjs/core/MathDocument.js
var MathDocument_namespaceObject = {};
__webpack_require__.r(MathDocument_namespaceObject);
__webpack_require__.d(MathDocument_namespaceObject, {
  AbstractMathDocument: () => (AbstractMathDocument),
  RenderList: () => (RenderList),
  resetAllOptions: () => (resetAllOptions),
  resetOptions: () => (resetOptions)
});

// NAMESPACE OBJECT: ./mjs/core/Handler.js
var Handler_namespaceObject = {};
__webpack_require__.r(Handler_namespaceObject);
__webpack_require__.d(Handler_namespaceObject, {
  AbstractHandler: () => (AbstractHandler)
});

// NAMESPACE OBJECT: ./mjs/core/HandlerList.js
var HandlerList_namespaceObject = {};
__webpack_require__.r(HandlerList_namespaceObject);
__webpack_require__.d(HandlerList_namespaceObject, {
  HandlerList: () => (HandlerList)
});

// NAMESPACE OBJECT: ./mjs/core/Tree/Visitor.js
var Visitor_namespaceObject = {};
__webpack_require__.r(Visitor_namespaceObject);
__webpack_require__.d(Visitor_namespaceObject, {
  AbstractVisitor: () => (AbstractVisitor)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MmlVisitor.js
var MmlVisitor_namespaceObject = {};
__webpack_require__.r(MmlVisitor_namespaceObject);
__webpack_require__.d(MmlVisitor_namespaceObject, {
  DATAMJX: () => (DATAMJX),
  MmlVisitor: () => (MmlVisitor)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/MathMLVisitor.js
var MathMLVisitor_namespaceObject = {};
__webpack_require__.r(MathMLVisitor_namespaceObject);
__webpack_require__.d(MathMLVisitor_namespaceObject, {
  MathMLVisitor: () => (MathMLVisitor)
});

// NAMESPACE OBJECT: ./mjs/core/MmlTree/SerializedMmlVisitor.js
var SerializedMmlVisitor_namespaceObject = {};
__webpack_require__.r(SerializedMmlVisitor_namespaceObject);
__webpack_require__.d(SerializedMmlVisitor_namespaceObject, {
  SerializedMmlVisitor: () => (SerializedMmlVisitor)
});

// NAMESPACE OBJECT: ./mjs/core/Tree/Wrapper.js
var Wrapper_namespaceObject = {};
__webpack_require__.r(Wrapper_namespaceObject);
__webpack_require__.d(Wrapper_namespaceObject, {
  AbstractWrapper: () => (AbstractWrapper)
});

// NAMESPACE OBJECT: ./mjs/core/Tree/WrapperFactory.js
var WrapperFactory_namespaceObject = {};
__webpack_require__.r(WrapperFactory_namespaceObject);
__webpack_require__.d(WrapperFactory_namespaceObject, {
  AbstractWrapperFactory: () => (AbstractWrapperFactory)
});

// NAMESPACE OBJECT: ./mjs/mathjax.js
var mathjax_namespaceObject = {};
__webpack_require__.r(mathjax_namespaceObject);
__webpack_require__.d(mathjax_namespaceObject, {
  mathjax: () => (mathjax)
});

// NAMESPACE OBJECT: ./mjs/handlers/html/HTMLMathItem.js
var HTMLMathItem_namespaceObject = {};
__webpack_require__.r(HTMLMathItem_namespaceObject);
__webpack_require__.d(HTMLMathItem_namespaceObject, {
  HTMLMathItem: () => (HTMLMathItem)
});

// NAMESPACE OBJECT: ./mjs/handlers/html/HTMLMathList.js
var HTMLMathList_namespaceObject = {};
__webpack_require__.r(HTMLMathList_namespaceObject);
__webpack_require__.d(HTMLMathList_namespaceObject, {
  HTMLMathList: () => (HTMLMathList)
});

// NAMESPACE OBJECT: ./mjs/handlers/html/HTMLDomStrings.js
var HTMLDomStrings_namespaceObject = {};
__webpack_require__.r(HTMLDomStrings_namespaceObject);
__webpack_require__.d(HTMLDomStrings_namespaceObject, {
  HTMLDomStrings: () => (HTMLDomStrings)
});

// NAMESPACE OBJECT: ./mjs/handlers/html/HTMLDocument.js
var HTMLDocument_namespaceObject = {};
__webpack_require__.r(HTMLDocument_namespaceObject);
__webpack_require__.d(HTMLDocument_namespaceObject, {
  HTMLDocument: () => (HTMLDocument)
});

// NAMESPACE OBJECT: ./mjs/handlers/html/HTMLHandler.js
var HTMLHandler_namespaceObject = {};
__webpack_require__.r(HTMLHandler_namespaceObject);
__webpack_require__.d(HTMLHandler_namespaceObject, {
  HTMLHandler: () => (HTMLHandler)
});

// NAMESPACE OBJECT: ./mjs/handlers/html.js
var html_namespaceObject = {};
__webpack_require__.r(html_namespaceObject);
__webpack_require__.d(html_namespaceObject, {
  RegisterHTMLHandler: () => (RegisterHTMLHandler)
});

// NAMESPACE OBJECT: ./mjs/util/AsyncLoad.js
var AsyncLoad_namespaceObject = {};
__webpack_require__.r(AsyncLoad_namespaceObject);
__webpack_require__.d(AsyncLoad_namespaceObject, {
  asyncLoad: () => (asyncLoad)
});

// NAMESPACE OBJECT: ./mjs/util/lengths.js
var lengths_namespaceObject = {};
__webpack_require__.r(lengths_namespaceObject);
__webpack_require__.d(lengths_namespaceObject, {
  BIGDIMEN: () => (BIGDIMEN),
  MATHSPACE: () => (MATHSPACE),
  RELUNITS: () => (RELUNITS),
  UNITS: () => (UNITS),
  em: () => (em),
  length2em: () => (length2em),
  percent: () => (percent),
  px: () => (px)
});

// NAMESPACE OBJECT: ./mjs/util/BBox.js
var BBox_namespaceObject = {};
__webpack_require__.r(BBox_namespaceObject);
__webpack_require__.d(BBox_namespaceObject, {
  BBox: () => (BBox)
});

// NAMESPACE OBJECT: ./mjs/util/Entities.js
var Entities_namespaceObject = {};
__webpack_require__.r(Entities_namespaceObject);
__webpack_require__.d(Entities_namespaceObject, {
  add: () => (add),
  entities: () => (entities),
  numeric: () => (numeric),
  options: () => (options),
  remove: () => (remove),
  translate: () => (translate)
});

// NAMESPACE OBJECT: ./mjs/util/StyleJson.js
var StyleJson_namespaceObject = {};
__webpack_require__.r(StyleJson_namespaceObject);
__webpack_require__.d(StyleJson_namespaceObject, {
  StyleJsonSheet: () => (StyleJsonSheet)
});

// NAMESPACE OBJECT: ./mjs/util/Styles.js
var Styles_namespaceObject = {};
__webpack_require__.r(Styles_namespaceObject);
__webpack_require__.d(Styles_namespaceObject, {
  Styles: () => (Styles),
  TRBL: () => (TRBL),
  WSC: () => (WSC)
});

// NAMESPACE OBJECT: ./mjs/util/numeric.js
var numeric_namespaceObject = {};
__webpack_require__.r(numeric_namespaceObject);
__webpack_require__.d(numeric_namespaceObject, {
  max: () => (max),
  sum: () => (sum)
});

// NAMESPACE OBJECT: ./mjs/input/tex/FindTeX.js
var FindTeX_namespaceObject = {};
__webpack_require__.r(FindTeX_namespaceObject);
__webpack_require__.d(FindTeX_namespaceObject, {
  FindTeX: () => (FindTeX)
});

// NAMESPACE OBJECT: ./mjs/input/tex/NodeUtil.js
var NodeUtil_namespaceObject = {};
__webpack_require__.r(NodeUtil_namespaceObject);
__webpack_require__.d(NodeUtil_namespaceObject, {
  "default": () => (tex_NodeUtil)
});

// NAMESPACE OBJECT: ./mjs/input/tex/FilterUtil.js
var FilterUtil_namespaceObject = {};
__webpack_require__.r(FilterUtil_namespaceObject);
__webpack_require__.d(FilterUtil_namespaceObject, {
  "default": () => (tex_FilterUtil)
});

// NAMESPACE OBJECT: ./mjs/input/tex/HandlerTypes.js
var HandlerTypes_namespaceObject = {};
__webpack_require__.r(HandlerTypes_namespaceObject);
__webpack_require__.d(HandlerTypes_namespaceObject, {
  ConfigurationType: () => (ConfigurationType),
  HandlerType: () => (HandlerType)
});

// NAMESPACE OBJECT: ./mjs/input/tex/UnitUtil.js
var UnitUtil_namespaceObject = {};
__webpack_require__.r(UnitUtil_namespaceObject);
__webpack_require__.d(UnitUtil_namespaceObject, {
  UnitUtil: () => (UnitUtil)
});

// NAMESPACE OBJECT: ./mjs/input/tex/Stack.js
var Stack_namespaceObject = {};
__webpack_require__.r(Stack_namespaceObject);
__webpack_require__.d(Stack_namespaceObject, {
  "default": () => (Stack)
});

// NAMESPACE OBJECT: ./mjs/input/tex/TexError.js
var TexError_namespaceObject = {};
__webpack_require__.r(TexError_namespaceObject);
__webpack_require__.d(TexError_namespaceObject, {
  "default": () => (tex_TexError)
});

// NAMESPACE OBJECT: ./mjs/input/tex/StackItem.js
var StackItem_namespaceObject = {};
__webpack_require__.r(StackItem_namespaceObject);
__webpack_require__.d(StackItem_namespaceObject, {
  BaseItem: () => (BaseItem),
  MmlStack: () => (MmlStack)
});

// NAMESPACE OBJECT: ./mjs/input/tex/TexConstants.js
var TexConstants_namespaceObject = {};
__webpack_require__.r(TexConstants_namespaceObject);
__webpack_require__.d(TexConstants_namespaceObject, {
  TexConstant: () => (TexConstant)
});

// NAMESPACE OBJECT: ./mjs/input/tex/TexParser.js
var TexParser_namespaceObject = {};
__webpack_require__.r(TexParser_namespaceObject);
__webpack_require__.d(TexParser_namespaceObject, {
  "default": () => (TexParser)
});

// NAMESPACE OBJECT: ./mjs/input/tex/StackItemFactory.js
var StackItemFactory_namespaceObject = {};
__webpack_require__.r(StackItemFactory_namespaceObject);
__webpack_require__.d(StackItemFactory_namespaceObject, {
  "default": () => (tex_StackItemFactory)
});

// NAMESPACE OBJECT: ./mjs/input/tex/NodeFactory.js
var tex_NodeFactory_namespaceObject = {};
__webpack_require__.r(tex_NodeFactory_namespaceObject);
__webpack_require__.d(tex_NodeFactory_namespaceObject, {
  NodeFactory: () => (NodeFactory)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ParseUtil.js
var ParseUtil_namespaceObject = {};
__webpack_require__.r(ParseUtil_namespaceObject);
__webpack_require__.d(ParseUtil_namespaceObject, {
  KeyValueDef: () => (KeyValueDef),
  KeyValueTypes: () => (KeyValueTypes),
  ParseUtil: () => (ParseUtil)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ColumnParser.js
var ColumnParser_namespaceObject = {};
__webpack_require__.r(ColumnParser_namespaceObject);
__webpack_require__.d(ColumnParser_namespaceObject, {
  ColumnParser: () => (ColumnParser)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ParseOptions.js
var ParseOptions_namespaceObject = {};
__webpack_require__.r(ParseOptions_namespaceObject);
__webpack_require__.d(ParseOptions_namespaceObject, {
  "default": () => (tex_ParseOptions)
});

// NAMESPACE OBJECT: ./mjs/input/tex/Tags.js
var Tags_namespaceObject = {};
__webpack_require__.r(Tags_namespaceObject);
__webpack_require__.d(Tags_namespaceObject, {
  AbstractTags: () => (AbstractTags),
  AllTags: () => (AllTags),
  Label: () => (Label),
  NoTags: () => (NoTags),
  TagInfo: () => (TagInfo),
  TagsFactory: () => (TagsFactory)
});

// NAMESPACE OBJECT: ./mjs/input/tex/Token.js
var Token_namespaceObject = {};
__webpack_require__.r(Token_namespaceObject);
__webpack_require__.d(Token_namespaceObject, {
  Macro: () => (Macro),
  Token: () => (Token)
});

// NAMESPACE OBJECT: ./mjs/input/tex/TokenMap.js
var TokenMap_namespaceObject = {};
__webpack_require__.r(TokenMap_namespaceObject);
__webpack_require__.d(TokenMap_namespaceObject, {
  AbstractParseMap: () => (AbstractParseMap),
  AbstractTokenMap: () => (AbstractTokenMap),
  CharacterMap: () => (CharacterMap),
  CommandMap: () => (CommandMap),
  DelimiterMap: () => (DelimiterMap),
  EnvironmentMap: () => (EnvironmentMap),
  MacroMap: () => (MacroMap),
  RegExpMap: () => (RegExpMap),
  parseResult: () => (parseResult)
});

// NAMESPACE OBJECT: ./mjs/input/tex/MapHandler.js
var MapHandler_namespaceObject = {};
__webpack_require__.r(MapHandler_namespaceObject);
__webpack_require__.d(MapHandler_namespaceObject, {
  MapHandler: () => (MapHandler),
  SubHandler: () => (SubHandler),
  SubHandlers: () => (SubHandlers)
});

// NAMESPACE OBJECT: ./mjs/input/tex/Configuration.js
var Configuration_namespaceObject = {};
__webpack_require__.r(Configuration_namespaceObject);
__webpack_require__.d(Configuration_namespaceObject, {
  Configuration: () => (Configuration),
  ConfigurationHandler: () => (ConfigurationHandler),
  ParserConfiguration: () => (ParserConfiguration)
});

// NAMESPACE OBJECT: ./mjs/input/tex/base/BaseItems.js
var BaseItems_namespaceObject = {};
__webpack_require__.r(BaseItems_namespaceObject);
__webpack_require__.d(BaseItems_namespaceObject, {
  ArrayItem: () => (ArrayItem),
  BeginItem: () => (BeginItem),
  BreakItem: () => (BreakItem),
  CellItem: () => (CellItem),
  CloseItem: () => (CloseItem),
  DotsItem: () => (DotsItem),
  EndItem: () => (EndItem),
  EqnArrayItem: () => (EqnArrayItem),
  EquationItem: () => (EquationItem),
  FnItem: () => (FnItem),
  LeftItem: () => (LeftItem),
  Middle: () => (Middle),
  MmlItem: () => (MmlItem),
  MstyleItem: () => (MstyleItem),
  NonscriptItem: () => (NonscriptItem),
  NotItem: () => (NotItem),
  NullItem: () => (NullItem),
  OpenItem: () => (OpenItem),
  OverItem: () => (OverItem),
  PositionItem: () => (PositionItem),
  PrimeItem: () => (PrimeItem),
  RightItem: () => (RightItem),
  StartItem: () => (StartItem),
  StopItem: () => (StopItem),
  StyleItem: () => (StyleItem),
  SubsupItem: () => (SubsupItem)
});

// NAMESPACE OBJECT: ./mjs/input/tex/base/BaseMethods.js
var BaseMethods_namespaceObject = {};
__webpack_require__.r(BaseMethods_namespaceObject);
__webpack_require__.d(BaseMethods_namespaceObject, {
  "default": () => (base_BaseMethods),
  splitAlignArray: () => (splitAlignArray)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ParseMethods.js
var ParseMethods_namespaceObject = {};
__webpack_require__.r(ParseMethods_namespaceObject);
__webpack_require__.d(ParseMethods_namespaceObject, {
  "default": () => (tex_ParseMethods)
});

// NAMESPACE OBJECT: ./mjs/input/tex/base/BaseConfiguration.js
var BaseConfiguration_namespaceObject = {};
__webpack_require__.r(BaseConfiguration_namespaceObject);
__webpack_require__.d(BaseConfiguration_namespaceObject, {
  BaseConfiguration: () => (BaseConfiguration),
  BaseTags: () => (BaseTags),
  Other: () => (Other)
});

// NAMESPACE OBJECT: ./mjs/input/tex.js
var tex_namespaceObject = {};
__webpack_require__.r(tex_namespaceObject);
__webpack_require__.d(tex_namespaceObject, {
  TeX: () => (TeX)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ams/AmsItems.js
var AmsItems_namespaceObject = {};
__webpack_require__.r(AmsItems_namespaceObject);
__webpack_require__.d(AmsItems_namespaceObject, {
  FlalignItem: () => (FlalignItem),
  MultlineItem: () => (MultlineItem)
});

// NAMESPACE OBJECT: ./mjs/input/tex/newcommand/NewcommandUtil.js
var NewcommandUtil_namespaceObject = {};
__webpack_require__.r(NewcommandUtil_namespaceObject);
__webpack_require__.d(NewcommandUtil_namespaceObject, {
  NewcommandPriority: () => (NewcommandPriority),
  NewcommandTables: () => (NewcommandTables),
  NewcommandUtil: () => (NewcommandUtil)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ams/AmsMethods.js
var AmsMethods_namespaceObject = {};
__webpack_require__.r(AmsMethods_namespaceObject);
__webpack_require__.d(AmsMethods_namespaceObject, {
  AmsMethods: () => (AmsMethods)
});

// NAMESPACE OBJECT: ./mjs/input/tex/newcommand/NewcommandItems.js
var NewcommandItems_namespaceObject = {};
__webpack_require__.r(NewcommandItems_namespaceObject);
__webpack_require__.d(NewcommandItems_namespaceObject, {
  BeginEnvItem: () => (BeginEnvItem)
});

// NAMESPACE OBJECT: ./mjs/input/tex/newcommand/NewcommandMethods.js
var NewcommandMethods_namespaceObject = {};
__webpack_require__.r(NewcommandMethods_namespaceObject);
__webpack_require__.d(NewcommandMethods_namespaceObject, {
  "default": () => (newcommand_NewcommandMethods)
});

// NAMESPACE OBJECT: ./mjs/input/tex/newcommand/NewcommandConfiguration.js
var NewcommandConfiguration_namespaceObject = {};
__webpack_require__.r(NewcommandConfiguration_namespaceObject);
__webpack_require__.d(NewcommandConfiguration_namespaceObject, {
  NewcommandConfig: () => (NewcommandConfig),
  NewcommandConfiguration: () => (NewcommandConfiguration)
});

// NAMESPACE OBJECT: ./mjs/input/tex/ams/AmsConfiguration.js
var AmsConfiguration_namespaceObject = {};
__webpack_require__.r(AmsConfiguration_namespaceObject);
__webpack_require__.d(AmsConfiguration_namespaceObject, {
  AmsConfiguration: () => (AmsConfiguration),
  AmsTags: () => (AmsTags)
});

// NAMESPACE OBJECT: ./mjs/input/tex/require/RequireConfiguration.js
var RequireConfiguration_namespaceObject = {};
__webpack_require__.r(RequireConfiguration_namespaceObject);
__webpack_require__.d(RequireConfiguration_namespaceObject, {
  RequireConfiguration: () => (RequireConfiguration),
  RequireLoad: () => (RequireLoad),
  RequireMethods: () => (RequireMethods),
  options: () => (RequireConfiguration_options)
});

// NAMESPACE OBJECT: ./mjs/input/tex/autoload/AutoloadConfiguration.js
var AutoloadConfiguration_namespaceObject = {};
__webpack_require__.r(AutoloadConfiguration_namespaceObject);
__webpack_require__.d(AutoloadConfiguration_namespaceObject, {
  AutoloadConfiguration: () => (AutoloadConfiguration)
});

// NAMESPACE OBJECT: ./mjs/input/tex/configmacros/ConfigMacrosConfiguration.js
var ConfigMacrosConfiguration_namespaceObject = {};
__webpack_require__.r(ConfigMacrosConfiguration_namespaceObject);
__webpack_require__.d(ConfigMacrosConfiguration_namespaceObject, {
  ConfigMacrosConfiguration: () => (ConfigMacrosConfiguration)
});

// NAMESPACE OBJECT: ./mjs/input/tex/noundefined/NoUndefinedConfiguration.js
var NoUndefinedConfiguration_namespaceObject = {};
__webpack_require__.r(NoUndefinedConfiguration_namespaceObject);
__webpack_require__.d(NoUndefinedConfiguration_namespaceObject, {
  NoUndefinedConfiguration: () => (NoUndefinedConfiguration)
});

// NAMESPACE OBJECT: ./mjs/input/tex/textmacros/TextParser.js
var TextParser_namespaceObject = {};
__webpack_require__.r(TextParser_namespaceObject);
__webpack_require__.d(TextParser_namespaceObject, {
  TextParser: () => (TextParser)
});

// NAMESPACE OBJECT: ./mjs/input/tex/textmacros/TextMacrosMethods.js
var TextMacrosMethods_namespaceObject = {};
__webpack_require__.r(TextMacrosMethods_namespaceObject);
__webpack_require__.d(TextMacrosMethods_namespaceObject, {
  TextMacrosMethods: () => (TextMacrosMethods)
});

// NAMESPACE OBJECT: ./mjs/input/tex/textmacros/TextMacrosConfiguration.js
var TextMacrosConfiguration_namespaceObject = {};
__webpack_require__.r(TextMacrosConfiguration_namespaceObject);
__webpack_require__.d(TextMacrosConfiguration_namespaceObject, {
  TextBaseConfiguration: () => (TextBaseConfiguration),
  TextMacrosConfiguration: () => (TextMacrosConfiguration)
});

// NAMESPACE OBJECT: ./mjs/output/common/Direction.js
var Direction_namespaceObject = {};
__webpack_require__.r(Direction_namespaceObject);
__webpack_require__.d(Direction_namespaceObject, {
  DIRECTION: () => (DIRECTION),
  H: () => (H),
  V: () => (V)
});

// NAMESPACE OBJECT: ./mjs/output/common/FontData.js
var FontData_namespaceObject = {};
__webpack_require__.r(FontData_namespaceObject);
__webpack_require__.d(FontData_namespaceObject, {
  DIRECTION: () => (DIRECTION),
  FontData: () => (FontData),
  NOSTRETCH: () => (NOSTRETCH),
  mergeOptions: () => (mergeOptions)
});

// NAMESPACE OBJECT: ./mjs/output/common/LineBBox.js
var LineBBox_namespaceObject = {};
__webpack_require__.r(LineBBox_namespaceObject);
__webpack_require__.d(LineBBox_namespaceObject, {
  LineBBox: () => (LineBBox)
});

// NAMESPACE OBJECT: ./mjs/output/common/LinebreakVisitor.js
var LinebreakVisitor_namespaceObject = {};
__webpack_require__.r(LinebreakVisitor_namespaceObject);
__webpack_require__.d(LinebreakVisitor_namespaceObject, {
  LinebreakVisitor: () => (LinebreakVisitor),
  Linebreaks: () => (Linebreaks),
  NOBREAK: () => (NOBREAK)
});

// NAMESPACE OBJECT: ./mjs/output/common.js
var common_namespaceObject = {};
__webpack_require__.r(common_namespaceObject);
__webpack_require__.d(common_namespaceObject, {
  CommonOutputJax: () => (CommonOutputJax),
  FONTPATH: () => (FONTPATH)
});

// NAMESPACE OBJECT: ./mjs/output/common/WrapperFactory.js
var common_WrapperFactory_namespaceObject = {};
__webpack_require__.r(common_WrapperFactory_namespaceObject);
__webpack_require__.d(common_WrapperFactory_namespaceObject, {
  CommonWrapperFactory: () => (CommonWrapperFactory)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrapper.js
var common_Wrapper_namespaceObject = {};
__webpack_require__.r(common_Wrapper_namespaceObject);
__webpack_require__.d(common_Wrapper_namespaceObject, {
  CommonWrapper: () => (CommonWrapper),
  SPACE: () => (SPACE)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrapper.js
var chtml_Wrapper_namespaceObject = {};
__webpack_require__.r(chtml_Wrapper_namespaceObject);
__webpack_require__.d(chtml_Wrapper_namespaceObject, {
  ChtmlWrapper: () => (ChtmlWrapper),
  FONTSIZE: () => (FONTSIZE)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/math.js
var Wrappers_math_namespaceObject = {};
__webpack_require__.r(Wrappers_math_namespaceObject);
__webpack_require__.d(Wrappers_math_namespaceObject, {
  CommonMathMixin: () => (CommonMathMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/math.js
var chtml_Wrappers_math_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_math_namespaceObject);
__webpack_require__.d(chtml_Wrappers_math_namespaceObject, {
  ChtmlMath: () => (ChtmlMath)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mi.js
var Wrappers_mi_namespaceObject = {};
__webpack_require__.r(Wrappers_mi_namespaceObject);
__webpack_require__.d(Wrappers_mi_namespaceObject, {
  CommonMiMixin: () => (CommonMiMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mi.js
var chtml_Wrappers_mi_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mi_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mi_namespaceObject, {
  ChtmlMi: () => (ChtmlMi)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mo.js
var Wrappers_mo_namespaceObject = {};
__webpack_require__.r(Wrappers_mo_namespaceObject);
__webpack_require__.d(Wrappers_mo_namespaceObject, {
  CommonMoMixin: () => (CommonMoMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Usage.js
var Usage_namespaceObject = {};
__webpack_require__.r(Usage_namespaceObject);
__webpack_require__.d(Usage_namespaceObject, {
  Usage: () => (Usage)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/FontData.js
var chtml_FontData_namespaceObject = {};
__webpack_require__.r(chtml_FontData_namespaceObject);
__webpack_require__.d(chtml_FontData_namespaceObject, {
  AddCSS: () => (AddCSS),
  ChtmlFontData: () => (ChtmlFontData),
  DIRECTION: () => (DIRECTION),
  FontData: () => (FontData),
  NOSTRETCH: () => (NOSTRETCH),
  mergeOptions: () => (mergeOptions)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mo.js
var chtml_Wrappers_mo_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mo_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mo_namespaceObject, {
  ChtmlMo: () => (ChtmlMo)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mn.js
var Wrappers_mn_namespaceObject = {};
__webpack_require__.r(Wrappers_mn_namespaceObject);
__webpack_require__.d(Wrappers_mn_namespaceObject, {
  CommonMnMixin: () => (CommonMnMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mn.js
var chtml_Wrappers_mn_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mn_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mn_namespaceObject, {
  ChtmlMn: () => (ChtmlMn)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/ms.js
var Wrappers_ms_namespaceObject = {};
__webpack_require__.r(Wrappers_ms_namespaceObject);
__webpack_require__.d(Wrappers_ms_namespaceObject, {
  CommonMsMixin: () => (CommonMsMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/ms.js
var chtml_Wrappers_ms_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_ms_namespaceObject);
__webpack_require__.d(chtml_Wrappers_ms_namespaceObject, {
  ChtmlMs: () => (ChtmlMs)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtext.js
var Wrappers_mtext_namespaceObject = {};
__webpack_require__.r(Wrappers_mtext_namespaceObject);
__webpack_require__.d(Wrappers_mtext_namespaceObject, {
  CommonMtextMixin: () => (CommonMtextMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtext.js
var chtml_Wrappers_mtext_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mtext_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mtext_namespaceObject, {
  ChtmlMtext: () => (ChtmlMtext)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mspace.js
var Wrappers_mspace_namespaceObject = {};
__webpack_require__.r(Wrappers_mspace_namespaceObject);
__webpack_require__.d(Wrappers_mspace_namespaceObject, {
  CommonMspaceMixin: () => (CommonMspaceMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mspace.js
var chtml_Wrappers_mspace_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mspace_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mspace_namespaceObject, {
  ChtmlMspace: () => (ChtmlMspace)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mpadded.js
var Wrappers_mpadded_namespaceObject = {};
__webpack_require__.r(Wrappers_mpadded_namespaceObject);
__webpack_require__.d(Wrappers_mpadded_namespaceObject, {
  CommonMpaddedMixin: () => (CommonMpaddedMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mpadded.js
var chtml_Wrappers_mpadded_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mpadded_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mpadded_namespaceObject, {
  ChtmlMpadded: () => (ChtmlMpadded)
});

// NAMESPACE OBJECT: ./mjs/output/common/Notation.js
var Notation_namespaceObject = {};
__webpack_require__.r(Notation_namespaceObject);
__webpack_require__.d(Notation_namespaceObject, {
  ARROWDX: () => (ARROWDX),
  ARROWX: () => (ARROWX),
  ARROWY: () => (ARROWY),
  CommonArrow: () => (CommonArrow),
  CommonBorder: () => (CommonBorder),
  CommonBorder2: () => (CommonBorder2),
  CommonDiagonalArrow: () => (CommonDiagonalArrow),
  CommonDiagonalStrike: () => (CommonDiagonalStrike),
  PADDING: () => (PADDING),
  SOLID: () => (SOLID),
  THICKNESS: () => (THICKNESS),
  arrowBBox: () => (arrowBBox),
  arrowBBoxHD: () => (arrowBBoxHD),
  arrowBBoxW: () => (arrowBBoxW),
  arrowDef: () => (arrowDef),
  arrowHead: () => (arrowHead),
  diagonalArrowDef: () => (diagonalArrowDef),
  fullBBox: () => (fullBBox),
  fullBorder: () => (fullBorder),
  fullPadding: () => (fullPadding),
  sideIndex: () => (sideIndex),
  sideNames: () => (sideNames)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/menclose.js
var Wrappers_menclose_namespaceObject = {};
__webpack_require__.r(Wrappers_menclose_namespaceObject);
__webpack_require__.d(Wrappers_menclose_namespaceObject, {
  CommonMencloseMixin: () => (CommonMencloseMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Notation.js
var chtml_Notation_namespaceObject = {};
__webpack_require__.r(chtml_Notation_namespaceObject);
__webpack_require__.d(chtml_Notation_namespaceObject, {
  ARROWDX: () => (ARROWDX),
  ARROWX: () => (ARROWX),
  ARROWY: () => (ARROWY),
  Arrow: () => (Arrow),
  Border: () => (Border),
  Border2: () => (Border2),
  CommonArrow: () => (CommonArrow),
  CommonBorder: () => (CommonBorder),
  CommonBorder2: () => (CommonBorder2),
  CommonDiagonalArrow: () => (CommonDiagonalArrow),
  CommonDiagonalStrike: () => (CommonDiagonalStrike),
  DiagonalArrow: () => (DiagonalArrow),
  DiagonalStrike: () => (DiagonalStrike),
  PADDING: () => (PADDING),
  RenderElement: () => (RenderElement),
  SOLID: () => (SOLID),
  THICKNESS: () => (THICKNESS),
  arrowBBox: () => (arrowBBox),
  arrowBBoxHD: () => (arrowBBoxHD),
  arrowBBoxW: () => (arrowBBoxW),
  arrowDef: () => (arrowDef),
  arrowHead: () => (arrowHead),
  diagonalArrowDef: () => (diagonalArrowDef),
  fullBBox: () => (fullBBox),
  fullBorder: () => (fullBorder),
  fullPadding: () => (fullPadding),
  sideIndex: () => (sideIndex),
  sideNames: () => (sideNames)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/menclose.js
var chtml_Wrappers_menclose_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_menclose_namespaceObject);
__webpack_require__.d(chtml_Wrappers_menclose_namespaceObject, {
  ChtmlMenclose: () => (ChtmlMenclose)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mrow.js
var Wrappers_mrow_namespaceObject = {};
__webpack_require__.r(Wrappers_mrow_namespaceObject);
__webpack_require__.d(Wrappers_mrow_namespaceObject, {
  CommonInferredMrowMixin: () => (CommonInferredMrowMixin),
  CommonMrowMixin: () => (CommonMrowMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mrow.js
var chtml_Wrappers_mrow_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mrow_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mrow_namespaceObject, {
  ChtmlInferredMrow: () => (ChtmlInferredMrow),
  ChtmlMrow: () => (ChtmlMrow)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mfenced.js
var Wrappers_mfenced_namespaceObject = {};
__webpack_require__.r(Wrappers_mfenced_namespaceObject);
__webpack_require__.d(Wrappers_mfenced_namespaceObject, {
  CommonMfencedMixin: () => (CommonMfencedMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mfenced.js
var chtml_Wrappers_mfenced_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mfenced_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mfenced_namespaceObject, {
  ChtmlMfenced: () => (ChtmlMfenced)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mfrac.js
var Wrappers_mfrac_namespaceObject = {};
__webpack_require__.r(Wrappers_mfrac_namespaceObject);
__webpack_require__.d(Wrappers_mfrac_namespaceObject, {
  CommonMfracMixin: () => (CommonMfracMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mfrac.js
var chtml_Wrappers_mfrac_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mfrac_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mfrac_namespaceObject, {
  ChtmlMfrac: () => (ChtmlMfrac)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/msqrt.js
var Wrappers_msqrt_namespaceObject = {};
__webpack_require__.r(Wrappers_msqrt_namespaceObject);
__webpack_require__.d(Wrappers_msqrt_namespaceObject, {
  CommonMsqrtMixin: () => (CommonMsqrtMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/msqrt.js
var chtml_Wrappers_msqrt_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_msqrt_namespaceObject);
__webpack_require__.d(chtml_Wrappers_msqrt_namespaceObject, {
  ChtmlMsqrt: () => (ChtmlMsqrt)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mroot.js
var Wrappers_mroot_namespaceObject = {};
__webpack_require__.r(Wrappers_mroot_namespaceObject);
__webpack_require__.d(Wrappers_mroot_namespaceObject, {
  CommonMrootMixin: () => (CommonMrootMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mroot.js
var chtml_Wrappers_mroot_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mroot_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mroot_namespaceObject, {
  ChtmlMroot: () => (ChtmlMroot)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/msubsup.js
var Wrappers_msubsup_namespaceObject = {};
__webpack_require__.r(Wrappers_msubsup_namespaceObject);
__webpack_require__.d(Wrappers_msubsup_namespaceObject, {
  CommonMsubMixin: () => (CommonMsubMixin),
  CommonMsubsupMixin: () => (CommonMsubsupMixin),
  CommonMsupMixin: () => (CommonMsupMixin)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/scriptbase.js
var scriptbase_namespaceObject = {};
__webpack_require__.r(scriptbase_namespaceObject);
__webpack_require__.d(scriptbase_namespaceObject, {
  CommonScriptbaseMixin: () => (CommonScriptbaseMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/scriptbase.js
var Wrappers_scriptbase_namespaceObject = {};
__webpack_require__.r(Wrappers_scriptbase_namespaceObject);
__webpack_require__.d(Wrappers_scriptbase_namespaceObject, {
  ChtmlScriptbase: () => (ChtmlScriptbase)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/msubsup.js
var chtml_Wrappers_msubsup_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_msubsup_namespaceObject);
__webpack_require__.d(chtml_Wrappers_msubsup_namespaceObject, {
  ChtmlMsub: () => (ChtmlMsub),
  ChtmlMsubsup: () => (ChtmlMsubsup),
  ChtmlMsup: () => (ChtmlMsup)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/munderover.js
var Wrappers_munderover_namespaceObject = {};
__webpack_require__.r(Wrappers_munderover_namespaceObject);
__webpack_require__.d(Wrappers_munderover_namespaceObject, {
  CommonMoverMixin: () => (CommonMoverMixin),
  CommonMunderMixin: () => (CommonMunderMixin),
  CommonMunderoverMixin: () => (CommonMunderoverMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/munderover.js
var chtml_Wrappers_munderover_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_munderover_namespaceObject);
__webpack_require__.d(chtml_Wrappers_munderover_namespaceObject, {
  ChtmlMover: () => (ChtmlMover),
  ChtmlMunder: () => (ChtmlMunder),
  ChtmlMunderover: () => (ChtmlMunderover)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mmultiscripts.js
var Wrappers_mmultiscripts_namespaceObject = {};
__webpack_require__.r(Wrappers_mmultiscripts_namespaceObject);
__webpack_require__.d(Wrappers_mmultiscripts_namespaceObject, {
  CommonMmultiscriptsMixin: () => (CommonMmultiscriptsMixin),
  NextScript: () => (NextScript),
  ScriptNames: () => (ScriptNames)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mmultiscripts.js
var chtml_Wrappers_mmultiscripts_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mmultiscripts_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mmultiscripts_namespaceObject, {
  ChtmlMmultiscripts: () => (ChtmlMmultiscripts)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtable.js
var Wrappers_mtable_namespaceObject = {};
__webpack_require__.r(Wrappers_mtable_namespaceObject);
__webpack_require__.d(Wrappers_mtable_namespaceObject, {
  BREAK_BELOW: () => (BREAK_BELOW),
  CommonMtableMixin: () => (CommonMtableMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtable.js
var chtml_Wrappers_mtable_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mtable_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mtable_namespaceObject, {
  ChtmlMtable: () => (ChtmlMtable)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtr.js
var Wrappers_mtr_namespaceObject = {};
__webpack_require__.r(Wrappers_mtr_namespaceObject);
__webpack_require__.d(Wrappers_mtr_namespaceObject, {
  CommonMlabeledtrMixin: () => (CommonMlabeledtrMixin),
  CommonMtrMixin: () => (CommonMtrMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtr.js
var chtml_Wrappers_mtr_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mtr_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mtr_namespaceObject, {
  ChtmlMlabeledtr: () => (ChtmlMlabeledtr),
  ChtmlMtr: () => (ChtmlMtr)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtd.js
var Wrappers_mtd_namespaceObject = {};
__webpack_require__.r(Wrappers_mtd_namespaceObject);
__webpack_require__.d(Wrappers_mtd_namespaceObject, {
  CommonMtdMixin: () => (CommonMtdMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtd.js
var chtml_Wrappers_mtd_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mtd_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mtd_namespaceObject, {
  ChtmlMtd: () => (ChtmlMtd)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/maction.js
var Wrappers_maction_namespaceObject = {};
__webpack_require__.r(Wrappers_maction_namespaceObject);
__webpack_require__.d(Wrappers_maction_namespaceObject, {
  CommonMactionMixin: () => (CommonMactionMixin),
  TooltipData: () => (TooltipData)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/maction.js
var chtml_Wrappers_maction_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_maction_namespaceObject);
__webpack_require__.d(chtml_Wrappers_maction_namespaceObject, {
  ChtmlMaction: () => (ChtmlMaction)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mglyph.js
var Wrappers_mglyph_namespaceObject = {};
__webpack_require__.r(Wrappers_mglyph_namespaceObject);
__webpack_require__.d(Wrappers_mglyph_namespaceObject, {
  CommonMglyphMixin: () => (CommonMglyphMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mglyph.js
var chtml_Wrappers_mglyph_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_mglyph_namespaceObject);
__webpack_require__.d(chtml_Wrappers_mglyph_namespaceObject, {
  ChtmlMglyph: () => (ChtmlMglyph)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/semantics.js
var Wrappers_semantics_namespaceObject = {};
__webpack_require__.r(Wrappers_semantics_namespaceObject);
__webpack_require__.d(Wrappers_semantics_namespaceObject, {
  CommonSemanticsMixin: () => (CommonSemanticsMixin)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/XmlNode.js
var XmlNode_namespaceObject = {};
__webpack_require__.r(XmlNode_namespaceObject);
__webpack_require__.d(XmlNode_namespaceObject, {
  CommonXmlNodeMixin: () => (CommonXmlNodeMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/semantics.js
var chtml_Wrappers_semantics_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_semantics_namespaceObject);
__webpack_require__.d(chtml_Wrappers_semantics_namespaceObject, {
  ChtmlAnnotation: () => (ChtmlAnnotation),
  ChtmlAnnotationXML: () => (ChtmlAnnotationXML),
  ChtmlSemantics: () => (ChtmlSemantics),
  ChtmlXmlNode: () => (ChtmlXmlNode)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/TeXAtom.js
var Wrappers_TeXAtom_namespaceObject = {};
__webpack_require__.r(Wrappers_TeXAtom_namespaceObject);
__webpack_require__.d(Wrappers_TeXAtom_namespaceObject, {
  CommonTeXAtomMixin: () => (CommonTeXAtomMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/TeXAtom.js
var chtml_Wrappers_TeXAtom_namespaceObject = {};
__webpack_require__.r(chtml_Wrappers_TeXAtom_namespaceObject);
__webpack_require__.d(chtml_Wrappers_TeXAtom_namespaceObject, {
  ChtmlTeXAtom: () => (ChtmlTeXAtom)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/TextNode.js
var TextNode_namespaceObject = {};
__webpack_require__.r(TextNode_namespaceObject);
__webpack_require__.d(TextNode_namespaceObject, {
  CommonTextNodeMixin: () => (CommonTextNodeMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/TextNode.js
var Wrappers_TextNode_namespaceObject = {};
__webpack_require__.r(Wrappers_TextNode_namespaceObject);
__webpack_require__.d(Wrappers_TextNode_namespaceObject, {
  ChtmlTextNode: () => (ChtmlTextNode)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/HtmlNode.js
var Wrappers_HtmlNode_namespaceObject = {};
__webpack_require__.r(Wrappers_HtmlNode_namespaceObject);
__webpack_require__.d(Wrappers_HtmlNode_namespaceObject, {
  ChtmlHtmlNode: () => (ChtmlHtmlNode)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers.js
var Wrappers_namespaceObject = {};
__webpack_require__.r(Wrappers_namespaceObject);
__webpack_require__.d(Wrappers_namespaceObject, {
  ChtmlWrappers: () => (ChtmlWrappers)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/WrapperFactory.js
var chtml_WrapperFactory_namespaceObject = {};
__webpack_require__.r(chtml_WrapperFactory_namespaceObject);
__webpack_require__.d(chtml_WrapperFactory_namespaceObject, {
  ChtmlWrapperFactory: () => (ChtmlWrapperFactory)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/DefaultFont.js
var DefaultFont_namespaceObject = {};
__webpack_require__.r(DefaultFont_namespaceObject);
__webpack_require__.d(DefaultFont_namespaceObject, {
  DefaultFont: () => (DefaultFont),
  fontName: () => (fontName)
});

// NAMESPACE OBJECT: ./mjs/output/chtml.js
var output_chtml_namespaceObject = {};
__webpack_require__.r(output_chtml_namespaceObject);
__webpack_require__.d(output_chtml_namespaceObject, {
  CHTML: () => (CHTML)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/DynamicFonts.js
var DynamicFonts_namespaceObject = {};
__webpack_require__.r(DynamicFonts_namespaceObject);
__webpack_require__.d(DynamicFonts_namespaceObject, {
  AddFontIds: () => (AddFontIds)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/MJContextMenu.js
var MJContextMenu_namespaceObject = {};
__webpack_require__.r(MJContextMenu_namespaceObject);
__webpack_require__.d(MJContextMenu_namespaceObject, {
  MJContextMenu: () => (MJContextMenu)
});

// NAMESPACE OBJECT: ./mjs/a11y/sre.js
var sre_namespaceObject = {};
__webpack_require__.r(sre_namespaceObject);
__webpack_require__.d(sre_namespaceObject, {
  addPreference: () => (sre_addPreference),
  engineSetup: () => (engineSetup),
  fromPreference: () => (sre_fromPreference),
  locales: () => (locales),
  parseDOM: () => (parseDOM),
  setupEngine: () => (setupEngine),
  toEnriched: () => (toEnriched),
  toPreference: () => (sre_toPreference)
});

// NAMESPACE OBJECT: ./mjs/a11y/speech/SpeechMenu.js
var SpeechMenu_namespaceObject = {};
__webpack_require__.r(SpeechMenu_namespaceObject);
__webpack_require__.d(SpeechMenu_namespaceObject, {
  clearspeakMenu: () => (clearspeakMenu),
  localeMenu: () => (localeMenu)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/MenuUtil.js
var MenuUtil_namespaceObject = {};
__webpack_require__.r(MenuUtil_namespaceObject);
__webpack_require__.d(MenuUtil_namespaceObject, {
  copyToClipboard: () => (copyToClipboard),
  isMac: () => (isMac)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/AnnotationMenu.js
var AnnotationMenu_namespaceObject = {};
__webpack_require__.r(AnnotationMenu_namespaceObject);
__webpack_require__.d(AnnotationMenu_namespaceObject, {
  annotation: () => (annotation),
  copyAnnotations: () => (copyAnnotations),
  showAnnotations: () => (showAnnotations)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/RadioCompare.js
var RadioCompare_namespaceObject = {};
__webpack_require__.r(RadioCompare_namespaceObject);
__webpack_require__.d(RadioCompare_namespaceObject, {
  RadioCompare: () => (RadioCompare)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/MmlVisitor.js
var menu_MmlVisitor_namespaceObject = {};
__webpack_require__.r(menu_MmlVisitor_namespaceObject);
__webpack_require__.d(menu_MmlVisitor_namespaceObject, {
  MmlVisitor: () => (MmlVisitor_MmlVisitor)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/SelectableInfo.js
var SelectableInfo_namespaceObject = {};
__webpack_require__.r(SelectableInfo_namespaceObject);
__webpack_require__.d(SelectableInfo_namespaceObject, {
  SelectableInfo: () => (SelectableInfo)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/Menu.js
var Menu_namespaceObject = {};
__webpack_require__.r(Menu_namespaceObject);
__webpack_require__.d(Menu_namespaceObject, {
  Menu: () => (Menu)
});

// NAMESPACE OBJECT: ./mjs/ui/menu/MenuHandler.js
var MenuHandler_namespaceObject = {};
__webpack_require__.r(MenuHandler_namespaceObject);
__webpack_require__.d(MenuHandler_namespaceObject, {
  MenuHandler: () => (MenuHandler),
  MenuMathDocumentMixin: () => (MenuMathDocumentMixin),
  MenuMathItemMixin: () => (MenuMathItemMixin)
});

// NAMESPACE OBJECT: ./mjs/input/mathml/FindMathML.js
var FindMathML_namespaceObject = {};
__webpack_require__.r(FindMathML_namespaceObject);
__webpack_require__.d(FindMathML_namespaceObject, {
  FindMathML: () => (FindMathML)
});

// NAMESPACE OBJECT: ./mjs/input/mathml/MathMLCompile.js
var MathMLCompile_namespaceObject = {};
__webpack_require__.r(MathMLCompile_namespaceObject);
__webpack_require__.d(MathMLCompile_namespaceObject, {
  MathMLCompile: () => (MathMLCompile)
});

// NAMESPACE OBJECT: ./mjs/input/mathml.js
var mathml_namespaceObject = {};
__webpack_require__.r(mathml_namespaceObject);
__webpack_require__.d(mathml_namespaceObject, {
  MathML: () => (MathML)
});

// NAMESPACE OBJECT: ./mjs/a11y/semantic-enrich.js
var semantic_enrich_namespaceObject = {};
__webpack_require__.r(semantic_enrich_namespaceObject);
__webpack_require__.d(semantic_enrich_namespaceObject, {
  EnrichHandler: () => (EnrichHandler),
  EnrichedMathDocumentMixin: () => (EnrichedMathDocumentMixin),
  EnrichedMathItemMixin: () => (EnrichedMathItemMixin),
  enrichVisitor: () => (enrichVisitor)
});

// NAMESPACE OBJECT: ./mjs/a11y/speech/SpeechUtil.js
var SpeechUtil_namespaceObject = {};
__webpack_require__.r(SpeechUtil_namespaceObject);
__webpack_require__.d(SpeechUtil_namespaceObject, {
  InPlace: () => (InPlace),
  SemAttr: () => (SemAttr),
  buildLabel: () => (buildLabel),
  buildSpeech: () => (buildSpeech),
  honk: () => (honk),
  ssmlParsing: () => (ssmlParsing)
});

// NAMESPACE OBJECT: ./mjs/a11y/speech/GeneratorPool.js
var GeneratorPool_namespaceObject = {};
__webpack_require__.r(GeneratorPool_namespaceObject);
__webpack_require__.d(GeneratorPool_namespaceObject, {
  GeneratorPool: () => (GeneratorPool)
});

// NAMESPACE OBJECT: ./mjs/a11y/speech/WebWorker.js
var WebWorker_namespaceObject = {};
__webpack_require__.r(WebWorker_namespaceObject);
__webpack_require__.d(WebWorker_namespaceObject, {
  WorkerHandler: () => (WorkerHandler)
});

// NAMESPACE OBJECT: ./mjs/a11y/speech.js
var speech_namespaceObject = {};
__webpack_require__.r(speech_namespaceObject);
__webpack_require__.d(speech_namespaceObject, {
  SpeechHandler: () => (SpeechHandler),
  SpeechMathDocumentMixin: () => (SpeechMathDocumentMixin),
  SpeechMathItemMixin: () => (SpeechMathItemMixin)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/Highlighter.js
var Highlighter_namespaceObject = {};
__webpack_require__.r(Highlighter_namespaceObject);
__webpack_require__.d(Highlighter_namespaceObject, {
  getHighlighter: () => (getHighlighter)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/Region.js
var Region_namespaceObject = {};
__webpack_require__.r(Region_namespaceObject);
__webpack_require__.d(Region_namespaceObject, {
  AbstractRegion: () => (AbstractRegion),
  DummyRegion: () => (DummyRegion),
  HoverRegion: () => (HoverRegion),
  LiveRegion: () => (LiveRegion),
  SpeechRegion: () => (SpeechRegion),
  StringRegion: () => (StringRegion),
  ToolTip: () => (ToolTip)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/Explorer.js
var Explorer_namespaceObject = {};
__webpack_require__.r(Explorer_namespaceObject);
__webpack_require__.d(Explorer_namespaceObject, {
  AbstractExplorer: () => (AbstractExplorer)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/KeyExplorer.js
var KeyExplorer_namespaceObject = {};
__webpack_require__.r(KeyExplorer_namespaceObject);
__webpack_require__.d(KeyExplorer_namespaceObject, {
  SpeechExplorer: () => (SpeechExplorer),
  hasModifiers: () => (hasModifiers),
  isContainer: () => (isContainer)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/MouseExplorer.js
var MouseExplorer_namespaceObject = {};
__webpack_require__.r(MouseExplorer_namespaceObject);
__webpack_require__.d(MouseExplorer_namespaceObject, {
  AbstractMouseExplorer: () => (AbstractMouseExplorer),
  ContentHoverer: () => (ContentHoverer),
  FlameHoverer: () => (FlameHoverer),
  Hoverer: () => (Hoverer),
  ValueHoverer: () => (ValueHoverer)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/TreeExplorer.js
var TreeExplorer_namespaceObject = {};
__webpack_require__.r(TreeExplorer_namespaceObject);
__webpack_require__.d(TreeExplorer_namespaceObject, {
  AbstractTreeExplorer: () => (AbstractTreeExplorer),
  ContrastPicker: () => (ContrastPicker),
  FlameColorer: () => (FlameColorer),
  TreeColorer: () => (TreeColorer)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer/ExplorerPool.js
var ExplorerPool_namespaceObject = {};
__webpack_require__.r(ExplorerPool_namespaceObject);
__webpack_require__.d(ExplorerPool_namespaceObject, {
  ExplorerPool: () => (ExplorerPool),
  RegionPool: () => (RegionPool)
});

// NAMESPACE OBJECT: ./mjs/a11y/explorer.js
var explorer_namespaceObject = {};
__webpack_require__.r(explorer_namespaceObject);
__webpack_require__.d(explorer_namespaceObject, {
  ExplorerHandler: () => (ExplorerHandler),
  ExplorerMathDocumentMixin: () => (ExplorerMathDocumentMixin),
  ExplorerMathItemMixin: () => (ExplorerMathItemMixin),
  setA11yOption: () => (setA11yOption),
  setA11yOptions: () => (setA11yOptions)
});

;// ./mjs/components/version.js
const VERSION = '4.0.0';
//# sourceMappingURL=version.js.map
;// ./mjs/components/global.js

const defaultGlobal = {};
const GLOBAL = (() => {
    if (typeof window !== 'undefined')
        return window;
    if (typeof global !== 'undefined')
        return global;
    if (typeof globalThis !== 'undefined')
        return globalThis;
    return defaultGlobal;
})();
function isObject(x) {
    return typeof x === 'object' && x !== null;
}
function combineConfig(dst, src, check = false) {
    var _a;
    for (const id of Object.keys(src)) {
        if (id === '__esModule' ||
            dst[id] === src[id] ||
            src[id] === null ||
            src[id] === undefined) {
            continue;
        }
        if (isObject(dst[id]) && isObject(src[id])) {
            combineConfig(dst[id], src[id], check || id === '_');
        }
        else if (!check || !((_a = Object.getOwnPropertyDescriptor(dst, id)) === null || _a === void 0 ? void 0 : _a.get)) {
            dst[id] = src[id];
        }
    }
    return dst;
}
function combineDefaults(dst, name, src) {
    if (!dst[name]) {
        dst[name] = {};
    }
    dst = dst[name];
    for (const id of Object.keys(src)) {
        if (isObject(dst[id]) && isObject(src[id])) {
            combineDefaults(dst, id, src[id]);
        }
        else if (dst[id] == null && src[id] != null) {
            dst[id] = src[id];
        }
    }
    return dst;
}
function combineWithMathJax(config) {
    return combineConfig(global_MathJax, config);
}
if (typeof GLOBAL.MathJax === 'undefined' ||
    GLOBAL.MathJax.constructor !== {}.constructor) {
    GLOBAL.MathJax = {};
}
if (!GLOBAL.MathJax.version) {
    GLOBAL.MathJax = {
        version: VERSION,
        _: {},
        config: GLOBAL.MathJax,
    };
}
const global_MathJax = GLOBAL.MathJax;
//# sourceMappingURL=global.js.map
;// ./mjs/util/context.js
const hasWindow = typeof window !== 'undefined';
const context = {
    window: hasWindow ? window : null,
    document: hasWindow ? window.document : null,
    os: (() => {
        if (hasWindow && window.navigator) {
            const app = window.navigator.appVersion;
            const osNames = [
                ['Win', 'Windows'],
                ['Mac', 'MacOS'],
                ['X11', 'Unix'],
                ['Linux', 'Unix'],
            ];
            for (const [key, os] of osNames) {
                if (app.includes(key)) {
                    return os;
                }
            }
            if (window.navigator.userAgent.includes('Android')) {
                return 'Unix';
            }
        }
        return 'unknown';
    })(),
};
//# sourceMappingURL=context.js.map
;// ./mjs/components/package.js


class PackageError extends Error {
    constructor(message, name) {
        super(message);
        this.package = name;
    }
}
class Package {
    get canLoad() {
        return (this.dependencyCount === 0 &&
            !this.noLoad &&
            !this.isLoading &&
            !this.hasFailed);
    }
    static loadPromise(name) {
        const config = (CONFIG[name] || {});
        const promise = config.extraLoads
            ? Loader.load(...config.extraLoads)
            : Promise.resolve();
        const checkReady = config.checkReady || (() => Promise.resolve());
        return promise.then(() => checkReady());
    }
    static resolvePath(name, addExtension = true) {
        const data = { name, original: name, addExtension };
        Loader.pathFilters.execute(data);
        return data.name;
    }
    static loadAll() {
        for (const extension of this.packages.values()) {
            if (extension.canLoad) {
                extension.load();
            }
        }
    }
    constructor(name, noLoad = false) {
        this.isLoaded = false;
        this.result = {};
        this.isLoading = false;
        this.hasFailed = false;
        this.dependents = [];
        this.dependencies = [];
        this.dependencyCount = 0;
        this.provided = [];
        this.name = name;
        this.noLoad = noLoad;
        Package.packages.set(name, this);
        this.promise = this.makePromise(this.makeDependencies());
    }
    makeDependencies() {
        const promises = [];
        const map = Package.packages;
        const noLoad = this.noLoad;
        const name = this.name;
        const dependencies = [];
        if (Object.hasOwn(CONFIG.dependencies, name)) {
            dependencies.push(...CONFIG.dependencies[name]);
        }
        else if (name !== 'core') {
            dependencies.push('core');
        }
        for (const dependent of dependencies) {
            const extension = map.get(dependent) || new Package(dependent, noLoad);
            if (!this.dependencies.includes(extension)) {
                extension.addDependent(this, noLoad);
                this.dependencies.push(extension);
                if (!extension.isLoaded) {
                    this.dependencyCount++;
                    promises.push(extension.promise);
                }
            }
        }
        return promises;
    }
    makePromise(promises) {
        let promise = new Promise(((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        }));
        const config = (CONFIG[this.name] || {});
        if (config.ready) {
            promise = promise.then((_name) => config.ready(this.name));
        }
        if (promises.length) {
            promises.push(promise);
            promise = Promise.all(promises).then((names) => names.join(', '));
        }
        if (config.failed) {
            promise.catch((message) => config.failed(new PackageError(message, this.name)));
        }
        return promise;
    }
    load() {
        if (!this.isLoaded && !this.isLoading && !this.noLoad) {
            this.isLoading = true;
            const url = Package.resolvePath(this.name);
            if (CONFIG.require) {
                this.loadCustom(url);
            }
            else {
                this.loadScript(url);
            }
        }
    }
    loadCustom(url) {
        try {
            const result = CONFIG.require(url);
            if (result instanceof Promise) {
                result
                    .then((result) => (this.result = result))
                    .then(() => this.checkLoad())
                    .catch((err) => this.failed('Can\'t load "' + url + '"\n' + err.message.trim()));
            }
            else {
                this.result = result;
                this.checkLoad();
            }
        }
        catch (err) {
            this.failed(err.message);
        }
    }
    loadScript(url) {
        const script = context.document.createElement('script');
        script.src = url;
        script.charset = 'UTF-8';
        script.onload = (_event) => this.checkLoad();
        script.onerror = (_event) => this.failed('Can\'t load "' + url + '"');
        context.document.head.appendChild(script);
    }
    loaded() {
        this.isLoaded = true;
        this.isLoading = false;
        for (const dependent of this.dependents) {
            dependent.requirementSatisfied();
        }
        for (const provided of this.provided) {
            provided.loaded();
        }
        this.resolve(this.name);
    }
    failed(message) {
        this.hasFailed = true;
        this.isLoading = false;
        this.reject(new PackageError(message, this.name));
    }
    checkLoad() {
        Package.loadPromise(this.name)
            .then(() => this.loaded())
            .catch((message) => this.failed(message));
    }
    requirementSatisfied() {
        if (this.dependencyCount) {
            this.dependencyCount--;
            if (this.canLoad) {
                this.load();
            }
        }
    }
    provides(names = []) {
        for (const name of names) {
            let provided = Package.packages.get(name);
            if (!provided) {
                if (!CONFIG.dependencies[name]) {
                    CONFIG.dependencies[name] = [];
                }
                CONFIG.dependencies[name].push(name);
                provided = new Package(name, true);
                provided.isLoading = true;
            }
            this.provided.push(provided);
        }
    }
    addDependent(extension, noLoad) {
        this.dependents.push(extension);
        if (!noLoad) {
            this.checkNoLoad();
        }
    }
    checkNoLoad() {
        if (this.noLoad) {
            this.noLoad = false;
            for (const dependency of this.dependencies) {
                dependency.checkNoLoad();
            }
        }
    }
}
Package.packages = new Map();
//# sourceMappingURL=package.js.map
;// ./mjs/util/PrioritizedList.js
class PrioritizedList {
    constructor() {
        this.items = [];
        this.items = [];
    }
    [Symbol.iterator]() {
        let i = 0;
        const items = this.items;
        return {
            next() {
                return { value: items[i++], done: i > items.length };
            },
        };
    }
    add(item, priority = PrioritizedList.DEFAULTPRIORITY) {
        let i = this.items.length;
        do {
            i--;
        } while (i >= 0 && priority < this.items[i].priority);
        this.items.splice(i + 1, 0, { item: item, priority: priority });
        return item;
    }
    remove(item) {
        let i = this.items.length;
        do {
            i--;
        } while (i >= 0 && this.items[i].item !== item);
        if (i >= 0) {
            this.items.splice(i, 1);
        }
        return this;
    }
}
PrioritizedList.DEFAULTPRIORITY = 5;
//# sourceMappingURL=PrioritizedList.js.map
;// ./mjs/util/FunctionList.js

class FunctionList extends PrioritizedList {
    constructor(list = null) {
        super();
        if (list) {
            this.addList(list);
        }
    }
    addList(list) {
        for (const item of list) {
            if (Array.isArray(item)) {
                this.add(item[0], item[1]);
            }
            else {
                this.add(item);
            }
        }
    }
    execute(...data) {
        for (const item of this) {
            const result = item.item(...data);
            if (result === false) {
                return false;
            }
        }
        return true;
    }
    asyncExecute(...data) {
        let i = -1;
        const items = this.items;
        return new Promise((ok, fail) => {
            (function execute() {
                while (++i < items.length) {
                    const result = items[i].item(...data);
                    if (result instanceof Promise) {
                        result.then(execute).catch((err) => fail(err));
                        return;
                    }
                    if (result === false) {
                        ok(false);
                        return;
                    }
                }
                ok(true);
            })();
        });
    }
}
//# sourceMappingURL=FunctionList.js.map
;// ./mjs/components/mjs/root.js
//
//  Replacement for __dirname for root directory
//



const config = global_MathJax.config || {};
const mjxRoot = () => config?.loader?.paths?.mathjax || config?.__dirname || '/';

;// ./mjs/components/loader.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const PathFilters = {
    source: (data) => {
        if (Object.hasOwn(CONFIG.source, data.name)) {
            data.name = CONFIG.source[data.name];
        }
        return true;
    },
    normalize: (data) => {
        const name = data.name;
        if (!name.match(/^(?:[a-z]+:\/)?\/|[a-z]:\\|\[/i)) {
            data.name = '[mathjax]/' + name.replace(/^\.\//, '');
        }
        return true;
    },
    prefix: (data) => {
        let match;
        while ((match = data.name.match(/^\[([^\]]*)\]/))) {
            if (!Object.hasOwn(CONFIG.paths, match[1]))
                break;
            data.name = CONFIG.paths[match[1]] + data.name.substring(match[0].length);
        }
        return true;
    },
    addExtension: (data) => {
        if (data.addExtension && !data.name.match(/\.[^/]+$/)) {
            data.name += '.js';
        }
        return true;
    },
};
const loader_VERSION = global_MathJax.version;
const Loader = {
    versions: new Map(),
    nestedLoads: [],
    ready(...names) {
        if (names.length === 0) {
            names = Array.from(Package.packages.keys());
        }
        const promises = [];
        for (const name of names) {
            const extension = Package.packages.get(name) || new Package(name, true);
            promises.push(extension.promise);
        }
        return Promise.all(promises);
    },
    load(...names) {
        if (names.length === 0) {
            return Promise.resolve([]);
        }
        let nested = [];
        this.nestedLoads.unshift(nested);
        const promise = Promise.resolve().then(() => __awaiter(this, void 0, void 0, function* () {
            const promises = [];
            for (const name of names) {
                let extension = Package.packages.get(name);
                if (!extension) {
                    extension = new Package(name);
                    extension.provides(CONFIG.provides[name]);
                }
                extension.checkNoLoad();
                promises.push(extension.promise.then(() => {
                    if (CONFIG.versionWarnings &&
                        extension.isLoaded &&
                        !Loader.versions.has(Package.resolvePath(name))) {
                        console.warn(`No version information available for component ${name}`);
                    }
                    return extension.result;
                }));
            }
            Package.loadAll();
            const result = yield Promise.all(promises);
            while (nested.length) {
                const promise = Promise.all(nested);
                nested = this.nestedLoads[this.nestedLoads.indexOf(nested)] = [];
                yield promise;
            }
            this.nestedLoads.splice(this.nestedLoads.indexOf(nested), 1);
            return result;
        }));
        this.nestedLoads
            .slice(1)
            .forEach((list) => list.push(promise));
        return promise;
    },
    preLoaded(...names) {
        for (const name of names) {
            let extension = Package.packages.get(name);
            if (!extension) {
                extension = new Package(name, true);
                extension.provides(CONFIG.provides[name]);
            }
            extension.loaded();
        }
    },
    addPackageData(name, data) {
        let config = CONFIG[name];
        if (!config) {
            config = CONFIG[name] = {};
        }
        for (const [key, value] of Object.entries(data)) {
            if (Array.isArray(value)) {
                if (!config[key]) {
                    config[key] = [];
                }
                const set = new Set([...config[key], ...value]);
                config[key] = [...set];
            }
            else {
                config[key] = value;
            }
        }
    },
    defaultReady() {
        if (typeof loader_MathJax.startup !== 'undefined') {
            loader_MathJax.config.startup.ready();
        }
    },
    getRoot() {
        if (context.document) {
            const script = context.document.currentScript ||
                context.document.getElementById('MathJax-script');
            if (script && script instanceof HTMLScriptElement) {
                return script.src.replace(/\/[^/]*$/, '');
            }
        }
        return mjxRoot();
    },
    checkVersion(name, version, _type) {
        this.saveVersion(name);
        if (CONFIG.versionWarnings && version !== loader_VERSION) {
            console.warn(`Component ${name} uses ${version} of MathJax; version in use is ${loader_VERSION}`);
            return true;
        }
        return false;
    },
    saveVersion(name) {
        Loader.versions.set(Package.resolvePath(name), loader_VERSION);
    },
    pathFilters: new FunctionList(),
};
Loader.pathFilters.add(PathFilters.source, 0);
Loader.pathFilters.add(PathFilters.normalize, 10);
Loader.pathFilters.add(PathFilters.prefix, 20);
Loader.pathFilters.add(PathFilters.addExtension, 30);
const loader_MathJax = global_MathJax;
if (typeof loader_MathJax.loader === 'undefined') {
    combineDefaults(loader_MathJax.config, 'loader', {
        paths: {
            mathjax: Loader.getRoot(),
        },
        source: {},
        dependencies: {},
        provides: {},
        load: [],
        ready: Loader.defaultReady.bind(Loader),
        failed: (error) => console.log(`MathJax(${error.package || '?'}): ${error.message}`),
        require: null,
        pathFilters: [],
        versionWarnings: true,
    });
    combineWithMathJax({
        loader: Loader,
    });
    for (const filter of loader_MathJax.config.loader.pathFilters) {
        if (Array.isArray(filter)) {
            Loader.pathFilters.add(filter[0], filter[1]);
        }
        else {
            Loader.pathFilters.add(filter);
        }
    }
}
const CONFIG = loader_MathJax.config.loader;
//# sourceMappingURL=loader.js.map
;// ./mjs/util/Options.js
const OBJECT = {}.constructor;
function Options_isObject(obj) {
    return (typeof obj === 'object' &&
        obj !== null &&
        (obj.constructor === OBJECT || obj.constructor === Expandable));
}
const APPEND = '[+]';
const REMOVE = '[-]';
const OPTIONS = {
    invalidOption: 'warn',
    optionError: (message, _key) => {
        if (OPTIONS.invalidOption === 'fatal') {
            throw new Error(message);
        }
        console.warn('MathJax: ' + message);
    },
};
class Expandable {
}
function expandable(def) {
    return Object.assign(Object.create(Expandable.prototype), def);
}
function makeArray(x) {
    return Array.isArray(x) ? x : [x];
}
function keys(def) {
    if (!def) {
        return [];
    }
    return Object.keys(def).concat(Object.getOwnPropertySymbols(def));
}
function copy(def) {
    const props = {};
    for (const key of keys(def)) {
        const prop = Object.getOwnPropertyDescriptor(def, key);
        const value = prop.value;
        if (Array.isArray(value)) {
            prop.value = insert([], value, false);
        }
        else if (Options_isObject(value)) {
            prop.value = copy(value);
        }
        if (prop.enumerable) {
            props[key] = prop;
        }
    }
    return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);
}
function insert(dst, src, warn = true) {
    for (let key of keys(src)) {
        if (warn && dst[key] === undefined && dst.constructor !== Expandable) {
            if (typeof key === 'symbol') {
                key = key.toString();
            }
            OPTIONS.optionError(`Invalid option "${key}" (no default value).`, key);
            continue;
        }
        const sval = src[key];
        let dval = dst[key];
        if (Options_isObject(sval) &&
            dval !== null &&
            (typeof dval === 'object' || typeof dval === 'function')) {
            const ids = keys(sval);
            if (Array.isArray(dval) &&
                ((ids.length === 1 &&
                    (ids[0] === APPEND || ids[0] === REMOVE) &&
                    Array.isArray(sval[ids[0]])) ||
                    (ids.length === 2 &&
                        ids.sort().join(',') === APPEND + ',' + REMOVE &&
                        Array.isArray(sval[APPEND]) &&
                        Array.isArray(sval[REMOVE])))) {
                if (sval[REMOVE]) {
                    dval = dst[key] = dval.filter((x) => sval[REMOVE].indexOf(x) < 0);
                }
                if (sval[APPEND]) {
                    dst[key] = [...dval, ...sval[APPEND]];
                }
            }
            else {
                insert(dval, sval, warn);
            }
        }
        else if (Array.isArray(sval)) {
            dst[key] = [];
            insert(dst[key], sval, false);
        }
        else if (Options_isObject(sval)) {
            dst[key] = copy(sval);
        }
        else {
            dst[key] = sval;
        }
    }
    return dst;
}
function defaultOptions(options, ...defs) {
    defs.forEach((def) => insert(options, def, false));
    return options;
}
function userOptions(options, ...defs) {
    defs.forEach((def) => insert(options, def, true));
    return options;
}
function selectOptions(options, ...keys) {
    const subset = {};
    for (const key of keys) {
        if (Object.hasOwn(options, key)) {
            subset[key] = options[key];
        }
    }
    return subset;
}
function selectOptionsFromKeys(options, object) {
    return selectOptions(options, ...Object.keys(object));
}
function separateOptions(options, ...objects) {
    const results = [];
    for (const object of objects) {
        const exists = {}, missing = {};
        for (const key of Object.keys(options || {})) {
            (object[key] === undefined ? missing : exists)[key] = options[key];
        }
        results.push(exists);
        options = missing;
    }
    results.unshift(options);
    return results;
}
function lookup(name, lookup, def = null) {
    return Object.hasOwn(lookup, name) ? lookup[name] : def;
}
//# sourceMappingURL=Options.js.map
;// ./mjs/components/startup.js
var startup_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




class Startup {
    static toMML(node) {
        return Startup.visitor.visitTree(node, this.document);
    }
    static registerConstructor(name, constructor) {
        Startup.constructors[name] = constructor;
    }
    static useHandler(name, force = false) {
        if (!startup_CONFIG.handler || force) {
            startup_CONFIG.handler = name;
        }
    }
    static useAdaptor(name, force = false) {
        if (!startup_CONFIG.adaptor || force) {
            startup_CONFIG.adaptor = name;
        }
    }
    static useInput(name, force = false) {
        if (!inputSpecified || force) {
            startup_CONFIG.input.push(name);
        }
    }
    static useOutput(name, force = false) {
        if (!startup_CONFIG.output || force) {
            startup_CONFIG.output = name;
        }
    }
    static extendHandler(extend, priority = 10) {
        Startup.extensions.add(extend, priority);
    }
    static defaultReady() {
        Startup.getComponents();
        Startup.makeMethods();
        Startup.pagePromise
            .then(() => startup_CONFIG.pageReady())
            .then(() => Startup.promiseResolve())
            .catch((err) => Startup.promiseReject(err));
    }
    static defaultPageReady() {
        return (startup_CONFIG.loadAllFontFiles && Startup.output.font
            ? Startup.output.font.loadDynamicFiles()
            : Promise.resolve())
            .then(() => { var _a; return (_a = Startup.document.menu) === null || _a === void 0 ? void 0 : _a.loadingPromise; })
            .then(startup_CONFIG.typeset && startup_MathJax.typesetPromise
            ? () => Startup.typesetPromise(startup_CONFIG.elements)
            : Promise.resolve())
            .then(() => Startup.promiseResolve());
    }
    static typesetPromise(elements) {
        this.hasTypeset = true;
        return Startup.document.whenReady(() => startup_awaiter(this, void 0, void 0, function* () {
            Startup.document.options.elements = elements;
            Startup.document.reset();
            yield Startup.document.renderPromise();
        }));
    }
    static getComponents() {
        Startup.visitor =
            new startup_MathJax._.core.MmlTree.SerializedMmlVisitor.SerializedMmlVisitor();
        Startup.mathjax = startup_MathJax._.mathjax.mathjax;
        Startup.input = Startup.getInputJax();
        Startup.output = Startup.getOutputJax();
        Startup.adaptor = Startup.getAdaptor();
        if (Startup.handler) {
            Startup.mathjax.handlers.unregister(Startup.handler);
        }
        Startup.handler = Startup.getHandler();
        if (Startup.handler) {
            Startup.mathjax.handlers.register(Startup.handler);
            Startup.document = Startup.getDocument();
        }
    }
    static makeMethods() {
        if (Startup.input && Startup.output) {
            Startup.makeTypesetMethods();
        }
        const oname = Startup.output ? Startup.output.name.toLowerCase() : '';
        for (const jax of Startup.input) {
            const iname = jax.name.toLowerCase();
            Startup.makeMmlMethods(iname, jax);
            Startup.makeResetMethod(iname, jax);
            if (Startup.output) {
                Startup.makeOutputMethods(iname, oname, jax);
            }
        }
        startup_MathJax.done = () => Startup.document.done();
        startup_MathJax.whenReady = (action) => Startup.document.whenReady(action);
    }
    static makeTypesetMethods() {
        startup_MathJax.typeset = (elements = null) => {
            this.hasTypeset = true;
            Startup.document.options.elements = elements;
            Startup.document.reset();
            Startup.document.render();
        };
        startup_MathJax.typesetPromise = (elements = null) => {
            return Startup.typesetPromise(elements);
        };
        startup_MathJax.typesetClear = (elements = null) => {
            if (elements) {
                Startup.document.clearMathItemsWithin(elements);
            }
            else {
                Startup.document.clear();
            }
        };
    }
    static makeOutputMethods(iname, oname, input) {
        const name = iname + '2' + oname;
        startup_MathJax[name] = (math, options = {}) => {
            options = Object.assign(Object.assign({}, options), { format: input.name });
            return Startup.document.convert(math, options);
        };
        startup_MathJax[name + 'Promise'] = (math, options = {}) => {
            options = Object.assign(Object.assign({}, options), { format: input.name });
            return Startup.document.convertPromise(math, options);
        };
        startup_MathJax[oname + 'Stylesheet'] = () => Startup.output.styleSheet(Startup.document);
        if ('getMetricsFor' in Startup.output) {
            startup_MathJax.getMetricsFor = (node, display) => {
                return Startup.output.getMetricsFor(node, display);
            };
        }
    }
    static makeMmlMethods(name, input) {
        const STATE = startup_MathJax._.core.MathItem.STATE;
        startup_MathJax[name + '2mml'] = (math, options = {}) => {
            options = Object.assign(Object.assign({}, options), { end: STATE.CONVERT, format: input.name });
            return Startup.toMML(Startup.document.convert(math, options));
        };
        startup_MathJax[name + '2mmlPromise'] = (math_1, ...args_1) => startup_awaiter(this, [math_1, ...args_1], void 0, function* (math, options = {}) {
            options = Object.assign(Object.assign({}, options), { end: STATE.CONVERT, format: input.name });
            const node = yield Startup.document.convertPromise(math, options);
            return Startup.toMML(node);
        });
    }
    static makeResetMethod(name, input) {
        startup_MathJax[name + 'Reset'] = (...args) => input.reset(...args);
    }
    static getInputJax() {
        const jax = [];
        for (const name of startup_CONFIG.input) {
            const inputClass = Startup.constructors[name];
            if (inputClass) {
                jax[name] = new inputClass(startup_MathJax.config[name]);
                jax.push(jax[name]);
            }
            else {
                throw Error('Input Jax "' + name + '" is not defined (has it been loaded?)');
            }
        }
        return jax;
    }
    static getOutputJax() {
        const name = startup_CONFIG.output;
        if (!name)
            return null;
        const outputClass = Startup.constructors[name];
        if (!outputClass) {
            throw Error('Output Jax "' + name + '" is not defined (has it been loaded?)');
        }
        return new outputClass(startup_MathJax.config[name]);
    }
    static getAdaptor() {
        const name = startup_CONFIG.adaptor;
        if (!name || name === 'none')
            return null;
        const adaptor = Startup.constructors[name];
        if (!adaptor) {
            throw Error('DOMAdaptor "' + name + '" is not defined (has it been loaded?)');
        }
        return adaptor(startup_MathJax.config[name]);
    }
    static getHandler() {
        const name = startup_CONFIG.handler;
        if (!name || name === 'none' || !Startup.adaptor)
            return null;
        const handlerClass = Startup.constructors[name];
        if (!handlerClass) {
            throw Error('Handler "' + name + '" is not defined (has it been loaded?)');
        }
        let handler = new handlerClass(Startup.adaptor, 5);
        for (const extend of Startup.extensions) {
            handler = extend.item(handler);
        }
        return handler;
    }
    static getDocument(root = null) {
        return Startup.mathjax.document(root || startup_CONFIG.document, Object.assign(Object.assign({}, startup_MathJax.config.options), { InputJax: Startup.input, OutputJax: Startup.output }));
    }
}
Startup.extensions = new PrioritizedList();
Startup.constructors = {};
Startup.input = [];
Startup.output = null;
Startup.handler = null;
Startup.adaptor = null;
Startup.elements = null;
Startup.document = null;
Startup.promise = new Promise((resolve, reject) => {
    Startup.promiseResolve = resolve;
    Startup.promiseReject = reject;
});
Startup.pagePromise = new Promise((resolve, _reject) => {
    const doc = GLOBAL.document;
    if (!doc ||
        !doc.readyState ||
        doc.readyState === 'complete' ||
        doc.readyState === 'interactive') {
        resolve();
    }
    else {
        const listener = () => resolve();
        doc.defaultView.addEventListener('load', listener, true);
        doc.defaultView.addEventListener('DOMContentLoaded', listener, true);
    }
});
Startup.hasTypeset = false;
Startup.defaultOptionError = OPTIONS.optionError;
const startup_MathJax = global_MathJax;
if (typeof startup_MathJax._.startup === 'undefined') {
    combineDefaults(startup_MathJax.config, 'startup', {
        input: [],
        output: '',
        handler: null,
        adaptor: null,
        document: context.document || '',
        elements: null,
        typeset: true,
        ready: Startup.defaultReady.bind(Startup),
        pageReady: Startup.defaultPageReady.bind(Startup),
    });
    combineWithMathJax({
        startup: Startup,
        options: {},
    });
    if (startup_MathJax.config.startup.invalidOption) {
        OPTIONS.invalidOption = startup_MathJax.config.startup.invalidOption;
    }
    if (startup_MathJax.config.startup.optionError) {
        OPTIONS.optionError = startup_MathJax.config.startup.optionError;
    }
}
const startup_CONFIG = startup_MathJax.config.startup;
const inputSpecified = startup_CONFIG.input.length !== 0;
//# sourceMappingURL=startup.js.map
;// ./components/mjs/startup/lib/startup.js







if (MathJax.loader) {
  MathJax.loader.checkVersion('startup', VERSION, 'startup');
}

combineWithMathJax({_: {
  components: {
    loader: loader_namespaceObject,
    package: package_namespaceObject,
    startup: startup_namespaceObject
  }
}});

;// ./components/mjs/dependencies.js
/*************************************************************
 *
 *  Copyright (c) 2019-2025 The MathJax Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

const dependencies = {
  'a11y/semantic-enrich': ['input/mml', 'a11y/sre'],
  'a11y/speech': ['a11y/semantic-enrich'],
  'a11y/complexity': ['a11y/semantic-enrich'],
  'a11y/explorer': ['a11y/speech'],
  '[mml]/mml3': ['input/mml'],
  '[tex]/action': ['input/tex-base'],
  '[tex]/ams': ['input/tex-base', '[tex]/newcommand'],
  '[tex]/amscd': ['input/tex-base'],
  '[tex]/autoload': ['input/tex-base', '[tex]/require'],
  '[tex]/bbm': ['input/tex-base'],
  '[tex]/bboldx': ['input/tex-base', '[tex]/textmacros'],
  '[tex]/bbox': ['input/tex-base'],
  '[tex]/begingroup': ['input/tex-base', '[tex]/newcommand'],
  '[tex]/boldsymbol': ['input/tex-base'],
  '[tex]/braket': ['input/tex-base'],
  '[tex]/bussproofs': ['input/tex-base'],
  '[tex]/cancel': ['input/tex-base', '[tex]/enclose'],
  '[tex]/cases': ['[tex]/empheq'],
  '[tex]/centernot': ['input/tex-base'],
  '[tex]/color': ['input/tex-base'],
  '[tex]/colortbl': ['input/tex-base', '[tex]/color'],
  '[tex]/colorv2': ['input/tex-base'],
  '[tex]/configmacros': ['input/tex-base', '[tex]/newcommand'],
  '[tex]/dsfont': ['input/tex-base'],
  '[tex]/empheq': ['input/tex-base', '[tex]/ams'],
  '[tex]/enclose': ['input/tex-base'],
  '[tex]/extpfeil': ['input/tex-base', '[tex]/newcommand', '[tex]/ams'],
  '[tex]/gensymb': ['input/tex-base'],
  '[tex]/html': ['input/tex-base'],
  '[tex]/mathtools': ['input/tex-base', '[tex]/newcommand', '[tex]/ams', '[tex]/boldsymbol'],
  '[tex]/mhchem': ['input/tex-base', '[tex]/ams'],
  '[tex]/newcommand': ['input/tex-base'],
  '[tex]/noerrors': ['input/tex-base'],
  '[tex]/noundefined': ['input/tex-base'],
  '[tex]/physics': ['input/tex-base'],
  '[tex]/require': ['input/tex-base'],
  '[tex]/setoptions': ['input/tex-base'],
  '[tex]/tagformat': ['input/tex-base'],
  '[tex]/texhtml': ['input/tex-base'],
  '[tex]/textcomp': ['input/tex-base', '[tex]/textmacros'],
  '[tex]/textmacros': ['input/tex-base'],
  '[tex]/unicode': ['input/tex-base'],
  '[tex]/units': ['input/tex-base'],
  '[tex]/upgreek': ['input/tex-base'],
  '[tex]/verb': ['input/tex-base'],
  'ui/menu': ['a11y/sre'],
};

const paths = {
  tex: '[mathjax]/input/tex/extensions',
  mml: '[mathjax]/input/mml/extensions',
  sre: '[mathjax]/sre',
  mathmaps: '[sre]/mathmaps',
};

const provides = {
  'startup': ['loader'],
  'input/tex': [
    'input/tex-base',
    '[tex]/ams',
    '[tex]/newcommand',
    '[tex]/textmacros',
    '[tex]/noundefined',
    '[tex]/require',
    '[tex]/autoload',
    '[tex]/configmacros'
  ]
};

//
//  Compatibility with v3.0 names for TeX extensions
//
const compatibility = {
  '[tex]/amsCd': '[tex]/amscd',
  '[tex]/colorV2': '[tex]/colorv2',
  '[tex]/configMacros': '[tex]/configmacros',
  '[tex]/tagFormat': '[tex]/tagformat'
};

;// ./components/mjs/startup/init.js






Loader.preLoaded('loader', 'startup');

combineDefaults(MathJax.config.loader, 'dependencies', dependencies);
combineDefaults(MathJax.config.loader, 'paths', paths);
combineDefaults(MathJax.config.loader, 'provides', provides);
combineDefaults(MathJax.config.loader, 'source', compatibility);

function startup(ready) {
  return Loader.load(...CONFIG.load)
               .then(() => (ready || function () {})())
               .then(() => CONFIG.ready())
               .catch(error => CONFIG.failed(error));
}

;// ./mjs/core/DOMAdaptor.js
class AbstractDOMAdaptor {
    constructor(document = null) {
        this.canMeasureNodes = true;
        this.document = document;
    }
    node(kind, def = {}, children = [], ns) {
        const node = this.create(kind, ns);
        this.setAttributes(node, def);
        for (const child of children) {
            this.append(node, child);
        }
        return node;
    }
    setProperty(node, name, value) {
        node[name] = value;
    }
    getProperty(node, name) {
        return node[name];
    }
    setAttributes(node, def) {
        if (def.style && typeof def.style !== 'string') {
            for (const key of Object.keys(def.style)) {
                this.setStyle(node, key.replace(/-([a-z])/g, (_m, c) => c.toUpperCase()), def.style[key]);
            }
        }
        if (def.properties) {
            for (const key of Object.keys(def.properties)) {
                node[key] = def.properties[key];
            }
        }
        for (const key of Object.keys(def)) {
            if ((key !== 'style' || typeof def.style === 'string') &&
                key !== 'properties') {
                this.setAttribute(node, key, def[key]);
            }
        }
    }
    replace(nnode, onode) {
        this.insert(nnode, onode);
        this.remove(onode);
        return onode;
    }
    childNode(node, i) {
        return this.childNodes(node)[i];
    }
    allClasses(node) {
        const classes = this.getAttribute(node, 'class');
        return !classes
            ? []
            : classes
                .replace(/  +/g, ' ')
                .replace(/^ /, '')
                .replace(/ $/, '')
                .split(/ /);
    }
    cssText(node) {
        return this.kind(node) === 'style' ? this.textContent(node) : '';
    }
}
//# sourceMappingURL=DOMAdaptor.js.map
;// ./mjs/adaptors/HTMLAdaptor.js
var HTMLAdaptor_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class HTMLAdaptor extends AbstractDOMAdaptor {
    constructor(window) {
        super(window.document);
        this.canMeasureNodes = true;
        this.window = window;
        this.parser = new window.DOMParser();
    }
    parse(text, format = 'text/html') {
        return this.parser.parseFromString(text, format);
    }
    create(kind, ns) {
        return ns
            ? this.document.createElementNS(ns, kind)
            : this.document.createElement(kind);
    }
    text(text) {
        return this.document.createTextNode(text);
    }
    head(doc = this.document) {
        return doc.head || doc;
    }
    body(doc = this.document) {
        return doc.body || doc;
    }
    root(doc = this.document) {
        return doc.documentElement || doc;
    }
    doctype(doc = this.document) {
        return doc.doctype ? `<!DOCTYPE ${doc.doctype.name}>` : '';
    }
    tags(node, name, ns = null) {
        const nodes = ns
            ? node.getElementsByTagNameNS(ns, name)
            : node.getElementsByTagName(name);
        return Array.from(nodes);
    }
    getElements(nodes, _document) {
        let containers = [];
        for (const node of nodes) {
            if (typeof node === 'string') {
                containers = containers.concat(Array.from(this.document.querySelectorAll(node)));
            }
            else if (Array.isArray(node)) {
                containers = containers.concat(Array.from(node));
            }
            else if (node instanceof this.window.NodeList ||
                node instanceof this.window.HTMLCollection) {
                containers = containers.concat(Array.from(node));
            }
            else {
                containers.push(node);
            }
        }
        return containers;
    }
    getElement(selector, node = this.document) {
        return node.querySelector(selector);
    }
    contains(container, node) {
        return container.contains(node);
    }
    parent(node) {
        return node.parentNode;
    }
    append(node, child) {
        return node.appendChild(child);
    }
    insert(nchild, ochild) {
        return this.parent(ochild).insertBefore(nchild, ochild);
    }
    remove(child) {
        return this.parent(child).removeChild(child);
    }
    replace(nnode, onode) {
        return this.parent(onode).replaceChild(nnode, onode);
    }
    clone(node, deep = true) {
        return node.cloneNode(deep);
    }
    split(node, n) {
        return node.splitText(n);
    }
    next(node) {
        return node.nextSibling;
    }
    previous(node) {
        return node.previousSibling;
    }
    firstChild(node) {
        return node.firstChild;
    }
    lastChild(node) {
        return node.lastChild;
    }
    childNodes(node) {
        return Array.from(node.childNodes);
    }
    childNode(node, i) {
        return node.childNodes[i];
    }
    kind(node) {
        const n = node.nodeType;
        return n === 1 || n === 3 || n === 8 ? node.nodeName.toLowerCase() : '';
    }
    value(node) {
        return node.nodeValue || '';
    }
    textContent(node) {
        return node.textContent;
    }
    innerHTML(node) {
        return node.innerHTML;
    }
    outerHTML(node) {
        return node.outerHTML;
    }
    serializeXML(node) {
        const serializer = new this.window.XMLSerializer();
        return serializer.serializeToString(node);
    }
    setAttribute(node, name, value, ns = null) {
        if (!ns) {
            return node.setAttribute(name, value);
        }
        name = ns.replace(/.*\//, '') + ':' + name.replace(/^.*:/, '');
        return node.setAttributeNS(ns, name, value);
    }
    getAttribute(node, name) {
        return node.getAttribute(name);
    }
    removeAttribute(node, name) {
        return node.removeAttribute(name);
    }
    hasAttribute(node, name) {
        return node.hasAttribute(name);
    }
    allAttributes(node) {
        return Array.from(node.attributes).map((x) => {
            return { name: x.name, value: x.value };
        });
    }
    addClass(node, name) {
        if (node.classList) {
            node.classList.add(name);
        }
        else {
            node.className = (node.className + ' ' + name).trim();
        }
    }
    removeClass(node, name) {
        if (node.classList) {
            node.classList.remove(name);
        }
        else {
            node.className = node.className
                .split(/ /)
                .filter((c) => c !== name)
                .join(' ');
        }
    }
    hasClass(node, name) {
        if (node.classList) {
            return node.classList.contains(name);
        }
        return node.className.split(/ /).includes(name);
    }
    setStyle(node, name, value) {
        node.style[name] = value;
    }
    getStyle(node, name) {
        return node.style[name];
    }
    allStyles(node) {
        return node.style.cssText;
    }
    insertRules(node, rules) {
        for (const rule of rules) {
            try {
                node.sheet.insertRule(rule, node.sheet.cssRules.length);
            }
            catch (e) {
                console.warn(`MathJax: can't insert css rule '${rule}': ${e.message}`);
            }
        }
    }
    cssText(node) {
        if (this.kind(node) !== 'style') {
            return '';
        }
        return Array.from(node.sheet.cssRules)
            .map((rule) => rule.cssText)
            .join('\n');
    }
    fontSize(node) {
        const style = this.window.getComputedStyle(node);
        return parseFloat(style.fontSize);
    }
    fontFamily(node) {
        const style = this.window.getComputedStyle(node);
        return style.fontFamily || '';
    }
    nodeSize(node, em = 1, local = false) {
        if (local && node.getBBox) {
            const { width, height } = node.getBBox();
            return [width / em, height / em];
        }
        return [node.offsetWidth / em, node.offsetHeight / em];
    }
    nodeBBox(node) {
        const { left, right, top, bottom } = node.getBoundingClientRect();
        return { left, right, top, bottom };
    }
    createWorker(listener, options) {
        return HTMLAdaptor_awaiter(this, void 0, void 0, function* () {
            const { path, maps, worker } = options;
            const file = `${path}/${worker}`;
            const content = `
      self.maps = '${quoted(maps)}';
      importScripts('${quoted(file)}');
    `;
            const url = URL.createObjectURL(new Blob([content], { type: 'text/javascript' }));
            const webworker = new Worker(url);
            webworker.onmessage = listener;
            URL.revokeObjectURL(url);
            return webworker;
        });
    }
}
function quoted(text) {
    return [...text]
        .map((c) => {
        if (c === '\\' || c === "'") {
            c = '\\' + c;
        }
        else if (c < ' ' || c > '\u007e') {
            c = `\\u{${c.codePointAt(0).toString(16)}}`;
        }
        return c;
    })
        .join('');
}
//# sourceMappingURL=HTMLAdaptor.js.map
;// ./mjs/adaptors/browserAdaptor.js

function browserAdaptor() {
    return new HTMLAdaptor(window);
}
//# sourceMappingURL=browserAdaptor.js.map
;// ./mjs/core/FindMath.js

class AbstractFindMath {
    constructor(options) {
        const CLASS = this.constructor;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
    }
}
AbstractFindMath.OPTIONS = {};
//# sourceMappingURL=FindMath.js.map
;// ./mjs/core/InputJax.js


class AbstractInputJax {
    constructor(options = {}) {
        this.adaptor = null;
        this.mmlFactory = null;
        const CLASS = this.constructor;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
        this.preFilters = new FunctionList(this.options.preFilters);
        this.postFilters = new FunctionList(this.options.postFilters);
    }
    get name() {
        return this.constructor.NAME;
    }
    setAdaptor(adaptor) {
        this.adaptor = adaptor;
    }
    setMmlFactory(mmlFactory) {
        this.mmlFactory = mmlFactory;
    }
    initialize() { }
    reset(..._args) { }
    get processStrings() {
        return true;
    }
    findMath(_node, _options) {
        return [];
    }
    executeFilters(filters, math, document, data) {
        const args = { math: math, document: document, data: data };
        filters.execute(args);
        return args.data;
    }
}
AbstractInputJax.NAME = 'generic';
AbstractInputJax.OPTIONS = {
    preFilters: [],
    postFilters: [],
};
//# sourceMappingURL=InputJax.js.map
;// ./mjs/core/OutputJax.js


class AbstractOutputJax {
    constructor(options = {}) {
        this.adaptor = null;
        const CLASS = this.constructor;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
        this.preFilters = new FunctionList(this.options.preFilters);
        this.postFilters = new FunctionList(this.options.postFilters);
    }
    get name() {
        return this.constructor.NAME;
    }
    setAdaptor(adaptor) {
        this.adaptor = adaptor;
    }
    initialize() { }
    reset(..._args) { }
    getMetrics(_document) { }
    styleSheet(_document) {
        return null;
    }
    pageElements(_document) {
        return null;
    }
    executeFilters(filters, math, document, data) {
        const args = { math, document, data };
        filters.execute(args);
        return args.data;
    }
}
AbstractOutputJax.NAME = 'generic';
AbstractOutputJax.OPTIONS = {
    preFilters: [],
    postFilters: [],
};
//# sourceMappingURL=OutputJax.js.map
;// ./mjs/util/LinkedList.js
const END = Symbol();
class ListItem {
    constructor(data = null) {
        this.next = null;
        this.prev = null;
        this.data = data;
    }
}
class LinkedList {
    constructor(...args) {
        this.list = new ListItem(END);
        this.list.next = this.list.prev = this.list;
        this.push(...args);
    }
    isBefore(a, b) {
        return a < b;
    }
    push(...args) {
        for (const data of args) {
            const item = new ListItem(data);
            item.next = this.list;
            item.prev = this.list.prev;
            this.list.prev = item;
            item.prev.next = item;
        }
        return this;
    }
    pop() {
        const item = this.list.prev;
        if (item.data === END) {
            return null;
        }
        this.list.prev = item.prev;
        item.prev.next = this.list;
        item.next = item.prev = null;
        return item.data;
    }
    unshift(...args) {
        for (const data of args.slice(0).reverse()) {
            const item = new ListItem(data);
            item.next = this.list.next;
            item.prev = this.list;
            this.list.next = item;
            item.next.prev = item;
        }
        return this;
    }
    shift() {
        const item = this.list.next;
        if (item.data === END) {
            return null;
        }
        this.list.next = item.next;
        item.next.prev = this.list;
        item.next = item.prev = null;
        return item.data;
    }
    remove(...items) {
        const map = new Map();
        for (const item of items) {
            map.set(item, true);
        }
        let item = this.list.next;
        while (item.data !== END) {
            const next = item.next;
            if (map.has(item.data)) {
                item.prev.next = item.next;
                item.next.prev = item.prev;
                item.next = item.prev = null;
            }
            item = next;
        }
        return this;
    }
    clear() {
        this.list.next.prev = this.list.prev.next = null;
        this.list.next = this.list.prev = this.list;
        return this;
    }
    *[Symbol.iterator]() {
        let current = this.list.next;
        while (current.data !== END) {
            yield current.data;
            current = current.next;
        }
    }
    *reversed() {
        let current = this.list.prev;
        while (current.data !== END) {
            yield current.data;
            current = current.prev;
        }
    }
    insert(data, isBefore = null) {
        if (isBefore === null) {
            isBefore = this.isBefore.bind(this);
        }
        const item = new ListItem(data);
        let cur = this.list.next;
        while (cur.data !== END &&
            isBefore(cur.data, item.data)) {
            cur = cur.next;
        }
        item.prev = cur.prev;
        item.next = cur;
        cur.prev.next = cur.prev = item;
        return this;
    }
    sort(isBefore = null) {
        if (isBefore === null) {
            isBefore = this.isBefore.bind(this);
        }
        const lists = [];
        for (const item of this) {
            lists.push(new LinkedList(item));
        }
        this.list.next = this.list.prev = this.list;
        while (lists.length > 1) {
            const l1 = lists.shift();
            const l2 = lists.shift();
            l1.merge(l2, isBefore);
            lists.push(l1);
        }
        if (lists.length) {
            this.list = lists[0].list;
        }
        return this;
    }
    merge(list, isBefore = null) {
        if (isBefore === null) {
            isBefore = this.isBefore.bind(this);
        }
        let lcur = this.list.next;
        let mcur = list.list.next;
        while (lcur.data !== END && mcur.data !== END) {
            if (isBefore(mcur.data, lcur.data)) {
                [mcur.prev.next, lcur.prev.next] = [lcur, mcur];
                [mcur.prev, lcur.prev] = [lcur.prev, mcur.prev];
                [this.list.prev.next, list.list.prev.next] = [list.list, this.list];
                [this.list.prev, list.list.prev] = [list.list.prev, this.list.prev];
                [lcur, mcur] = [mcur.next, lcur];
            }
            else {
                lcur = lcur.next;
            }
        }
        if (mcur.data !== END) {
            this.list.prev.next = list.list.next;
            list.list.next.prev = this.list.prev;
            list.list.prev.next = this.list;
            this.list.prev = list.list.prev;
            list.list.next = list.list.prev = list.list;
        }
        return this;
    }
}
//# sourceMappingURL=LinkedList.js.map
;// ./mjs/core/MathList.js

class AbstractMathList extends LinkedList {
    isBefore(a, b) {
        return (a.start.i < b.start.i ||
            (a.start.i === b.start.i && a.start.n < b.start.n));
    }
}
//# sourceMappingURL=MathList.js.map
;// ./mjs/core/MathItem.js
function protoItem(open, math, close, n, start, end, display = null) {
    const item = {
        open: open,
        math: math,
        close: close,
        n: n,
        start: { n: start },
        end: { n: end },
        display: display,
    };
    return item;
}
class AbstractMathItem {
    get isEscaped() {
        return this.display === null;
    }
    constructor(math, jax, display = true, start = { i: 0, n: 0, delim: '' }, end = { i: 0, n: 0, delim: '' }) {
        this.root = null;
        this.typesetRoot = null;
        this.metrics = {};
        this.inputData = {};
        this.outputData = {};
        this._state = STATE.UNPROCESSED;
        this.math = math;
        this.inputJax = jax;
        this.display = display;
        this.start = start;
        this.end = end;
        this.root = null;
        this.typesetRoot = null;
        this.metrics = {};
        this.inputData = {};
        this.outputData = {};
    }
    render(document) {
        document.renderActions.renderMath(this, document);
    }
    rerender(document, start = STATE.RERENDER) {
        if (this.state() >= start) {
            this.state(start - 1);
        }
        document.renderActions.renderMath(this, document, start);
    }
    convert(document, end = STATE.LAST) {
        document.renderActions.renderConvert(this, document, end);
    }
    compile(document) {
        if (this.state() < STATE.COMPILED) {
            this.root = this.inputJax.compile(this, document);
            this.state(STATE.COMPILED);
        }
    }
    typeset(document) {
        if (this.state() < STATE.TYPESET) {
            this.typesetRoot = document.outputJax[this.isEscaped ? 'escaped' : 'typeset'](this, document);
            this.state(STATE.TYPESET);
        }
    }
    updateDocument(_document) { }
    removeFromDocument(_restore = false) {
        this.clear();
    }
    setMetrics(em, ex, cwidth, scale) {
        this.metrics = {
            em: em,
            ex: ex,
            containerWidth: cwidth,
            scale: scale,
        };
    }
    state(state = null, restore = false) {
        if (state != null) {
            if (state < STATE.INSERTED && this._state >= STATE.INSERTED) {
                this.removeFromDocument(restore);
            }
            if (state < STATE.TYPESET && this._state >= STATE.TYPESET) {
                this.outputData = {};
            }
            if (state < STATE.COMPILED && this._state >= STATE.COMPILED) {
                this.inputData = {};
            }
            this._state = state;
        }
        return this._state;
    }
    reset(restore = false) {
        this.state(STATE.UNPROCESSED, restore);
    }
    clear() { }
}
const STATE = {
    UNPROCESSED: 0,
    FINDMATH: 10,
    COMPILED: 20,
    CONVERT: 100,
    METRICS: 110,
    RERENDER: 125,
    TYPESET: 150,
    INSERTED: 200,
    LAST: 10000,
};
function newState(name, state) {
    if (name in STATE) {
        throw Error('State ' + name + ' already exists');
    }
    STATE[name] = state;
}
//# sourceMappingURL=MathItem.js.map
;// ./mjs/core/Tree/Factory.js
class AbstractFactory {
    constructor(nodes = null) {
        this.defaultKind = 'unknown';
        this.nodeMap = new Map();
        this.node = {};
        if (nodes === null) {
            nodes = this.constructor.defaultNodes;
        }
        for (const kind of Object.keys(nodes)) {
            this.setNodeClass(kind, nodes[kind]);
        }
    }
    create(kind, ...args) {
        return (this.node[kind] || this.node[this.defaultKind])(...args);
    }
    setNodeClass(kind, nodeClass) {
        this.nodeMap.set(kind, nodeClass);
        const KIND = this.nodeMap.get(kind);
        this.node[kind] = (...args) => {
            return new KIND(this, ...args);
        };
    }
    getNodeClass(kind) {
        return this.nodeMap.get(kind);
    }
    deleteNodeClass(kind) {
        this.nodeMap.delete(kind);
        delete this.node[kind];
    }
    nodeIsKind(node, kind) {
        return node instanceof this.getNodeClass(kind);
    }
    getKinds() {
        return Array.from(this.nodeMap.keys());
    }
}
AbstractFactory.defaultNodes = {};
//# sourceMappingURL=Factory.js.map
;// ./mjs/core/Tree/NodeFactory.js

class AbstractNodeFactory extends AbstractFactory {
    create(kind, properties = {}, children = []) {
        return this.node[kind](properties, children);
    }
}
//# sourceMappingURL=NodeFactory.js.map
;// ./mjs/core/MmlTree/Attributes.js
const INHERIT = '_inherit_';
class Attributes {
    constructor(defaults, global) {
        this.global = global;
        this.defaults = Object.create(global);
        this.inherited = Object.create(this.defaults);
        this.attributes = Object.create(this.inherited);
        Object.assign(this.defaults, defaults);
    }
    set(name, value) {
        this.attributes[name] = value;
    }
    setList(list) {
        Object.assign(this.attributes, list);
    }
    unset(name) {
        delete this.attributes[name];
    }
    get(name) {
        let value = this.attributes[name];
        if (value === INHERIT) {
            value = this.global[name];
        }
        return value;
    }
    getExplicit(name) {
        return this.hasExplicit(name) ? this.attributes[name] : undefined;
    }
    hasExplicit(name) {
        return Object.hasOwn(this.attributes, name);
    }
    hasOneOf(names) {
        for (const name of names) {
            if (this.hasExplicit(name)) {
                return true;
            }
        }
        return false;
    }
    getList(...names) {
        const values = {};
        for (const name of names) {
            values[name] = this.get(name);
        }
        return values;
    }
    setInherited(name, value) {
        this.inherited[name] = value;
    }
    getInherited(name) {
        return this.inherited[name];
    }
    getDefault(name) {
        return this.defaults[name];
    }
    isSet(name) {
        return (Object.hasOwn(this.attributes, name) ||
            Object.hasOwn(this.inherited, name));
    }
    hasDefault(name) {
        return name in this.defaults;
    }
    getExplicitNames() {
        return Object.keys(this.attributes);
    }
    getInheritedNames() {
        return Object.keys(this.inherited);
    }
    getDefaultNames() {
        return Object.keys(this.defaults);
    }
    getGlobalNames() {
        return Object.keys(this.global);
    }
    getAllAttributes() {
        return this.attributes;
    }
    getAllInherited() {
        return this.inherited;
    }
    getAllDefaults() {
        return this.defaults;
    }
    getAllGlobals() {
        return this.global;
    }
}
//# sourceMappingURL=Attributes.js.map
;// ./mjs/core/Tree/Node.js
class AbstractNode {
    constructor(factory, properties = {}, children = []) {
        this.factory = factory;
        this.parent = null;
        this.properties = {};
        this.childNodes = [];
        for (const name of Object.keys(properties)) {
            this.setProperty(name, properties[name]);
        }
        if (children.length) {
            this.setChildren(children);
        }
    }
    get kind() {
        return 'unknown';
    }
    setProperty(name, value) {
        this.properties[name] = value;
    }
    getProperty(name) {
        return this.properties[name];
    }
    getPropertyNames() {
        return Object.keys(this.properties);
    }
    getAllProperties() {
        return this.properties;
    }
    removeProperty(...names) {
        for (const name of names) {
            delete this.properties[name];
        }
    }
    isKind(kind) {
        return this.factory.nodeIsKind(this, kind);
    }
    setChildren(children) {
        this.childNodes = [];
        for (const child of children) {
            this.appendChild(child);
        }
    }
    appendChild(child) {
        this.childNodes.push(child);
        child.parent = this;
        return child;
    }
    replaceChild(newChild, oldChild) {
        const i = this.childIndex(oldChild);
        if (i !== null) {
            this.childNodes[i] = newChild;
            newChild.parent = this;
            if (oldChild.parent === this) {
                oldChild.parent = null;
            }
        }
        return newChild;
    }
    removeChild(child) {
        const i = this.childIndex(child);
        if (i !== null) {
            this.childNodes.splice(i, 1);
            child.parent = null;
        }
        return child;
    }
    childIndex(node) {
        const i = this.childNodes.indexOf(node);
        return i === -1 ? null : i;
    }
    copy() {
        const node = this.factory.create(this.kind);
        node.properties = Object.assign({}, this.properties);
        for (const child of this.childNodes || []) {
            if (child) {
                node.appendChild(child.copy());
            }
        }
        return node;
    }
    findNodes(kind) {
        const nodes = [];
        this.walkTree((node) => {
            if (node.isKind(kind)) {
                nodes.push(node);
            }
        });
        return nodes;
    }
    walkTree(func, data) {
        func(this, data);
        for (const child of this.childNodes) {
            if (child) {
                child.walkTree(func, data);
            }
        }
        return data;
    }
    toString() {
        return this.kind + '(' + this.childNodes.join(',') + ')';
    }
}
class AbstractEmptyNode extends AbstractNode {
    setChildren(_children) { }
    appendChild(child) {
        return child;
    }
    replaceChild(_newChild, oldChild) {
        return oldChild;
    }
    childIndex(_node) {
        return null;
    }
    walkTree(func, data) {
        func(this, data);
        return data;
    }
    toString() {
        return this.kind;
    }
}
//# sourceMappingURL=Node.js.map
;// ./mjs/core/MmlTree/MmlNode.js


const TEXCLASS = {
    ORD: 0,
    OP: 1,
    BIN: 2,
    REL: 3,
    OPEN: 4,
    CLOSE: 5,
    PUNCT: 6,
    INNER: 7,
    NONE: -1,
};
const TEXCLASSNAMES = [
    'ORD',
    'OP',
    'BIN',
    'REL',
    'OPEN',
    'CLOSE',
    'PUNCT',
    'INNER',
];
const TEXSPACELENGTH = [
    '',
    'thinmathspace',
    'mediummathspace',
    'thickmathspace',
];
const TEXSPACE = [
    [0, -1, 2, 3, 0, 0, 0, 1],
    [-1, -1, 0, 3, 0, 0, 0, 1],
    [2, 2, 0, 0, 2, 0, 0, 2],
    [3, 3, 0, 0, 3, 0, 0, 3],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, -1, 2, 3, 0, 0, 0, 1],
    [1, 1, 0, 1, 1, 1, 1, 1],
    [1, -1, 2, 3, 1, 0, 1, 1]
];
const MATHVARIANTS = new Set([
    'normal',
    'bold',
    'italic',
    'bold-italic',
    'double-struck',
    'fraktur',
    'bold-fraktur',
    'script',
    'bold-script',
    'sans-serif',
    'bold-sans-serif',
    'sans-serif-italic',
    'sans-serif-bold-italic',
    'monospace',
    'inital',
    'tailed',
    'looped',
    'stretched',
]);
const indentAttributes = [
    'indentalign',
    'indentalignfirst',
    'indentshift',
    'indentshiftfirst',
];
class AbstractMmlNode extends AbstractNode {
    constructor(factory, attributes = {}, children = []) {
        super(factory);
        this.prevClass = null;
        this.prevLevel = null;
        this.texclass = null;
        if (this.arity < 0) {
            this.childNodes = [factory.create('inferredMrow')];
            this.childNodes[0].parent = this;
        }
        this.setChildren(children);
        this.attributes = new Attributes(factory.getNodeClass(this.kind).defaults, factory.getNodeClass('math').defaults);
        this.attributes.setList(attributes);
    }
    copy(keepIds = false) {
        const node = this.factory.create(this.kind);
        node.properties = Object.assign({}, this.properties);
        if (this.attributes) {
            const attributes = this.attributes.getAllAttributes();
            for (const name of Object.keys(attributes)) {
                if (name !== 'id' || keepIds) {
                    node.attributes.set(name, attributes[name]);
                }
            }
        }
        if (this.childNodes && this.childNodes.length) {
            let children = this.childNodes;
            if (children.length === 1 && children[0].isInferred) {
                children = children[0].childNodes;
            }
            for (const child of children) {
                if (child) {
                    node.appendChild(child.copy());
                }
                else {
                    node.childNodes.push(null);
                }
            }
        }
        return node;
    }
    get texClass() {
        return this.texclass;
    }
    set texClass(texClass) {
        this.texclass = texClass;
    }
    get isToken() {
        return false;
    }
    get isEmbellished() {
        return false;
    }
    get isSpacelike() {
        return false;
    }
    get linebreakContainer() {
        return false;
    }
    get linebreakAlign() {
        return 'data-align';
    }
    get arity() {
        return Infinity;
    }
    get isInferred() {
        return false;
    }
    get Parent() {
        let parent = this.parent;
        while (parent && parent.notParent) {
            parent = parent.Parent;
        }
        return parent;
    }
    get notParent() {
        return false;
    }
    setChildren(children) {
        if (this.arity < 0) {
            return this.childNodes[0].setChildren(children);
        }
        return super.setChildren(children);
    }
    appendChild(child) {
        if (this.arity < 0) {
            this.childNodes[0].appendChild(child);
            return child;
        }
        if (child.isInferred) {
            if (this.arity === Infinity) {
                child.childNodes.forEach((node) => super.appendChild(node));
                return child;
            }
            const original = child;
            child = this.factory.create('mrow');
            child.setChildren(original.childNodes);
            child.attributes = original.attributes;
            for (const name of original.getPropertyNames()) {
                child.setProperty(name, original.getProperty(name));
            }
        }
        return super.appendChild(child);
    }
    replaceChild(newChild, oldChild) {
        if (this.arity < 0) {
            this.childNodes[0].replaceChild(newChild, oldChild);
            return newChild;
        }
        return super.replaceChild(newChild, oldChild);
    }
    core() {
        return this;
    }
    coreMO() {
        return this;
    }
    coreIndex() {
        return 0;
    }
    childPosition() {
        let child = null;
        let parent = this.parent;
        while (parent && parent.notParent) {
            child = parent;
            parent = parent.parent;
        }
        child = child || this;
        if (parent) {
            let i = 0;
            for (const node of parent.childNodes) {
                if (node === child) {
                    return i;
                }
                i++;
            }
        }
        return null;
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        return this.texClass != null ? this : prev;
    }
    updateTeXclass(core) {
        if (core) {
            this.prevClass = core.prevClass;
            this.prevLevel = core.prevLevel;
            core.prevClass = core.prevLevel = null;
            this.texClass = core.texClass;
        }
    }
    getPrevClass(prev) {
        if (prev) {
            this.prevClass = prev.texClass;
            this.prevLevel = prev.attributes.get('scriptlevel');
        }
    }
    texSpacing() {
        const prevClass = this.prevClass != null ? this.prevClass : TEXCLASS.NONE;
        const texClass = this.texClass || TEXCLASS.ORD;
        if (prevClass === TEXCLASS.NONE || texClass === TEXCLASS.NONE) {
            return '';
        }
        const space = TEXSPACE[prevClass][texClass];
        if ((this.prevLevel > 0 ||
            this.attributes.get('scriptlevel') > 0) &&
            space >= 0) {
            return '';
        }
        return TEXSPACELENGTH[Math.abs(space)];
    }
    hasSpacingAttributes() {
        return this.isEmbellished && this.coreMO().hasSpacingAttributes();
    }
    setInheritedAttributes(attributes = {}, display = false, level = 0, prime = false) {
        var _a, _b, _c;
        const defaults = this.attributes.getAllDefaults();
        for (const key of Object.keys(attributes)) {
            if (Object.hasOwn(defaults, key) ||
                Object.hasOwn(AbstractMmlNode.alwaysInherit, key)) {
                const [node, value] = attributes[key];
                if (!((_b = (_a = AbstractMmlNode.noInherit[node]) === null || _a === void 0 ? void 0 : _a[this.kind]) === null || _b === void 0 ? void 0 : _b[key])) {
                    this.attributes.setInherited(key, value);
                }
            }
            if ((_c = AbstractMmlNode.stopInherit[this.kind]) === null || _c === void 0 ? void 0 : _c[key]) {
                attributes = Object.assign({}, attributes);
                delete attributes[key];
            }
        }
        const displaystyle = this.attributes.getExplicit('displaystyle');
        if (displaystyle === undefined) {
            this.attributes.setInherited('displaystyle', display);
        }
        const scriptlevel = this.attributes.getExplicit('scriptlevel');
        if (scriptlevel === undefined) {
            this.attributes.setInherited('scriptlevel', level);
        }
        if (prime) {
            this.setProperty('texprimestyle', prime);
        }
        const arity = this.arity;
        if (arity >= 0 &&
            arity !== Infinity &&
            ((arity === 1 && this.childNodes.length === 0) ||
                (arity !== 1 && this.childNodes.length !== arity))) {
            if (arity < this.childNodes.length) {
                this.childNodes = this.childNodes.slice(0, arity);
            }
            else {
                while (this.childNodes.length < arity) {
                    this.appendChild(this.factory.create('mrow'));
                }
            }
        }
        if (this.linebreakContainer && !this.isEmbellished) {
            const align = this.linebreakAlign;
            if (align) {
                const indentalign = this.attributes.get(align) || 'left';
                attributes = this.addInheritedAttributes(attributes, {
                    indentalign,
                    indentshift: '0',
                    indentalignfirst: indentalign,
                    indentshiftfirst: '0',
                    indentalignlast: 'indentalign',
                    indentshiftlast: 'indentshift',
                });
            }
        }
        this.setChildInheritedAttributes(attributes, display, level, prime);
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        for (const child of this.childNodes) {
            child.setInheritedAttributes(attributes, display, level, prime);
        }
    }
    addInheritedAttributes(current, attributes) {
        const updated = Object.assign({}, current);
        for (const name of Object.keys(attributes)) {
            if (name !== 'displaystyle' &&
                name !== 'scriptlevel' &&
                name !== 'style') {
                updated[name] = [this.kind, attributes[name]];
            }
        }
        return updated;
    }
    inheritAttributesFrom(node) {
        const attributes = node.attributes;
        const display = attributes.get('displaystyle');
        const scriptlevel = attributes.get('scriptlevel');
        const defaults = !attributes.isSet('mathsize')
            ? {}
            : { mathsize: ['math', attributes.get('mathsize')] };
        const prime = node.getProperty('texprimestyle') || false;
        this.setInheritedAttributes(defaults, display, scriptlevel, prime);
    }
    verifyTree(options = null) {
        if (options === null) {
            return;
        }
        this.verifyAttributes(options);
        const arity = this.arity;
        if (options['checkArity']) {
            if (arity >= 0 &&
                arity !== Infinity &&
                ((arity === 1 && this.childNodes.length === 0) ||
                    (arity !== 1 && this.childNodes.length !== arity))) {
                this.mError('Wrong number of children for "' + this.kind + '" node', options, true);
            }
        }
        this.verifyChildren(options);
    }
    verifyAttributes(options) {
        if (options.checkAttributes) {
            const attributes = this.attributes;
            const bad = [];
            for (const name of attributes.getExplicitNames()) {
                if (name.substring(0, 5) !== 'data-' &&
                    attributes.getDefault(name) === undefined &&
                    !name.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {
                    bad.push(name);
                }
            }
            if (bad.length) {
                this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);
            }
        }
        if (options.checkMathvariants) {
            const variant = this.attributes.getExplicit('mathvariant');
            if (variant &&
                !MATHVARIANTS.has(variant) &&
                !this.getProperty('ignore-variant')) {
                this.mError(`Invalid mathvariant: ${variant}`, options, true);
            }
        }
    }
    verifyChildren(options) {
        for (const child of this.childNodes) {
            child.verifyTree(options);
        }
    }
    mError(message, options, short = false) {
        if (this.parent && this.parent.isKind('merror')) {
            return null;
        }
        const merror = this.factory.create('merror');
        merror.attributes.set('data-mjx-message', message);
        if (options.fullErrors || short) {
            const mtext = this.factory.create('mtext');
            const text = this.factory.create('text');
            text.setText(options.fullErrors ? message : this.kind);
            mtext.appendChild(text);
            merror.appendChild(mtext);
            this.parent.replaceChild(merror, this);
            if (!options.fullErrors) {
                merror.attributes.set('title', message);
            }
        }
        else {
            this.parent.replaceChild(merror, this);
            merror.appendChild(this);
        }
        return merror;
    }
}
AbstractMmlNode.defaults = {
    mathbackground: INHERIT,
    mathcolor: INHERIT,
    mathsize: INHERIT,
    dir: INHERIT,
};
AbstractMmlNode.noInherit = {
    mstyle: {
        mpadded: {
            width: true,
            height: true,
            depth: true,
            lspace: true,
            voffset: true,
        },
        mtable: { width: true, height: true, depth: true, align: true },
    },
    maligngroup: {
        mrow: { groupalign: true },
        mtable: { groupalign: true },
    },
    mtr: {
        msqrt: { 'data-vertical-align': true },
        mroot: { 'data-vertical-align': true },
    },
    mlabeledtr: {
        msqrt: { 'data-vertical-align': true },
        mroot: { 'data-vertical-align': true },
    },
};
AbstractMmlNode.stopInherit = {
    mtd: { columnalign: true, rowalign: true, groupalign: true },
};
AbstractMmlNode.alwaysInherit = {
    scriptminsize: true,
    scriptsizemultiplier: true,
    infixlinebreakstyle: true,
};
AbstractMmlNode.verifyDefaults = {
    checkArity: true,
    checkAttributes: false,
    checkMathvariants: true,
    fullErrors: false,
    fixMmultiscripts: true,
    fixMtables: true,
};
class AbstractMmlTokenNode extends AbstractMmlNode {
    get isToken() {
        return true;
    }
    getText() {
        let text = '';
        for (const child of this.childNodes) {
            if (child instanceof TextNode) {
                text += child.getText();
            }
            else if ('textContent' in child) {
                text += child.textContent();
            }
        }
        return text;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        for (const child of this.childNodes) {
            if (child instanceof AbstractMmlNode) {
                child.setInheritedAttributes(attributes, display, level, prime);
            }
        }
    }
    walkTree(func, data) {
        func(this, data);
        for (const child of this.childNodes) {
            if (child instanceof AbstractMmlNode) {
                child.walkTree(func, data);
            }
        }
        return data;
    }
}
AbstractMmlTokenNode.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { mathvariant: 'normal', mathsize: INHERIT });
class AbstractMmlLayoutNode extends AbstractMmlNode {
    get isSpacelike() {
        return this.childNodes[0].isSpacelike;
    }
    get isEmbellished() {
        return this.childNodes[0].isEmbellished;
    }
    get arity() {
        return -1;
    }
    core() {
        return this.childNodes[0];
    }
    coreMO() {
        return this.childNodes[0].coreMO();
    }
    setTeXclass(prev) {
        prev = this.childNodes[0].setTeXclass(prev);
        this.updateTeXclass(this.childNodes[0]);
        return prev;
    }
}
AbstractMmlLayoutNode.defaults = AbstractMmlNode.defaults;
class AbstractMmlBaseNode extends AbstractMmlNode {
    get isEmbellished() {
        return this.childNodes[0].isEmbellished;
    }
    core() {
        return this.childNodes[0];
    }
    coreMO() {
        return this.childNodes[0].coreMO();
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        this.texClass = TEXCLASS.ORD;
        const base = this.childNodes[0];
        let result = null;
        if (base) {
            if (this.isEmbellished || base.isKind('mi')) {
                result = base.setTeXclass(prev);
                this.updateTeXclass(this.core());
            }
            else {
                base.setTeXclass(null);
            }
        }
        for (const child of this.childNodes.slice(1)) {
            if (child) {
                child.setTeXclass(null);
            }
        }
        return result || this;
    }
}
AbstractMmlBaseNode.defaults = AbstractMmlNode.defaults;
class AbstractMmlEmptyNode extends AbstractEmptyNode {
    get isToken() {
        return false;
    }
    get isEmbellished() {
        return false;
    }
    get isSpacelike() {
        return false;
    }
    get linebreakContainer() {
        return false;
    }
    get linebreakAlign() {
        return '';
    }
    get arity() {
        return 0;
    }
    get isInferred() {
        return false;
    }
    get notParent() {
        return false;
    }
    get Parent() {
        return this.parent;
    }
    get texClass() {
        return TEXCLASS.NONE;
    }
    get prevClass() {
        return TEXCLASS.NONE;
    }
    get prevLevel() {
        return 0;
    }
    hasSpacingAttributes() {
        return false;
    }
    get attributes() {
        return null;
    }
    core() {
        return this;
    }
    coreMO() {
        return this;
    }
    coreIndex() {
        return 0;
    }
    childPosition() {
        return 0;
    }
    setTeXclass(prev) {
        return prev;
    }
    texSpacing() {
        return '';
    }
    setInheritedAttributes(_attributes, _display, _level, _prime) { }
    inheritAttributesFrom(_node) { }
    verifyTree(_options) { }
    mError(_message, _options, _short = false) {
        return null;
    }
}
class TextNode extends AbstractMmlEmptyNode {
    constructor() {
        super(...arguments);
        this.text = '';
    }
    get kind() {
        return 'text';
    }
    getText() {
        return this.text;
    }
    setText(text) {
        this.text = text;
        return this;
    }
    copy() {
        return this.factory.create(this.kind).setText(this.getText());
    }
    toString() {
        return this.text;
    }
}
class XMLNode extends AbstractMmlEmptyNode {
    constructor() {
        super(...arguments);
        this.xml = null;
        this.adaptor = null;
    }
    get kind() {
        return 'XML';
    }
    getXML() {
        return this.xml;
    }
    setXML(xml, adaptor = null) {
        this.xml = xml;
        this.adaptor = adaptor;
        return this;
    }
    getSerializedXML() {
        return this.adaptor.serializeXML(this.xml);
    }
    copy() {
        return this.factory.create(this.kind).setXML(this.adaptor.clone(this.xml));
    }
    toString() {
        return 'XML data';
    }
}
//# sourceMappingURL=MmlNode.js.map
;// ./mjs/core/MmlTree/MmlNodes/math.js

class MmlMath extends AbstractMmlLayoutNode {
    get kind() {
        return 'math';
    }
    get linebreakContainer() {
        return true;
    }
    get linebreakAlign() {
        return '';
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        if (this.attributes.get('mode') === 'display') {
            this.attributes.setInherited('display', 'block');
        }
        attributes = this.addInheritedAttributes(attributes, this.attributes.getAllAttributes());
        display =
            !!this.attributes.get('displaystyle') ||
                (!this.attributes.get('displaystyle') &&
                    this.attributes.get('display') === 'block');
        this.attributes.setInherited('displaystyle', display);
        level = (this.attributes.get('scriptlevel') ||
            this.constructor.defaults['scriptlevel']);
        super.setChildInheritedAttributes(attributes, display, level, prime);
    }
    verifyTree(options = null) {
        super.verifyTree(options);
        if (this.parent) {
            this.mError('Improper nesting of math tags', options, true);
        }
    }
}
MmlMath.defaults = Object.assign(Object.assign({}, AbstractMmlLayoutNode.defaults), { mathvariant: 'normal', mathsize: 'normal', mathcolor: '', mathbackground: 'transparent', dir: 'ltr', scriptlevel: 0, displaystyle: false, display: 'inline', maxwidth: '', overflow: 'linebreak', altimg: '', 'altimg-width': '', 'altimg-height': '', 'altimg-valign': '', alttext: '', cdgroup: '', scriptsizemultiplier: 1 / Math.sqrt(2), scriptminsize: '.4em', infixlinebreakstyle: 'before', lineleading: '100%', linebreakmultchar: '\u2062', indentshift: 'auto', indentalign: 'auto', indenttarget: '', indentalignfirst: 'indentalign', indentshiftfirst: 'indentshift', indentalignlast: 'indentalign', indentshiftlast: 'indentshift' });
//# sourceMappingURL=math.js.map
;// ./mjs/core/MmlTree/MmlNodes/mi.js

class MmlMi extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mi';
    }
    setInheritedAttributes(attributes = {}, display = false, level = 0, prime = false) {
        super.setInheritedAttributes(attributes, display, level, prime);
        const text = this.getText();
        if (text.match(MmlMi.singleCharacter) && !attributes.mathvariant) {
            this.attributes.setInherited('mathvariant', 'italic');
        }
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        const name = this.getText();
        if (name.length > 1 &&
            name.match(MmlMi.operatorName) &&
            this.attributes.get('mathvariant') === 'normal' &&
            this.getProperty('autoOP') === undefined &&
            this.getProperty('texClass') === undefined) {
            this.texClass = TEXCLASS.OP;
            this.setProperty('autoOP', true);
        }
        return this;
    }
}
MmlMi.defaults = Object.assign({}, AbstractMmlTokenNode.defaults);
MmlMi.operatorName = /^[a-z][a-z0-9]*$/i;
MmlMi.singleCharacter = /^[\uD800-\uDBFF]?.[\u0300-\u036F\u1AB0-\u1ABE\u1DC0-\u1DFF\u20D0-\u20EF]*$/;
//# sourceMappingURL=mi.js.map
;// ./mjs/core/MmlTree/MmlNodes/mn.js

class MmlMn extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mn';
    }
}
MmlMn.defaults = Object.assign({}, AbstractMmlTokenNode.defaults);
//# sourceMappingURL=mn.js.map
;// ./mjs/core/MmlTree/OperatorDictionary.js

function OPDEF(lspace, rspace, texClass = TEXCLASS.BIN, properties = null) {
    return [lspace, rspace, texClass, properties];
}
const MO = {
    ORD: OPDEF(0, 0, TEXCLASS.ORD),
    ORD11: OPDEF(1, 1, TEXCLASS.ORD),
    ORD21: OPDEF(2, 1, TEXCLASS.ORD),
    ORD02: OPDEF(0, 2, TEXCLASS.ORD),
    ORD55: OPDEF(5, 5, TEXCLASS.ORD),
    NONE: OPDEF(0, 0, TEXCLASS.NONE),
    OP: OPDEF(1, 2, TEXCLASS.OP, {
        largeop: true,
        movablelimits: true,
        symmetric: true,
    }),
    OPFIXED: OPDEF(1, 2, TEXCLASS.OP, { largeop: true, movablelimits: true }),
    INTEGRAL: OPDEF(0, 1, TEXCLASS.OP, { largeop: true, symmetric: true }),
    INTEGRAL2: OPDEF(1, 2, TEXCLASS.OP, { largeop: true, symmetric: true }),
    BIN3: OPDEF(3, 3, TEXCLASS.BIN),
    BIN4: OPDEF(4, 4, TEXCLASS.BIN),
    BIN01: OPDEF(0, 1, TEXCLASS.BIN),
    BIN5: OPDEF(5, 5, TEXCLASS.BIN),
    TALLBIN: OPDEF(4, 4, TEXCLASS.BIN, { stretchy: true }),
    BINOP: OPDEF(4, 4, TEXCLASS.BIN, { largeop: true, movablelimits: true }),
    REL: OPDEF(5, 5, TEXCLASS.REL),
    REL1: OPDEF(1, 1, TEXCLASS.REL, { stretchy: true }),
    REL4: OPDEF(4, 4, TEXCLASS.REL),
    RELSTRETCH: OPDEF(5, 5, TEXCLASS.REL, { stretchy: true }),
    RELACCENT: OPDEF(5, 5, TEXCLASS.REL, { accent: true }),
    WIDEREL: OPDEF(5, 5, TEXCLASS.REL, { accent: true, stretchy: true }),
    OPEN: OPDEF(0, 0, TEXCLASS.OPEN, {
        fence: true,
        stretchy: true,
        symmetric: true,
    }),
    CLOSE: OPDEF(0, 0, TEXCLASS.CLOSE, {
        fence: true,
        stretchy: true,
        symmetric: true,
    }),
    INNER: OPDEF(0, 0, TEXCLASS.INNER),
    PUNCT: OPDEF(0, 3, TEXCLASS.PUNCT),
    ACCENT: OPDEF(0, 0, TEXCLASS.ORD, { accent: true }),
    WIDEACCENT: OPDEF(0, 0, TEXCLASS.ORD, { accent: true, stretchy: true }),
};
const RANGES = [
    [0x0020, 0x007f, TEXCLASS.REL, 'mo'],
    [0x00a0, 0x00bf, TEXCLASS.ORD, 'mo'],
    [0x00c0, 0x024f, TEXCLASS.ORD, 'mi'],
    [0x02b0, 0x036f, TEXCLASS.ORD, 'mo'],
    [0x0370, 0x1a20, TEXCLASS.ORD, 'mi'],
    [0x1ab0, 0x1aff, TEXCLASS.ORD, 'mo'],
    [0x1b00, 0x1dbf, TEXCLASS.ORD, 'mi'],
    [0x1dc0, 0x1dff, TEXCLASS.ORD, 'mo'],
    [0x1e00, 0x1fff, TEXCLASS.ORD, 'mi'],
    [0x2000, 0x206f, TEXCLASS.ORD, 'mo'],
    [0x2070, 0x209f, TEXCLASS.ORD, 'mo'],
    [0x2100, 0x214f, TEXCLASS.ORD, 'mi'],
    [0x2150, 0x218f, TEXCLASS.ORD, 'mn'],
    [0x2190, 0x21ff, TEXCLASS.REL, 'mo'],
    [0x2200, 0x22ff, TEXCLASS.BIN, 'mo'],
    [0x2300, 0x23ff, TEXCLASS.ORD, 'mo'],
    [0x2460, 0x24ff, TEXCLASS.ORD, 'mn'],
    [0x2500, 0x27ef, TEXCLASS.ORD, 'mo'],
    [0x27f0, 0x27ff, TEXCLASS.REL, 'mo'],
    [0x2800, 0x28ff, TEXCLASS.ORD, 'mtext'],
    [0x2900, 0x297f, TEXCLASS.REL, 'mo'],
    [0x2980, 0x29ff, TEXCLASS.ORD, 'mo'],
    [0x2a00, 0x2aff, TEXCLASS.BIN, 'mo'],
    [0x2b00, 0x2b2f, TEXCLASS.ORD, 'mo'],
    [0x2b30, 0x2b4f, TEXCLASS.REL, 'mo'],
    [0x2b50, 0x2bff, TEXCLASS.ORD, 'mo'],
    [0x2c00, 0x2de0, TEXCLASS.ORD, 'mi'],
    [0x2e00, 0x2e7f, TEXCLASS.ORD, 'mo'],
    [0x2e80, 0x2fdf, TEXCLASS.ORD, 'mi', 'normal'],
    [0x2ff0, 0x303f, TEXCLASS.ORD, 'mo'],
    [0x3040, 0xa49f, TEXCLASS.ORD, 'mi', 'normal'],
    [0xa4d0, 0xa82f, TEXCLASS.ORD, 'mi'],
    [0xa830, 0xa83f, TEXCLASS.ORD, 'mn'],
    [0xa840, 0xd7ff, TEXCLASS.ORD, 'mi'],
    [0xf900, 0xfaff, TEXCLASS.ORD, 'mi', 'normal'],
    [0xfb00, 0xfdff, TEXCLASS.ORD, 'mi'],
    [0xfe00, 0xfe6f, TEXCLASS.ORD, 'mo'],
    [0xfe70, 0x100ff, TEXCLASS.ORD, 'mi'],
    [0x10100, 0x1018f, TEXCLASS.ORD, 'mn'],
    [0x10190, 0x123ff, TEXCLASS.ORD, 'mi', 'normal'],
    [0x12400, 0x1247f, TEXCLASS.ORD, 'mn'],
    [0x12480, 0x1bc9f, TEXCLASS.ORD, 'mi', 'normal'],
    [0x1bca0, 0x1d25f, TEXCLASS.ORD, 'mo'],
    [0x1d360, 0x1d37f, TEXCLASS.ORD, 'mn'],
    [0x1d400, 0x1d7cd, TEXCLASS.ORD, 'mi'],
    [0x1d7ce, 0x1d7ff, TEXCLASS.ORD, 'mn'],
    [0x1df00, 0x1f7ff, TEXCLASS.ORD, 'mo'],
    [0x1f800, 0x1f8ff, TEXCLASS.REL, 'mo'],
    [0x1f900, 0x1f9ff, TEXCLASS.ORD, 'mo'],
    [0x20000, 0x2fa1f, TEXCLASS.ORD, 'mi', 'normal'],
];
function getRange(text) {
    const def = OPTABLE.infix[text] || OPTABLE.prefix[text] || OPTABLE.postfix[text];
    if (def) {
        return [0, 0, def[2], 'mo'];
    }
    const n = text.codePointAt(0);
    for (const range of RANGES) {
        if (n <= range[1]) {
            if (n >= range[0]) {
                return range;
            }
            break;
        }
    }
    return [0, 0, TEXCLASS.REL, 'mo'];
}
const MMLSPACING = [
    [0, 0],
    [1, 2],
    [3, 3],
    [4, 4],
    [0, 0],
    [0, 0],
    [0, 3],
];
const OPTABLE = {
    prefix: {
        '(': MO.OPEN,
        '+': MO.BIN01,
        '-': MO.BIN01,
        '[': MO.OPEN,
        '{': MO.OPEN,
        '|': MO.OPEN,
        '||': [0, 0, TEXCLASS.BIN, { fence: true, stretchy: true, symmetric: true }],
        '|||': [0, 0, TEXCLASS.ORD, { fence: true, stretchy: true, symmetric: true }],
        '\u00AC': MO.ORD21,
        '\u00B1': MO.BIN01,
        '\u2016': [0, 0, TEXCLASS.ORD, { fence: true, stretchy: true }],
        '\u2018': [0, 0, TEXCLASS.OPEN, { fence: true }],
        '\u201C': [0, 0, TEXCLASS.OPEN, { fence: true }],
        '\u2145': MO.ORD21,
        '\u2146': OPDEF(2, 0, TEXCLASS.ORD),
        '\u2200': MO.ORD21,
        '\u2202': MO.ORD21,
        '\u2203': MO.ORD21,
        '\u2204': MO.ORD21,
        '\u2207': MO.ORD21,
        '\u220F': MO.OP,
        '\u2210': MO.OP,
        '\u2211': MO.OP,
        '\u2212': MO.BIN01,
        '\u2213': MO.BIN01,
        '\u221A': [1, 1, TEXCLASS.ORD, { stretchy: true }],
        '\u221B': MO.ORD11,
        '\u221C': MO.ORD11,
        '\u2220': MO.ORD,
        '\u2221': MO.ORD,
        '\u2222': MO.ORD,
        '\u222B': MO.INTEGRAL,
        '\u222C': MO.INTEGRAL,
        '\u222D': MO.INTEGRAL,
        '\u222E': MO.INTEGRAL,
        '\u222F': MO.INTEGRAL,
        '\u2230': MO.INTEGRAL,
        '\u2231': MO.INTEGRAL,
        '\u2232': MO.INTEGRAL,
        '\u2233': MO.INTEGRAL,
        '\u22C0': MO.OP,
        '\u22C1': MO.OP,
        '\u22C2': MO.OP,
        '\u22C3': MO.OP,
        '\u2308': MO.OPEN,
        '\u230A': MO.OPEN,
        '\u2329': MO.OPEN,
        '\u2772': MO.OPEN,
        '\u27E6': MO.OPEN,
        '\u27E8': MO.OPEN,
        '\u27EA': MO.OPEN,
        '\u27EC': MO.OPEN,
        '\u27EE': MO.OPEN,
        '\u2980': [0, 0, TEXCLASS.ORD, { fence: true, stretchy: true }],
        '\u2983': MO.OPEN,
        '\u2985': MO.OPEN,
        '\u2987': MO.OPEN,
        '\u2989': MO.OPEN,
        '\u298B': MO.OPEN,
        '\u298D': MO.OPEN,
        '\u298F': MO.OPEN,
        '\u2991': MO.OPEN,
        '\u2993': MO.OPEN,
        '\u2995': MO.OPEN,
        '\u2997': MO.OPEN,
        '\u29FC': MO.OPEN,
        '\u2A00': MO.OP,
        '\u2A01': MO.OP,
        '\u2A02': MO.OP,
        '\u2A03': MO.OP,
        '\u2A04': MO.OP,
        '\u2A05': MO.OP,
        '\u2A06': MO.OP,
        '\u2A07': MO.OP,
        '\u2A08': MO.OP,
        '\u2A09': MO.OP,
        '\u2A0A': MO.OP,
        '\u2A0B': MO.INTEGRAL2,
        '\u2A0C': MO.INTEGRAL,
        '\u2A0D': MO.INTEGRAL2,
        '\u2A0E': MO.INTEGRAL2,
        '\u2A0F': MO.INTEGRAL2,
        '\u2A10': MO.OP,
        '\u2A11': MO.OP,
        '\u2A12': MO.OP,
        '\u2A13': MO.OP,
        '\u2A14': MO.OP,
        '\u2A15': MO.INTEGRAL2,
        '\u2A16': MO.INTEGRAL2,
        '\u2A17': MO.INTEGRAL2,
        '\u2A18': MO.INTEGRAL2,
        '\u2A19': MO.INTEGRAL2,
        '\u2A1A': MO.INTEGRAL2,
        '\u2A1B': MO.INTEGRAL2,
        '\u2A1C': MO.INTEGRAL2,
        '\u2AFC': MO.OP,
        '\u2AFF': MO.OP,
    },
    postfix: {
        '!!': OPDEF(1, 0),
        '!': [1, 0, TEXCLASS.CLOSE, null],
        '"': MO.ACCENT,
        '&': MO.ORD,
        ')': MO.CLOSE,
        '++': OPDEF(0, 0),
        '--': OPDEF(0, 0),
        '..': OPDEF(0, 0),
        '...': MO.ORD,
        '\'': MO.ACCENT,
        ']': MO.CLOSE,
        '^': MO.WIDEACCENT,
        '_': MO.WIDEACCENT,
        '`': MO.ACCENT,
        '|': MO.CLOSE,
        '}': MO.CLOSE,
        '~': MO.WIDEACCENT,
        '||': [0, 0, TEXCLASS.BIN, { fence: true, stretchy: true, symmetric: true }],
        '|||': [0, 0, TEXCLASS.ORD, { fence: true, stretchy: true, symmetric: true }],
        '\u00A8': MO.ACCENT,
        '\u00AA': MO.ACCENT,
        '\u00AF': MO.WIDEACCENT,
        '\u00B0': MO.ORD,
        '\u00B2': MO.ACCENT,
        '\u00B3': MO.ACCENT,
        '\u00B4': MO.ACCENT,
        '\u00B8': MO.ACCENT,
        '\u00B9': MO.ACCENT,
        '\u00BA': MO.ACCENT,
        '\u02C6': MO.WIDEACCENT,
        '\u02C7': MO.WIDEACCENT,
        '\u02C9': MO.WIDEACCENT,
        '\u02CA': MO.ACCENT,
        '\u02CB': MO.ACCENT,
        '\u02CD': MO.WIDEACCENT,
        '\u02D8': MO.ACCENT,
        '\u02D9': MO.ACCENT,
        '\u02DA': MO.ACCENT,
        '\u02DC': MO.WIDEACCENT,
        '\u02DD': MO.ACCENT,
        '\u02F7': MO.WIDEACCENT,
        '\u0302': MO.WIDEACCENT,
        '\u0311': MO.ACCENT,
        '\u03F6': MO.REL,
        '\u2016': [0, 0, TEXCLASS.ORD, { fence: true, stretchy: true }],
        '\u2019': [0, 0, TEXCLASS.CLOSE, { fence: true }],
        '\u201A': MO.ACCENT,
        '\u201B': MO.ACCENT,
        '\u201D': [0, 0, TEXCLASS.CLOSE, { fence: true }],
        '\u201E': MO.ACCENT,
        '\u201F': MO.ACCENT,
        '\u2032': MO.ORD,
        '\u2033': MO.ORD,
        '\u2034': MO.ORD,
        '\u2035': MO.ORD,
        '\u2036': MO.ORD,
        '\u2037': MO.ORD,
        '\u203E': MO.WIDEACCENT,
        '\u2057': MO.ORD,
        '\u20DB': MO.ACCENT,
        '\u20DC': MO.ACCENT,
        '\u2309': MO.CLOSE,
        '\u230B': MO.CLOSE,
        '\u232A': MO.CLOSE,
        '\u23B4': MO.WIDEACCENT,
        '\u23B5': MO.WIDEACCENT,
        '\u23DC': MO.WIDEACCENT,
        '\u23DD': MO.WIDEACCENT,
        '\u23DE': MO.WIDEACCENT,
        '\u23DF': MO.WIDEACCENT,
        '\u23E0': MO.WIDEACCENT,
        '\u23E1': MO.WIDEACCENT,
        '\u25A0': MO.BIN3,
        '\u25A1': MO.BIN3,
        '\u25AA': MO.BIN3,
        '\u25AB': MO.BIN3,
        '\u25AD': MO.BIN3,
        '\u25AE': MO.BIN3,
        '\u25AF': MO.BIN3,
        '\u25B0': MO.BIN3,
        '\u25B1': MO.BIN3,
        '\u25B2': MO.BIN4,
        '\u25B4': MO.BIN4,
        '\u25B6': MO.BIN4,
        '\u25B7': MO.BIN4,
        '\u25B8': MO.BIN4,
        '\u25BC': MO.BIN4,
        '\u25BE': MO.BIN4,
        '\u25C0': MO.BIN4,
        '\u25C1': MO.BIN4,
        '\u25C2': MO.BIN4,
        '\u25C4': MO.BIN4,
        '\u25C5': MO.BIN4,
        '\u25C6': MO.BIN4,
        '\u25C7': MO.BIN4,
        '\u25C8': MO.BIN4,
        '\u25C9': MO.BIN4,
        '\u25CC': MO.BIN4,
        '\u25CD': MO.BIN4,
        '\u25CE': MO.BIN4,
        '\u25CF': MO.BIN4,
        '\u25D6': MO.BIN4,
        '\u25D7': MO.BIN4,
        '\u25E6': MO.BIN4,
        '\u266D': MO.ORD02,
        '\u266E': MO.ORD02,
        '\u266F': MO.ORD02,
        '\u2773': MO.CLOSE,
        '\u27E7': MO.CLOSE,
        '\u27E9': MO.CLOSE,
        '\u27EB': MO.CLOSE,
        '\u27ED': MO.CLOSE,
        '\u27EF': MO.CLOSE,
        '\u2980': [0, 0, TEXCLASS.ORD, { fence: true, stretchy: true }],
        '\u2984': MO.CLOSE,
        '\u2986': MO.CLOSE,
        '\u2988': MO.CLOSE,
        '\u298A': MO.CLOSE,
        '\u298C': MO.CLOSE,
        '\u298E': MO.CLOSE,
        '\u2990': MO.CLOSE,
        '\u2992': MO.CLOSE,
        '\u2994': MO.CLOSE,
        '\u2996': MO.CLOSE,
        '\u2998': MO.CLOSE,
        '\u29FD': MO.CLOSE,
    },
    infix: {
        '!=': MO.BIN4,
        '#': MO.ORD,
        '$': MO.ORD,
        '%': [3, 3, TEXCLASS.ORD, null],
        '&&': MO.BIN4,
        '': MO.ORD,
        '*': MO.BIN3,
        '**': OPDEF(1, 1),
        '*=': MO.BIN4,
        '+': MO.BIN4,
        '+=': MO.BIN4,
        ',': [0, 3, TEXCLASS.PUNCT, { linebreakstyle: 'after', separator: true }],
        '-': MO.BIN4,
        '-=': MO.BIN4,
        '->': MO.BIN5,
        '.': [0, 3, TEXCLASS.PUNCT, { linebreakstyle: 'after', separator: true }],
        '/': MO.ORD11,
        '//': OPDEF(1, 1),
        '/=': MO.BIN4,
        ':': [1, 2, TEXCLASS.REL, null],
        ':=': MO.BIN4,
        ';': [0, 3, TEXCLASS.PUNCT, { linebreakstyle: 'after', separator: true }],
        '<': MO.REL,
        '<=': MO.BIN5,
        '<>': OPDEF(1, 1),
        '=': MO.REL,
        '==': MO.BIN4,
        '>': MO.REL,
        '>=': MO.BIN5,
        '?': [1, 1, TEXCLASS.CLOSE, null],
        '@': MO.ORD11,
        '\\': MO.ORD,
        '^': MO.ORD11,
        '_': MO.ORD11,
        '|': [2, 2, TEXCLASS.ORD, { fence: true, stretchy: true, symmetric: true }],
        '||': [2, 2, TEXCLASS.BIN, { fence: true, stretchy: true, symmetric: true }],
        '|||': [2, 2, TEXCLASS.ORD, { fence: true, stretchy: true, symmetric: true }],
        '\u00B1': MO.BIN4,
        '\u00B7': MO.BIN4,
        '\u00D7': MO.BIN4,
        '\u00F7': MO.BIN4,
        '\u02B9': MO.ORD,
        '\u0300': MO.ACCENT,
        '\u0301': MO.ACCENT,
        '\u0303': MO.WIDEACCENT,
        '\u0304': MO.ACCENT,
        '\u0306': MO.ACCENT,
        '\u0307': MO.ACCENT,
        '\u0308': MO.ACCENT,
        '\u030C': MO.ACCENT,
        '\u0332': MO.WIDEACCENT,
        '\u0338': MO.REL4,
        '\u2015': [0, 0, TEXCLASS.ORD, { stretchy: true }],
        '\u2017': [0, 0, TEXCLASS.ORD, { stretchy: true }],
        '\u2020': MO.BIN3,
        '\u2021': MO.BIN3,
        '\u2022': MO.BIN4,
        '\u2026': MO.INNER,
        '\u2043': MO.BIN4,
        '\u2044': MO.TALLBIN,
        '\u2061': MO.NONE,
        '\u2062': MO.NONE,
        '\u2063': [0, 0, TEXCLASS.NONE, { linebreakstyle: 'after', separator: true }],
        '\u2064': MO.NONE,
        '\u20D7': MO.ACCENT,
        '\u2111': MO.ORD,
        '\u2113': MO.ORD,
        '\u2118': MO.ORD,
        '\u211C': MO.ORD,
        '\u2190': MO.WIDEREL,
        '\u2191': MO.RELSTRETCH,
        '\u2192': MO.WIDEREL,
        '\u2193': MO.RELSTRETCH,
        '\u2194': MO.WIDEREL,
        '\u2195': MO.RELSTRETCH,
        '\u2196': MO.RELSTRETCH,
        '\u2197': MO.RELSTRETCH,
        '\u2198': MO.RELSTRETCH,
        '\u2199': MO.RELSTRETCH,
        '\u219A': MO.RELACCENT,
        '\u219B': MO.RELACCENT,
        '\u219C': MO.WIDEREL,
        '\u219D': MO.WIDEREL,
        '\u219E': MO.WIDEREL,
        '\u219F': MO.WIDEREL,
        '\u21A0': MO.WIDEREL,
        '\u21A1': MO.RELSTRETCH,
        '\u21A2': MO.WIDEREL,
        '\u21A3': MO.WIDEREL,
        '\u21A4': MO.WIDEREL,
        '\u21A5': MO.RELSTRETCH,
        '\u21A6': MO.WIDEREL,
        '\u21A7': MO.RELSTRETCH,
        '\u21A8': MO.RELSTRETCH,
        '\u21A9': MO.WIDEREL,
        '\u21AA': MO.WIDEREL,
        '\u21AB': MO.WIDEREL,
        '\u21AC': MO.WIDEREL,
        '\u21AD': MO.WIDEREL,
        '\u21AE': MO.RELACCENT,
        '\u21AF': MO.RELSTRETCH,
        '\u21B0': MO.RELSTRETCH,
        '\u21B1': MO.RELSTRETCH,
        '\u21B2': MO.RELSTRETCH,
        '\u21B3': MO.RELSTRETCH,
        '\u21B4': MO.RELSTRETCH,
        '\u21B5': MO.RELSTRETCH,
        '\u21B6': MO.RELACCENT,
        '\u21B7': MO.RELACCENT,
        '\u21B8': MO.REL,
        '\u21B9': MO.WIDEREL,
        '\u21BA': MO.REL,
        '\u21BB': MO.REL,
        '\u21BC': MO.WIDEREL,
        '\u21BD': MO.WIDEREL,
        '\u21BE': MO.RELSTRETCH,
        '\u21BF': MO.RELSTRETCH,
        '\u21C0': MO.WIDEREL,
        '\u21C1': MO.WIDEREL,
        '\u21C2': MO.RELSTRETCH,
        '\u21C3': MO.RELSTRETCH,
        '\u21C4': MO.WIDEREL,
        '\u21C5': MO.RELSTRETCH,
        '\u21C6': MO.WIDEREL,
        '\u21C7': MO.WIDEREL,
        '\u21C8': MO.RELSTRETCH,
        '\u21C9': MO.WIDEREL,
        '\u21CA': MO.RELSTRETCH,
        '\u21CB': MO.WIDEREL,
        '\u21CC': MO.WIDEREL,
        '\u21CD': MO.RELACCENT,
        '\u21CE': MO.RELACCENT,
        '\u21CF': MO.RELACCENT,
        '\u21D0': MO.WIDEREL,
        '\u21D1': MO.RELSTRETCH,
        '\u21D2': MO.WIDEREL,
        '\u21D3': MO.RELSTRETCH,
        '\u21D4': MO.WIDEREL,
        '\u21D5': MO.RELSTRETCH,
        '\u21D6': MO.RELSTRETCH,
        '\u21D7': MO.RELSTRETCH,
        '\u21D8': MO.RELSTRETCH,
        '\u21D9': MO.RELSTRETCH,
        '\u21DA': MO.WIDEREL,
        '\u21DB': MO.WIDEREL,
        '\u21DC': MO.WIDEREL,
        '\u21DD': MO.WIDEREL,
        '\u21DE': MO.REL,
        '\u21DF': MO.REL,
        '\u21E0': MO.WIDEREL,
        '\u21E1': MO.RELSTRETCH,
        '\u21E2': MO.WIDEREL,
        '\u21E3': MO.RELSTRETCH,
        '\u21E4': MO.WIDEREL,
        '\u21E5': MO.WIDEREL,
        '\u21E6': MO.WIDEREL,
        '\u21E7': MO.RELSTRETCH,
        '\u21E8': MO.WIDEREL,
        '\u21E9': MO.RELSTRETCH,
        '\u21EA': MO.RELSTRETCH,
        '\u21EB': MO.RELSTRETCH,
        '\u21EC': MO.RELSTRETCH,
        '\u21ED': MO.RELSTRETCH,
        '\u21EE': MO.RELSTRETCH,
        '\u21EF': MO.RELSTRETCH,
        '\u21F0': MO.WIDEREL,
        '\u21F1': MO.REL,
        '\u21F2': MO.REL,
        '\u21F3': MO.RELSTRETCH,
        '\u21F4': MO.RELACCENT,
        '\u21F5': MO.RELSTRETCH,
        '\u21F6': MO.WIDEREL,
        '\u21F7': MO.RELACCENT,
        '\u21F8': MO.RELACCENT,
        '\u21F9': MO.RELACCENT,
        '\u21FA': MO.RELACCENT,
        '\u21FB': MO.RELACCENT,
        '\u21FC': MO.RELACCENT,
        '\u21FD': MO.WIDEREL,
        '\u21FE': MO.WIDEREL,
        '\u21FF': MO.WIDEREL,
        '\u2201': OPDEF(1, 2, TEXCLASS.ORD),
        '\u2205': MO.ORD,
        '\u2206': MO.BIN3,
        '\u2208': MO.REL,
        '\u2209': MO.REL,
        '\u220A': MO.REL,
        '\u220B': MO.REL,
        '\u220C': MO.REL,
        '\u220D': MO.REL,
        '\u220E': MO.BIN3,
        '\u2212': MO.BIN4,
        '\u2213': MO.BIN4,
        '\u2214': MO.BIN4,
        '\u2215': MO.TALLBIN,
        '\u2216': MO.BIN4,
        '\u2217': MO.BIN4,
        '\u2218': MO.BIN4,
        '\u2219': MO.BIN4,
        '\u221D': MO.REL,
        '\u221E': MO.ORD,
        '\u221F': MO.REL,
        '\u2223': MO.REL,
        '\u2224': MO.REL,
        '\u2225': MO.REL,
        '\u2226': MO.REL,
        '\u2227': MO.BIN4,
        '\u2228': MO.BIN4,
        '\u2229': MO.BIN4,
        '\u222A': MO.BIN4,
        '\u2234': MO.REL,
        '\u2235': MO.REL,
        '\u2236': MO.REL,
        '\u2237': MO.REL,
        '\u2238': MO.BIN4,
        '\u2239': MO.REL,
        '\u223A': MO.BIN4,
        '\u223B': MO.REL,
        '\u223C': MO.REL,
        '\u223D': MO.REL,
        '\u223D\u0331': MO.BIN3,
        '\u223E': MO.REL,
        '\u223F': MO.BIN3,
        '\u2240': MO.BIN4,
        '\u2241': MO.REL,
        '\u2242': MO.REL,
        '\u2242\u0338': MO.REL,
        '\u2243': MO.REL,
        '\u2244': MO.REL,
        '\u2245': MO.REL,
        '\u2246': MO.REL,
        '\u2247': MO.REL,
        '\u2248': MO.REL,
        '\u2249': MO.REL,
        '\u224A': MO.REL,
        '\u224B': MO.REL,
        '\u224C': MO.REL,
        '\u224D': MO.REL,
        '\u224E': MO.REL,
        '\u224E\u0338': MO.REL,
        '\u224F': MO.REL,
        '\u224F\u0338': MO.REL,
        '\u2250': MO.REL,
        '\u2251': MO.REL,
        '\u2252': MO.REL,
        '\u2253': MO.REL,
        '\u2254': MO.REL,
        '\u2255': MO.REL,
        '\u2256': MO.REL,
        '\u2257': MO.REL,
        '\u2258': MO.REL,
        '\u2259': MO.REL,
        '\u225A': MO.REL,
        '\u225B': MO.REL,
        '\u225C': MO.REL,
        '\u225D': MO.REL,
        '\u225E': MO.REL,
        '\u225F': MO.REL,
        '\u2260': MO.REL,
        '\u2261': MO.REL,
        '\u2262': MO.REL,
        '\u2263': MO.REL,
        '\u2264': MO.REL,
        '\u2265': MO.REL,
        '\u2266': MO.REL,
        '\u2266\u0338': MO.REL,
        '\u2267': MO.REL,
        '\u2268': MO.REL,
        '\u2269': MO.REL,
        '\u226A': MO.REL,
        '\u226A\u0338': MO.REL,
        '\u226B': MO.REL,
        '\u226B\u0338': MO.REL,
        '\u226C': MO.REL,
        '\u226D': MO.REL,
        '\u226E': MO.REL,
        '\u226F': MO.REL,
        '\u2270': MO.REL,
        '\u2271': MO.REL,
        '\u2272': MO.REL,
        '\u2273': MO.REL,
        '\u2274': MO.REL,
        '\u2275': MO.REL,
        '\u2276': MO.REL,
        '\u2277': MO.REL,
        '\u2278': MO.REL,
        '\u2279': MO.REL,
        '\u227A': MO.REL,
        '\u227B': MO.REL,
        '\u227C': MO.REL,
        '\u227D': MO.REL,
        '\u227E': MO.REL,
        '\u227F': MO.REL,
        '\u227F\u0338': MO.REL,
        '\u2280': MO.REL,
        '\u2281': MO.REL,
        '\u2282': MO.REL,
        '\u2282\u20D2': MO.REL,
        '\u2283': MO.REL,
        '\u2283\u20D2': MO.REL,
        '\u2284': MO.REL,
        '\u2285': MO.REL,
        '\u2286': MO.REL,
        '\u2287': MO.REL,
        '\u2288': MO.REL,
        '\u2289': MO.REL,
        '\u228A': MO.REL,
        '\u228B': MO.REL,
        '\u228C': MO.BIN4,
        '\u228D': MO.BIN4,
        '\u228E': MO.BIN4,
        '\u228F': MO.REL,
        '\u228F\u0338': MO.REL,
        '\u2290': MO.REL,
        '\u2290\u0338': MO.REL,
        '\u2291': MO.REL,
        '\u2292': MO.REL,
        '\u2293': MO.BIN4,
        '\u2294': MO.BIN4,
        '\u2295': MO.BIN4,
        '\u2296': MO.BIN4,
        '\u2297': MO.BIN4,
        '\u2298': MO.BIN4,
        '\u2299': MO.BIN4,
        '\u229A': MO.BIN4,
        '\u229B': MO.BIN4,
        '\u229C': MO.BIN4,
        '\u229D': MO.BIN4,
        '\u229E': MO.BIN4,
        '\u229F': MO.BIN4,
        '\u22A0': MO.BIN4,
        '\u22A1': MO.BIN4,
        '\u22A2': MO.REL,
        '\u22A3': MO.REL,
        '\u22A4': MO.ORD55,
        '\u22A5': MO.REL,
        '\u22A6': MO.REL,
        '\u22A7': MO.REL,
        '\u22A8': MO.REL,
        '\u22A9': MO.REL,
        '\u22AA': MO.REL,
        '\u22AB': MO.REL,
        '\u22AC': MO.REL,
        '\u22AD': MO.REL,
        '\u22AE': MO.REL,
        '\u22AF': MO.REL,
        '\u22B0': MO.REL,
        '\u22B1': MO.REL,
        '\u22B2': MO.REL,
        '\u22B3': MO.REL,
        '\u22B4': MO.REL,
        '\u22B5': MO.REL,
        '\u22B6': MO.REL,
        '\u22B7': MO.REL,
        '\u22B8': MO.REL,
        '\u22B9': MO.REL,
        '\u22BA': MO.BIN4,
        '\u22BB': MO.BIN4,
        '\u22BC': MO.BIN4,
        '\u22BD': MO.BIN4,
        '\u22BE': MO.BIN3,
        '\u22BF': MO.BIN3,
        '\u22C4': MO.BIN4,
        '\u22C5': MO.BIN4,
        '\u22C6': MO.BIN4,
        '\u22C7': MO.BIN4,
        '\u22C8': MO.REL,
        '\u22C9': MO.BIN4,
        '\u22CA': MO.BIN4,
        '\u22CB': MO.BIN4,
        '\u22CC': MO.BIN4,
        '\u22CD': MO.REL,
        '\u22CE': MO.BIN4,
        '\u22CF': MO.BIN4,
        '\u22D0': MO.REL,
        '\u22D1': MO.REL,
        '\u22D2': MO.BIN4,
        '\u22D3': MO.BIN4,
        '\u22D4': MO.REL,
        '\u22D5': MO.REL,
        '\u22D6': MO.REL,
        '\u22D7': MO.REL,
        '\u22D8': MO.REL,
        '\u22D9': MO.REL,
        '\u22DA': MO.REL,
        '\u22DB': MO.REL,
        '\u22DC': MO.REL,
        '\u22DD': MO.REL,
        '\u22DE': MO.REL,
        '\u22DF': MO.REL,
        '\u22E0': MO.REL,
        '\u22E1': MO.REL,
        '\u22E2': MO.REL,
        '\u22E3': MO.REL,
        '\u22E4': MO.REL,
        '\u22E5': MO.REL,
        '\u22E6': MO.REL,
        '\u22E7': MO.REL,
        '\u22E8': MO.REL,
        '\u22E9': MO.REL,
        '\u22EA': MO.REL,
        '\u22EB': MO.REL,
        '\u22EC': MO.REL,
        '\u22ED': MO.REL,
        '\u22EE': MO.ORD55,
        '\u22EF': MO.INNER,
        '\u22F0': MO.REL,
        '\u22F1': [5, 5, TEXCLASS.INNER, null],
        '\u22F2': MO.REL,
        '\u22F3': MO.REL,
        '\u22F4': MO.REL,
        '\u22F5': MO.REL,
        '\u22F6': MO.REL,
        '\u22F7': MO.REL,
        '\u22F8': MO.REL,
        '\u22F9': MO.REL,
        '\u22FA': MO.REL,
        '\u22FB': MO.REL,
        '\u22FC': MO.REL,
        '\u22FD': MO.REL,
        '\u22FE': MO.REL,
        '\u22FF': MO.REL,
        '\u2305': MO.BIN3,
        '\u2306': MO.BIN3,
        '\u2322': MO.REL4,
        '\u2323': MO.REL4,
        '\u2329': MO.OPEN,
        '\u232A': MO.CLOSE,
        '\u23AA': MO.ORD,
        '\u23AF': [0, 0, TEXCLASS.ORD, { stretchy: true }],
        '\u23B0': MO.OPEN,
        '\u23B1': MO.CLOSE,
        '\u2500': MO.ORD,
        '\u25B3': MO.BIN4,
        '\u25B5': MO.BIN4,
        '\u25B9': MO.BIN4,
        '\u25BD': MO.BIN4,
        '\u25BF': MO.BIN4,
        '\u25C3': MO.BIN4,
        '\u25EF': MO.BIN3,
        '\u2660': MO.ORD,
        '\u2661': MO.ORD,
        '\u2662': MO.ORD,
        '\u2663': MO.ORD,
        '\u2758': MO.REL,
        '\u27F0': MO.RELSTRETCH,
        '\u27F1': MO.RELSTRETCH,
        '\u27F5': MO.WIDEREL,
        '\u27F6': MO.WIDEREL,
        '\u27F7': MO.WIDEREL,
        '\u27F8': MO.WIDEREL,
        '\u27F9': MO.WIDEREL,
        '\u27FA': MO.WIDEREL,
        '\u27FB': MO.WIDEREL,
        '\u27FC': MO.WIDEREL,
        '\u27FD': MO.WIDEREL,
        '\u27FE': MO.WIDEREL,
        '\u27FF': MO.WIDEREL,
        '\u2900': MO.RELACCENT,
        '\u2901': MO.RELACCENT,
        '\u2902': MO.RELACCENT,
        '\u2903': MO.RELACCENT,
        '\u2904': MO.RELACCENT,
        '\u2905': MO.RELACCENT,
        '\u2906': MO.RELACCENT,
        '\u2907': MO.RELACCENT,
        '\u2908': MO.REL,
        '\u2909': MO.REL,
        '\u290A': MO.RELSTRETCH,
        '\u290B': MO.RELSTRETCH,
        '\u290C': MO.WIDEREL,
        '\u290D': MO.WIDEREL,
        '\u290E': MO.WIDEREL,
        '\u290F': MO.WIDEREL,
        '\u2910': MO.WIDEREL,
        '\u2911': MO.RELACCENT,
        '\u2912': MO.RELSTRETCH,
        '\u2913': MO.RELSTRETCH,
        '\u2914': MO.RELACCENT,
        '\u2915': MO.RELACCENT,
        '\u2916': MO.RELACCENT,
        '\u2917': MO.RELACCENT,
        '\u2918': MO.RELACCENT,
        '\u2919': MO.RELACCENT,
        '\u291A': MO.RELACCENT,
        '\u291B': MO.RELACCENT,
        '\u291C': MO.RELACCENT,
        '\u291D': MO.RELACCENT,
        '\u291E': MO.RELACCENT,
        '\u291F': MO.RELACCENT,
        '\u2920': MO.RELACCENT,
        '\u2921': MO.RELSTRETCH,
        '\u2922': MO.RELSTRETCH,
        '\u2923': MO.REL,
        '\u2924': MO.REL,
        '\u2925': MO.REL,
        '\u2926': MO.REL,
        '\u2927': MO.REL,
        '\u2928': MO.REL,
        '\u2929': MO.REL,
        '\u292A': MO.REL,
        '\u292B': MO.REL,
        '\u292C': MO.REL,
        '\u292D': MO.REL,
        '\u292E': MO.REL,
        '\u292F': MO.REL,
        '\u2930': MO.REL,
        '\u2931': MO.REL,
        '\u2932': MO.REL,
        '\u2933': MO.RELACCENT,
        '\u2934': MO.REL,
        '\u2935': MO.REL,
        '\u2936': MO.REL,
        '\u2937': MO.REL,
        '\u2938': MO.REL,
        '\u2939': MO.REL,
        '\u293A': MO.RELACCENT,
        '\u293B': MO.RELACCENT,
        '\u293C': MO.RELACCENT,
        '\u293D': MO.RELACCENT,
        '\u293E': MO.REL,
        '\u293F': MO.REL,
        '\u2940': MO.REL,
        '\u2941': MO.REL,
        '\u2942': MO.RELACCENT,
        '\u2943': MO.RELACCENT,
        '\u2944': MO.RELACCENT,
        '\u2945': MO.RELACCENT,
        '\u2946': MO.RELACCENT,
        '\u2947': MO.RELACCENT,
        '\u2948': MO.RELACCENT,
        '\u2949': MO.REL,
        '\u294A': MO.RELACCENT,
        '\u294B': MO.RELACCENT,
        '\u294C': MO.REL,
        '\u294D': MO.REL,
        '\u294E': MO.WIDEREL,
        '\u294F': MO.RELSTRETCH,
        '\u2950': MO.WIDEREL,
        '\u2951': MO.RELSTRETCH,
        '\u2952': MO.WIDEREL,
        '\u2953': MO.WIDEREL,
        '\u2954': MO.RELSTRETCH,
        '\u2955': MO.RELSTRETCH,
        '\u2956': MO.RELSTRETCH,
        '\u2957': MO.RELSTRETCH,
        '\u2958': MO.RELSTRETCH,
        '\u2959': MO.RELSTRETCH,
        '\u295A': MO.WIDEREL,
        '\u295B': MO.WIDEREL,
        '\u295C': MO.RELSTRETCH,
        '\u295D': MO.RELSTRETCH,
        '\u295E': MO.WIDEREL,
        '\u295F': MO.WIDEREL,
        '\u2960': MO.RELSTRETCH,
        '\u2961': MO.RELSTRETCH,
        '\u2962': MO.RELACCENT,
        '\u2963': MO.REL,
        '\u2964': MO.RELACCENT,
        '\u2965': MO.REL,
        '\u2966': MO.RELACCENT,
        '\u2967': MO.RELACCENT,
        '\u2968': MO.RELACCENT,
        '\u2969': MO.RELACCENT,
        '\u296A': MO.RELACCENT,
        '\u296B': MO.RELACCENT,
        '\u296C': MO.RELACCENT,
        '\u296D': MO.RELACCENT,
        '\u296E': MO.RELSTRETCH,
        '\u296F': MO.RELSTRETCH,
        '\u2970': MO.RELACCENT,
        '\u2971': MO.RELACCENT,
        '\u2972': MO.RELACCENT,
        '\u2973': MO.RELACCENT,
        '\u2974': MO.RELACCENT,
        '\u2975': MO.RELACCENT,
        '\u2976': MO.RELACCENT,
        '\u2977': MO.RELACCENT,
        '\u2978': MO.RELACCENT,
        '\u2979': MO.RELACCENT,
        '\u297A': MO.RELACCENT,
        '\u297B': MO.RELACCENT,
        '\u297C': MO.RELACCENT,
        '\u297D': MO.RELACCENT,
        '\u297E': MO.REL,
        '\u297F': MO.REL,
        '\u2981': MO.BIN3,
        '\u2982': MO.BIN3,
        '\u2999': MO.BIN3,
        '\u299A': MO.BIN3,
        '\u299B': MO.BIN3,
        '\u299C': MO.BIN3,
        '\u299D': MO.BIN3,
        '\u299E': MO.BIN3,
        '\u299F': MO.BIN3,
        '\u29A0': MO.BIN3,
        '\u29A1': MO.BIN3,
        '\u29A2': MO.BIN3,
        '\u29A3': MO.BIN3,
        '\u29A4': MO.BIN3,
        '\u29A5': MO.BIN3,
        '\u29A6': MO.BIN3,
        '\u29A7': MO.BIN3,
        '\u29A8': MO.BIN3,
        '\u29A9': MO.BIN3,
        '\u29AA': MO.BIN3,
        '\u29AB': MO.BIN3,
        '\u29AC': MO.BIN3,
        '\u29AD': MO.BIN3,
        '\u29AE': MO.BIN3,
        '\u29AF': MO.BIN3,
        '\u29B0': MO.BIN3,
        '\u29B1': MO.BIN3,
        '\u29B2': MO.BIN3,
        '\u29B3': MO.BIN3,
        '\u29B4': MO.BIN3,
        '\u29B5': MO.BIN3,
        '\u29B6': MO.BIN4,
        '\u29B7': MO.BIN4,
        '\u29B8': MO.BIN4,
        '\u29B9': MO.BIN4,
        '\u29BA': MO.BIN4,
        '\u29BB': MO.BIN4,
        '\u29BC': MO.BIN4,
        '\u29BD': MO.BIN4,
        '\u29BE': MO.BIN4,
        '\u29BF': MO.BIN4,
        '\u29C0': MO.REL,
        '\u29C1': MO.REL,
        '\u29C2': MO.BIN3,
        '\u29C3': MO.BIN3,
        '\u29C4': MO.BIN4,
        '\u29C5': MO.BIN4,
        '\u29C6': MO.BIN4,
        '\u29C7': MO.BIN4,
        '\u29C8': MO.BIN4,
        '\u29C9': MO.BIN3,
        '\u29CA': MO.BIN3,
        '\u29CB': MO.BIN3,
        '\u29CC': MO.BIN3,
        '\u29CD': MO.BIN3,
        '\u29CE': MO.REL,
        '\u29CF': MO.REL,
        '\u29CF\u0338': MO.REL,
        '\u29D0': MO.REL,
        '\u29D0\u0338': MO.REL,
        '\u29D1': MO.REL,
        '\u29D2': MO.REL,
        '\u29D3': MO.REL,
        '\u29D4': MO.REL,
        '\u29D5': MO.REL,
        '\u29D6': MO.BIN4,
        '\u29D7': MO.BIN4,
        '\u29D8': MO.BIN3,
        '\u29D9': MO.BIN3,
        '\u29DB': MO.BIN3,
        '\u29DC': MO.BIN3,
        '\u29DD': MO.BIN3,
        '\u29DE': MO.REL,
        '\u29DF': MO.BIN3,
        '\u29E0': MO.BIN3,
        '\u29E1': MO.REL,
        '\u29E2': MO.BIN4,
        '\u29E3': MO.REL,
        '\u29E4': MO.REL,
        '\u29E5': MO.REL,
        '\u29E6': MO.REL,
        '\u29E7': MO.BIN3,
        '\u29E8': MO.BIN3,
        '\u29E9': MO.BIN3,
        '\u29EA': MO.BIN3,
        '\u29EB': MO.BIN3,
        '\u29EC': MO.BIN3,
        '\u29ED': MO.BIN3,
        '\u29EE': MO.BIN3,
        '\u29EF': MO.BIN3,
        '\u29F0': MO.BIN3,
        '\u29F1': MO.BIN3,
        '\u29F2': MO.BIN3,
        '\u29F3': MO.BIN3,
        '\u29F4': MO.REL,
        '\u29F5': MO.BIN4,
        '\u29F6': MO.BIN4,
        '\u29F7': MO.BIN4,
        '\u29F8': MO.BIN3,
        '\u29F9': MO.BIN3,
        '\u29FA': MO.BIN3,
        '\u29FB': MO.BIN3,
        '\u29FE': MO.BIN4,
        '\u29FF': MO.BIN4,
        '\u2A1D': MO.BIN3,
        '\u2A1E': MO.BIN3,
        '\u2A1F': MO.BIN3,
        '\u2A20': MO.BIN3,
        '\u2A21': MO.BIN3,
        '\u2A22': MO.BIN4,
        '\u2A23': MO.BIN4,
        '\u2A24': MO.BIN4,
        '\u2A25': MO.BIN4,
        '\u2A26': MO.BIN4,
        '\u2A27': MO.BIN4,
        '\u2A28': MO.BIN4,
        '\u2A29': MO.BIN4,
        '\u2A2A': MO.BIN4,
        '\u2A2B': MO.BIN4,
        '\u2A2C': MO.BIN4,
        '\u2A2D': MO.BIN4,
        '\u2A2E': MO.BIN4,
        '\u2A2F': MO.BIN4,
        '\u2A30': MO.BIN4,
        '\u2A31': MO.BIN4,
        '\u2A32': MO.BIN4,
        '\u2A33': MO.BIN4,
        '\u2A34': MO.BIN4,
        '\u2A35': MO.BIN4,
        '\u2A36': MO.BIN4,
        '\u2A37': MO.BIN4,
        '\u2A38': MO.BIN4,
        '\u2A39': MO.BIN4,
        '\u2A3A': MO.BIN4,
        '\u2A3B': MO.BIN4,
        '\u2A3C': MO.BIN4,
        '\u2A3D': MO.BIN4,
        '\u2A3E': MO.BIN4,
        '\u2A3F': MO.BIN4,
        '\u2A40': MO.BIN4,
        '\u2A41': MO.BIN4,
        '\u2A42': MO.BIN4,
        '\u2A43': MO.BIN4,
        '\u2A44': MO.BIN4,
        '\u2A45': MO.BIN4,
        '\u2A46': MO.BIN4,
        '\u2A47': MO.BIN4,
        '\u2A48': MO.BIN4,
        '\u2A49': MO.BIN4,
        '\u2A4A': MO.BIN4,
        '\u2A4B': MO.BIN4,
        '\u2A4C': MO.BIN4,
        '\u2A4D': MO.BIN4,
        '\u2A4E': MO.BIN4,
        '\u2A4F': MO.BIN4,
        '\u2A50': MO.BIN4,
        '\u2A51': MO.BIN4,
        '\u2A52': MO.BIN4,
        '\u2A53': MO.BIN4,
        '\u2A54': MO.BIN4,
        '\u2A55': MO.BIN4,
        '\u2A56': MO.BIN4,
        '\u2A57': MO.BIN4,
        '\u2A58': MO.BIN4,
        '\u2A59': MO.REL,
        '\u2A5A': MO.BIN4,
        '\u2A5B': MO.BIN4,
        '\u2A5C': MO.BIN4,
        '\u2A5D': MO.BIN4,
        '\u2A5E': MO.BIN4,
        '\u2A5F': MO.BIN4,
        '\u2A60': MO.BIN4,
        '\u2A61': MO.BIN4,
        '\u2A62': MO.BIN4,
        '\u2A63': MO.BIN4,
        '\u2A64': MO.BIN4,
        '\u2A65': MO.BIN4,
        '\u2A66': MO.REL,
        '\u2A67': MO.REL,
        '\u2A68': MO.REL,
        '\u2A69': MO.REL,
        '\u2A6A': MO.REL,
        '\u2A6B': MO.REL,
        '\u2A6C': MO.REL,
        '\u2A6D': MO.REL,
        '\u2A6E': MO.REL,
        '\u2A6F': MO.REL,
        '\u2A70': MO.REL,
        '\u2A71': MO.BIN4,
        '\u2A72': MO.BIN4,
        '\u2A73': MO.REL,
        '\u2A74': MO.REL,
        '\u2A75': MO.REL,
        '\u2A76': MO.REL,
        '\u2A77': MO.REL,
        '\u2A78': MO.REL,
        '\u2A79': MO.REL,
        '\u2A7A': MO.REL,
        '\u2A7B': MO.REL,
        '\u2A7C': MO.REL,
        '\u2A7D': MO.REL,
        '\u2A7D\u0338': MO.REL,
        '\u2A7E': MO.REL,
        '\u2A7E\u0338': MO.REL,
        '\u2A7F': MO.REL,
        '\u2A80': MO.REL,
        '\u2A81': MO.REL,
        '\u2A82': MO.REL,
        '\u2A83': MO.REL,
        '\u2A84': MO.REL,
        '\u2A85': MO.REL,
        '\u2A86': MO.REL,
        '\u2A87': MO.REL,
        '\u2A88': MO.REL,
        '\u2A89': MO.REL,
        '\u2A8A': MO.REL,
        '\u2A8B': MO.REL,
        '\u2A8C': MO.REL,
        '\u2A8D': MO.REL,
        '\u2A8E': MO.REL,
        '\u2A8F': MO.REL,
        '\u2A90': MO.REL,
        '\u2A91': MO.REL,
        '\u2A92': MO.REL,
        '\u2A93': MO.REL,
        '\u2A94': MO.REL,
        '\u2A95': MO.REL,
        '\u2A96': MO.REL,
        '\u2A97': MO.REL,
        '\u2A98': MO.REL,
        '\u2A99': MO.REL,
        '\u2A9A': MO.REL,
        '\u2A9B': MO.REL,
        '\u2A9C': MO.REL,
        '\u2A9D': MO.REL,
        '\u2A9E': MO.REL,
        '\u2A9F': MO.REL,
        '\u2AA0': MO.REL,
        '\u2AA1': MO.REL,
        '\u2AA1\u0338': MO.REL,
        '\u2AA2': MO.REL,
        '\u2AA2\u0338': MO.REL,
        '\u2AA3': MO.REL,
        '\u2AA4': MO.REL,
        '\u2AA5': MO.REL,
        '\u2AA6': MO.REL,
        '\u2AA7': MO.REL,
        '\u2AA8': MO.REL,
        '\u2AA9': MO.REL,
        '\u2AAA': MO.REL,
        '\u2AAB': MO.REL,
        '\u2AAC': MO.REL,
        '\u2AAD': MO.REL,
        '\u2AAE': MO.REL,
        '\u2AAF': MO.REL,
        '\u2AAF\u0338': MO.REL,
        '\u2AB0': MO.REL,
        '\u2AB0\u0338': MO.REL,
        '\u2AB1': MO.REL,
        '\u2AB2': MO.REL,
        '\u2AB3': MO.REL,
        '\u2AB4': MO.REL,
        '\u2AB5': MO.REL,
        '\u2AB6': MO.REL,
        '\u2AB7': MO.REL,
        '\u2AB8': MO.REL,
        '\u2AB9': MO.REL,
        '\u2ABA': MO.REL,
        '\u2ABB': MO.REL,
        '\u2ABC': MO.REL,
        '\u2ABD': MO.REL,
        '\u2ABE': MO.REL,
        '\u2ABF': MO.REL,
        '\u2AC0': MO.REL,
        '\u2AC1': MO.REL,
        '\u2AC2': MO.REL,
        '\u2AC3': MO.REL,
        '\u2AC4': MO.REL,
        '\u2AC5': MO.REL,
        '\u2AC6': MO.REL,
        '\u2AC7': MO.REL,
        '\u2AC8': MO.REL,
        '\u2AC9': MO.REL,
        '\u2ACA': MO.REL,
        '\u2ACB': MO.REL,
        '\u2ACC': MO.REL,
        '\u2ACD': MO.REL,
        '\u2ACE': MO.REL,
        '\u2ACF': MO.REL,
        '\u2AD0': MO.REL,
        '\u2AD1': MO.REL,
        '\u2AD2': MO.REL,
        '\u2AD3': MO.REL,
        '\u2AD4': MO.REL,
        '\u2AD5': MO.REL,
        '\u2AD6': MO.REL,
        '\u2AD7': MO.REL,
        '\u2AD8': MO.REL,
        '\u2AD9': MO.REL,
        '\u2ADA': MO.REL,
        '\u2ADB': MO.REL,
        '\u2ADD': MO.REL,
        '\u2ADD\u0338': MO.REL,
        '\u2ADE': MO.REL,
        '\u2ADF': MO.REL,
        '\u2AE0': MO.REL,
        '\u2AE1': MO.REL,
        '\u2AE2': MO.REL,
        '\u2AE3': MO.REL,
        '\u2AE4': MO.REL,
        '\u2AE5': MO.REL,
        '\u2AE6': MO.REL,
        '\u2AE7': MO.REL,
        '\u2AE8': MO.REL,
        '\u2AE9': MO.REL,
        '\u2AEA': MO.REL,
        '\u2AEB': MO.REL,
        '\u2AEC': MO.REL,
        '\u2AED': MO.REL,
        '\u2AEE': MO.REL,
        '\u2AEF': MO.REL,
        '\u2AF0': MO.REL,
        '\u2AF1': MO.REL,
        '\u2AF2': MO.REL,
        '\u2AF3': MO.REL,
        '\u2AF4': MO.BIN4,
        '\u2AF5': MO.BIN4,
        '\u2AF6': MO.BIN4,
        '\u2AF7': MO.REL,
        '\u2AF8': MO.REL,
        '\u2AF9': MO.REL,
        '\u2AFA': MO.REL,
        '\u2AFB': MO.BIN4,
        '\u2AFD': MO.BIN4,
        '\u2AFE': MO.BIN3,
        '\u2B45': MO.RELSTRETCH,
        '\u2B46': MO.RELSTRETCH,
        '\u3008': MO.OPEN,
        '\u3009': MO.CLOSE,
        '\uFE37': MO.WIDEACCENT,
        '\uFE38': MO.WIDEACCENT,
    }
};
OPTABLE.infix['^'] = MO.WIDEREL;
OPTABLE.infix['_'] = MO.WIDEREL;
OPTABLE.infix['\u2ADC'] = MO.REL;
//# sourceMappingURL=OperatorDictionary.js.map
;// ./mjs/util/string.js
function sortLength(a, b) {
    return a.length !== b.length
        ? b.length - a.length
        : a === b
            ? 0
            : a < b
                ? -1
                : 1;
}
function quotePattern(text) {
    return text.replace(/([\^$(){}.+*?\-|[\]:\\])/g, '\\$1');
}
function unicodeChars(text) {
    return Array.from(text).map((c) => c.codePointAt(0));
}
function unicodeString(data) {
    return String.fromCodePoint(...data);
}
function isPercent(x) {
    return !!x.match(/%\s*$/);
}
function split(x) {
    return x.trim().split(/\s+/);
}
function replaceUnicode(text) {
    return text.replace(/\\U(?:([0-9A-Fa-f]{4})|\{\s*([0-9A-Fa-f]{1,6})\s*\})|\\./g, (m, h1, h2) => m === '\\\\' ? '\\' : String.fromCodePoint(parseInt(h1 || h2, 16)));
}
function toEntity(c) {
    return `&#x${c.codePointAt(0).toString(16).toUpperCase()};`;
}
//# sourceMappingURL=string.js.map
;// ./mjs/core/MmlTree/MmlNodes/mo.js



class MmlMo extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this._texClass = null;
        this.lspace = 5 / 18;
        this.rspace = 5 / 18;
    }
    get texClass() {
        if (this._texClass === null) {
            return this.getOperatorDef(this.getText())[2];
        }
        return this._texClass;
    }
    set texClass(value) {
        this._texClass = value;
    }
    get kind() {
        return 'mo';
    }
    get isEmbellished() {
        return true;
    }
    coreParent() {
        let embellished = null;
        let parent = this;
        const math = this.factory.getNodeClass('math');
        while (parent &&
            parent.isEmbellished &&
            parent.coreMO() === this &&
            !(parent instanceof math)) {
            embellished = parent;
            parent = parent.parent;
        }
        return embellished || this;
    }
    coreText(parent) {
        if (!parent) {
            return '';
        }
        if (parent.isEmbellished) {
            return parent.coreMO().getText();
        }
        while ((((parent.isKind('mrow') ||
            parent.isKind('TeXAtom') ||
            parent.isKind('mstyle') ||
            parent.isKind('mphantom')) &&
            parent.childNodes.length === 1) ||
            parent.isKind('munderover')) &&
            parent.childNodes[0]) {
            parent = parent.childNodes[0];
        }
        return parent.isToken ? parent.getText() : '';
    }
    hasSpacingAttributes() {
        return this.attributes.isSet('lspace') || this.attributes.isSet('rspace');
    }
    get isAccent() {
        let accent = false;
        const node = this.coreParent().parent;
        if (node) {
            const key = node.isKind('mover')
                ? node.childNodes[node.over].coreMO()
                    ? 'accent'
                    : ''
                : node.isKind('munder')
                    ? node.childNodes[node.under].coreMO()
                        ? 'accentunder'
                        : ''
                    : node.isKind('munderover')
                        ? this === node.childNodes[node.over].coreMO()
                            ? 'accent'
                            : this === node.childNodes[node.under].coreMO()
                                ? 'accentunder'
                                : ''
                        : '';
            if (key) {
                const value = node.attributes.getExplicit(key);
                accent = (value !== undefined ? accent : this.attributes.get('accent'));
            }
        }
        return accent;
    }
    setTeXclass(prev) {
        const { form, fence } = this.attributes.getList('form', 'fence');
        if (this.getProperty('texClass') === undefined &&
            this.hasSpacingAttributes()) {
            return null;
        }
        if (fence && this.texClass === TEXCLASS.REL) {
            if (form === 'prefix') {
                this.texClass = TEXCLASS.OPEN;
            }
            if (form === 'postfix') {
                this.texClass = TEXCLASS.CLOSE;
            }
        }
        return this.adjustTeXclass(prev);
    }
    adjustTeXclass(prev) {
        const texClass = this.texClass;
        let prevClass = this.prevClass;
        if (texClass === TEXCLASS.NONE) {
            return prev;
        }
        if (prev) {
            if (prev.getProperty('autoOP') &&
                (texClass === TEXCLASS.BIN || texClass === TEXCLASS.REL)) {
                prevClass = prev.texClass = TEXCLASS.ORD;
            }
            prevClass = this.prevClass = prev.texClass || TEXCLASS.ORD;
            this.prevLevel = this.attributes.getInherited('scriptlevel');
        }
        else {
            prevClass = this.prevClass = TEXCLASS.NONE;
        }
        if (texClass === TEXCLASS.BIN &&
            (prevClass === TEXCLASS.NONE ||
                prevClass === TEXCLASS.BIN ||
                prevClass === TEXCLASS.OP ||
                prevClass === TEXCLASS.REL ||
                prevClass === TEXCLASS.OPEN ||
                prevClass === TEXCLASS.PUNCT)) {
            this.texClass = TEXCLASS.ORD;
        }
        else if (prevClass === TEXCLASS.BIN &&
            (texClass === TEXCLASS.REL ||
                texClass === TEXCLASS.CLOSE ||
                texClass === TEXCLASS.PUNCT)) {
            prev.texClass = this.prevClass = TEXCLASS.ORD;
        }
        else if (texClass === TEXCLASS.BIN) {
            let child = null;
            let parent = this.parent;
            while (parent &&
                parent.parent &&
                parent.isEmbellished &&
                (parent.childNodes.length === 1 ||
                    (!parent.isKind('mrow') && parent.core() === child))) {
                child = parent;
                parent = parent.parent;
            }
            child = child || this;
            if (parent.childNodes[parent.childNodes.length - 1] === child) {
                this.texClass = TEXCLASS.ORD;
            }
        }
        return this;
    }
    setInheritedAttributes(attributes = {}, display = false, level = 0, prime = false) {
        super.setInheritedAttributes(attributes, display, level, prime);
        const mo = this.getText();
        this.checkOperatorTable(mo);
        this.checkPseudoScripts(mo);
        this.checkPrimes(mo);
        this.checkMathAccent(mo);
    }
    getOperatorDef(mo) {
        const [form1, form2, form3] = this.handleExplicitForm(this.getForms());
        this.attributes.setInherited('form', form1);
        const CLASS = this.constructor;
        const OPTABLE = CLASS.OPTABLE;
        const def = OPTABLE[form1][mo] || OPTABLE[form2][mo] || OPTABLE[form3][mo];
        if (def) {
            return def;
        }
        this.setProperty('noDictDef', true);
        const limits = this.attributes.get('movablelimits');
        const isOP = !!mo.match(CLASS.opPattern);
        if ((isOP || limits) && this.getProperty('texClass') === undefined) {
            return OPDEF(1, 2, TEXCLASS.OP);
        }
        const range = getRange(mo);
        const [l, r] = CLASS.MMLSPACING[range[2]];
        return OPDEF(l, r, range[2]);
    }
    checkOperatorTable(mo) {
        const def = this.getOperatorDef(mo);
        if (this.getProperty('texClass') === undefined) {
            this.texClass = def[2];
        }
        for (const name of Object.keys(def[3] || {})) {
            this.attributes.setInherited(name, def[3][name]);
        }
        this.lspace = ((def[0] || -1) + 1) / 18;
        this.rspace = ((def[1] || -1) + 1) / 18;
    }
    getForms() {
        let core = null;
        let parent = this.parent;
        let Parent = this.Parent;
        while (Parent && Parent.isEmbellished) {
            core = parent;
            parent = Parent.parent;
            Parent = Parent.Parent;
        }
        core = core || this;
        if (parent &&
            parent.isKind('mrow') &&
            parent.nonSpaceLength() !== 1) {
            if (parent.firstNonSpace() === core) {
                return ['prefix', 'infix', 'postfix'];
            }
            if (parent.lastNonSpace() === core) {
                return ['postfix', 'infix', 'prefix'];
            }
        }
        return ['infix', 'prefix', 'postfix'];
    }
    handleExplicitForm(forms) {
        if (this.attributes.isSet('form')) {
            const form = this.attributes.get('form');
            forms = [form].concat(forms.filter((name) => name !== form));
        }
        return forms;
    }
    checkPseudoScripts(mo) {
        const PSEUDOSCRIPTS = this.constructor.pseudoScripts;
        if (!mo.match(PSEUDOSCRIPTS))
            return;
        const parent = this.coreParent().Parent;
        const isPseudo = !parent || !(parent.isKind('msubsup') && !parent.isKind('msub'));
        this.setProperty('pseudoscript', isPseudo);
        if (isPseudo) {
            this.attributes.setInherited('lspace', 0);
            this.attributes.setInherited('rspace', 0);
        }
    }
    checkPrimes(mo) {
        const PRIMES = this.constructor.primes;
        if (!mo.match(PRIMES))
            return;
        const REMAP = this.constructor.remapPrimes;
        const primes = unicodeString(unicodeChars(mo).map((c) => REMAP[c]));
        this.setProperty('primes', primes);
    }
    checkMathAccent(mo) {
        const parent = this.Parent;
        if (this.getProperty('mathaccent') !== undefined ||
            !parent ||
            !parent.isKind('munderover'))
            return;
        const [base, under, over] = parent.childNodes;
        if (base.isEmbellished && base.coreMO() === this)
            return;
        const isUnder = !!(under && under.isEmbellished && under.coreMO() === this);
        const isOver = !!(over && over.isEmbellished && under.coreMO() === this);
        if (!isUnder && !isOver)
            return;
        if (this.isMathAccent(mo)) {
            this.setProperty('mathaccent', true);
        }
        else if (this.isMathAccentWithWidth(mo)) {
            this.setProperty('mathaccent', false);
        }
    }
    isMathAccent(mo = this.getText()) {
        const MATHACCENT = this.constructor.mathaccents;
        return !!mo.match(MATHACCENT);
    }
    isMathAccentWithWidth(mo = this.getText()) {
        const MATHACCENT = this.constructor.mathaccentsWithWidth;
        return !!mo.match(MATHACCENT);
    }
}
MmlMo.defaults = Object.assign(Object.assign({}, AbstractMmlTokenNode.defaults), { form: 'infix', fence: false, separator: false, lspace: 'thickmathspace', rspace: 'thickmathspace', stretchy: false, symmetric: false, maxsize: 'infinity', minsize: '0em', largeop: false, movablelimits: false, accent: false, linebreak: 'auto', lineleading: '100%', linebreakstyle: 'before', indentalign: 'auto', indentshift: '0', indenttarget: '', indentalignfirst: 'indentalign', indentshiftfirst: 'indentshift', indentalignlast: 'indentalign', indentshiftlast: 'indentshift' });
MmlMo.MMLSPACING = MMLSPACING;
MmlMo.OPTABLE = OPTABLE;
MmlMo.pseudoScripts = new RegExp([
    '^["\'*`',
    '\u00AA',
    '\u00B0',
    '\u00B2-\u00B4',
    '\u00B9',
    '\u00BA',
    '\u2018-\u201F',
    '\u2032-\u2037\u2057',
    '\u2070\u2071',
    '\u2074-\u207F',
    '\u2080-\u208E',
    ']+$'
].join(''));
MmlMo.primes = new RegExp([
    '^["\'',
    '\u2018-\u201F',
    ']+$',
].join(''));
MmlMo.opPattern = /^[a-zA-Z]{2,}$/;
MmlMo.remapPrimes = {
    0x0022: 0x2033,
    0x0027: 0x2032,
    0x2018: 0x2035,
    0x2019: 0x2032,
    0x201a: 0x2032,
    0x201b: 0x2035,
    0x201c: 0x2036,
    0x201d: 0x2033,
    0x201e: 0x2033,
    0x201f: 0x2036,
};
MmlMo.mathaccents = new RegExp([
    '^[',
    '\u00B4\u0301\u02CA',
    '\u0060\u0300\u02CB',
    '\u00A8\u0308',
    '\u007E\u0303\u02DC',
    '\u00AF\u0304\u02C9',
    '\u02D8\u0306',
    '\u02C7\u030C',
    '\u005E\u0302\u02C6',
    '\u20D0\u20D1',
    '\u20D6\u20D7\u20E1',
    '\u02D9\u0307',
    '\u02DA\u030A',
    '\u20DB',
    '\u20DC',
    ']$'
].join(''));
MmlMo.mathaccentsWithWidth = new RegExp([
    '^[',
    '\u2190\u2192\u2194',
    '\u23DC\u23DD',
    '\u23DE\u23DF',
    ']$'
].join(''));
//# sourceMappingURL=mo.js.map
;// ./mjs/core/MmlTree/MmlNodes/mtext.js

class MmlMtext extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mtext';
    }
    get isSpacelike() {
        return (!!this.getText().match(/^\s*$/) &&
            !this.attributes.hasOneOf(MmlMtext.NONSPACELIKE));
    }
}
MmlMtext.NONSPACELIKE = ['style', 'mathbackground', 'background'];
MmlMtext.defaults = Object.assign({}, AbstractMmlTokenNode.defaults);
//# sourceMappingURL=mtext.js.map
;// ./mjs/core/MmlTree/MmlNodes/mspace.js

class MmlMspace extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.NONE;
    }
    setTeXclass(prev) {
        return prev;
    }
    get kind() {
        return 'mspace';
    }
    get arity() {
        return 0;
    }
    get isSpacelike() {
        return !this.attributes.hasExplicit('linebreak') && this.canBreak;
    }
    get hasNewline() {
        const linebreak = this.attributes.get('linebreak');
        return (this.canBreak &&
            (linebreak === 'newline' || linebreak === 'indentingnewline'));
    }
    get canBreak() {
        return (!this.attributes.hasOneOf(MmlMspace.NONSPACELIKE) &&
            String(this.attributes.get('width')).trim().charAt(0) !== '-');
    }
}
MmlMspace.NONSPACELIKE = [
    'height',
    'depth',
    'style',
    'mathbackground',
    'background',
];
MmlMspace.defaults = Object.assign(Object.assign({}, AbstractMmlTokenNode.defaults), { width: '0em', height: '0ex', depth: '0ex', linebreak: 'auto', indentshift: 'auto', indentalign: 'auto', indenttarget: '', indentalignfirst: 'indentalign', indentshiftfirst: 'indentshift', indentalignlast: 'indentalign', indentshiftlast: 'indentshift' });
//# sourceMappingURL=mspace.js.map
;// ./mjs/core/MmlTree/MmlNodes/ms.js

class MmlMs extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'ms';
    }
}
MmlMs.defaults = Object.assign(Object.assign({}, AbstractMmlTokenNode.defaults), { lquote: '"', rquote: '"' });
//# sourceMappingURL=ms.js.map
;// ./mjs/core/MmlTree/MmlNodes/mrow.js

class MmlMrow extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this._core = null;
    }
    get kind() {
        return 'mrow';
    }
    get isSpacelike() {
        for (const child of this.childNodes) {
            if (!child.isSpacelike) {
                return false;
            }
        }
        return true;
    }
    get isEmbellished() {
        let embellished = false;
        let i = 0;
        for (const child of this.childNodes) {
            if (child) {
                if (child.isEmbellished) {
                    if (embellished) {
                        return false;
                    }
                    embellished = true;
                    this._core = i;
                }
                else if (!child.isSpacelike) {
                    return false;
                }
            }
            i++;
        }
        return embellished;
    }
    core() {
        if (!this.isEmbellished || this._core == null) {
            return this;
        }
        return this.childNodes[this._core];
    }
    coreMO() {
        if (!this.isEmbellished || this._core == null) {
            return this;
        }
        return this.childNodes[this._core].coreMO();
    }
    nonSpaceLength() {
        let n = 0;
        for (const child of this.childNodes) {
            if (child && !child.isSpacelike) {
                n++;
            }
        }
        return n;
    }
    firstNonSpace() {
        for (const child of this.childNodes) {
            if (child && !child.isSpacelike) {
                return child;
            }
        }
        return null;
    }
    lastNonSpace() {
        let i = this.childNodes.length;
        while (--i >= 0) {
            const child = this.childNodes[i];
            if (child && !child.isSpacelike) {
                return child;
            }
        }
        return null;
    }
    setTeXclass(prev) {
        if (this.getProperty('open') != null || this.getProperty('close') != null) {
            this.getPrevClass(prev);
            prev = null;
            for (const child of this.childNodes) {
                prev = child.setTeXclass(prev);
            }
            if (this.texClass == null) {
                this.texClass = TEXCLASS.INNER;
            }
            return this;
        }
        for (const child of this.childNodes) {
            prev = child.setTeXclass(prev);
        }
        if (this.childNodes[0]) {
            this.updateTeXclass(this.childNodes[0]);
        }
        return prev;
    }
}
MmlMrow.defaults = Object.assign({}, AbstractMmlNode.defaults);
class MmlInferredMrow extends MmlMrow {
    get kind() {
        return 'inferredMrow';
    }
    get isInferred() {
        return true;
    }
    get notParent() {
        return true;
    }
    toString() {
        return '[' + this.childNodes.join(',') + ']';
    }
}
MmlInferredMrow.defaults = MmlMrow.defaults;
//# sourceMappingURL=mrow.js.map
;// ./mjs/core/MmlTree/MmlNodes/mfrac.js

class MmlMfrac extends AbstractMmlBaseNode {
    get kind() {
        return 'mfrac';
    }
    get arity() {
        return 2;
    }
    get linebreakContainer() {
        return true;
    }
    get linebreakAlign() {
        return '';
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        for (const child of this.childNodes) {
            child.setTeXclass(null);
        }
        return this;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        if (!display || level > 0) {
            level++;
        }
        const numalign = this.attributes.get('numalign');
        const denalign = this.attributes.get('denomalign');
        const numAttributes = this.addInheritedAttributes(Object.assign({}, attributes), {
            numalign,
            indentshift: '0',
            indentalignfirst: numalign,
            indentshiftfirst: '0',
            indentalignlast: 'indentalign',
            indentshiftlast: 'indentshift',
        });
        const denAttributes = this.addInheritedAttributes(Object.assign({}, attributes), {
            denalign,
            indentshift: '0',
            indentalignfirst: denalign,
            indentshiftfirst: '0',
            indentalignlast: 'indentalign',
            indentshiftlast: 'indentshift',
        });
        this.childNodes[0].setInheritedAttributes(numAttributes, false, level, prime);
        this.childNodes[1].setInheritedAttributes(denAttributes, false, level, true);
    }
}
MmlMfrac.defaults = Object.assign(Object.assign({}, AbstractMmlBaseNode.defaults), { linethickness: 'medium', numalign: 'center', denomalign: 'center', bevelled: false });
//# sourceMappingURL=mfrac.js.map
;// ./mjs/core/MmlTree/MmlNodes/msqrt.js

class MmlMsqrt extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'msqrt';
    }
    get arity() {
        return -1;
    }
    get linebreakContainer() {
        return true;
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        this.childNodes[0].setTeXclass(null);
        return this;
    }
    setChildInheritedAttributes(attributes, display, level, _prime) {
        this.childNodes[0].setInheritedAttributes(attributes, display, level, true);
    }
}
MmlMsqrt.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { 'data-vertical-align': 'bottom' });
//# sourceMappingURL=msqrt.js.map
;// ./mjs/core/MmlTree/MmlNodes/mroot.js

class MmlMroot extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mroot';
    }
    get arity() {
        return 2;
    }
    get linebreakContainer() {
        return true;
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        this.childNodes[0].setTeXclass(null);
        this.childNodes[1].setTeXclass(null);
        return this;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        this.childNodes[0].setInheritedAttributes(attributes, display, level, true);
        this.childNodes[1].setInheritedAttributes(attributes, false, level + 2, prime);
    }
}
MmlMroot.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { 'data-vertical-align': 'bottom' });
//# sourceMappingURL=mroot.js.map
;// ./mjs/core/MmlTree/MmlNodes/mstyle.js


class MmlMstyle extends AbstractMmlLayoutNode {
    get kind() {
        return 'mstyle';
    }
    get notParent() {
        return this.childNodes[0] && this.childNodes[0].childNodes.length === 1;
    }
    setInheritedAttributes(attributes = {}, display = false, level = 0, prime = false) {
        this.attributes.setInherited('displaystyle', display);
        this.attributes.setInherited('scriptlevel', level);
        super.setInheritedAttributes(attributes, display, level, prime);
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        let scriptlevel = this.attributes.getExplicit('scriptlevel');
        if (scriptlevel != null) {
            scriptlevel = scriptlevel.toString();
            if (scriptlevel.match(/^\s*[-+]/)) {
                level += parseInt(scriptlevel);
            }
            else {
                level = parseInt(scriptlevel);
            }
            prime = false;
        }
        const displaystyle = this.attributes.getExplicit('displaystyle');
        if (displaystyle != null) {
            display = displaystyle === true;
            prime = false;
        }
        const cramped = this.attributes.getExplicit('data-cramped');
        if (cramped != null) {
            prime = cramped;
        }
        attributes = this.addInheritedAttributes(attributes, this.attributes.getAllAttributes());
        this.childNodes[0].setInheritedAttributes(attributes, display, level, prime);
    }
}
MmlMstyle.defaults = Object.assign(Object.assign({}, AbstractMmlLayoutNode.defaults), { scriptlevel: INHERIT, displaystyle: INHERIT, scriptsizemultiplier: 1 / Math.sqrt(2), scriptminsize: '.4em', mathbackground: INHERIT, mathcolor: INHERIT, dir: INHERIT, infixlinebreakstyle: 'before' });
//# sourceMappingURL=mstyle.js.map
;// ./mjs/core/MmlTree/MmlNodes/merror.js

class MmlMerror extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'merror';
    }
    get arity() {
        return -1;
    }
    get linebreakContainer() {
        return true;
    }
}
MmlMerror.defaults = Object.assign({}, AbstractMmlNode.defaults);
//# sourceMappingURL=merror.js.map
;// ./mjs/core/MmlTree/MmlNodes/mpadded.js

class MmlMpadded extends AbstractMmlLayoutNode {
    get kind() {
        return 'mpadded';
    }
    get linebreakContainer() {
        return true;
    }
    setTeXclass(prev) {
        if (!this.getProperty('vbox')) {
            return super.setTeXclass(prev);
        }
        this.getPrevClass(prev);
        this.texClass = TEXCLASS.ORD;
        this.childNodes[0].setTeXclass(null);
        return this;
    }
}
MmlMpadded.defaults = Object.assign(Object.assign({}, AbstractMmlLayoutNode.defaults), { width: '', height: '', depth: '', lspace: 0, voffset: 0 });
//# sourceMappingURL=mpadded.js.map
;// ./mjs/core/MmlTree/MmlNodes/mphantom.js

class MmlMphantom extends AbstractMmlLayoutNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mphantom';
    }
}
MmlMphantom.defaults = Object.assign({}, AbstractMmlLayoutNode.defaults);
//# sourceMappingURL=mphantom.js.map
;// ./mjs/core/MmlTree/MmlNodes/mfenced.js

class MmlMfenced extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.INNER;
        this.separators = [];
        this.open = null;
        this.close = null;
    }
    get kind() {
        return 'mfenced';
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        if (this.open) {
            prev = this.open.setTeXclass(prev);
        }
        if (this.childNodes[0]) {
            prev = this.childNodes[0].setTeXclass(prev);
        }
        for (let i = 1, m = this.childNodes.length; i < m; i++) {
            if (this.separators[i - 1]) {
                prev = this.separators[i - 1].setTeXclass(prev);
            }
            if (this.childNodes[i]) {
                prev = this.childNodes[i].setTeXclass(prev);
            }
        }
        if (this.close) {
            prev = this.close.setTeXclass(prev);
        }
        this.updateTeXclass(this.open);
        return prev;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        this.addFakeNodes();
        for (const child of [this.open, this.close].concat(this.separators)) {
            if (child) {
                child.setInheritedAttributes(attributes, display, level, prime);
            }
        }
        super.setChildInheritedAttributes(attributes, display, level, prime);
    }
    addFakeNodes() {
        let { open, close, separators } = this.attributes.getList('open', 'close', 'separators');
        open = open.replace(/[ \t\n\r]/g, '');
        close = close.replace(/[ \t\n\r]/g, '');
        separators = separators.replace(/[ \t\n\r]/g, '');
        if (open) {
            this.open = this.fakeNode(open, { fence: true, form: 'prefix' }, TEXCLASS.OPEN);
        }
        if (separators) {
            while (separators.length < this.childNodes.length - 1) {
                separators += separators.charAt(separators.length - 1);
            }
            let i = 0;
            for (const child of this.childNodes.slice(1)) {
                if (child) {
                    this.separators.push(this.fakeNode(separators.charAt(i++)));
                }
            }
        }
        if (close) {
            this.close = this.fakeNode(close, { fence: true, form: 'postfix' }, TEXCLASS.CLOSE);
        }
    }
    fakeNode(c, properties = {}, texClass = null) {
        const text = this.factory.create('text').setText(c);
        const node = this.factory.create('mo', properties, [text]);
        node.texClass = texClass;
        node.parent = this;
        return node;
    }
}
MmlMfenced.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { open: '(', close: ')', separators: ',' });
//# sourceMappingURL=mfenced.js.map
;// ./mjs/core/MmlTree/MmlNodes/menclose.js

class MmlMenclose extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'menclose';
    }
    get arity() {
        return -1;
    }
    get linebreakContainer() {
        return true;
    }
    setTeXclass(prev) {
        prev = this.childNodes[0].setTeXclass(prev);
        this.updateTeXclass(this.childNodes[0]);
        return prev;
    }
}
MmlMenclose.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { notation: 'longdiv' });
//# sourceMappingURL=menclose.js.map
;// ./mjs/core/MmlTree/MmlNodes/maction.js

class MmlMaction extends AbstractMmlNode {
    get kind() {
        return 'maction';
    }
    get arity() {
        return 1;
    }
    get selected() {
        const selection = this.attributes.get('selection');
        const i = Math.max(1, Math.min(this.childNodes.length, selection)) - 1;
        return this.childNodes[i] || this.factory.create('mrow');
    }
    get isEmbellished() {
        return this.selected.isEmbellished;
    }
    get isSpacelike() {
        return this.selected.isSpacelike;
    }
    core() {
        return this.selected.core();
    }
    coreMO() {
        return this.selected.coreMO();
    }
    verifyAttributes(options) {
        super.verifyAttributes(options);
        if (this.attributes.get('actiontype') !== 'toggle' &&
            this.attributes.hasExplicit('selection')) {
            this.attributes.unset('selection');
        }
    }
    setTeXclass(prev) {
        if (this.attributes.get('actiontype') === 'tooltip' && this.childNodes[1]) {
            this.childNodes[1].setTeXclass(null);
        }
        const selected = this.selected;
        prev = selected.setTeXclass(prev);
        this.updateTeXclass(selected);
        return prev;
    }
    nextToggleSelection() {
        let selection = Math.max(1, parseInt(this.attributes.get('selection')) + 1);
        if (selection > this.childNodes.length) {
            selection = 1;
        }
        this.attributes.set('selection', selection);
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        var _a, _b;
        if (this.attributes.get('actiontype').toLowerCase() !== 'tooltip') {
            super.setChildInheritedAttributes(attributes, display, level, prime);
            return;
        }
        (_a = this.childNodes[0]) === null || _a === void 0 ? void 0 : _a.setInheritedAttributes(attributes, display, level, prime);
        (_b = this.childNodes[1]) === null || _b === void 0 ? void 0 : _b.setInheritedAttributes(attributes, false, 1, false);
    }
}
MmlMaction.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { actiontype: 'toggle', selection: 1 });
//# sourceMappingURL=maction.js.map
;// ./mjs/core/MmlTree/MmlNodes/msubsup.js

class MmlMsubsup extends AbstractMmlBaseNode {
    get kind() {
        return 'msubsup';
    }
    get arity() {
        return 3;
    }
    get base() {
        return 0;
    }
    get sub() {
        return 1;
    }
    get sup() {
        return 2;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        const nodes = this.childNodes;
        nodes[0].setInheritedAttributes(attributes, display, level, prime);
        nodes[1].setInheritedAttributes(attributes, false, level + 1, prime || this.sub === 1);
        if (!nodes[2]) {
            return;
        }
        nodes[2].setInheritedAttributes(attributes, false, level + 1, prime || this.sub === 2);
    }
}
MmlMsubsup.defaults = Object.assign(Object.assign({}, AbstractMmlBaseNode.defaults), { subscriptshift: '', superscriptshift: '' });
class MmlMsub extends MmlMsubsup {
    get kind() {
        return 'msub';
    }
    get arity() {
        return 2;
    }
}
MmlMsub.defaults = Object.assign({}, MmlMsubsup.defaults);
class MmlMsup extends MmlMsubsup {
    get kind() {
        return 'msup';
    }
    get arity() {
        return 2;
    }
    get sup() {
        return 1;
    }
    get sub() {
        return 2;
    }
}
MmlMsup.defaults = Object.assign({}, MmlMsubsup.defaults);
//# sourceMappingURL=msubsup.js.map
;// ./mjs/core/MmlTree/MmlNodes/munderover.js

class MmlMunderover extends AbstractMmlBaseNode {
    get kind() {
        return 'munderover';
    }
    get arity() {
        return 3;
    }
    get base() {
        return 0;
    }
    get under() {
        return 1;
    }
    get over() {
        return 2;
    }
    get linebreakContainer() {
        return true;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        const nodes = this.childNodes;
        nodes[0].setInheritedAttributes(attributes, display, level, prime || !!nodes[this.over]);
        const force = !!(!display && nodes[0].coreMO().attributes.get('movablelimits'));
        const ACCENTS = this.constructor.ACCENTS;
        nodes[1].setInheritedAttributes(attributes, false, this.getScriptlevel(ACCENTS[1], force, level), prime || this.under === 1);
        this.setInheritedAccent(1, ACCENTS[1], display, level, prime, force);
        if (!nodes[2]) {
            return;
        }
        nodes[2].setInheritedAttributes(attributes, false, this.getScriptlevel(ACCENTS[2], force, level), prime || this.under === 2);
        this.setInheritedAccent(2, ACCENTS[2], display, level, prime, force);
    }
    getScriptlevel(accent, force, level) {
        if (force || !this.attributes.get(accent)) {
            level++;
        }
        return level;
    }
    setInheritedAccent(n, accent, display, level, prime, force) {
        const node = this.childNodes[n];
        if (!this.attributes.hasExplicit(accent) && node.isEmbellished) {
            const value = node.coreMO().attributes.get('accent');
            this.attributes.setInherited(accent, value);
            if (value !== this.attributes.getDefault(accent)) {
                node.setInheritedAttributes({}, display, this.getScriptlevel(accent, force, level), prime);
            }
        }
    }
}
MmlMunderover.defaults = Object.assign(Object.assign({}, AbstractMmlBaseNode.defaults), { accent: false, accentunder: false, align: 'center' });
MmlMunderover.ACCENTS = ['', 'accentunder', 'accent'];
class MmlMunder extends MmlMunderover {
    get kind() {
        return 'munder';
    }
    get arity() {
        return 2;
    }
}
MmlMunder.defaults = Object.assign({}, MmlMunderover.defaults);
class MmlMover extends MmlMunderover {
    get kind() {
        return 'mover';
    }
    get arity() {
        return 2;
    }
    get over() {
        return 1;
    }
    get under() {
        return 2;
    }
}
MmlMover.defaults = Object.assign({}, MmlMunderover.defaults);
MmlMover.ACCENTS = ['', 'accent', 'accentunder'];
//# sourceMappingURL=munderover.js.map
;// ./mjs/core/MmlTree/MmlNodes/mmultiscripts.js


class MmlMmultiscripts extends MmlMsubsup {
    get kind() {
        return 'mmultiscripts';
    }
    get arity() {
        return 1;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        this.childNodes[0].setInheritedAttributes(attributes, display, level, prime);
        let prescripts = false;
        for (let i = 1, n = 0; i < this.childNodes.length; i++) {
            const child = this.childNodes[i];
            if (child.isKind('mprescripts')) {
                if (!prescripts) {
                    prescripts = true;
                    if (i % 2 === 0) {
                        const none = this.factory.create('none');
                        this.childNodes.splice(i, 0, none);
                        none.parent = this;
                        i++;
                    }
                }
            }
            else {
                const primestyle = prime || n % 2 === 0;
                child.setInheritedAttributes(attributes, false, level + 1, primestyle);
                n++;
            }
        }
        if (this.childNodes.length % 2 === (prescripts ? 1 : 0)) {
            this.appendChild(this.factory.create('none'));
            this.childNodes[this.childNodes.length - 1].setInheritedAttributes(attributes, false, level + 1, prime);
        }
    }
    verifyChildren(options) {
        let prescripts = false;
        const fix = options['fixMmultiscripts'];
        for (let i = 0; i < this.childNodes.length; i++) {
            const child = this.childNodes[i];
            if (child.isKind('mprescripts')) {
                if (prescripts) {
                    child.mError(child.kind + ' can only appear once in ' + this.kind, options, true);
                }
                else {
                    prescripts = true;
                    if (i % 2 === 0 && !fix) {
                        this.mError('There must be an equal number of prescripts of each type', options);
                    }
                }
            }
        }
        if (this.childNodes.length % 2 === (prescripts ? 1 : 0) && !fix) {
            this.mError('There must be an equal number of scripts of each type', options);
        }
        super.verifyChildren(options);
    }
}
MmlMmultiscripts.defaults = Object.assign({}, MmlMsubsup.defaults);
class MmlMprescripts extends AbstractMmlNode {
    get kind() {
        return 'mprescripts';
    }
    get arity() {
        return 0;
    }
    verifyTree(options) {
        super.verifyTree(options);
        if (this.parent && !this.parent.isKind('mmultiscripts')) {
            this.mError(this.kind + ' must be a child of mmultiscripts', options, true);
        }
    }
}
MmlMprescripts.defaults = Object.assign({}, AbstractMmlNode.defaults);
class MmlNone extends AbstractMmlNode {
    get kind() {
        return 'none';
    }
    get arity() {
        return 0;
    }
    verifyTree(options) {
        super.verifyTree(options);
        if (this.parent && !this.parent.isKind('mmultiscripts')) {
            this.mError(this.kind + ' must be a child of mmultiscripts', options, true);
        }
    }
}
MmlNone.defaults = Object.assign({}, AbstractMmlNode.defaults);
//# sourceMappingURL=mmultiscripts.js.map
;// ./mjs/core/MmlTree/MmlNodes/mtable.js


class MmlMtable extends AbstractMmlNode {
    constructor() {
        super(...arguments);
        this.properties = {
            useHeight: true,
        };
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mtable';
    }
    get linebreakContainer() {
        return true;
    }
    get linebreakAlign() {
        return '';
    }
    setInheritedAttributes(attributes, display, level, prime) {
        for (const name of indentAttributes) {
            if (attributes[name]) {
                this.attributes.setInherited(name, attributes[name][1]);
            }
            if (this.attributes.hasExplicit(name)) {
                this.attributes.unset(name);
            }
        }
        super.setInheritedAttributes(attributes, display, level, prime);
    }
    setChildInheritedAttributes(attributes, display, level, _prime) {
        for (const child of this.childNodes) {
            if (!child.isKind('mtr')) {
                this.replaceChild(this.factory.create('mtr'), child).appendChild(child);
            }
        }
        display = !!(this.attributes.getExplicit('displaystyle') ||
            this.attributes.getDefault('displaystyle'));
        attributes = this.addInheritedAttributes(attributes, {
            columnalign: this.attributes.get('columnalign'),
            rowalign: 'center',
            'data-break-align': this.attributes.get('data-break-align'),
        });
        const cramped = this.attributes.getExplicit('data-cramped');
        const ralign = split(this.attributes.get('rowalign'));
        for (const child of this.childNodes) {
            attributes.rowalign[1] = ralign.shift() || attributes.rowalign[1];
            child.setInheritedAttributes(attributes, display, level, !!cramped);
        }
    }
    verifyChildren(options) {
        let mtr = null;
        const factory = this.factory;
        for (let i = 0; i < this.childNodes.length; i++) {
            const child = this.childNodes[i];
            if (child.isKind('mtr')) {
                mtr = null;
            }
            else {
                const isMtd = child.isKind('mtd');
                if (mtr) {
                    this.removeChild(child);
                    i--;
                }
                else {
                    mtr = this.replaceChild(factory.create('mtr'), child);
                }
                mtr.appendChild(isMtd ? child : factory.create('mtd', {}, [child]));
                if (!options['fixMtables']) {
                    child.parent.removeChild(child);
                    child.parent = this;
                    if (isMtd) {
                        mtr.appendChild(factory.create('mtd'));
                    }
                    const merror = child.mError('Children of ' + this.kind + ' must be mtr or mlabeledtr', options, isMtd);
                    mtr.childNodes[mtr.childNodes.length - 1].appendChild(merror);
                }
            }
        }
        super.verifyChildren(options);
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        for (const child of this.childNodes) {
            child.setTeXclass(null);
        }
        return this;
    }
}
MmlMtable.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { align: 'axis', rowalign: 'baseline', columnalign: 'center', groupalign: '{left}', alignmentscope: true, columnwidth: 'auto', width: 'auto', rowspacing: '1ex', columnspacing: '.8em', rowlines: 'none', columnlines: 'none', frame: 'none', framespacing: '0.4em 0.5ex', equalrows: false, equalcolumns: false, displaystyle: false, side: 'right', minlabelspacing: '0.8em', 'data-break-align': 'top' });
//# sourceMappingURL=mtable.js.map
;// ./mjs/core/MmlTree/MmlNodes/mtr.js



class MmlMtr extends AbstractMmlNode {
    get kind() {
        return 'mtr';
    }
    get linebreakContainer() {
        return true;
    }
    get linebreakAlign() {
        return '';
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        for (const child of this.childNodes) {
            if (!child.isKind('mtd')) {
                this.replaceChild(this.factory.create('mtd'), child).appendChild(child);
            }
        }
        const calign = split(this.attributes.get('columnalign'));
        const balign = split(this.attributes.get('data-break-align'));
        if (this.arity === 1) {
            calign.unshift(this.parent.attributes.get('side'));
            balign.unshift('top');
        }
        attributes = this.addInheritedAttributes(attributes, {
            rowalign: this.attributes.get('rowalign'),
            columnalign: 'center',
            'data-break-align': 'top',
        });
        for (const child of this.childNodes) {
            attributes.columnalign[1] = calign.shift() || attributes.columnalign[1];
            attributes['data-vertical-align'] = [
                this.kind,
                balign.shift() || attributes['data-break-align'][1],
            ];
            child.setInheritedAttributes(attributes, display, level, prime);
        }
    }
    verifyChildren(options) {
        if (this.parent && !this.parent.isKind('mtable')) {
            this.mError(this.kind + ' can only be a child of an mtable', options, true);
            return;
        }
        for (const child of this.childNodes) {
            if (!child.isKind('mtd')) {
                const mtd = this.replaceChild(this.factory.create('mtd'), child);
                mtd.appendChild(child);
                if (!options['fixMtables']) {
                    child.mError('Children of ' + this.kind + ' must be mtd', options);
                }
            }
        }
        super.verifyChildren(options);
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        for (const child of this.childNodes) {
            child.setTeXclass(null);
        }
        return this;
    }
}
MmlMtr.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { rowalign: INHERIT, columnalign: INHERIT, groupalign: INHERIT, 'data-break-align': 'top' });
class MmlMlabeledtr extends MmlMtr {
    get kind() {
        return 'mlabeledtr';
    }
    get arity() {
        return 1;
    }
}
//# sourceMappingURL=mtr.js.map
;// ./mjs/core/MmlTree/MmlNodes/mtd.js


class MmlMtd extends AbstractMmlBaseNode {
    get kind() {
        return 'mtd';
    }
    get arity() {
        return -1;
    }
    get linebreakContainer() {
        return true;
    }
    get linebreakAlign() {
        return 'columnalign';
    }
    verifyChildren(options) {
        if (this.parent && !this.parent.isKind('mtr')) {
            this.mError(this.kind + ' can only be a child of an mtr or mlabeledtr', options, true);
            return;
        }
        super.verifyChildren(options);
    }
    setTeXclass(prev) {
        this.getPrevClass(prev);
        this.childNodes[0].setTeXclass(null);
        return this;
    }
}
MmlMtd.defaults = Object.assign(Object.assign({}, AbstractMmlBaseNode.defaults), { rowspan: 1, columnspan: 1, rowalign: INHERIT, columnalign: INHERIT, groupalign: INHERIT, 'data-vertical-align': 'top' });
//# sourceMappingURL=mtd.js.map
;// ./mjs/core/MmlTree/MmlNodes/maligngroup.js


class MmlMaligngroup extends AbstractMmlLayoutNode {
    get kind() {
        return 'maligngroup';
    }
    get isSpacelike() {
        return true;
    }
    setChildInheritedAttributes(attributes, display, level, prime) {
        attributes = this.addInheritedAttributes(attributes, this.attributes.getAllAttributes());
        super.setChildInheritedAttributes(attributes, display, level, prime);
    }
}
MmlMaligngroup.defaults = Object.assign(Object.assign({}, AbstractMmlLayoutNode.defaults), { groupalign: INHERIT });
//# sourceMappingURL=maligngroup.js.map
;// ./mjs/core/MmlTree/MmlNodes/malignmark.js

class MmlMalignmark extends AbstractMmlNode {
    get kind() {
        return 'malignmark';
    }
    get arity() {
        return 0;
    }
    get isSpacelike() {
        return true;
    }
}
MmlMalignmark.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { edge: 'left' });
//# sourceMappingURL=malignmark.js.map
;// ./mjs/core/MmlTree/MmlNodes/mglyph.js

class MmlMglyph extends AbstractMmlTokenNode {
    constructor() {
        super(...arguments);
        this.texclass = TEXCLASS.ORD;
    }
    get kind() {
        return 'mglyph';
    }
    verifyAttributes(options) {
        const { src, fontfamily, index } = this.attributes.getList('src', 'fontfamily', 'index');
        if (src === '' && (fontfamily === '' || index === '')) {
            this.mError('mglyph must have either src or fontfamily and index attributes', options, true);
        }
        else {
            super.verifyAttributes(options);
        }
    }
}
MmlMglyph.defaults = Object.assign(Object.assign({}, AbstractMmlTokenNode.defaults), { alt: '', src: '', index: '', width: 'auto', height: 'auto', valign: '0em' });
//# sourceMappingURL=mglyph.js.map
;// ./mjs/core/MmlTree/MmlNodes/semantics.js

class MmlSemantics extends AbstractMmlBaseNode {
    get kind() {
        return 'semantics';
    }
    get arity() {
        return 1;
    }
    get notParent() {
        return true;
    }
}
MmlSemantics.defaults = Object.assign(Object.assign({}, AbstractMmlBaseNode.defaults), { definitionUrl: null, encoding: null });
class MmlAnnotationXML extends AbstractMmlNode {
    get kind() {
        return 'annotation-xml';
    }
    setChildInheritedAttributes() { }
}
MmlAnnotationXML.defaults = Object.assign(Object.assign({}, AbstractMmlNode.defaults), { definitionUrl: null, encoding: null, cd: 'mathmlkeys', name: '', src: null });
class MmlAnnotation extends MmlAnnotationXML {
    constructor() {
        super(...arguments);
        this.properties = {
            isChars: true,
        };
    }
    get kind() {
        return 'annotation';
    }
}
MmlAnnotation.defaults = Object.assign({}, MmlAnnotationXML.defaults);
//# sourceMappingURL=semantics.js.map
;// ./mjs/core/MmlTree/MmlNodes/TeXAtom.js


class TeXAtom extends AbstractMmlBaseNode {
    get kind() {
        return 'TeXAtom';
    }
    get arity() {
        return -1;
    }
    get notParent() {
        return true;
    }
    constructor(factory, attributes, children) {
        super(factory, attributes, children);
        this.texclass = TEXCLASS.ORD;
        this.setProperty('texClass', this.texClass);
    }
    setTeXclass(prev) {
        this.childNodes[0].setTeXclass(null);
        return this.adjustTeXclass(prev);
    }
    adjustTeXclass(prev) {
        return prev;
    }
}
TeXAtom.defaults = Object.assign({}, AbstractMmlBaseNode.defaults);
TeXAtom.prototype.adjustTeXclass = MmlMo.prototype.adjustTeXclass;
//# sourceMappingURL=TeXAtom.js.map
;// ./mjs/core/MmlTree/MmlNodes/mathchoice.js

class MathChoice extends AbstractMmlBaseNode {
    get kind() {
        return 'MathChoice';
    }
    get arity() {
        return 4;
    }
    get notParent() {
        return true;
    }
    setInheritedAttributes(attributes, display, level, prime) {
        const selection = display ? 0 : Math.max(0, Math.min(level, 2)) + 1;
        const child = this.childNodes[selection] || this.factory.create('mrow');
        this.parent.replaceChild(child, this);
        child.setInheritedAttributes(attributes, display, level, prime);
    }
}
MathChoice.defaults = Object.assign({}, AbstractMmlBaseNode.defaults);
//# sourceMappingURL=mathchoice.js.map
;// ./mjs/core/MmlTree/MmlNodes/HtmlNode.js

class HtmlNode extends XMLNode {
    get kind() {
        return 'html';
    }
    getHTML() {
        return this.getXML();
    }
    setHTML(html, adaptor = null) {
        try {
            adaptor.getAttribute(html, 'data-mjx-hdw');
        }
        catch (_error) {
            html = adaptor.node('span', {}, [html]);
        }
        return this.setXML(html, adaptor);
    }
    getSerializedHTML() {
        return this.adaptor.outerHTML(this.xml);
    }
    textContent() {
        return this.adaptor.textContent(this.xml);
    }
    toString() {
        const kind = this.adaptor.kind(this.xml);
        return `HTML=<${kind}>...</${kind}>`;
    }
    verifyTree(options) {
        if (this.parent && !this.parent.isToken) {
            this.mError('HTML can only be a child of a token element', options, true);
            return;
        }
    }
}
//# sourceMappingURL=HtmlNode.js.map
;// ./mjs/core/MmlTree/MML.js
































const MML = {
    [MmlMath.prototype.kind]: MmlMath,
    [MmlMi.prototype.kind]: MmlMi,
    [MmlMn.prototype.kind]: MmlMn,
    [MmlMo.prototype.kind]: MmlMo,
    [MmlMtext.prototype.kind]: MmlMtext,
    [MmlMspace.prototype.kind]: MmlMspace,
    [MmlMs.prototype.kind]: MmlMs,
    [MmlMrow.prototype.kind]: MmlMrow,
    [MmlInferredMrow.prototype.kind]: MmlInferredMrow,
    [MmlMfrac.prototype.kind]: MmlMfrac,
    [MmlMsqrt.prototype.kind]: MmlMsqrt,
    [MmlMroot.prototype.kind]: MmlMroot,
    [MmlMstyle.prototype.kind]: MmlMstyle,
    [MmlMerror.prototype.kind]: MmlMerror,
    [MmlMpadded.prototype.kind]: MmlMpadded,
    [MmlMphantom.prototype.kind]: MmlMphantom,
    [MmlMfenced.prototype.kind]: MmlMfenced,
    [MmlMenclose.prototype.kind]: MmlMenclose,
    [MmlMaction.prototype.kind]: MmlMaction,
    [MmlMsub.prototype.kind]: MmlMsub,
    [MmlMsup.prototype.kind]: MmlMsup,
    [MmlMsubsup.prototype.kind]: MmlMsubsup,
    [MmlMunder.prototype.kind]: MmlMunder,
    [MmlMover.prototype.kind]: MmlMover,
    [MmlMunderover.prototype.kind]: MmlMunderover,
    [MmlMmultiscripts.prototype.kind]: MmlMmultiscripts,
    [MmlMprescripts.prototype.kind]: MmlMprescripts,
    [MmlNone.prototype.kind]: MmlNone,
    [MmlMtable.prototype.kind]: MmlMtable,
    [MmlMlabeledtr.prototype.kind]: MmlMlabeledtr,
    [MmlMtr.prototype.kind]: MmlMtr,
    [MmlMtd.prototype.kind]: MmlMtd,
    [MmlMaligngroup.prototype.kind]: MmlMaligngroup,
    [MmlMalignmark.prototype.kind]: MmlMalignmark,
    [MmlMglyph.prototype.kind]: MmlMglyph,
    [MmlSemantics.prototype.kind]: MmlSemantics,
    [MmlAnnotation.prototype.kind]: MmlAnnotation,
    [MmlAnnotationXML.prototype.kind]: MmlAnnotationXML,
    [TeXAtom.prototype.kind]: TeXAtom,
    [MathChoice.prototype.kind]: MathChoice,
    [TextNode.prototype.kind]: TextNode,
    [XMLNode.prototype.kind]: XMLNode,
    [HtmlNode.prototype.kind]: HtmlNode,
};
//# sourceMappingURL=MML.js.map
;// ./mjs/core/MmlTree/MmlFactory.js


class MmlFactory extends AbstractNodeFactory {
    get MML() {
        return this.node;
    }
}
MmlFactory.defaultNodes = MML;
//# sourceMappingURL=MmlFactory.js.map
;// ./mjs/util/BitField.js
class BitField {
    constructor() {
        this.bits = 0;
    }
    static allocate(...names) {
        for (const name of names) {
            if (this.has(name)) {
                throw new Error('Bit already allocated for ' + name);
            }
            if (this.next === BitField.MAXBIT) {
                throw new Error('Maximum number of bits already allocated');
            }
            this.names.set(name, this.next);
            this.next <<= 1;
        }
    }
    static has(name) {
        return this.names.has(name);
    }
    set(name) {
        this.bits |= this.getBit(name);
    }
    clear(name) {
        this.bits &= ~this.getBit(name);
    }
    isSet(name) {
        return !!(this.bits & this.getBit(name));
    }
    reset() {
        this.bits = 0;
    }
    getBit(name) {
        const bit = this.constructor.names.get(name);
        if (!bit) {
            throw new Error('Unknown bit-field name: ' + name);
        }
        return bit;
    }
}
BitField.MAXBIT = 1 << 31;
BitField.next = 1;
BitField.names = new Map();
function BitFieldClass(...names) {
    const bits = class extends BitField {
    };
    bits.allocate(...names);
    return bits;
}
//# sourceMappingURL=BitField.js.map
;// ./mjs/util/Retries.js
function handleRetriesFor(code) {
    return new Promise(function run(ok, fail) {
        const handleRetry = (err) => {
            var _a;
            if (err.retry instanceof Promise) {
                err.retry.then(() => run(ok, fail)).catch((e) => fail(e));
            }
            else if ((_a = err.restart) === null || _a === void 0 ? void 0 : _a.isCallback) {
                MathJax.Callback.After(() => run(ok, fail), err.restart);
            }
            else {
                fail(err);
            }
        };
        try {
            const result = code();
            if (result instanceof Promise) {
                result.then((value) => ok(value)).catch((err) => handleRetry(err));
            }
            else {
                ok(result);
            }
        }
        catch (err) {
            handleRetry(err);
        }
    });
}
function retryAfter(promise) {
    const err = new Error('MathJax retry -- an asynchronous action is required; ' +
        'try using one of the promise-based functions and await its resolution.');
    err.retry = promise;
    throw err;
}
//# sourceMappingURL=Retries.js.map
;// ./mjs/core/MathDocument.js
var MathDocument_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









class RenderList extends PrioritizedList {
    static create(actions) {
        const list = new this();
        for (const id of Object.keys(actions)) {
            const [action, priority] = this.action(id, actions[id]);
            if (priority) {
                list.add(action, priority);
            }
        }
        return list;
    }
    static action(id, action) {
        let renderDoc, renderMath;
        let convert = true;
        const priority = action[0];
        if (action.length === 1 || typeof action[1] === 'boolean') {
            if (action.length === 2) {
                convert = action[1];
            }
            [renderDoc, renderMath] = this.methodActions(id);
        }
        else if (typeof action[1] === 'string') {
            if (typeof action[2] === 'string') {
                if (action.length === 4) {
                    convert = action[3];
                }
                const [method1, method2] = action.slice(1);
                [renderDoc, renderMath] = this.methodActions(method1, method2);
            }
            else {
                if (action.length === 3) {
                    convert = action[2];
                }
                [renderDoc, renderMath] = this.methodActions(action[1]);
            }
        }
        else {
            if (action.length === 4) {
                convert = action[3];
            }
            [renderDoc, renderMath] = action.slice(1);
        }
        return [
            { id, renderDoc, renderMath, convert },
            priority,
        ];
    }
    static methodActions(method1, method2 = method1) {
        return [
            (document) => {
                if (method1) {
                    document[method1]();
                }
                return false;
            },
            (math, document) => {
                if (method2) {
                    math[method2](document);
                }
                return false;
            },
        ];
    }
    renderDoc(document, start = STATE.UNPROCESSED) {
        for (const item of this.items) {
            if (item.priority >= start) {
                if (item.item.renderDoc(document))
                    return;
            }
        }
    }
    renderMath(math, document, start = STATE.UNPROCESSED) {
        for (const item of this.items) {
            if (item.priority >= start) {
                if (item.item.renderMath(math, document))
                    return;
            }
        }
    }
    renderConvert(math, document, end = STATE.LAST) {
        for (const item of this.items) {
            if (item.priority > end)
                return;
            if (item.item.convert) {
                if (item.item.renderMath(math, document))
                    return;
            }
        }
    }
    findID(id) {
        for (const item of this.items) {
            if (item.item.id === id) {
                return item.item;
            }
        }
        return null;
    }
}
const resetOptions = {
    all: false,
    processed: false,
    inputJax: null,
    outputJax: null,
};
const resetAllOptions = {
    all: true,
    processed: true,
    inputJax: [],
    outputJax: [],
};
class DefaultInputJax extends AbstractInputJax {
    compile(_math) {
        return null;
    }
}
class DefaultOutputJax extends AbstractOutputJax {
    typeset(_math, _document = null) {
        return null;
    }
    escaped(_math, _document) {
        return null;
    }
}
class DefaultMathList extends AbstractMathList {
}
class DefaultMathItem extends AbstractMathItem {
}
class AbstractMathDocument {
    constructor(document, adaptor, options) {
        const CLASS = this.constructor;
        this.document = document;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
        this.math = new (this.options['MathList'] || DefaultMathList)();
        this.renderActions = RenderList.create(this.options['renderActions']);
        this._actionPromises = [];
        this._readyPromise = Promise.resolve();
        this.processed = new AbstractMathDocument.ProcessBits();
        this.outputJax =
            this.options['OutputJax'] || new DefaultOutputJax();
        let inputJax = this.options['InputJax'] || [new DefaultInputJax()];
        if (!Array.isArray(inputJax)) {
            inputJax = [inputJax];
        }
        this.inputJax = inputJax;
        this.adaptor = adaptor;
        this.outputJax.setAdaptor(adaptor);
        this.inputJax.map((jax) => jax.setAdaptor(adaptor));
        this.mmlFactory = this.options['MmlFactory'] || new MmlFactory();
        this.inputJax.map((jax) => jax.setMmlFactory(this.mmlFactory));
        this.outputJax.initialize();
        this.inputJax.map((jax) => jax.initialize());
    }
    get kind() {
        return this.constructor.KIND;
    }
    addRenderAction(id, ...action) {
        const [fn, p] = RenderList.action(id, action);
        this.renderActions.add(fn, p);
    }
    removeRenderAction(id) {
        const action = this.renderActions.findID(id);
        if (action) {
            this.renderActions.remove(action);
        }
    }
    render() {
        this.clearPromises();
        this.renderActions.renderDoc(this);
        return this;
    }
    renderPromise() {
        return this.whenReady(() => handleRetriesFor(() => MathDocument_awaiter(this, void 0, void 0, function* () {
            this.render();
            yield this.actionPromises();
            this.clearPromises();
            return this;
        })));
    }
    rerender(start = STATE.RERENDER) {
        this.state(start - 1);
        this.render();
        return this;
    }
    rerenderPromise(start = STATE.RERENDER) {
        return this.whenReady(() => handleRetriesFor(() => MathDocument_awaiter(this, void 0, void 0, function* () {
            this.rerender(start);
            yield this.actionPromises();
            this.clearPromises();
            return this;
        })));
    }
    convert(math, options = {}) {
        let { format, display, end, ex, em, containerWidth, scale, family } = userOptions({
            format: this.inputJax[0].name,
            display: true,
            end: STATE.LAST,
            em: 16,
            ex: 8,
            containerWidth: null,
            scale: 1,
            family: '',
        }, options);
        if (containerWidth === null) {
            containerWidth = 80 * ex;
        }
        const jax = this.inputJax.reduce((jax, ijax) => (ijax.name === format ? ijax : jax), null);
        const mitem = new this.options.MathItem(math, jax, display);
        mitem.start.node = this.adaptor.body(this.document);
        mitem.setMetrics(em, ex, containerWidth, scale);
        if (family && this.outputJax.options.mtextInheritFont) {
            mitem.outputData.mtextFamily = family;
        }
        if (family && this.outputJax.options.merrorInheritFont) {
            mitem.outputData.merrorFamily = family;
        }
        this.clearPromises();
        mitem.convert(this, end);
        return mitem.typesetRoot || mitem.root;
    }
    convertPromise(math, options = {}) {
        return this.whenReady(() => handleRetriesFor(() => MathDocument_awaiter(this, void 0, void 0, function* () {
            const node = this.convert(math, options);
            yield this.actionPromises();
            this.clearPromises();
            return node;
        })));
    }
    whenReady(action) {
        return (this._readyPromise = this._readyPromise
            .catch((_) => { })
            .then(() => {
            const ready = this._readyPromise;
            this._readyPromise = Promise.resolve();
            const result = action();
            const promise = this._readyPromise.then(() => result);
            this._readyPromise = ready;
            return promise;
        }));
    }
    actionPromises() {
        return Promise.all(this._actionPromises);
    }
    clearPromises() {
        this._actionPromises = [];
    }
    savePromise(promise) {
        this._actionPromises.push(promise);
    }
    findMath(_options = null) {
        this.processed.set('findMath');
        return this;
    }
    compile() {
        if (!this.processed.isSet('compile')) {
            const recompile = [];
            for (const math of this.math) {
                this.compileMath(math);
                if (math.inputData.recompile !== undefined) {
                    recompile.push(math);
                }
            }
            for (const math of recompile) {
                const data = math.inputData.recompile;
                math.state(data.state);
                math.inputData.recompile = data;
                this.compileMath(math);
            }
            this.processed.set('compile');
        }
        return this;
    }
    compileMath(math) {
        try {
            math.compile(this);
        }
        catch (err) {
            if (err.retry || err.restart) {
                throw err;
            }
            this.options['compileError'](this, math, err);
            math.inputData['error'] = err;
        }
    }
    compileError(math, err) {
        math.root = this.mmlFactory.create('math', null, [
            this.mmlFactory.create('merror', { 'data-mjx-error': err.message, title: err.message }, [
                this.mmlFactory.create('mtext', null, [
                    this.mmlFactory.create('text').setText('Math input error'),
                ]),
            ]),
        ]);
        if (math.display) {
            math.root.attributes.set('display', 'block');
        }
        math.inputData.error = err.message;
    }
    typeset() {
        if (!this.processed.isSet('typeset')) {
            for (const math of this.math) {
                try {
                    math.typeset(this);
                }
                catch (err) {
                    if (err.retry || err.restart) {
                        throw err;
                    }
                    this.options['typesetError'](this, math, err);
                    math.outputData['error'] = err;
                }
            }
            this.processed.set('typeset');
        }
        return this;
    }
    typesetError(math, err) {
        math.typesetRoot = this.adaptor.node('mjx-container', {
            class: 'MathJax mjx-output-error',
            jax: this.outputJax.name,
        }, [
            this.adaptor.node('span', {
                'data-mjx-error': err.message,
                title: err.message,
                style: {
                    color: 'red',
                    'background-color': 'yellow',
                    'line-height': 'normal',
                },
            }, [this.adaptor.text('Math output error')]),
        ]);
        if (math.display) {
            this.adaptor.setAttributes(math.typesetRoot, {
                style: {
                    display: 'block',
                    margin: '1em 0',
                    'text-align': 'center',
                },
            });
        }
        math.outputData.error = err.message;
    }
    getMetrics() {
        if (!this.processed.isSet('getMetrics')) {
            this.outputJax.getMetrics(this);
            this.processed.set('getMetrics');
        }
        return this;
    }
    updateDocument() {
        if (!this.processed.isSet('updateDocument')) {
            for (const math of this.math.reversed()) {
                math.updateDocument(this);
            }
            this.processed.set('updateDocument');
        }
        return this;
    }
    removeFromDocument(_restore = false) {
        return this;
    }
    state(state, restore = false) {
        for (const math of this.math) {
            math.state(state, restore);
        }
        if (state < STATE.INSERTED) {
            this.processed.clear('updateDocument');
        }
        if (state < STATE.TYPESET) {
            this.processed.clear('typeset');
            this.processed.clear('getMetrics');
        }
        if (state < STATE.COMPILED) {
            this.processed.clear('compile');
        }
        if (state < STATE.FINDMATH) {
            this.processed.clear('findMath');
        }
        return this;
    }
    reset(options = { processed: true }) {
        options = userOptions(Object.assign({}, resetOptions), options);
        if (options.all) {
            Object.assign(options, resetAllOptions);
        }
        if (options.processed) {
            this.processed.reset();
        }
        if (options.inputJax) {
            this.inputJax.forEach((jax) => jax.reset(...options.inputJax));
        }
        if (options.outputJax) {
            this.outputJax.reset(...options.outputJax);
        }
        return this;
    }
    clear() {
        this.reset();
        this.math.clear();
        return this;
    }
    done() {
        return Promise.resolve();
    }
    concat(list) {
        this.math.merge(list);
        return this;
    }
    clearMathItemsWithin(containers) {
        const items = this.getMathItemsWithin(containers);
        for (const item of items.slice(0).reverse()) {
            item.clear();
        }
        this.math.remove(...items);
        return items;
    }
    getMathItemsWithin(elements) {
        if (!Array.isArray(elements)) {
            elements = [elements];
        }
        const adaptor = this.adaptor;
        const items = [];
        const containers = adaptor.getElements(elements, this.document);
        ITEMS: for (const item of this.math) {
            for (const container of containers) {
                if (item.start.node && adaptor.contains(container, item.start.node)) {
                    items.push(item);
                    continue ITEMS;
                }
            }
        }
        return items;
    }
}
AbstractMathDocument.KIND = 'MathDocument';
AbstractMathDocument.OPTIONS = {
    OutputJax: null,
    InputJax: null,
    MmlFactory: null,
    MathList: DefaultMathList,
    MathItem: DefaultMathItem,
    compileError: (doc, math, err) => {
        doc.compileError(math, err);
    },
    typesetError: (doc, math, err) => {
        doc.typesetError(math, err);
    },
    renderActions: expandable({
        find: [STATE.FINDMATH, 'findMath', '', false],
        compile: [STATE.COMPILED],
        metrics: [STATE.METRICS, 'getMetrics', '', false],
        typeset: [STATE.TYPESET],
        update: [STATE.INSERTED, 'updateDocument', false],
    }),
};
AbstractMathDocument.ProcessBits = BitFieldClass('findMath', 'compile', 'getMetrics', 'typeset', 'updateDocument');
//# sourceMappingURL=MathDocument.js.map
;// ./mjs/core/Handler.js

class DefaultMathDocument extends AbstractMathDocument {
}
class AbstractHandler {
    constructor(adaptor, priority = 5) {
        this.documentClass = DefaultMathDocument;
        this.adaptor = adaptor;
        this.priority = priority;
    }
    get name() {
        return this.constructor.NAME;
    }
    handlesDocument(_document) {
        return false;
    }
    create(document, options) {
        return new this.documentClass(document, this.adaptor, options);
    }
}
AbstractHandler.NAME = 'generic';
//# sourceMappingURL=Handler.js.map
;// ./mjs/core/HandlerList.js

class HandlerList extends PrioritizedList {
    register(handler) {
        return this.add(handler, handler.priority);
    }
    unregister(handler) {
        this.remove(handler);
    }
    handlesDocument(document) {
        for (const item of this) {
            const handler = item.item;
            if (handler.handlesDocument(document)) {
                return handler;
            }
        }
        throw new Error(`Can't find handler for document`);
    }
    document(document, options = null) {
        return this.handlesDocument(document).create(document, options);
    }
}
//# sourceMappingURL=HandlerList.js.map
;// ./mjs/core/Tree/Visitor.js
class AbstractVisitor {
    static methodName(kind) {
        return ('visit' +
            (kind.charAt(0).toUpperCase() + kind.substring(1)).replace(/[^a-z0-9_]/gi, '_') +
            'Node');
    }
    constructor(factory) {
        this.nodeHandlers = new Map();
        for (const kind of factory.getKinds()) {
            const method = this[AbstractVisitor.methodName(kind)];
            if (method) {
                this.nodeHandlers.set(kind, method);
            }
        }
    }
    visitTree(tree, ...args) {
        return this.visitNode(tree, ...args);
    }
    visitNode(node, ...args) {
        const handler = this.nodeHandlers.get(node.kind) || this.visitDefault;
        return handler.call(this, node, ...args);
    }
    visitDefault(node, ...args) {
        if ('childNodes' in node) {
            for (const child of node.childNodes) {
                this.visitNode(child, ...args);
            }
        }
    }
    setNodeHandler(kind, handler) {
        this.nodeHandlers.set(kind, handler);
    }
    removeNodeHandler(kind) {
        this.nodeHandlers.delete(kind);
    }
}
//# sourceMappingURL=Visitor.js.map
;// ./mjs/core/MmlTree/MmlVisitor.js





const DATAMJX = 'data-mjx-';
class MmlVisitor extends AbstractVisitor {
    constructor(factory = null) {
        if (!factory) {
            factory = new MmlFactory();
        }
        super(factory);
    }
    visitTextNode(_node, ..._args) { }
    visitXMLNode(_node, ..._args) { }
    visitHtmlNode(_node, ..._args) { }
    getKind(node) {
        const kind = node.kind;
        return lookup(kind, this.constructor.rename, kind);
    }
    getAttributeList(node) {
        const CLASS = this.constructor;
        const defaults = lookup(node.kind, CLASS.defaultAttributes, {});
        const attributes = Object.assign({}, defaults, this.getDataAttributes(node), node.attributes.getAllAttributes());
        const variants = CLASS.variants;
        if (Object.hasOwn(attributes, 'mathvariant')) {
            if (Object.hasOwn(variants, attributes.mathvariant)) {
                attributes.mathvariant = variants[attributes.mathvariant];
            }
            else if (node.getProperty('ignore-variant')) {
                delete attributes.mathvariant;
            }
        }
        return attributes;
    }
    getDataAttributes(node) {
        const data = {};
        const variant = node.attributes.getExplicit('mathvariant');
        const variants = this.constructor.variants;
        if (variant &&
            (node.getProperty('ignore-variant') || Object.hasOwn(variants, variant))) {
            this.setDataAttribute(data, 'variant', variant);
        }
        if (node.getProperty('variantForm')) {
            this.setDataAttribute(data, 'alternate', '1');
        }
        if (node.getProperty('pseudoscript')) {
            this.setDataAttribute(data, 'pseudoscript', 'true');
        }
        if (node.getProperty('autoOP') === false) {
            this.setDataAttribute(data, 'auto-op', 'false');
        }
        const vbox = node.getProperty('vbox');
        if (vbox) {
            this.setDataAttribute(data, 'vbox', vbox);
        }
        const scriptalign = node.getProperty('scriptalign');
        if (scriptalign) {
            this.setDataAttribute(data, 'script-align', scriptalign);
        }
        const accent = node.getProperty('mathaccent');
        if (accent !== undefined) {
            if ((accent && !node.isMathAccent()) ||
                (!accent && !node.isMathAccentWithWidth())) {
                this.setDataAttribute(data, 'mathaccent', accent.toString());
            }
        }
        const texclass = node.getProperty('texClass');
        if (texclass !== undefined) {
            let setclass = true;
            if (texclass === TEXCLASS.OP && node.isKind('mi')) {
                const name = node.getText();
                setclass = !(name.length > 1 && name.match(MmlMi.operatorName));
            }
            if (setclass) {
                this.setDataAttribute(data, 'texclass', texclass < 0 ? 'NONE' : TEXCLASSNAMES[texclass]);
            }
        }
        if (node.getProperty('smallmatrix')) {
            this.setDataAttribute(data, 'smallmatrix', 'true');
        }
        return data;
    }
    setDataAttribute(data, name, value) {
        data[DATAMJX + name] = value;
    }
}
MmlVisitor.rename = {
    TeXAtom: 'mrow',
};
MmlVisitor.variants = {
    '-tex-calligraphic': 'script',
    '-tex-bold-calligraphic': 'bold-script',
    '-tex-oldstyle': 'normal',
    '-tex-bold-oldstyle': 'bold',
    '-tex-mathit': 'italic',
};
MmlVisitor.defaultAttributes = {
    math: {
        xmlns: 'http://www.w3.org/1998/Math/MathML',
    },
};
//# sourceMappingURL=MmlVisitor.js.map
;// ./mjs/core/MmlTree/MathMLVisitor.js

class MathMLVisitor extends MmlVisitor {
    constructor() {
        super(...arguments);
        this.document = null;
    }
    visitTree(node, document) {
        this.document = document;
        const root = document.createElement('top');
        this.visitNode(node, root);
        this.document = null;
        return root.firstChild;
    }
    visitTextNode(node, parent) {
        parent.appendChild(this.document.createTextNode(node.getText()));
    }
    visitXMLNode(node, parent) {
        parent.appendChild(node.getXML().cloneNode(true));
    }
    visitHtmlNode(node, parent) {
        parent.appendChild(node.getHTML().cloneNode(true));
    }
    visitInferredMrowNode(node, parent) {
        for (const child of node.childNodes) {
            this.visitNode(child, parent);
        }
    }
    visitDefault(node, parent) {
        const mml = this.document.createElement(this.getKind(node));
        this.addAttributes(node, mml);
        for (const child of node.childNodes) {
            this.visitNode(child, mml);
        }
        parent.appendChild(mml);
    }
    addAttributes(node, mml) {
        const attributes = this.getAttributeList(node);
        for (const name of Object.keys(attributes)) {
            mml.setAttribute(name, attributes[name].toString());
        }
    }
}
//# sourceMappingURL=MathMLVisitor.js.map
;// ./mjs/core/MmlTree/SerializedMmlVisitor.js


class SerializedMmlVisitor extends MmlVisitor {
    visitTree(node) {
        return this.visitNode(node, '');
    }
    visitTextNode(node, _space) {
        return this.quoteHTML(node.getText());
    }
    visitXMLNode(node, space) {
        return space + node.getSerializedXML();
    }
    visitHtmlNode(node, _space) {
        return node.getSerializedHTML();
    }
    visitInferredMrowNode(node, space) {
        const mml = [];
        for (const child of node.childNodes) {
            mml.push(this.visitNode(child, space));
        }
        return mml.join('\n');
    }
    visitAnnotationNode(node, space) {
        const children = this.childNodeMml(node, '', '');
        return `${space}<annotation${this.getAttributes(node)}>${children}</annotation>`;
    }
    visitDefault(node, space) {
        const kind = this.getKind(node);
        const [nl, endspace] = node.isToken || node.childNodes.length === 0 ? ['', ''] : ['\n', space];
        const children = this.childNodeMml(node, space + '  ', nl);
        const childNode = children.match(/\S/) ? nl + children + endspace : '';
        return `${space}<${kind}${this.getAttributes(node)}>${childNode}</${kind}>`;
    }
    childNodeMml(node, space, nl) {
        let mml = '';
        for (const child of node.childNodes) {
            mml += this.visitNode(child, space) + nl;
        }
        return mml;
    }
    getAttributes(node) {
        const attr = [];
        const attributes = this.getAttributeList(node);
        for (const name of Object.keys(attributes)) {
            const value = String(attributes[name]);
            if (value === undefined)
                continue;
            attr.push(name + '="' + this.quoteHTML(value) + '"');
        }
        return attr.length ? ' ' + attr.join(' ') : '';
    }
    quoteHTML(value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/[\uD800-\uDBFF]./g, this.toEntity)
            .replace(/[\u0080-\uD7FF\uE000-\uFFFF]/g, this.toEntity);
    }
    toEntity(c) {
        return toEntity(c);
    }
}
//# sourceMappingURL=SerializedMmlVisitor.js.map
;// ./mjs/core/Tree/Wrapper.js
class AbstractWrapper {
    get kind() {
        return this.node.kind;
    }
    constructor(factory, node) {
        this.factory = factory;
        this.node = node;
    }
    wrap(node) {
        return this.factory.wrap(node);
    }
    walkTree(func, data) {
        func(this, data);
        if ('childNodes' in this) {
            for (const child of this.childNodes) {
                if (child) {
                    child.walkTree(func, data);
                }
            }
        }
        return data;
    }
}
//# sourceMappingURL=Wrapper.js.map
;// ./mjs/core/Tree/WrapperFactory.js

class AbstractWrapperFactory extends AbstractFactory {
    wrap(node, ...args) {
        return this.create(node.kind, node, ...args);
    }
}
//# sourceMappingURL=WrapperFactory.js.map
;// ./mjs/mathjax.js




const mathjax = {
    version: VERSION,
    context: context,
    handlers: new HandlerList(),
    document: function (document, options) {
        return mathjax.handlers.document(document, options);
    },
    handleRetriesFor: handleRetriesFor,
    retryAfter: retryAfter,
    asyncLoad: null,
    asyncIsSynchronous: false,
};
//# sourceMappingURL=mathjax.js.map
;// ./mjs/handlers/html/HTMLMathItem.js

class HTMLMathItem extends AbstractMathItem {
    get adaptor() {
        return this.inputJax.adaptor;
    }
    constructor(math, jax, display = true, start = { node: null, n: 0, delim: '' }, end = { node: null, n: 0, delim: '' }) {
        super(math, jax, display, start, end);
    }
    updateDocument(_html) {
        if (this.state() < STATE.INSERTED) {
            if (this.inputJax.processStrings) {
                let node = this.start.node;
                if (node === this.end.node) {
                    if (this.end.n &&
                        this.end.n < this.adaptor.value(this.end.node).length) {
                        this.adaptor.split(this.end.node, this.end.n);
                    }
                    if (this.start.n) {
                        node = this.adaptor.split(this.start.node, this.start.n);
                    }
                    this.adaptor.replace(this.typesetRoot, node);
                }
                else {
                    if (this.start.n) {
                        node = this.adaptor.split(node, this.start.n);
                    }
                    while (node !== this.end.node) {
                        const next = this.adaptor.next(node);
                        this.adaptor.remove(node);
                        node = next;
                    }
                    this.adaptor.insert(this.typesetRoot, node);
                    if (this.end.n < this.adaptor.value(node).length) {
                        this.adaptor.split(node, this.end.n);
                    }
                    this.adaptor.remove(node);
                }
            }
            else {
                this.adaptor.replace(this.typesetRoot, this.start.node);
            }
            this.start.node = this.end.node = this.typesetRoot;
            this.start.n = this.end.n = 0;
            this.state(STATE.INSERTED);
        }
    }
    updateStyleSheet(document) {
        document.addStyleSheet();
    }
    removeFromDocument(restore = false) {
        super.removeFromDocument(restore);
        if (this.state() >= STATE.TYPESET) {
            const adaptor = this.adaptor;
            const node = this.start.node;
            let math = adaptor.text('');
            if (restore) {
                const text = this.start.delim + this.math + this.end.delim;
                if (this.inputJax.processStrings) {
                    math = adaptor.text(text);
                }
                else {
                    const doc = adaptor.parse(text, 'text/html');
                    math = adaptor.firstChild(adaptor.body(doc));
                }
            }
            if (adaptor.parent(node)) {
                adaptor.replace(math, node);
            }
            this.start.node = this.end.node = math;
            this.start.n = this.end.n = 0;
        }
    }
}
//# sourceMappingURL=HTMLMathItem.js.map
;// ./mjs/handlers/html/HTMLMathList.js

class HTMLMathList extends AbstractMathList {
}
//# sourceMappingURL=HTMLMathList.js.map
;// ./mjs/handlers/html/HTMLDomStrings.js

class HTMLDomStrings {
    constructor(options = null) {
        const CLASS = this.constructor;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
        this.init();
        this.getPatterns();
    }
    init() {
        this.strings = [];
        this.string = '';
        this.snodes = [];
        this.nodes = [];
        this.stack = [];
    }
    getPatterns() {
        const skip = makeArray(this.options['skipHtmlTags']);
        const ignore = makeArray(this.options['ignoreHtmlClass']);
        const process = makeArray(this.options['processHtmlClass']);
        this.skipHtmlTags = new RegExp('^(?:' + skip.join('|') + ')$', 'i');
        this.ignoreHtmlClass = new RegExp('(?:^| )(?:' + ignore.join('|') + ')(?: |$)');
        this.processHtmlClass = new RegExp('(?:^| )(?:' + process + ')(?: |$)');
    }
    pushString() {
        if (this.string.match(/\S/)) {
            this.strings.push(this.string);
            this.nodes.push(this.snodes);
        }
        this.string = '';
        this.snodes = [];
    }
    extendString(node, text) {
        this.snodes.push([node, text.length]);
        this.string += text;
    }
    handleText(node, ignore) {
        if (!ignore) {
            this.extendString(node, this.adaptor.value(node));
        }
        return this.adaptor.next(node);
    }
    handleTag(node, ignore) {
        if (!ignore) {
            const text = this.options['includeHtmlTags'][this.adaptor.kind(node)];
            if (text instanceof Function) {
                this.extendString(node, text(node, this.adaptor));
            }
            else {
                this.extendString(node, text);
            }
        }
        return this.adaptor.next(node);
    }
    handleContainer(node, ignore) {
        this.pushString();
        const cname = this.adaptor.getAttribute(node, 'class') || '';
        const tname = this.adaptor.kind(node) || '';
        const process = this.processHtmlClass.exec(cname);
        let next = node;
        if (this.adaptor.firstChild(node) &&
            !this.adaptor.getAttribute(node, 'data-MJX') &&
            (process || !this.skipHtmlTags.exec(tname))) {
            if (this.adaptor.next(node)) {
                this.stack.push([this.adaptor.next(node), ignore]);
            }
            next = this.adaptor.firstChild(node);
            ignore = (ignore || this.ignoreHtmlClass.exec(cname)) && !process;
        }
        else {
            next = this.adaptor.next(node);
        }
        return [next, ignore];
    }
    handleOther(node, _ignore) {
        this.pushString();
        return this.adaptor.next(node);
    }
    find(node) {
        this.init();
        const stop = this.adaptor.next(node);
        let ignore = false;
        const include = this.options['includeHtmlTags'];
        while (node && node !== stop) {
            const kind = this.adaptor.kind(node);
            if (kind === '#text') {
                node = this.handleText(node, ignore);
            }
            else if (Object.hasOwn(include, kind)) {
                node = this.handleTag(node, ignore);
            }
            else if (kind) {
                [node, ignore] = this.handleContainer(node, ignore);
            }
            else {
                node = this.handleOther(node, ignore);
            }
            if (!node && this.stack.length) {
                this.pushString();
                [node, ignore] = this.stack.pop();
            }
        }
        this.pushString();
        const result = [this.strings, this.nodes];
        this.init();
        return result;
    }
}
HTMLDomStrings.OPTIONS = {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code',
        'math', 'select', 'option', 'mjx-container'],
    includeHtmlTags: expandable({ br: '\n', wbr: '', '#comment': '' }),
    ignoreHtmlClass: 'mathjax_ignore',
    processHtmlClass: 'mathjax_process'
};
//# sourceMappingURL=HTMLDomStrings.js.map
;// ./mjs/handlers/html/HTMLDocument.js






newState('STYLES', STATE.INSERTED + 1);
class HTMLDocument extends AbstractMathDocument {
    constructor(document, adaptor, options) {
        const [html, dom] = separateOptions(options, HTMLDomStrings.OPTIONS);
        super(document, adaptor, html);
        this.domStrings =
            this.options['DomStrings'] || new HTMLDomStrings(dom);
        this.domStrings.adaptor = adaptor;
        this.styles = [];
    }
    findPosition(N, index, delim, nodes) {
        const adaptor = this.adaptor;
        const inc = 1 / (nodes[N].length || 1);
        let i = N;
        for (const [node, n] of nodes[N]) {
            if (index <= n && adaptor.kind(node) === '#text') {
                return { i, node, n: Math.max(index, 0), delim };
            }
            index -= n;
            i += inc;
        }
        return { node: null, n: 0, delim };
    }
    mathItem(item, jax, nodes) {
        const math = item.math;
        const start = this.findPosition(item.n, item.start.n, item.open, nodes);
        const end = this.findPosition(item.n, item.end.n, item.close, nodes);
        return new this.options.MathItem(math, jax, item.display, start, end);
    }
    findMath(options) {
        if (!this.processed.isSet('findMath')) {
            this.adaptor.document = this.document;
            options = userOptions({
                elements: this.options.elements || [this.adaptor.body(this.document)],
            }, options);
            const containers = this.adaptor.getElements(options.elements, this.document);
            for (const jax of this.inputJax) {
                const list = jax.processStrings
                    ? this.findMathFromStrings(jax, containers)
                    : this.findMathFromDOM(jax, containers);
                this.math.merge(list);
            }
            this.processed.set('findMath');
        }
        return this;
    }
    findMathFromStrings(jax, containers) {
        const strings = [];
        const nodes = [];
        for (const container of containers) {
            const [slist, nlist] = this.domStrings.find(container);
            strings.push(...slist);
            nodes.push(...nlist);
        }
        const list = new this.options.MathList();
        for (const math of jax.findMath(strings)) {
            list.push(this.mathItem(math, jax, nodes));
        }
        return list;
    }
    findMathFromDOM(jax, containers) {
        const items = [];
        for (const container of containers) {
            for (const math of jax.findMath(container)) {
                items.push(new this.options.MathItem(math.math, jax, math.display, math.start, math.end));
            }
        }
        return new this.options.MathList(...items);
    }
    updateDocument() {
        if (!this.processed.isSet('updateDocument')) {
            this.addPageElements();
            this.addStyleSheet();
            super.updateDocument();
            this.processed.set('updateDocument');
        }
        return this;
    }
    addPageElements() {
        const adaptor = this.adaptor;
        const body = adaptor.body(this.document);
        const node = this.documentPageElements();
        if (node) {
            const child = adaptor.firstChild(body);
            if (child) {
                adaptor.insert(node, child);
            }
            else {
                adaptor.append(body, node);
            }
        }
    }
    addStyleSheet() {
        const sheet = this.documentStyleSheet();
        const adaptor = this.adaptor;
        if (sheet && !adaptor.parent(sheet)) {
            const head = adaptor.head(this.document);
            const styles = this.findSheet(head, adaptor.getAttribute(sheet, 'id'));
            if (styles) {
                adaptor.replace(sheet, styles);
            }
            else {
                adaptor.append(head, sheet);
            }
        }
    }
    findSheet(head, id) {
        if (id) {
            for (const sheet of this.adaptor.tags(head, 'style')) {
                if (this.adaptor.getAttribute(sheet, 'id') === id) {
                    return sheet;
                }
            }
        }
        return null;
    }
    removeFromDocument(restore = false) {
        if (this.processed.isSet('updateDocument')) {
            for (const math of this.math) {
                if (math.state() >= STATE.INSERTED) {
                    math.state(STATE.TYPESET, restore);
                }
            }
        }
        this.processed.clear('updateDocument');
        return this;
    }
    documentStyleSheet() {
        return this.outputJax.styleSheet(this);
    }
    documentPageElements() {
        return this.outputJax.pageElements(this);
    }
    addStyles(styles) {
        this.styles.push(styles);
        if ('insertStyles' in this.outputJax) {
            this.outputJax.insertStyles(styles);
        }
    }
    getStyles() {
        return this.styles;
    }
}
HTMLDocument.KIND = 'HTML';
HTMLDocument.OPTIONS = Object.assign(Object.assign({}, AbstractMathDocument.OPTIONS), { renderActions: expandable(Object.assign(Object.assign({}, AbstractMathDocument.OPTIONS.renderActions), { styles: [STATE.STYLES, '', 'updateStyleSheet', false] })), MathList: HTMLMathList, MathItem: HTMLMathItem, DomStrings: null });
//# sourceMappingURL=HTMLDocument.js.map
;// ./mjs/handlers/html/HTMLHandler.js


class HTMLHandler extends AbstractHandler {
    constructor() {
        super(...arguments);
        this.documentClass = HTMLDocument;
    }
    handlesDocument(document) {
        const adaptor = this.adaptor;
        if (typeof document === 'string') {
            try {
                document = adaptor.parse(document, 'text/html');
            }
            catch (_err) {
            }
        }
        if (document instanceof adaptor.window.Document ||
            document instanceof adaptor.window.HTMLElement ||
            document instanceof adaptor.window.DocumentFragment) {
            return true;
        }
        return false;
    }
    create(document, options) {
        const adaptor = this.adaptor;
        if (typeof document === 'string') {
            document = adaptor.parse(document, 'text/html');
        }
        else if (document instanceof adaptor.window.HTMLElement ||
            document instanceof adaptor.window.DocumentFragment) {
            const child = document;
            document = adaptor.parse('', 'text/html');
            adaptor.append(adaptor.body(document), child);
        }
        return super.create(document, options);
    }
}
//# sourceMappingURL=HTMLHandler.js.map
;// ./mjs/handlers/html.js


function RegisterHTMLHandler(adaptor) {
    const handler = new HTMLHandler(adaptor);
    mathjax.handlers.register(handler);
    return handler;
}
//# sourceMappingURL=html.js.map
;// ./mjs/util/AsyncLoad.js

function asyncLoad(name) {
    if (!mathjax.asyncLoad) {
        return Promise.reject(`Can't load '${name}': No mathjax.asyncLoad method specified`);
    }
    return new Promise((ok, fail) => {
        const result = mathjax.asyncLoad(name);
        if (result instanceof Promise) {
            result.then((value) => ok(value)).catch((err) => fail(err));
        }
        else {
            ok(result);
        }
    });
}
//# sourceMappingURL=AsyncLoad.js.map
;// ./mjs/util/lengths.js
const BIGDIMEN = 1000000;
const UNITS = {
    px: 1,
    'in': 96,
    cm: 96 / 2.54,
    mm: 96 / 25.4
};
const RELUNITS = {
    em: 1,
    ex: .431,
    pt: 1 / 10,
    pc: 12 / 10,
    mu: 1 / 18
};
const MATHSPACE = {
    veryverythinmathspace: 1 / 18,
    verythinmathspace: 2 / 18,
    thinmathspace: 3 / 18,
    mediummathspace: 4 / 18,
    thickmathspace: 5 / 18,
    verythickmathspace: 6 / 18,
    veryverythickmathspace: 7 / 18,
    negativeveryverythinmathspace: -1 / 18,
    negativeverythinmathspace: -2 / 18,
    negativethinmathspace: -3 / 18,
    negativemediummathspace: -4 / 18,
    negativethickmathspace: -5 / 18,
    negativeverythickmathspace: -6 / 18,
    negativeveryverythickmathspace: -7 / 18,
    thin: .04,
    medium: .06,
    thick: .1,
    normal: 1,
    big: 2,
    small: 1 / Math.sqrt(2),
    infinity: BIGDIMEN
};
function length2em(length, size = 0, scale = 1, em = 16) {
    if (typeof length !== 'string') {
        length = String(length);
    }
    if (length === '' || length == null) {
        return size;
    }
    if (MATHSPACE[length]) {
        return MATHSPACE[length];
    }
    const match = length.match(/^\s*([-+]?(?:\.\d+|\d+(?:\.\d*)?))?(pt|em|ex|mu|px|pc|in|mm|cm|%)?/);
    if (!match || match[0] === '') {
        return size;
    }
    const m = parseFloat(match[1] || '1');
    const unit = match[2];
    if (Object.hasOwn(UNITS, unit)) {
        return (m * UNITS[unit]) / em / scale;
    }
    if (Object.hasOwn(RELUNITS, unit)) {
        return m * RELUNITS[unit];
    }
    if (unit === '%') {
        return (m / 100) * size;
    }
    return m * size;
}
function percent(m) {
    return (100 * m).toFixed(1).replace(/\.?0+$/, '') + '%';
}
function em(m) {
    if (Math.abs(m) < 0.001)
        return '0';
    return m.toFixed(3).replace(/\.?0+$/, '') + 'em';
}
function px(m, M = -BIGDIMEN, em = 16) {
    m *= em;
    if (M && m < M)
        m = M;
    if (Math.abs(m) < 0.1)
        return '0';
    return m.toFixed(1).replace(/\.0$/, '') + 'px';
}
//# sourceMappingURL=lengths.js.map
;// ./mjs/util/BBox.js

class BBox {
    static zero() {
        return new BBox({ h: 0, d: 0, w: 0 });
    }
    static empty() {
        return new BBox();
    }
    constructor(def = { w: 0, h: -BIGDIMEN, d: -BIGDIMEN }) {
        this.w = def.w || 0;
        this.h = 'h' in def ? def.h : -BIGDIMEN;
        this.d = 'd' in def ? def.d : -BIGDIMEN;
        this.L = this.R = this.ic = this.oc = this.sk = this.dx = 0;
        this.scale = this.rscale = 1;
        this.pwidth = '';
    }
    empty() {
        this.w = 0;
        this.h = this.d = -BIGDIMEN;
        return this;
    }
    clean() {
        if (this.w === -BIGDIMEN)
            this.w = 0;
        if (this.h === -BIGDIMEN)
            this.h = 0;
        if (this.d === -BIGDIMEN)
            this.d = 0;
    }
    rescale(scale) {
        this.w *= scale;
        this.h *= scale;
        this.d *= scale;
    }
    combine(cbox, x = 0, y = 0) {
        const rscale = cbox.rscale;
        const w = x + rscale * (cbox.w + cbox.L + cbox.R);
        const h = y + rscale * cbox.h;
        const d = rscale * cbox.d - y;
        if (w > this.w)
            this.w = w;
        if (h > this.h)
            this.h = h;
        if (d > this.d)
            this.d = d;
    }
    append(cbox) {
        const scale = cbox.rscale;
        this.w += scale * (cbox.w + cbox.L + cbox.R);
        if (scale * cbox.h > this.h) {
            this.h = scale * cbox.h;
        }
        if (scale * cbox.d > this.d) {
            this.d = scale * cbox.d;
        }
    }
    updateFrom(cbox) {
        this.h = cbox.h;
        this.d = cbox.d;
        this.w = cbox.w;
        if (cbox.pwidth) {
            this.pwidth = cbox.pwidth;
        }
    }
    copy() {
        const bbox = new BBox();
        Object.assign(bbox, this);
        return bbox;
    }
}
BBox.fullWidth = '100%';
BBox.boxSides = [
    ['Top', 0, 'h'],
    ['Right', 1, 'w'],
    ['Bottom', 2, 'd'],
    ['Left', 3, 'w'],
];
//# sourceMappingURL=BBox.js.map
;// ./mjs/util/Entities.js


const options = {
    loadMissingEntities: true,
};
const entities = {
    ApplyFunction: '\u2061',
    Backslash: '\u2216',
    Because: '\u2235',
    Breve: '\u02D8',
    Cap: '\u22D2',
    CenterDot: '\u00B7',
    CircleDot: '\u2299',
    CircleMinus: '\u2296',
    CirclePlus: '\u2295',
    CircleTimes: '\u2297',
    Congruent: '\u2261',
    ContourIntegral: '\u222E',
    Coproduct: '\u2210',
    Cross: '\u2A2F',
    Cup: '\u22D3',
    CupCap: '\u224D',
    Dagger: '\u2021',
    Del: '\u2207',
    Delta: '\u0394',
    Diamond: '\u22C4',
    DifferentialD: '\u2146',
    DotEqual: '\u2250',
    DoubleDot: '\u00A8',
    DoubleRightTee: '\u22A8',
    DoubleVerticalBar: '\u2225',
    DownArrow: '\u2193',
    DownLeftVector: '\u21BD',
    DownRightVector: '\u21C1',
    DownTee: '\u22A4',
    Downarrow: '\u21D3',
    Element: '\u2208',
    EqualTilde: '\u2242',
    Equilibrium: '\u21CC',
    Exists: '\u2203',
    ExponentialE: '\u2147',
    FilledVerySmallSquare: '\u25AA',
    ForAll: '\u2200',
    Gamma: '\u0393',
    Gg: '\u22D9',
    GreaterEqual: '\u2265',
    GreaterEqualLess: '\u22DB',
    GreaterFullEqual: '\u2267',
    GreaterLess: '\u2277',
    GreaterSlantEqual: '\u2A7E',
    GreaterTilde: '\u2273',
    Hacek: '\u02C7',
    Hat: '\u005E',
    HumpDownHump: '\u224E',
    HumpEqual: '\u224F',
    Im: '\u2111',
    ImaginaryI: '\u2148',
    Integral: '\u222B',
    Intersection: '\u22C2',
    InvisibleComma: '\u2063',
    InvisibleTimes: '\u2062',
    Lambda: '\u039B',
    Larr: '\u219E',
    LeftAngleBracket: '\u27E8',
    LeftArrow: '\u2190',
    LeftArrowRightArrow: '\u21C6',
    LeftCeiling: '\u2308',
    LeftDownVector: '\u21C3',
    LeftFloor: '\u230A',
    LeftRightArrow: '\u2194',
    LeftTee: '\u22A3',
    LeftTriangle: '\u22B2',
    LeftTriangleEqual: '\u22B4',
    LeftUpVector: '\u21BF',
    LeftVector: '\u21BC',
    Leftarrow: '\u21D0',
    Leftrightarrow: '\u21D4',
    LessEqualGreater: '\u22DA',
    LessFullEqual: '\u2266',
    LessGreater: '\u2276',
    LessSlantEqual: '\u2A7D',
    LessTilde: '\u2272',
    Ll: '\u22D8',
    Lleftarrow: '\u21DA',
    LongLeftArrow: '\u27F5',
    LongLeftRightArrow: '\u27F7',
    LongRightArrow: '\u27F6',
    Longleftarrow: '\u27F8',
    Longleftrightarrow: '\u27FA',
    Longrightarrow: '\u27F9',
    Lsh: '\u21B0',
    MinusPlus: '\u2213',
    NestedGreaterGreater: '\u226B',
    NestedLessLess: '\u226A',
    NotDoubleVerticalBar: '\u2226',
    NotElement: '\u2209',
    NotEqual: '\u2260',
    NotExists: '\u2204',
    NotGreater: '\u226F',
    NotGreaterEqual: '\u2271',
    NotLeftTriangle: '\u22EA',
    NotLeftTriangleEqual: '\u22EC',
    NotLess: '\u226E',
    NotLessEqual: '\u2270',
    NotPrecedes: '\u2280',
    NotPrecedesSlantEqual: '\u22E0',
    NotRightTriangle: '\u22EB',
    NotRightTriangleEqual: '\u22ED',
    NotSubsetEqual: '\u2288',
    NotSucceeds: '\u2281',
    NotSucceedsSlantEqual: '\u22E1',
    NotSupersetEqual: '\u2289',
    NotTilde: '\u2241',
    NotVerticalBar: '\u2224',
    Omega: '\u03A9',
    OverBar: '\u203E',
    OverBrace: '\u23DE',
    PartialD: '\u2202',
    Phi: '\u03A6',
    Pi: '\u03A0',
    PlusMinus: '\u00B1',
    Precedes: '\u227A',
    PrecedesEqual: '\u2AAF',
    PrecedesSlantEqual: '\u227C',
    PrecedesTilde: '\u227E',
    Product: '\u220F',
    Proportional: '\u221D',
    Psi: '\u03A8',
    Rarr: '\u21A0',
    Re: '\u211C',
    ReverseEquilibrium: '\u21CB',
    RightAngleBracket: '\u27E9',
    RightArrow: '\u2192',
    RightArrowLeftArrow: '\u21C4',
    RightCeiling: '\u2309',
    RightDownVector: '\u21C2',
    RightFloor: '\u230B',
    RightTee: '\u22A2',
    RightTeeArrow: '\u21A6',
    RightTriangle: '\u22B3',
    RightTriangleEqual: '\u22B5',
    RightUpVector: '\u21BE',
    RightVector: '\u21C0',
    Rightarrow: '\u21D2',
    Rrightarrow: '\u21DB',
    Rsh: '\u21B1',
    Sigma: '\u03A3',
    SmallCircle: '\u2218',
    Sqrt: '\u221A',
    Square: '\u25A1',
    SquareIntersection: '\u2293',
    SquareSubset: '\u228F',
    SquareSubsetEqual: '\u2291',
    SquareSuperset: '\u2290',
    SquareSupersetEqual: '\u2292',
    SquareUnion: '\u2294',
    Star: '\u22C6',
    Subset: '\u22D0',
    SubsetEqual: '\u2286',
    Succeeds: '\u227B',
    SucceedsEqual: '\u2AB0',
    SucceedsSlantEqual: '\u227D',
    SucceedsTilde: '\u227F',
    SuchThat: '\u220B',
    Sum: '\u2211',
    Superset: '\u2283',
    SupersetEqual: '\u2287',
    Supset: '\u22D1',
    Therefore: '\u2234',
    Theta: '\u0398',
    Tilde: '\u223C',
    TildeEqual: '\u2243',
    TildeFullEqual: '\u2245',
    TildeTilde: '\u2248',
    UnderBar: '\u005F',
    UnderBrace: '\u23DF',
    Union: '\u22C3',
    UnionPlus: '\u228E',
    UpArrow: '\u2191',
    UpDownArrow: '\u2195',
    UpTee: '\u22A5',
    Uparrow: '\u21D1',
    Updownarrow: '\u21D5',
    Upsilon: '\u03A5',
    Vdash: '\u22A9',
    Vee: '\u22C1',
    VerticalBar: '\u2223',
    VerticalTilde: '\u2240',
    Vvdash: '\u22AA',
    Wedge: '\u22C0',
    Xi: '\u039E',
    amp: '\u0026',
    acute: '\u00B4',
    aleph: '\u2135',
    alpha: '\u03B1',
    amalg: '\u2A3F',
    and: '\u2227',
    ang: '\u2220',
    angmsd: '\u2221',
    angsph: '\u2222',
    ape: '\u224A',
    backprime: '\u2035',
    backsim: '\u223D',
    backsimeq: '\u22CD',
    beta: '\u03B2',
    beth: '\u2136',
    between: '\u226C',
    bigcirc: '\u25EF',
    bigodot: '\u2A00',
    bigoplus: '\u2A01',
    bigotimes: '\u2A02',
    bigsqcup: '\u2A06',
    bigstar: '\u2605',
    bigtriangledown: '\u25BD',
    bigtriangleup: '\u25B3',
    biguplus: '\u2A04',
    blacklozenge: '\u29EB',
    blacktriangle: '\u25B4',
    blacktriangledown: '\u25BE',
    blacktriangleleft: '\u25C2',
    bowtie: '\u22C8',
    boxdl: '\u2510',
    boxdr: '\u250C',
    boxminus: '\u229F',
    boxplus: '\u229E',
    boxtimes: '\u22A0',
    boxul: '\u2518',
    boxur: '\u2514',
    bsol: '\u005C',
    bull: '\u2022',
    cap: '\u2229',
    check: '\u2713',
    chi: '\u03C7',
    circ: '\u02C6',
    circeq: '\u2257',
    circlearrowleft: '\u21BA',
    circlearrowright: '\u21BB',
    circledR: '\u00AE',
    circledS: '\u24C8',
    circledast: '\u229B',
    circledcirc: '\u229A',
    circleddash: '\u229D',
    clubs: '\u2663',
    colon: '\u003A',
    comp: '\u2201',
    ctdot: '\u22EF',
    cuepr: '\u22DE',
    cuesc: '\u22DF',
    cularr: '\u21B6',
    cup: '\u222A',
    curarr: '\u21B7',
    curlyvee: '\u22CE',
    curlywedge: '\u22CF',
    dagger: '\u2020',
    daleth: '\u2138',
    ddarr: '\u21CA',
    deg: '\u00B0',
    delta: '\u03B4',
    digamma: '\u03DD',
    div: '\u00F7',
    divideontimes: '\u22C7',
    dot: '\u02D9',
    doteqdot: '\u2251',
    dotplus: '\u2214',
    dotsquare: '\u22A1',
    dtdot: '\u22F1',
    ecir: '\u2256',
    efDot: '\u2252',
    egs: '\u2A96',
    ell: '\u2113',
    els: '\u2A95',
    empty: '\u2205',
    epsi: '\u03B5',
    epsiv: '\u03F5',
    erDot: '\u2253',
    eta: '\u03B7',
    eth: '\u00F0',
    flat: '\u266D',
    fork: '\u22D4',
    frown: '\u2322',
    gEl: '\u2A8C',
    gamma: '\u03B3',
    gap: '\u2A86',
    gimel: '\u2137',
    gnE: '\u2269',
    gnap: '\u2A8A',
    gne: '\u2A88',
    gnsim: '\u22E7',
    gt: '\u003E',
    gtdot: '\u22D7',
    harrw: '\u21AD',
    hbar: '\u210F',
    hellip: '\u2026',
    hookleftarrow: '\u21A9',
    hookrightarrow: '\u21AA',
    imath: '\u0131',
    infin: '\u221E',
    intcal: '\u22BA',
    iota: '\u03B9',
    jmath: '\u0237',
    kappa: '\u03BA',
    kappav: '\u03F0',
    lEg: '\u2A8B',
    lambda: '\u03BB',
    lap: '\u2A85',
    larrlp: '\u21AB',
    larrtl: '\u21A2',
    lbrace: '\u007B',
    lbrack: '\u005B',
    le: '\u2264',
    leftleftarrows: '\u21C7',
    leftthreetimes: '\u22CB',
    lessdot: '\u22D6',
    lmoust: '\u23B0',
    lnE: '\u2268',
    lnap: '\u2A89',
    lne: '\u2A87',
    lnsim: '\u22E6',
    longmapsto: '\u27FC',
    looparrowright: '\u21AC',
    lowast: '\u2217',
    loz: '\u25CA',
    lt: '\u003C',
    ltimes: '\u22C9',
    ltri: '\u25C3',
    macr: '\u00AF',
    malt: '\u2720',
    mho: '\u2127',
    mu: '\u03BC',
    multimap: '\u22B8',
    nLeftarrow: '\u21CD',
    nLeftrightarrow: '\u21CE',
    nRightarrow: '\u21CF',
    nVDash: '\u22AF',
    nVdash: '\u22AE',
    natur: '\u266E',
    nearr: '\u2197',
    nharr: '\u21AE',
    nlarr: '\u219A',
    not: '\u00AC',
    nrarr: '\u219B',
    nu: '\u03BD',
    nvDash: '\u22AD',
    nvdash: '\u22AC',
    nwarr: '\u2196',
    omega: '\u03C9',
    omicron: '\u03BF',
    or: '\u2228',
    osol: '\u2298',
    period: '\u002E',
    phi: '\u03C6',
    phiv: '\u03D5',
    pi: '\u03C0',
    piv: '\u03D6',
    prap: '\u2AB7',
    precnapprox: '\u2AB9',
    precneqq: '\u2AB5',
    precnsim: '\u22E8',
    prime: '\u2032',
    psi: '\u03C8',
    quot: '\u0022',
    rarrtl: '\u21A3',
    rbrace: '\u007D',
    rbrack: '\u005D',
    rho: '\u03C1',
    rhov: '\u03F1',
    rightrightarrows: '\u21C9',
    rightthreetimes: '\u22CC',
    ring: '\u02DA',
    rmoust: '\u23B1',
    rtimes: '\u22CA',
    rtri: '\u25B9',
    scap: '\u2AB8',
    scnE: '\u2AB6',
    scnap: '\u2ABA',
    scnsim: '\u22E9',
    sdot: '\u22C5',
    searr: '\u2198',
    sect: '\u00A7',
    sharp: '\u266F',
    sigma: '\u03C3',
    sigmav: '\u03C2',
    simne: '\u2246',
    smile: '\u2323',
    spades: '\u2660',
    sub: '\u2282',
    subE: '\u2AC5',
    subnE: '\u2ACB',
    subne: '\u228A',
    supE: '\u2AC6',
    supnE: '\u2ACC',
    supne: '\u228B',
    swarr: '\u2199',
    tau: '\u03C4',
    theta: '\u03B8',
    thetav: '\u03D1',
    tilde: '\u02DC',
    times: '\u00D7',
    triangle: '\u25B5',
    triangleq: '\u225C',
    upsi: '\u03C5',
    upuparrows: '\u21C8',
    veebar: '\u22BB',
    vellip: '\u22EE',
    weierp: '\u2118',
    xi: '\u03BE',
    yen: '\u00A5',
    zeta: '\u03B6',
    zigrarr: '\u21DD',
    nbsp: '\u00A0',
    rsquo: '\u2019',
    lsquo: '\u2018',
};
const loaded = {};
function add(additions, file) {
    Object.assign(entities, additions);
    loaded[file] = true;
}
function remove(entity) {
    delete entities[entity];
}
function translate(text) {
    return text.replace(/&([a-z][a-z0-9]*|#(?:[0-9]+|x[0-9a-f]+));/gi, replace);
}
function replace(match, entity) {
    if (entity.charAt(0) === '#') {
        return numeric(entity.slice(1));
    }
    if (entities[entity]) {
        return entities[entity];
    }
    if (options['loadMissingEntities']) {
        const file = entity.match(/^[a-zA-Z](fr|scr|opf)$/)
            ? RegExp.$1
            : entity.charAt(0).toLowerCase();
        if (!loaded[file]) {
            loaded[file] = true;
            retryAfter(asyncLoad('./util/entities/' + file + '.js'));
        }
    }
    return match;
}
function numeric(entity) {
    const n = entity.charAt(0) === 'x' ? parseInt(entity.slice(1), 16) : parseInt(entity);
    return String.fromCodePoint(n);
}
//# sourceMappingURL=Entities.js.map
;// ./mjs/util/StyleJson.js
class StyleJsonSheet {
    get cssText() {
        return this.getStyleString();
    }
    constructor(styles = null) {
        this.styles = {};
        this.addStyles(styles);
    }
    addStyles(styles) {
        if (!styles)
            return;
        for (const style of Object.keys(styles)) {
            if (!this.styles[style]) {
                this.styles[style] = {};
            }
            Object.assign(this.styles[style], styles[style]);
        }
    }
    removeStyles(...selectors) {
        for (const selector of selectors) {
            delete this.styles[selector];
        }
    }
    clear() {
        this.styles = {};
    }
    getStyleString() {
        return this.getStyleRules().join('\n\n');
    }
    getStyleRules() {
        const selectors = Object.keys(this.styles);
        const defs = new Array(selectors.length);
        let i = 0;
        for (const selector of selectors) {
            defs[i++] =
                selector +
                    ' {\n' +
                    this.getStyleDefString(this.styles[selector]) +
                    '\n}';
        }
        return defs;
    }
    getStyleDefString(styles) {
        const properties = Object.keys(styles);
        const values = new Array(properties.length);
        let i = 0;
        for (const property of properties) {
            values[i++] = '  ' + property + ': ' + styles[property] + ';';
        }
        return values.join('\n');
    }
}
//# sourceMappingURL=StyleJson.js.map
;// ./mjs/util/Styles.js
const TRBL = ['top', 'right', 'bottom', 'left'];
const WSC = ['width', 'style', 'color'];
function splitSpaces(text) {
    const parts = text.split(/((?:'[^']*'|"[^"]*"|,[\s\n]|[^\s\n])*)/g);
    const split = [];
    while (parts.length > 1) {
        parts.shift();
        split.push(parts.shift());
    }
    return split;
}
function splitTRBL(name) {
    const parts = splitSpaces(this.styles[name]);
    if (parts.length === 0) {
        parts.push('');
    }
    if (parts.length === 1) {
        parts.push(parts[0]);
    }
    if (parts.length === 2) {
        parts.push(parts[0]);
    }
    if (parts.length === 3) {
        parts.push(parts[1]);
    }
    for (const child of Styles.connect[name].children) {
        this.setStyle(this.childName(name, child), parts.shift());
    }
}
function combineTRBL(name) {
    const children = Styles.connect[name].children;
    const parts = [];
    for (const child of children) {
        const part = this.styles[name + '-' + child];
        if (!part) {
            delete this.styles[name];
            return;
        }
        parts.push(part);
    }
    if (parts[3] === parts[1]) {
        parts.pop();
        if (parts[2] === parts[0]) {
            parts.pop();
            if (parts[1] === parts[0]) {
                parts.pop();
            }
        }
    }
    this.styles[name] = parts.join(' ');
}
function splitSame(name) {
    for (const child of Styles.connect[name].children) {
        this.setStyle(this.childName(name, child), this.styles[name]);
    }
}
function combineSame(name) {
    const children = [...Styles.connect[name].children];
    const value = this.styles[this.childName(name, children.shift())];
    for (const child of children) {
        if (this.styles[this.childName(name, child)] !== value) {
            delete this.styles[name];
            return;
        }
    }
    this.styles[name] = value;
}
const BORDER = {
    width: /^(?:[\d.]+(?:[a-z]+)|thin|medium|thick|inherit|initial|unset)$/,
    style: /^(?:none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset|inherit|initial|unset)$/,
};
function splitWSC(name) {
    const parts = { width: '', style: '', color: '' };
    for (const part of splitSpaces(this.styles[name])) {
        if (part.match(BORDER.width) && parts.width === '') {
            parts.width = part;
        }
        else if (part.match(BORDER.style) && parts.style === '') {
            parts.style = part;
        }
        else {
            parts.color = part;
        }
    }
    for (const child of Styles.connect[name].children) {
        this.setStyle(this.childName(name, child), parts[child]);
    }
}
function combineWSC(name) {
    const parts = [];
    for (const child of Styles.connect[name].children) {
        const value = this.styles[this.childName(name, child)];
        if (value) {
            parts.push(value);
        }
    }
    if (parts.length) {
        this.styles[name] = parts.join(' ');
    }
    else {
        delete this.styles[name];
    }
}
const FONT = {
    style: /^(?:normal|italic|oblique|inherit|initial|unset)$/,
    variant: new RegExp('^(?:' +
        [
            'normal|none',
            'inherit|initial|unset',
            'common-ligatures|no-common-ligatures',
            'discretionary-ligatures|no-discretionary-ligatures',
            'historical-ligatures|no-historical-ligatures',
            'contextual|no-contextual',
            '(?:stylistic|character-variant|swash|ornaments|annotation)\\([^)]*\\)',
            'small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps',
            'lining-nums|oldstyle-nums|proportional-nums|tabular-nums',
            'diagonal-fractions|stacked-fractions',
            'ordinal|slashed-zero',
            'jis78|jis83|jis90|jis04|simplified|traditional',
            'full-width|proportional-width',
            'ruby',
        ].join('|') +
        ')$'),
    weight: /^(?:normal|bold|bolder|lighter|[1-9]00|inherit|initial|unset)$/,
    stretch: new RegExp('^(?:' +
        [
            'normal',
            '(?:(?:ultra|extra|semi)-)?(?:condensed|expanded)',
            'inherit|initial|unset',
        ].join('|') +
        ')$'),
    size: new RegExp('^(?:' +
        [
            'xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller',
            '[\\d.]+%|[\\d.]+[a-z]+',
            'inherit|initial|unset',
        ].join('|') +
        ')' +
        '(?:/(?:normal|[\\d.]+(?:%|[a-z]+)?))?$'),
};
function splitFont(name) {
    const parts = splitSpaces(this.styles[name]);
    const value = {
        style: '',
        variant: [],
        weight: '',
        stretch: '',
        size: '',
        family: '',
        'line-height': '',
    };
    for (const part of parts) {
        if (!value.family) {
            value.family = part;
        }
        for (const name of Object.keys(FONT)) {
            if ((Array.isArray(value[name]) || value[name] === '') &&
                part.match(FONT[name])) {
                if (value.family === part) {
                    value.family = '';
                }
                if (name === 'size') {
                    const [size, height] = part.split(/\//);
                    value[name] = size;
                    if (height) {
                        value['line-height'] = height;
                    }
                }
                else if (value.size === '') {
                    if (Array.isArray(value[name])) {
                        value[name].push(part);
                    }
                    else if (value[name] === '') {
                        value[name] = part;
                    }
                }
            }
        }
    }
    saveFontParts.call(this, name, value);
    delete this.styles[name];
}
function saveFontParts(name, value) {
    for (const child of Styles.connect[name].children) {
        const cname = this.childName(name, child);
        if (Array.isArray(value[child])) {
            const values = value[child];
            if (values.length) {
                this.styles[cname] = values.join(' ');
            }
        }
        else if (value[child] !== '') {
            this.styles[cname] = value[child];
        }
    }
}
function combineFont(_name) { }
class Styles {
    constructor(cssText = '') {
        this.parse(cssText);
    }
    sanitizeValue(text) {
        const PATTERN = this.constructor.pattern;
        if (!text.match(PATTERN.sanitize)) {
            return text;
        }
        text = text.replace(PATTERN.value, '$1');
        const test = text
            .replace(/\\./g, '')
            .replace(/(['"]).*?\1/g, '')
            .replace(/[^'"]/g, '');
        if (test.length) {
            text += test.charAt(0);
        }
        return text;
    }
    get cssText() {
        var _a, _b;
        const styles = [];
        for (const name of Object.keys(this.styles)) {
            const parent = this.parentName(name);
            const cname = name.replace(/.*-/, '');
            if (!this.styles[parent] ||
                !((_b = (_a = Styles.connect[parent]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.includes(cname))) {
                styles.push(`${name}: ${this.styles[name]};`);
            }
        }
        return styles.join(' ');
    }
    get styleList() {
        return Object.assign({}, this.styles);
    }
    set(name, value) {
        var _a, _b;
        name = this.normalizeName(name);
        this.setStyle(name, String(value));
        if (Styles.connect[name] && !Styles.connect[name].combine) {
            this.combineChildren(name);
            delete this.styles[name];
        }
        while (name.match(/-/)) {
            const cname = name;
            name = this.parentName(name);
            if (!Styles.connect[cname] &&
                !((_b = (_a = Styles.connect[name]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.includes(cname.substring(name.length + 1)))) {
                break;
            }
            Styles.connect[name].combine.call(this, name);
        }
    }
    get(name) {
        name = this.normalizeName(name);
        return Object.hasOwn(this.styles, name) ? this.styles[name] : '';
    }
    setStyle(name, value) {
        this.styles[name] = this.sanitizeValue(value);
        if (Styles.connect[name] && Styles.connect[name].children) {
            Styles.connect[name].split.call(this, name);
        }
        if (value === '') {
            delete this.styles[name];
        }
    }
    combineChildren(name) {
        const parent = this.parentName(name);
        for (const child of Styles.connect[name].children) {
            const cname = this.childName(parent, child);
            Styles.connect[cname].combine.call(this, cname);
        }
    }
    parentName(name) {
        const parent = name.replace(/-[^-]*$/, '');
        return name === parent ? '' : parent;
    }
    childName(name, child) {
        if (child.match(/-/)) {
            return child;
        }
        if (Styles.connect[name] && !Styles.connect[name].combine) {
            child += name.replace(/.*-/, '-');
            name = this.parentName(name);
        }
        return name + '-' + child;
    }
    normalizeName(name) {
        return name.replace(/[A-Z]/g, (c) => '-' + c.toLowerCase());
    }
    parse(cssText = '') {
        const PATTERN = this.constructor.pattern;
        this.styles = {};
        const parts = cssText
            .replace(/\n/g, ' ')
            .replace(PATTERN.comment, '')
            .split(PATTERN.style);
        while (parts.length > 1) {
            const [space, name, value] = parts.splice(0, 3);
            if (space.match(/[^\s\n;]/))
                return;
            this.set(name, value);
        }
    }
}
Styles.pattern = {
    sanitize: /['";]/,
    value: /^((:?'(?:\\.|[^'])*(?:'|$)|"(?:\\.|[^"])*(?:"|$)|\n|\\.|[^'";])*?)[\s\n]*(?:;|$).*/,
    style: /([-a-z]+)[\s\n]*:[\s\n]*((?:'(?:\\.|[^'])*(?:'|$)|"(?:\\.|[^"])*(?:"|$)|\n|\\.|[^'";])*?)[\s\n]*(?:;|$)/g,
    comment: /\/\*[^]*?\*\//g,
};
Styles.connect = {
    padding: {
        children: TRBL,
        split: splitTRBL,
        combine: combineTRBL,
    },
    border: {
        children: TRBL,
        split: splitSame,
        combine: combineSame,
    },
    'border-top': {
        children: WSC,
        split: splitWSC,
        combine: combineWSC,
    },
    'border-right': {
        children: WSC,
        split: splitWSC,
        combine: combineWSC,
    },
    'border-bottom': {
        children: WSC,
        split: splitWSC,
        combine: combineWSC,
    },
    'border-left': {
        children: WSC,
        split: splitWSC,
        combine: combineWSC,
    },
    'border-width': {
        children: TRBL,
        split: splitTRBL,
        combine: null,
    },
    'border-style': {
        children: TRBL,
        split: splitTRBL,
        combine: null,
    },
    'border-color': {
        children: TRBL,
        split: splitTRBL,
        combine: null,
    },
    font: {
        children: [
            'style',
            'variant',
            'weight',
            'stretch',
            'line-height',
            'size',
            'family',
        ],
        split: splitFont,
        combine: combineFont,
    },
};
//# sourceMappingURL=Styles.js.map
;// ./mjs/util/numeric.js
function sum(A) {
    return A.reduce((a, b) => a + b, 0);
}
function max(A) {
    return A.reduce((a, b) => Math.max(a, b), 0);
}
//# sourceMappingURL=numeric.js.map
;// ./components/mjs/core/lib/core.js



















































































if (MathJax.loader) {
  MathJax.loader.checkVersion('core', VERSION, 'core');
}

combineWithMathJax({_: {
  adaptors: {
    HTMLAdaptor: HTMLAdaptor_namespaceObject,
    browserAdaptor: browserAdaptor_namespaceObject
  },
  components: {
    global: global_namespaceObject
  },
  core: {
    DOMAdaptor: DOMAdaptor_namespaceObject,
    FindMath: FindMath_namespaceObject,
    Handler: Handler_namespaceObject,
    HandlerList: HandlerList_namespaceObject,
    InputJax: InputJax_namespaceObject,
    MathDocument: MathDocument_namespaceObject,
    MathItem: MathItem_namespaceObject,
    MathList: MathList_namespaceObject,
    MmlTree: {
      Attributes: Attributes_namespaceObject,
      MML: MML_namespaceObject,
      MathMLVisitor: MathMLVisitor_namespaceObject,
      MmlFactory: MmlFactory_namespaceObject,
      MmlNode: MmlNode_namespaceObject,
      MmlNodes: {
        HtmlNode: HtmlNode_namespaceObject,
        TeXAtom: TeXAtom_namespaceObject,
        maction: maction_namespaceObject,
        maligngroup: maligngroup_namespaceObject,
        malignmark: malignmark_namespaceObject,
        math: math_namespaceObject,
        mathchoice: mathchoice_namespaceObject,
        menclose: menclose_namespaceObject,
        merror: merror_namespaceObject,
        mfenced: mfenced_namespaceObject,
        mfrac: mfrac_namespaceObject,
        mglyph: mglyph_namespaceObject,
        mi: mi_namespaceObject,
        mmultiscripts: mmultiscripts_namespaceObject,
        mn: mn_namespaceObject,
        mo: mo_namespaceObject,
        mpadded: mpadded_namespaceObject,
        mphantom: mphantom_namespaceObject,
        mroot: mroot_namespaceObject,
        mrow: mrow_namespaceObject,
        ms: ms_namespaceObject,
        mspace: mspace_namespaceObject,
        msqrt: msqrt_namespaceObject,
        mstyle: mstyle_namespaceObject,
        msubsup: msubsup_namespaceObject,
        mtable: mtable_namespaceObject,
        mtd: mtd_namespaceObject,
        mtext: mtext_namespaceObject,
        mtr: mtr_namespaceObject,
        munderover: munderover_namespaceObject,
        semantics: semantics_namespaceObject
      },
      MmlVisitor: MmlVisitor_namespaceObject,
      OperatorDictionary: OperatorDictionary_namespaceObject,
      SerializedMmlVisitor: SerializedMmlVisitor_namespaceObject
    },
    OutputJax: OutputJax_namespaceObject,
    Tree: {
      Factory: Factory_namespaceObject,
      Node: Node_namespaceObject,
      NodeFactory: NodeFactory_namespaceObject,
      Visitor: Visitor_namespaceObject,
      Wrapper: Wrapper_namespaceObject,
      WrapperFactory: WrapperFactory_namespaceObject
    }
  },
  handlers: {
    html_ts: html_namespaceObject,
    html: {
      HTMLDocument: HTMLDocument_namespaceObject,
      HTMLDomStrings: HTMLDomStrings_namespaceObject,
      HTMLHandler: HTMLHandler_namespaceObject,
      HTMLMathItem: HTMLMathItem_namespaceObject,
      HTMLMathList: HTMLMathList_namespaceObject
    }
  },
  mathjax: mathjax_namespaceObject,
    util: {
    AsyncLoad: AsyncLoad_namespaceObject,
    BBox: BBox_namespaceObject,
    BitField: BitField_namespaceObject,
    Entities: Entities_namespaceObject,
    FunctionList: FunctionList_namespaceObject,
    LinkedList: LinkedList_namespaceObject,
    Options: Options_namespaceObject,
    PrioritizedList: PrioritizedList_namespaceObject,
    Retries: Retries_namespaceObject,
    StyleJson: StyleJson_namespaceObject,
    Styles: Styles_namespaceObject,
    context: context_namespaceObject,
    lengths: lengths_namespaceObject,
    numeric: numeric_namespaceObject,
    string: string_namespaceObject
  }
}});

;// ./components/mjs/core/core.js





if (MathJax.startup) {
  MathJax.startup.registerConstructor('HTMLHandler', HTMLHandler);
  MathJax.startup.registerConstructor('browserAdaptor', browserAdaptor);
  MathJax.startup.useHandler('HTMLHandler');
  MathJax.startup.useAdaptor('browserAdaptor');
}
if (MathJax.loader) {
  const config = MathJax.config.loader;
  MathJax._.mathjax.mathjax.asyncLoad = (
    (name) => name.substring(0, 5) === 'node:'
      ? config.require(name)
      : MathJax.loader.load(name).then(result => result[0])
  );
}

;// ./mjs/input/tex/FindTeX.js



class FindTeX extends AbstractFindMath {
    constructor(options) {
        super(options);
        this.getPatterns();
    }
    getPatterns() {
        const options = this.options;
        const starts = [];
        const parts = [];
        const subparts = [];
        this.end = {};
        this.env = this.sub = 0;
        let i = 1;
        options['inlineMath'].forEach((delims) => this.addPattern(starts, delims, false));
        options['displayMath'].forEach((delims) => this.addPattern(starts, delims, true));
        if (starts.length) {
            parts.push(starts.sort(sortLength).join('|'));
        }
        if (options['processEnvironments']) {
            parts.push('\\\\begin\\s*\\{([^}]*)\\}');
            this.env = i;
            i++;
        }
        if (options['processEscapes']) {
            subparts.push('\\\\([\\\\$])');
        }
        if (options['processRefs']) {
            subparts.push('(\\\\(?:eq)?ref\\s*\\{[^}]*\\})');
        }
        if (subparts.length) {
            parts.push('(' + subparts.join('|') + ')');
            this.sub = i;
        }
        this.start = new RegExp(parts.join('|'), 'g');
        this.hasPatterns = parts.length > 0;
    }
    addPattern(starts, delims, display) {
        const [open, close] = delims;
        starts.push(quotePattern(open));
        this.end[open] = [close, display, this.endPattern(close)];
    }
    endPattern(end, endp) {
        return new RegExp((endp || quotePattern(end)) + '|\\\\(?:[a-zA-Z]|.)|[{}]', 'g');
    }
    findEnd(text, n, start, end) {
        const [close, display, pattern] = end;
        const i = (pattern.lastIndex = start.index + start[0].length);
        let match, braces = 0;
        while ((match = pattern.exec(text))) {
            if ((match[1] || match[0]) === close && braces === 0) {
                return protoItem(start[0], text.substring(i, match.index), match[0], n, start.index, match.index + match[0].length, display);
            }
            else if (match[0] === '{') {
                braces++;
            }
            else if (match[0] === '}' && braces) {
                braces--;
            }
        }
        return null;
    }
    findMathInString(math, n, text) {
        let start, match;
        this.start.lastIndex = 0;
        while ((start = this.start.exec(text))) {
            if (start[this.env] !== undefined && this.env) {
                const end = '\\\\end\\s*(\\{' + quotePattern(start[this.env]) + '\\})';
                match = this.findEnd(text, n, start, [
                    '{' + start[this.env] + '}',
                    true,
                    this.endPattern(null, end),
                ]);
                if (match) {
                    match.math = match.open + match.math + match.close;
                    match.open = match.close = '';
                }
            }
            else if (start[this.sub] !== undefined && this.sub) {
                const math = start[this.sub];
                const end = start.index + start[this.sub].length;
                if (math.length === 2) {
                    match = protoItem('\\', math.substring(1), '', n, start.index, end);
                }
                else {
                    match = protoItem('', math, '', n, start.index, end, false);
                }
            }
            else {
                match = this.findEnd(text, n, start, this.end[start[0]]);
            }
            if (match) {
                math.push(match);
                this.start.lastIndex = match.end.n;
            }
        }
    }
    findMath(strings) {
        const math = [];
        if (this.hasPatterns) {
            for (let i = 0, m = strings.length; i < m; i++) {
                this.findMathInString(math, i, strings[i]);
            }
        }
        return math;
    }
}
FindTeX.OPTIONS = {
    inlineMath: [
        ['\\(', '\\)']
    ],
    displayMath: [
        ['$$', '$$'],
        ['\\[', '\\]']
    ],
    processEscapes: true,
    processEnvironments: true,
    processRefs: true,
};
//# sourceMappingURL=FindTeX.js.map
;// ./mjs/input/tex/NodeUtil.js


const NodeUtil = {
    attrs: new Set([
        'autoOP',
        'fnOP',
        'movesupsub',
        'subsupOK',
        'texprimestyle',
        'useHeight',
        'variantForm',
        'withDelims',
        'mathaccent',
        'open',
        'close',
    ]),
    createEntity(code) {
        return String.fromCodePoint(parseInt(code, 16));
    },
    getChildren(node) {
        return node.childNodes;
    },
    getText(node) {
        return node.getText();
    },
    appendChildren(node, children) {
        for (const child of children) {
            node.appendChild(child);
        }
    },
    setAttribute(node, attribute, value) {
        node.attributes.set(attribute, value);
    },
    setProperty(node, property, value) {
        node.setProperty(property, value);
    },
    setProperties(node, properties) {
        for (const name of Object.keys(properties)) {
            const value = properties[name];
            if (name === 'texClass') {
                node.texClass = value;
                node.setProperty(name, value);
            }
            else if (name === 'movablelimits') {
                node.setProperty('movablelimits', value);
                if (node.isKind('mo') || node.isKind('mstyle')) {
                    node.attributes.set('movablelimits', value);
                }
            }
            else if (name === 'inferred') {
            }
            else if (NodeUtil.attrs.has(name)) {
                node.setProperty(name, value);
            }
            else {
                node.attributes.set(name, value);
            }
        }
    },
    getProperty(node, property) {
        return node.getProperty(property);
    },
    getAttribute(node, attr) {
        return node.attributes.get(attr);
    },
    removeAttribute(node, attr) {
        node.attributes.unset(attr);
    },
    removeProperties(node, ...properties) {
        node.removeProperty(...properties);
    },
    getChildAt(node, position) {
        return node.childNodes[position];
    },
    setChild(node, position, child) {
        const children = node.childNodes;
        children[position] = child;
        if (child) {
            child.parent = node;
        }
    },
    copyChildren(oldNode, newNode) {
        const children = oldNode.childNodes;
        for (let i = 0; i < children.length; i++) {
            this.setChild(newNode, i, children[i]);
        }
    },
    copyAttributes(oldNode, newNode) {
        newNode.attributes = oldNode.attributes;
        this.setProperties(newNode, oldNode.getAllProperties());
    },
    isType(node, kind) {
        return node.isKind(kind);
    },
    isEmbellished(node) {
        return node.isEmbellished;
    },
    getTexClass(node) {
        return node.texClass;
    },
    getCoreMO(node) {
        return node.coreMO();
    },
    isNode(item) {
        return (item instanceof AbstractMmlNode || item instanceof AbstractMmlEmptyNode);
    },
    isInferred(node) {
        return node.isInferred;
    },
    getForm(node) {
        if (!node.isKind('mo')) {
            return null;
        }
        const mo = node;
        const forms = mo.getForms();
        for (const form of forms) {
            const symbol = this.getOp(mo, form);
            if (symbol) {
                return symbol;
            }
        }
        return null;
    },
    getOp(mo, form = 'infix') {
        return MmlMo.OPTABLE[form][mo.getText()] || null;
    },
    getMoAttribute(mo, attr) {
        var _a, _b;
        if (!mo.attributes.isSet(attr)) {
            for (const form of ['infix', 'postfix', 'prefix']) {
                const value = (_b = (_a = this.getOp(mo, form)) === null || _a === void 0 ? void 0 : _a[3]) === null || _b === void 0 ? void 0 : _b[attr];
                if (value !== undefined) {
                    return value;
                }
            }
        }
        return mo.attributes.get(attr);
    },
};
/* harmony default export */ const tex_NodeUtil = (NodeUtil);
//# sourceMappingURL=NodeUtil.js.map
;// ./mjs/input/tex/FilterUtil.js


function _copyExplicit(attrs, node1, node2) {
    const attr1 = node1.attributes;
    const attr2 = node2.attributes;
    attrs.forEach((x) => {
        const attr = attr2.getExplicit(x);
        if (attr != null) {
            attr1.set(x, attr);
        }
    });
}
function _compareExplicit(node1, node2) {
    const filter = (attr, space) => {
        const exp = attr.getExplicitNames();
        return exp.filter((x) => {
            return (x !== space &&
                (x !== 'stretchy' || attr.getExplicit('stretchy')) &&
                x !== 'data-latex' &&
                x !== 'data-latex-item');
        });
    };
    const attr1 = node1.attributes;
    const attr2 = node2.attributes;
    const exp1 = filter(attr1, 'lspace');
    const exp2 = filter(attr2, 'rspace');
    if (exp1.length !== exp2.length) {
        return false;
    }
    for (const name of exp1) {
        if (attr1.getExplicit(name) !== attr2.getExplicit(name)) {
            return false;
        }
    }
    return true;
}
function _cleanSubSup(options, low, up) {
    const remove = [];
    for (const mml of options.getList('m' + low + up)) {
        const children = mml.childNodes;
        if (children[mml[low]] && children[mml[up]]) {
            continue;
        }
        const parent = mml.parent;
        const newNode = children[mml[low]]
            ? options.nodeFactory.create('node', 'm' + low, [
                children[mml.base],
                children[mml[low]],
            ])
            : options.nodeFactory.create('node', 'm' + up, [
                children[mml.base],
                children[mml[up]],
            ]);
        tex_NodeUtil.copyAttributes(mml, newNode);
        parent.replaceChild(newNode, mml);
        remove.push(mml);
    }
    options.removeFromList('m' + low + up, remove);
}
function _moveLimits(options, underover, subsup) {
    const remove = [];
    for (const mml of options.getList(underover)) {
        if (mml.attributes.get('displaystyle')) {
            continue;
        }
        const base = mml.childNodes[mml.base];
        const mo = base.coreMO();
        if (base.getProperty('movablelimits') &&
            !mo.attributes.hasExplicit('movablelimits')) {
            const node = options.nodeFactory.create('node', subsup, mml.childNodes);
            tex_NodeUtil.copyAttributes(mml, node);
            mml.parent.replaceChild(node, mml);
            remove.push(mml);
        }
    }
    options.removeFromList(underover, remove);
}
const FilterUtil = {
    cleanStretchy(arg) {
        const options = arg.data;
        for (const mo of options.getList('fixStretchy')) {
            if (tex_NodeUtil.getProperty(mo, 'fixStretchy')) {
                const symbol = tex_NodeUtil.getForm(mo);
                if (symbol && symbol[3] && symbol[3]['stretchy']) {
                    tex_NodeUtil.setAttribute(mo, 'stretchy', false);
                }
                const parent = mo.parent;
                if (!tex_NodeUtil.getTexClass(mo) && (!symbol || !symbol[2])) {
                    const texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);
                    parent.replaceChild(texAtom, mo);
                    texAtom.inheritAttributesFrom(mo);
                }
                tex_NodeUtil.removeProperties(mo, 'fixStretchy');
            }
        }
    },
    cleanAttributes(arg) {
        const node = arg.data.root;
        node.walkTree((mml, _d) => {
            const attribs = mml.attributes;
            const keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));
            attribs.unset('mjx-keep-attrs');
            for (const key of attribs.getExplicitNames()) {
                if (!keep.has(key) &&
                    attribs.get(key) === mml.attributes.getInherited(key)) {
                    attribs.unset(key);
                }
            }
        }, {});
    },
    combineRelations(arg) {
        const remove = [];
        for (const mo of arg.data.getList('mo')) {
            if (mo.getProperty('relationsCombined') ||
                !mo.parent ||
                (mo.parent && !tex_NodeUtil.isType(mo.parent, 'mrow')) ||
                tex_NodeUtil.getTexClass(mo) !== TEXCLASS.REL) {
                continue;
            }
            const mml = mo.parent;
            let m2;
            const children = mml.childNodes;
            const next = children.indexOf(mo) + 1;
            const variantForm = tex_NodeUtil.getProperty(mo, 'variantForm');
            while (next < children.length &&
                (m2 = children[next]) &&
                tex_NodeUtil.isType(m2, 'mo') &&
                tex_NodeUtil.getTexClass(m2) === TEXCLASS.REL) {
                if (variantForm === tex_NodeUtil.getProperty(m2, 'variantForm') &&
                    _compareExplicit(mo, m2)) {
                    tex_NodeUtil.appendChildren(mo, tex_NodeUtil.getChildren(m2));
                    _copyExplicit(['stretchy', 'rspace'], mo, m2);
                    for (const name of m2.getPropertyNames()) {
                        mo.setProperty(name, m2.getProperty(name));
                    }
                    if (m2.attributes.get('data-latex')) {
                        mo.attributes.set('data-latex', mo.attributes.get('data-latex') +
                            m2.attributes.get('data-latex'));
                    }
                    children.splice(next, 1);
                    remove.push(m2);
                    m2.parent = null;
                    m2.setProperty('relationsCombined', true);
                    mo.setProperty('texClass', TEXCLASS.REL);
                }
                else {
                    if (!mo.attributes.hasExplicit('rspace')) {
                        tex_NodeUtil.setAttribute(mo, 'rspace', '0pt');
                    }
                    if (!m2.attributes.hasExplicit('lspace')) {
                        tex_NodeUtil.setAttribute(m2, 'lspace', '0pt');
                    }
                    break;
                }
            }
            mo.attributes.setInherited('form', mo.getForms()[0]);
        }
        arg.data.removeFromList('mo', remove);
    },
    cleanSubSup(arg) {
        const options = arg.data;
        if (options.error) {
            return;
        }
        _cleanSubSup(options, 'sub', 'sup');
        _cleanSubSup(options, 'under', 'over');
    },
    moveLimits(arg) {
        const options = arg.data;
        _moveLimits(options, 'munderover', 'msubsup');
        _moveLimits(options, 'munder', 'msub');
        _moveLimits(options, 'mover', 'msup');
    },
    setInherited(arg) {
        arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);
    },
    checkScriptlevel(arg) {
        const options = arg.data;
        const remove = [];
        for (const mml of options.getList('mstyle')) {
            if (mml.childNodes[0].childNodes.length !== 1) {
                continue;
            }
            const attributes = mml.attributes;
            for (const key of ['displaystyle', 'scriptlevel']) {
                if (attributes.getExplicit(key) === attributes.getInherited(key)) {
                    attributes.unset(key);
                }
            }
            const names = attributes.getExplicitNames();
            if (names.filter((key) => key.substring(0, 10) !== 'data-latex').length ===
                0) {
                const child = mml.childNodes[0].childNodes[0];
                names.forEach((key) => child.attributes.set(key, attributes.get(key)));
                mml.parent.replaceChild(child, mml);
                remove.push(mml);
            }
        }
        options.removeFromList('mstyle', remove);
    },
};
/* harmony default export */ const tex_FilterUtil = (FilterUtil);
//# sourceMappingURL=FilterUtil.js.map
;// ./mjs/input/tex/HandlerTypes.js
var ConfigurationType;
(function (ConfigurationType) {
    ConfigurationType["HANDLER"] = "handler";
    ConfigurationType["FALLBACK"] = "fallback";
    ConfigurationType["ITEMS"] = "items";
    ConfigurationType["TAGS"] = "tags";
    ConfigurationType["OPTIONS"] = "options";
    ConfigurationType["NODES"] = "nodes";
    ConfigurationType["PREPROCESSORS"] = "preprocessors";
    ConfigurationType["POSTPROCESSORS"] = "postprocessors";
    ConfigurationType["INIT"] = "init";
    ConfigurationType["CONFIG"] = "config";
    ConfigurationType["PRIORITY"] = "priority";
    ConfigurationType["PARSER"] = "parser";
})(ConfigurationType || (ConfigurationType = {}));
var HandlerType;
(function (HandlerType) {
    HandlerType["DELIMITER"] = "delimiter";
    HandlerType["MACRO"] = "macro";
    HandlerType["CHARACTER"] = "character";
    HandlerType["ENVIRONMENT"] = "environment";
})(HandlerType || (HandlerType = {}));
//# sourceMappingURL=HandlerTypes.js.map
;// ./mjs/input/tex/UnitUtil.js
class UnitMap {
    constructor(map) {
        this.num = '([-+]?([.,]\\d+|\\d+([.,]\\d*)?))';
        this.unit = '';
        this.dimenEnd = /./;
        this.dimenRest = /./;
        this.map = new Map(map);
        this.updateDimen();
    }
    updateDimen() {
        this.unit = `(${Array.from(this.map.keys()).join('|')})`;
        this.dimenEnd = RegExp('^\\s*' + this.num + '\\s*' + this.unit + '\\s*$');
        this.dimenRest = RegExp('^\\s*' + this.num + '\\s*' + this.unit + ' ?');
    }
    set(name, ems) {
        this.map.set(name, ems);
        this.updateDimen();
        return this;
    }
    get(name) {
        return this.map.get(name) || this.map.get('pt');
    }
    delete(name) {
        if (this.map.delete(name)) {
            this.updateDimen();
            return true;
        }
        return false;
    }
}
const emPerInch = 7.2;
const pxPerInch = 72;
function muReplace([value, unit, length]) {
    if (unit !== 'mu') {
        return [value, unit, length];
    }
    const em = UnitUtil.em(UnitUtil.UNIT_CASES.get(unit) * parseFloat(value));
    return [em.slice(0, -2), 'em', length];
}
const UnitUtil = {
    UNIT_CASES: new UnitMap([
        ['em', 1],
        ['ex', .43],
        ['pt', 1 / 10],
        ['pc', 1.2],
        ['px', emPerInch / pxPerInch],
        ['in', emPerInch],
        ['cm', emPerInch / 2.54],
        ['mm', emPerInch / 25.4],
        ['mu', 1 / 18],
    ]),
    matchDimen(dim, rest = false) {
        const match = dim.match(rest ? UnitUtil.UNIT_CASES.dimenRest : UnitUtil.UNIT_CASES.dimenEnd);
        return match
            ? muReplace([match[1].replace(/,/, '.'), match[4], match[0].length])
            : [null, null, 0];
    },
    dimen2em(dim) {
        const [value, unit] = UnitUtil.matchDimen(dim);
        const m = parseFloat(value || '1');
        const factor = UnitUtil.UNIT_CASES.get(unit);
        return factor * m;
    },
    em(m) {
        if (Math.abs(m) < 0.0006) {
            return '0em';
        }
        return m.toFixed(3).replace(/\.?0+$/, '') + 'em';
    },
    trimSpaces(text) {
        if (typeof text !== 'string') {
            return text;
        }
        let TEXT = text.trim();
        if (TEXT.match(/\\$/) && text.match(/ $/)) {
            TEXT += ' ';
        }
        return TEXT;
    },
};
//# sourceMappingURL=UnitUtil.js.map
;// ./mjs/input/tex/Stack.js

class Stack {
    constructor(_factory, _env, inner) {
        this._factory = _factory;
        this._env = _env;
        this.global = {};
        this.stack = [];
        this.global = { isInner: inner };
        this.stack = [this._factory.create('start', this.global)];
        if (_env) {
            this.stack[0].env = _env;
        }
        this.env = this.stack[0].env;
    }
    set env(env) {
        this._env = env;
    }
    get env() {
        return this._env;
    }
    Push(...args) {
        for (const node of args) {
            if (!node) {
                continue;
            }
            const item = tex_NodeUtil.isNode(node)
                ? this._factory.create('mml', node)
                : node;
            item.global = this.global;
            const [top, success] = this.stack.length
                ? this.Top().checkItem(item)
                : [null, true];
            if (!success) {
                continue;
            }
            if (top) {
                this.Pop();
                this.Push(...top);
                continue;
            }
            if (!item.isKind('null')) {
                this.stack.push(item);
            }
            if (item.env) {
                if (item.copyEnv) {
                    Object.assign(item.env, this.env);
                }
                this.env = item.env;
            }
            else {
                item.env = this.env;
            }
        }
    }
    Pop() {
        const item = this.stack.pop();
        if (!item.isOpen) {
            delete item.env;
        }
        this.env = this.stack.length ? this.Top().env : {};
        return item;
    }
    Top(n = 1) {
        return this.stack.length < n ? null : this.stack[this.stack.length - n];
    }
    Prev(noPop) {
        const top = this.Top();
        return noPop ? top.First : top.Pop();
    }
    get height() {
        return this.stack.length;
    }
    toString() {
        return 'stack[\n  ' + this.stack.join('\n  ') + '\n]';
    }
}
//# sourceMappingURL=Stack.js.map
;// ./mjs/input/tex/TexError.js
class TexError {
    static processString(str, args) {
        const parts = str.split(TexError.pattern);
        for (let i = 1, m = parts.length; i < m; i += 2) {
            let c = parts[i].charAt(0);
            if (c >= '0' && c <= '9') {
                parts[i] = args[parseInt(parts[i], 10) - 1];
                if (typeof parts[i] === 'number') {
                    parts[i] = parts[i].toString();
                }
            }
            else if (c === '{') {
                c = parts[i].substring(1);
                if (c >= '0' && c <= '9') {
                    parts[i] =
                        args[parseInt(parts[i].substring(1, parts[i].length - 1), 10) - 1];
                    if (typeof parts[i] === 'number') {
                        parts[i] = parts[i].toString();
                    }
                }
                else {
                    const match = parts[i].match(/^\{([a-z]+):%(\d+)\|(.*)\}$/);
                    if (match) {
                        parts[i] = '%' + parts[i];
                    }
                }
            }
        }
        return parts.join('');
    }
    constructor(id, message, ...rest) {
        this.id = id;
        this.message = TexError.processString(message, rest);
    }
}
TexError.pattern = /%(\d+|\{\d+\}|\{[a-z]+:%\d+(?:\|(?:%\{\d+\}|%.|[^}])*)+\}|.)/g;
/* harmony default export */ const tex_TexError = (TexError);
//# sourceMappingURL=TexError.js.map
;// ./mjs/input/tex/StackItem.js

class MmlStack {
    constructor(_nodes) {
        this._nodes = _nodes;
        this.startStr = '';
        this.startI = 0;
        this.stopI = 0;
    }
    get nodes() {
        return this._nodes;
    }
    Push(...nodes) {
        this._nodes.push(...nodes);
    }
    Pop() {
        return this._nodes.pop();
    }
    get First() {
        return this._nodes[this.Size() - 1];
    }
    set First(node) {
        this._nodes[this.Size() - 1] = node;
    }
    get Last() {
        return this._nodes[0];
    }
    set Last(node) {
        this._nodes[0] = node;
    }
    Peek(n) {
        if (n == null) {
            n = 1;
        }
        return this._nodes.slice(this.Size() - n);
    }
    Size() {
        return this._nodes.length;
    }
    Clear() {
        this._nodes = [];
    }
    toMml(inferred = true, forceRow) {
        if (this._nodes.length === 1 && !forceRow) {
            return this.First;
        }
        return this.create('node', inferred ? 'inferredMrow' : 'mrow', this._nodes, {});
    }
    create(kind, ...rest) {
        return this.factory.configuration.nodeFactory.create(kind, ...rest);
    }
}
class BaseItem extends MmlStack {
    constructor(factory, ...nodes) {
        super(nodes);
        this.factory = factory;
        this.global = {};
        this._properties = {};
        if (this.isOpen) {
            this._env = {};
        }
    }
    get kind() {
        return 'base';
    }
    get env() {
        return this._env;
    }
    set env(value) {
        this._env = value;
    }
    get copyEnv() {
        return true;
    }
    getProperty(key) {
        return this._properties[key];
    }
    setProperty(key, value) {
        this._properties[key] = value;
        return this;
    }
    get isOpen() {
        return false;
    }
    get isClose() {
        return false;
    }
    get isFinal() {
        return false;
    }
    isKind(kind) {
        return kind === this.kind;
    }
    checkItem(item) {
        if (item.isKind('over') && this.isOpen) {
            item.setProperty('num', this.toMml(false));
            this.Clear();
        }
        if (item.isKind('cell') && this.isOpen) {
            if (item.getProperty('linebreak')) {
                return BaseItem.fail;
            }
            throw new tex_TexError('Misplaced', 'Misplaced %1', item.getName());
        }
        if (item.isClose && this.getErrors(item.kind)) {
            const [id, message] = this.getErrors(item.kind);
            throw new tex_TexError(id, message, item.getName());
        }
        if (!item.isFinal) {
            return BaseItem.success;
        }
        this.Push(item.First);
        return BaseItem.fail;
    }
    clearEnv() {
        for (const id of Object.keys(this.env)) {
            delete this.env[id];
        }
    }
    setProperties(def) {
        Object.assign(this._properties, def);
        return this;
    }
    getName() {
        return this.getProperty('name');
    }
    toString() {
        return this.kind + '[' + this.nodes.join('; ') + ']';
    }
    getErrors(kind) {
        const CLASS = this.constructor;
        return CLASS.errors[kind] || BaseItem.errors[kind];
    }
}
BaseItem.fail = [null, false];
BaseItem.success = [null, true];
BaseItem.errors = {
    end: ['MissingBeginExtraEnd', 'Missing \\begin{%1} or extra \\end{%1}'],
    close: ['ExtraCloseMissingOpen', 'Extra close brace or missing open brace'],
    right: ['MissingLeftExtraRight', 'Missing \\left or extra \\right'],
    middle: ['ExtraMiddle', 'Extra \\middle'],
};
//# sourceMappingURL=StackItem.js.map
;// ./mjs/input/tex/TexConstants.js
const TexConstant = {
    Variant: {
        NORMAL: 'normal',
        BOLD: 'bold',
        ITALIC: 'italic',
        BOLDITALIC: 'bold-italic',
        DOUBLESTRUCK: 'double-struck',
        FRAKTUR: 'fraktur',
        BOLDFRAKTUR: 'bold-fraktur',
        SCRIPT: 'script',
        BOLDSCRIPT: 'bold-script',
        SANSSERIF: 'sans-serif',
        BOLDSANSSERIF: 'bold-sans-serif',
        SANSSERIFITALIC: 'sans-serif-italic',
        SANSSERIFBOLDITALIC: 'sans-serif-bold-italic',
        MONOSPACE: 'monospace',
        INITIAL: 'inital',
        TAILED: 'tailed',
        LOOPED: 'looped',
        STRETCHED: 'stretched',
        CALLIGRAPHIC: '-tex-calligraphic',
        BOLDCALLIGRAPHIC: '-tex-bold-calligraphic',
        OLDSTYLE: '-tex-oldstyle',
        BOLDOLDSTYLE: '-tex-bold-oldstyle',
        MATHITALIC: '-tex-mathit',
    },
    Form: {
        PREFIX: 'prefix',
        INFIX: 'infix',
        POSTFIX: 'postfix',
    },
    LineBreak: {
        AUTO: 'auto',
        NEWLINE: 'newline',
        NOBREAK: 'nobreak',
        GOODBREAK: 'goodbreak',
        BADBREAK: 'badbreak',
    },
    LineBreakStyle: {
        BEFORE: 'before',
        AFTER: 'after',
        DUPLICATE: 'duplicate',
        INFIXLINBREAKSTYLE: 'infixlinebreakstyle',
    },
    IndentAlign: {
        LEFT: 'left',
        CENTER: 'center',
        RIGHT: 'right',
        AUTO: 'auto',
        ID: 'id',
        INDENTALIGN: 'indentalign',
    },
    IndentShift: {
        INDENTSHIFT: 'indentshift',
    },
    LineThickness: {
        THIN: 'thin',
        MEDIUM: 'medium',
        THICK: 'thick',
    },
    Notation: {
        LONGDIV: 'longdiv',
        ACTUARIAL: 'actuarial',
        PHASORANGLE: 'phasorangle',
        RADICAL: 'radical',
        BOX: 'box',
        ROUNDEDBOX: 'roundedbox',
        CIRCLE: 'circle',
        LEFT: 'left',
        RIGHT: 'right',
        TOP: 'top',
        BOTTOM: 'bottom',
        UPDIAGONALSTRIKE: 'updiagonalstrike',
        DOWNDIAGONALSTRIKE: 'downdiagonalstrike',
        VERTICALSTRIKE: 'verticalstrike',
        HORIZONTALSTRIKE: 'horizontalstrike',
        NORTHEASTARROW: 'northeastarrow',
        MADRUWB: 'madruwb',
        UPDIAGONALARROW: 'updiagonalarrow',
    },
    Align: {
        TOP: 'top',
        BOTTOM: 'bottom',
        CENTER: 'center',
        BASELINE: 'baseline',
        AXIS: 'axis',
        LEFT: 'left',
        RIGHT: 'right',
    },
    Lines: {
        NONE: 'none',
        SOLID: 'solid',
        DASHED: 'dashed',
    },
    Side: {
        LEFT: 'left',
        RIGHT: 'right',
        LEFTOVERLAP: 'leftoverlap',
        RIGHTOVERLAP: 'rightoverlap',
    },
    Width: {
        AUTO: 'auto',
        FIT: 'fit',
    },
    Actiontype: {
        TOGGLE: 'toggle',
        STATUSLINE: 'statusline',
        TOOLTIP: 'tooltip',
        INPUT: 'input',
    },
    Overflow: {
        LINBREAK: 'linebreak',
        SCROLL: 'scroll',
        ELIDE: 'elide',
        TRUNCATE: 'truncate',
        SCALE: 'scale',
    },
    Unit: {
        EM: 'em',
        EX: 'ex',
        PX: 'px',
        IN: 'in',
        CM: 'cm',
        MM: 'mm',
        PT: 'pt',
        PC: 'pc',
    },
    Attr: {
        LATEX: 'data-latex',
        LATEXITEM: 'data-latex-item',
    },
};
//# sourceMappingURL=TexConstants.js.map
;// ./mjs/input/tex/TexParser.js







class TexParser {
    constructor(_string, env, configuration) {
        this._string = _string;
        this.configuration = configuration;
        this.macroCount = 0;
        this.i = 0;
        this.currentCS = '';
        this.saveI = 0;
        const inner = Object.hasOwn(env, 'isInner');
        const isInner = env['isInner'];
        delete env['isInner'];
        let ENV;
        if (env) {
            ENV = {};
            for (const id of Object.keys(env)) {
                ENV[id] = env[id];
            }
        }
        this.configuration.pushParser(this);
        this.stack = new Stack(this.itemFactory, ENV, inner ? isInner : true);
        this.Parse();
        this.Push(this.itemFactory.create('stop'));
        this.updateResult(this.string, this.i);
        this.stack.env = ENV;
    }
    get options() {
        return this.configuration.options;
    }
    get itemFactory() {
        return this.configuration.itemFactory;
    }
    get tags() {
        return this.configuration.tags;
    }
    set string(str) {
        this._string = str;
    }
    get string() {
        return this._string;
    }
    parse(kind, input) {
        const i = this.saveI;
        this.saveI = this.i;
        const result = this.configuration.handlers.get(kind).parse(input);
        this.updateResult(input[1], i);
        this.saveI = i;
        return result;
    }
    lookup(kind, token) {
        return this.configuration.handlers.get(kind).lookup(token);
    }
    contains(kind, token) {
        return this.configuration.handlers.get(kind).contains(token);
    }
    toString() {
        let str = '';
        for (const config of Array.from(this.configuration.handlers.keys())) {
            str +=
                config +
                    ': ' +
                    this.configuration.handlers.get(config) +
                    '\n';
        }
        return str;
    }
    Parse() {
        let c;
        while (this.i < this.string.length) {
            c = this.getCodePoint();
            this.i += c.length;
            this.parse(HandlerType.CHARACTER, [this, c]);
        }
    }
    Push(arg) {
        if (arg instanceof BaseItem) {
            arg.startI = this.saveI;
            arg.stopI = this.i;
            arg.startStr = this.string;
        }
        if (arg instanceof AbstractMmlNode && arg.isInferred) {
            this.PushAll(arg.childNodes);
        }
        else {
            this.stack.Push(arg);
        }
    }
    PushAll(args) {
        for (const arg of args) {
            this.stack.Push(arg);
        }
    }
    mml() {
        if (!this.stack.Top().isKind('mml')) {
            return null;
        }
        const node = this.stack.Top().First;
        this.configuration.popParser();
        node.attributes.set(TexConstant.Attr.LATEX, this.string);
        return node;
    }
    convertDelimiter(c) {
        var _a;
        const token = this.lookup(HandlerType.DELIMITER, c);
        return (_a = token === null || token === void 0 ? void 0 : token.char) !== null && _a !== void 0 ? _a : null;
    }
    getCodePoint() {
        const code = this.string.codePointAt(this.i);
        return code === undefined ? '' : String.fromCodePoint(code);
    }
    nextIsSpace() {
        return !!this.string.charAt(this.i).match(/\s/);
    }
    GetNext() {
        while (this.nextIsSpace()) {
            this.i++;
        }
        return this.getCodePoint();
    }
    GetCS() {
        const CS = this.string
            .slice(this.i)
            .match(/^(([a-z]+) ?|[\uD800-\uDBFF].|.)/i);
        if (CS) {
            this.i += CS[0].length;
            return CS[2] || CS[1];
        }
        else {
            this.i++;
            return ' ';
        }
    }
    GetArgument(_name, noneOK = false) {
        switch (this.GetNext()) {
            case '':
                if (!noneOK) {
                    throw new tex_TexError('MissingArgFor', 'Missing argument for %1', this.currentCS);
                }
                return null;
            case '}':
                if (!noneOK) {
                    throw new tex_TexError('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
                }
                return null;
            case '\\':
                this.i++;
                return '\\' + this.GetCS();
            case '{': {
                const j = ++this.i;
                let parens = 1;
                while (this.i < this.string.length) {
                    switch (this.string.charAt(this.i++)) {
                        case '\\':
                            this.i++;
                            break;
                        case '{':
                            parens++;
                            break;
                        case '}':
                            if (--parens === 0) {
                                return this.string.slice(j, this.i - 1);
                            }
                            break;
                    }
                }
                throw new tex_TexError('MissingCloseBrace', 'Missing close brace');
            }
        }
        const c = this.getCodePoint();
        this.i += c.length;
        return c;
    }
    GetBrackets(_name, def, matchBrackets = false) {
        if (this.GetNext() !== '[') {
            return def;
        }
        const j = ++this.i;
        let braces = 0;
        let brackets = 0;
        while (this.i < this.string.length) {
            switch (this.string.charAt(this.i++)) {
                case '{':
                    braces++;
                    break;
                case '\\':
                    this.i++;
                    break;
                case '}':
                    if (braces-- <= 0) {
                        throw new tex_TexError('ExtraCloseLooking', 'Extra close brace while looking for %1', "']'");
                    }
                    break;
                case '[':
                    if (braces === 0)
                        brackets++;
                    break;
                case ']':
                    if (braces === 0) {
                        if (!matchBrackets || brackets === 0) {
                            return this.string.slice(j, this.i - 1);
                        }
                        brackets--;
                    }
                    break;
            }
        }
        throw new tex_TexError('MissingCloseBracket', "Could not find closing ']' for argument to %1", this.currentCS);
    }
    GetDelimiter(name, braceOK = false) {
        let c = this.GetNext();
        this.i += c.length;
        if (this.i <= this.string.length) {
            if (c === '\\') {
                c += this.GetCS();
            }
            else if (c === '{' && braceOK) {
                this.i--;
                c = this.GetArgument(name).trim();
            }
            if (this.contains(HandlerType.DELIMITER, c)) {
                return this.convertDelimiter(c);
            }
        }
        throw new tex_TexError('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);
    }
    GetDimen(name) {
        if (this.GetNext() === '{') {
            const dimen = this.GetArgument(name);
            const [value, unit] = UnitUtil.matchDimen(dimen);
            if (value) {
                return value + unit;
            }
        }
        else {
            const dimen = this.string.slice(this.i);
            const [value, unit, length] = UnitUtil.matchDimen(dimen, true);
            if (value) {
                this.i += length;
                return value + unit;
            }
        }
        throw new tex_TexError('MissingDimOrUnits', 'Missing dimension or its units for %1', this.currentCS);
    }
    GetUpTo(_name, token) {
        while (this.nextIsSpace()) {
            this.i++;
        }
        const j = this.i;
        let braces = 0;
        while (this.i < this.string.length) {
            const k = this.i;
            let c = this.GetNext();
            this.i += c.length;
            switch (c) {
                case '\\':
                    c += this.GetCS();
                    break;
                case '{':
                    braces++;
                    break;
                case '}':
                    if (braces === 0) {
                        throw new tex_TexError('ExtraCloseLooking', 'Extra close brace while looking for %1', token);
                    }
                    braces--;
                    break;
            }
            if (braces === 0 && c === token) {
                return this.string.slice(j, k);
            }
        }
        throw new tex_TexError('TokenNotFoundForCommand', 'Could not find %1 for %2', token, this.currentCS);
    }
    ParseArg(name) {
        return new TexParser(this.GetArgument(name), this.stack.env, this.configuration).mml();
    }
    ParseUpTo(name, token) {
        return new TexParser(this.GetUpTo(name, token), this.stack.env, this.configuration).mml();
    }
    GetDelimiterArg(name) {
        const c = UnitUtil.trimSpaces(this.GetArgument(name));
        if (c === '') {
            return null;
        }
        if (this.contains(HandlerType.DELIMITER, c)) {
            return c;
        }
        throw new tex_TexError('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);
    }
    GetStar() {
        const star = this.GetNext() === '*';
        if (star) {
            this.i++;
        }
        return star;
    }
    create(kind, ...rest) {
        const node = this.configuration.nodeFactory.create(kind, ...rest);
        if (node.isToken && node.attributes.hasExplicit('mathvariant')) {
            if (node.attributes.get('mathvariant').charAt(0) === '-') {
                node.setProperty('ignore-variant', true);
            }
        }
        return node;
    }
    updateResult(input, old) {
        const node = this.stack.Prev(true);
        if (!node) {
            return;
        }
        const existing = node.attributes.get(TexConstant.Attr.LATEXITEM);
        if (existing !== undefined) {
            node.attributes.set(TexConstant.Attr.LATEX, existing);
            return;
        }
        old = old < this.saveI ? this.saveI : old;
        let str = old !== this.i ? this.string.slice(old, this.i) : input;
        str = str.trim();
        if (!str) {
            return;
        }
        if (input === '\\') {
            str = '\\' + str;
        }
        if (node.attributes.get(TexConstant.Attr.LATEX) === '^' &&
            str !== '^' &&
            str !== '\\^') {
            if (node.childNodes[2]) {
                if (str === '}') {
                    this.composeBraces(node.childNodes[2]);
                }
                else {
                    node.childNodes[2].attributes.set(TexConstant.Attr.LATEX, str);
                }
            }
            if (node.childNodes[1]) {
                const sub = node.childNodes[1].attributes.get(TexConstant.Attr.LATEX);
                this.composeLatex(node, `_${sub}^`, 0, 2);
            }
            else {
                this.composeLatex(node, '^', 0, 2);
            }
            return;
        }
        if (node.attributes.get(TexConstant.Attr.LATEX) === '_' &&
            str !== '_' &&
            str !== '\\_') {
            if (node.childNodes[1]) {
                if (str === '}') {
                    this.composeBraces(node.childNodes[1]);
                }
                else {
                    node.childNodes[1].attributes.set(TexConstant.Attr.LATEX, str);
                }
            }
            if (node.childNodes[2]) {
                const sub = node.childNodes[2].attributes.get(TexConstant.Attr.LATEX);
                this.composeLatex(node, `^${sub}_`, 0, 1);
            }
            else {
                this.composeLatex(node, '_', 0, 1);
            }
            return;
        }
        if (str === '}') {
            this.composeBraces(node);
            return;
        }
        node.attributes.set(TexConstant.Attr.LATEX, str);
    }
    composeLatex(node, comp, pos1, pos2) {
        if (!node.childNodes[pos1] || !node.childNodes[pos2])
            return;
        const expr = (node.childNodes[pos1].attributes.get(TexConstant.Attr.LATEX) || '') +
            comp +
            node.childNodes[pos2].attributes.get(TexConstant.Attr.LATEX);
        node.attributes.set(TexConstant.Attr.LATEX, expr);
    }
    composeBraces(atom) {
        const str = this.composeBracedContent(atom);
        atom.attributes.set(TexConstant.Attr.LATEX, `{${str}}`);
    }
    composeBracedContent(atom) {
        var _a, _b;
        const children = ((_a = atom.childNodes[0]) === null || _a === void 0 ? void 0 : _a.childNodes) || [];
        let expr = '';
        for (const child of children) {
            const att = (((_b = child === null || child === void 0 ? void 0 : child.attributes) === null || _b === void 0 ? void 0 : _b.get(TexConstant.Attr.LATEX)) ||
                '');
            if (!att)
                continue;
            expr +=
                expr && expr.match(/[a-zA-Z]$/) && att.match(/^[a-zA-Z]/)
                    ? ' ' + att
                    : att;
        }
        return expr;
    }
}
//# sourceMappingURL=TexParser.js.map
;// ./mjs/input/tex/StackItemFactory.js


class DummyItem extends BaseItem {
}
class StackItemFactory extends AbstractFactory {
    constructor() {
        super(...arguments);
        this.defaultKind = 'dummy';
        this.configuration = null;
    }
}
StackItemFactory.DefaultStackItems = {
    [DummyItem.prototype.kind]: DummyItem,
};
/* harmony default export */ const tex_StackItemFactory = (StackItemFactory);
//# sourceMappingURL=StackItemFactory.js.map
;// ./mjs/input/tex/NodeFactory.js

class NodeFactory {
    constructor() {
        this.mmlFactory = null;
        this.factory = {
            node: NodeFactory.createNode,
            token: NodeFactory.createToken,
            text: NodeFactory.createText,
            error: NodeFactory.createError,
        };
    }
    static createNode(factory, kind, children = [], def = {}, text) {
        const node = factory.mmlFactory.create(kind);
        node.setChildren(children);
        if (text) {
            node.appendChild(text);
        }
        tex_NodeUtil.setProperties(node, def);
        return node;
    }
    static createToken(factory, kind, def = {}, text = '') {
        const textNode = factory.create('text', text);
        return factory.create('node', kind, [], def, textNode);
    }
    static createText(factory, text) {
        if (text == null) {
            return null;
        }
        return factory.mmlFactory.create('text').setText(text);
    }
    static createError(factory, message) {
        const text = factory.create('text', message);
        const mtext = factory.create('node', 'mtext', [], {}, text);
        const error = factory.create('node', 'merror', [mtext], {
            'data-mjx-error': message,
        });
        return error;
    }
    setMmlFactory(mmlFactory) {
        this.mmlFactory = mmlFactory;
    }
    set(kind, func) {
        this.factory[kind] = func;
    }
    setCreators(maps) {
        for (const kind in maps) {
            this.set(kind, maps[kind]);
        }
    }
    create(kind, ...rest) {
        const func = this.factory[kind] || this.factory['node'];
        const node = func(this, rest[0], ...rest.slice(1));
        if (kind === 'node') {
            this.configuration.addNode(rest[0], node);
        }
        return node;
    }
    get(kind) {
        return this.factory[kind];
    }
}
//# sourceMappingURL=NodeFactory.js.map
;// ./mjs/input/tex/ParseUtil.js






class KeyValueDef {
    static oneof(...values) {
        return new this('string', (value) => values.includes(value), (value) => value);
    }
    constructor(name, verify, convert) {
        this.name = name;
        this.verify = verify;
        this.convert = convert;
    }
}
const KeyValueTypes = {
    boolean: new KeyValueDef('boolean', (value) => value === 'true' || value === 'false', (value) => value === 'true'),
    number: new KeyValueDef('number', (value) => !!value.match(/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[-+]?\d+)?$/), (value) => parseFloat(value)),
    integer: new KeyValueDef('integer', (value) => !!value.match(/^[-+]?\d+$/), (value) => parseInt(value)),
    string: new KeyValueDef('string', (_value) => true, (value) => value),
    dimen: new KeyValueDef('dimen', (value) => UnitUtil.matchDimen(value)[0] !== null, (value) => value),
};
function readKeyval(text, l3keys = false) {
    const options = {};
    let rest = text;
    let end, key, val;
    let dropBrace = true;
    while (rest) {
        [key, end, rest] = readValue(rest, ['=', ','], l3keys, dropBrace);
        dropBrace = false;
        if (end === '=') {
            [val, end, rest] = readValue(rest, [','], l3keys);
            val = val === 'false' || val === 'true' ? JSON.parse(val) : val;
            options[key] = val;
        }
        else if (key) {
            options[key] = true;
        }
    }
    return options;
}
function removeBraces(text, count) {
    if (count === 0) {
        return text
            .replace(/^\s+/, '')
            .replace(/([^\\\s]|^)((?:\\\\)*(?:\\\s)?)?\s+$/, '$1$2');
    }
    while (count > 0) {
        text = text.trim().slice(1, -1);
        count--;
    }
    return text;
}
function readValue(text, end, l3keys = false, dropBrace = false) {
    const length = text.length;
    let braces = 0;
    let value = '';
    let index = 0;
    let start = 0;
    let countBraces = true;
    while (index < length) {
        const c = text[index++];
        switch (c) {
            case '\\':
                value += c + (text[index++] || '');
                countBraces = false;
                continue;
            case ' ':
                break;
            case '{':
                if (countBraces) {
                    start++;
                }
                braces++;
                break;
            case '}':
                if (!braces) {
                    throw new tex_TexError('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
                }
                braces--;
                countBraces = false;
                break;
            default:
                if (!braces && end.includes(c)) {
                    return [
                        removeBraces(value, l3keys ? Math.min(1, start) : start),
                        c,
                        text.slice(index),
                    ];
                }
                if (start > braces) {
                    start = braces;
                }
                countBraces = false;
        }
        value += c;
    }
    if (braces) {
        throw new tex_TexError('ExtraOpenMissingClose', 'Extra open brace or missing close brace');
    }
    return dropBrace && start
        ? ['', '', removeBraces(value, 1)]
        : [
            removeBraces(value, l3keys ? Math.min(1, start) : start),
            '',
            text.slice(index),
        ];
}
const ParseUtil = {
    cols(...W) {
        return W.map((n) => UnitUtil.em(n)).join(' ');
    },
    fenced(configuration, open, mml, close, big = '', color = '') {
        const nf = configuration.nodeFactory;
        const mrow = nf.create('node', 'mrow', [], {
            open: open,
            close: close,
            texClass: TEXCLASS.INNER,
        });
        let mo;
        if (big) {
            mo = new TexParser('\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();
        }
        else {
            const openNode = nf.create('text', open);
            mo = nf.create('node', 'mo', [], {
                fence: true,
                stretchy: true,
                symmetric: true,
                texClass: TEXCLASS.OPEN,
            }, openNode);
        }
        tex_NodeUtil.appendChildren(mrow, [mo, mml]);
        if (big) {
            mo = new TexParser('\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();
        }
        else {
            const closeNode = nf.create('text', close);
            mo = nf.create('node', 'mo', [], {
                fence: true,
                stretchy: true,
                symmetric: true,
                texClass: TEXCLASS.CLOSE,
            }, closeNode);
        }
        if (color) {
            mo.attributes.set('mathcolor', color);
        }
        tex_NodeUtil.appendChildren(mrow, [mo]);
        return mrow;
    },
    fixedFence(configuration, open, mml, close) {
        const mrow = configuration.nodeFactory.create('node', 'mrow', [], {
            open: open,
            close: close,
            texClass: TEXCLASS.ORD,
        });
        if (open) {
            tex_NodeUtil.appendChildren(mrow, [
                ParseUtil.mathPalette(configuration, open, 'l'),
            ]);
        }
        if (tex_NodeUtil.isType(mml, 'mrow')) {
            tex_NodeUtil.appendChildren(mrow, tex_NodeUtil.getChildren(mml));
        }
        else {
            tex_NodeUtil.appendChildren(mrow, [mml]);
        }
        if (close) {
            tex_NodeUtil.appendChildren(mrow, [
                ParseUtil.mathPalette(configuration, close, 'r'),
            ]);
        }
        return mrow;
    },
    mathPalette(configuration, fence, side) {
        if (fence === '{' || fence === '}') {
            fence = '\\' + fence;
        }
        const D = '{\\bigg' + side + ' ' + fence + '}';
        const T = '{\\big' + side + ' ' + fence + '}';
        return new TexParser('\\mathchoice' + D + T + T + T, {}, configuration).mml();
    },
    fixInitialMO(configuration, nodes) {
        for (let i = 0, m = nodes.length; i < m; i++) {
            const child = nodes[i];
            if (child &&
                !tex_NodeUtil.isType(child, 'mspace') &&
                (!tex_NodeUtil.isType(child, 'TeXAtom') ||
                    (tex_NodeUtil.getChildren(child)[0] &&
                        tex_NodeUtil.getChildren(tex_NodeUtil.getChildren(child)[0]).length))) {
                if (tex_NodeUtil.isEmbellished(child) ||
                    (tex_NodeUtil.isType(child, 'TeXAtom') &&
                        tex_NodeUtil.getTexClass(child) === TEXCLASS.REL)) {
                    const mi = configuration.nodeFactory.create('node', 'mi');
                    nodes.unshift(mi);
                }
                break;
            }
        }
    },
    internalMath(parser, text, level, font) {
        text = text.replace(/ +/g, ' ');
        if (parser.configuration.options.internalMath) {
            return parser.configuration.options.internalMath(parser, text, level, font);
        }
        const mathvariant = font || parser.stack.env.font;
        const def = mathvariant ? { mathvariant } : {};
        let mml = [], i = 0, k = 0, c, node, match = '', braces = 0;
        if (text.match(/\\?[${}\\]|\\\(|\\(?:eq)?ref\s*\{|\\U/)) {
            while (i < text.length) {
                c = text.charAt(i++);
                if (c === '$') {
                    if (match === '$' && braces === 0) {
                        node = parser.create('node', 'TeXAtom', [
                            new TexParser(text.slice(k, i - 1), {}, parser.configuration).mml(),
                        ]);
                        mml.push(node);
                        match = '';
                        k = i;
                    }
                    else if (match === '') {
                        if (k < i - 1) {
                            mml.push(ParseUtil.internalText(parser, text.slice(k, i - 1), def));
                        }
                        match = '$';
                        k = i;
                    }
                }
                else if (c === '{' && match !== '') {
                    braces++;
                }
                else if (c === '}') {
                    if (match === '}' && braces === 0) {
                        const atom = new TexParser(text.slice(k, i), {}, parser.configuration).mml();
                        node = parser.create('node', 'TeXAtom', [atom], def);
                        mml.push(node);
                        match = '';
                        k = i;
                    }
                    else if (match !== '') {
                        if (braces) {
                            braces--;
                        }
                    }
                }
                else if (c === '\\') {
                    if (match === '' && text.substring(i).match(/^(eq)?ref\s*\{/)) {
                        const len = RegExp['$&'].length;
                        if (k < i - 1) {
                            mml.push(ParseUtil.internalText(parser, text.slice(k, i - 1), def));
                        }
                        match = '}';
                        k = i - 1;
                        i += len;
                    }
                    else {
                        c = text.charAt(i++);
                        if (c === '(' && match === '') {
                            if (k < i - 2) {
                                mml.push(ParseUtil.internalText(parser, text.slice(k, i - 2), def));
                            }
                            match = ')';
                            k = i;
                        }
                        else if (c === ')' && match === ')' && braces === 0) {
                            node = parser.create('node', 'TeXAtom', [
                                new TexParser(text.slice(k, i - 2), {}, parser.configuration).mml(),
                            ]);
                            mml.push(node);
                            match = '';
                            k = i;
                        }
                        else if (c.match(/[${}\\]/) && match === '') {
                            i--;
                            text = text.substring(0, i - 1) + text.substring(i);
                        }
                        else if (c === 'U') {
                            const arg = text
                                .substring(i)
                                .match(/^\s*(?:([0-9A-F])|\{\s*([0-9A-F]+)\s*\})/);
                            if (!arg) {
                                throw new tex_TexError('BadRawUnicode', 'Argument to %1 must a hexadecimal number with 1 to 6 digits', '\\U');
                            }
                            const c = String.fromCodePoint(parseInt(arg[1] || arg[2], 16));
                            text =
                                text.substring(0, i - 2) +
                                    c +
                                    text.substring(i + arg[0].length);
                            i = i - 2 + c.length;
                        }
                    }
                }
            }
            if (match !== '') {
                throw new tex_TexError('MathNotTerminated', 'Math mode is not properly terminated');
            }
        }
        if (k < text.length) {
            mml.push(ParseUtil.internalText(parser, text.slice(k), def));
        }
        if (level != null) {
            mml = [
                parser.create('node', 'mstyle', mml, {
                    displaystyle: false,
                    scriptlevel: level,
                }),
            ];
        }
        else if (mml.length > 1) {
            mml = [parser.create('node', 'mrow', mml)];
        }
        return mml;
    },
    internalText(parser, text, def) {
        text = text
            .replace(/\n+/g, ' ')
            .replace(/^ +/, entities.nbsp)
            .replace(/ +$/, entities.nbsp);
        const textNode = parser.create('text', text);
        return parser.create('node', 'mtext', [], def, textNode);
    },
    underOver(parser, base, script, pos, stack) {
        ParseUtil.checkMovableLimits(base);
        if (tex_NodeUtil.isType(base, 'munderover') && tex_NodeUtil.isEmbellished(base)) {
            tex_NodeUtil.setProperties(tex_NodeUtil.getCoreMO(base), {
                lspace: 0,
                rspace: 0,
            });
            const mo = parser.create('node', 'mo', [], { rspace: 0 });
            base = parser.create('node', 'mrow', [mo, base]);
        }
        const mml = parser.create('node', 'munderover', [base]);
        tex_NodeUtil.setChild(mml, pos === 'over' ? mml.over : mml.under, script);
        let node = mml;
        if (stack) {
            node = parser.create('node', 'TeXAtom', [
                parser.create('node', 'mstyle', [mml], {
                    displaystyle: true,
                    scriptlevel: 0,
                }),
            ], {
                texClass: TEXCLASS.OP,
                movesupsub: true,
            });
        }
        tex_NodeUtil.setProperty(node, 'subsupOK', true);
        return node;
    },
    checkMovableLimits(base) {
        const symbol = tex_NodeUtil.isType(base, 'mo') ? tex_NodeUtil.getForm(base) : null;
        if (tex_NodeUtil.getProperty(base, 'movablelimits') ||
            (symbol && symbol[3] && symbol[3].movablelimits)) {
            tex_NodeUtil.setProperties(base, { movablelimits: false });
        }
    },
    setArrayAlign(array, align, parser) {
        if (!parser) {
            align = UnitUtil.trimSpaces(align || '');
        }
        if (align === 't') {
            array.arraydef.align = 'baseline 1';
        }
        else if (align === 'b') {
            array.arraydef.align = 'baseline -1';
        }
        else if (align === 'c') {
            array.arraydef.align = 'axis';
        }
        else if (align) {
            if (parser) {
                parser.string = `[${align}]` + parser.string.slice(parser.i);
                parser.i = 0;
            }
            else {
                array.arraydef.align = align;
            }
        }
        return array;
    },
    substituteArgs(parser, args, str) {
        let text = '';
        let newstring = '';
        let i = 0;
        while (i < str.length) {
            let c = str.charAt(i++);
            if (c === '\\') {
                text += c + str.charAt(i++);
            }
            else if (c === '#') {
                c = str.charAt(i++);
                if (c === '#') {
                    text += c;
                }
                else {
                    if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {
                        throw new tex_TexError('IllegalMacroParam', 'Illegal macro parameter reference');
                    }
                    newstring = ParseUtil.addArgs(parser, ParseUtil.addArgs(parser, newstring, text), args[parseInt(c, 10) - 1]);
                    text = '';
                }
            }
            else {
                text += c;
            }
        }
        return ParseUtil.addArgs(parser, newstring, text);
    },
    addArgs(parser, s1, s2) {
        if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\])(\\\\)*\\[a-z]+$/i)) {
            s1 += ' ';
        }
        if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {
            throw new tex_TexError('MaxBufferSize', 'MathJax internal buffer size exceeded; is there a' +
                ' recursive macro call?');
        }
        return s1 + s2;
    },
    checkMaxMacros(parser, isMacro = true) {
        if (++parser.macroCount <= parser.configuration.options['maxMacros']) {
            return;
        }
        if (isMacro) {
            throw new tex_TexError('MaxMacroSub1', 'MathJax maximum macro substitution count exceeded; ' +
                'is here a recursive macro call?');
        }
        else {
            throw new tex_TexError('MaxMacroSub2', 'MathJax maximum substitution count exceeded; ' +
                'is there a recursive latex environment?');
        }
    },
    checkEqnEnv(parser, nestable = true) {
        const top = parser.stack.Top();
        const first = top.First;
        if ((top.getProperty('nestable') && nestable && !first) ||
            top.getProperty('nestStart')) {
            return;
        }
        if (!top.isKind('start') || first) {
            throw new tex_TexError('ErroneousNestingEq', 'Erroneous nesting of equation structures');
        }
    },
    copyNode(node, parser) {
        const tree = node.copy();
        const options = parser.configuration;
        tree.walkTree((n) => {
            options.addNode(n.kind, n);
            const lists = (n.getProperty('in-lists') || '').split(/,/);
            for (const list of lists) {
                if (list) {
                    options.addNode(list, n);
                }
            }
        });
        return tree;
    },
    mmlFilterAttribute(_parser, _name, value) {
        return value;
    },
    getFontDef(parser) {
        const font = parser.stack.env['font'];
        return font ? { mathvariant: font } : {};
    },
    keyvalOptions(attrib, allowed = null, error = false, l3keys = false) {
        const def = readKeyval(attrib, l3keys);
        if (allowed) {
            for (const key of Object.keys(def)) {
                if (Object.hasOwn(allowed, key)) {
                    if (allowed[key] instanceof KeyValueDef) {
                        const type = allowed[key];
                        const value = String(def[key]);
                        if (!type.verify(value)) {
                            throw new tex_TexError('InvalidValue', "Value for key '%1' is not of the expected type", key);
                        }
                        def[key] = type.convert(value);
                    }
                }
                else {
                    if (error) {
                        throw new tex_TexError('InvalidOption', 'Invalid option: %1', key);
                    }
                    delete def[key];
                }
            }
        }
        return def;
    },
    isLatinOrGreekChar(c) {
        return !!c.normalize('NFD').match(/[a-zA-Z\u0370-\u03F0]/);
    },
};
//# sourceMappingURL=ParseUtil.js.map
;// ./mjs/input/tex/ColumnParser.js




class ColumnParser {
    constructor() {
        this.columnHandler = {
            l: (state) => (state.calign[state.j++] = 'left'),
            c: (state) => (state.calign[state.j++] = 'center'),
            r: (state) => (state.calign[state.j++] = 'right'),
            p: (state) => this.getColumn(state, 'top'),
            m: (state) => this.getColumn(state, 'middle'),
            b: (state) => this.getColumn(state, 'bottom'),
            w: (state) => this.getColumn(state, 'top', ''),
            W: (state) => this.getColumn(state, 'top', ''),
            '|': (state) => this.addRule(state, 'solid'),
            ':': (state) => this.addRule(state, 'dashed'),
            '>': (state) => (state.cstart[state.j] =
                (state.cstart[state.j] || '') + this.getBraces(state)),
            '<': (state) => (state.cend[state.j - 1] =
                (state.cend[state.j - 1] || '') + this.getBraces(state)),
            '@': (state) => this.addAt(state, this.getBraces(state)),
            '!': (state) => this.addBang(state, this.getBraces(state)),
            '*': (state) => this.repeat(state),
            P: (state) => this.macroColumn(state, '>{$}p{#1}<{$}', 1),
            M: (state) => this.macroColumn(state, '>{$}m{#1}<{$}', 1),
            B: (state) => this.macroColumn(state, '>{$}b{#1}<{$}', 1),
            ' ': (_state) => { },
        };
        this.MAXCOLUMNS = 10000;
    }
    process(parser, template, array) {
        const state = {
            parser,
            template,
            i: 0,
            j: 0,
            c: '',
            cwidth: [],
            calign: [],
            cspace: [],
            clines: [],
            cstart: array.cstart,
            cend: array.cend,
            ralign: array.ralign,
            cextra: array.cextra,
        };
        let n = 0;
        while (state.i < state.template.length) {
            if (n++ > this.MAXCOLUMNS) {
                throw new tex_TexError('MaxColumns', 'Too many column specifiers (perhaps looping column definitions?)');
            }
            const code = state.template.codePointAt(state.i);
            const c = (state.c = String.fromCodePoint(code));
            state.i += c.length;
            if (!Object.hasOwn(this.columnHandler, c)) {
                throw new tex_TexError('BadPreamToken', 'Illegal pream-token (%1)', c);
            }
            this.columnHandler[c](state);
        }
        this.setColumnAlign(state, array);
        this.setColumnWidths(state, array);
        this.setColumnSpacing(state, array);
        this.setColumnLines(state, array);
        this.setPadding(state, array);
    }
    setColumnAlign(state, array) {
        array.arraydef.columnalign = state.calign.join(' ');
    }
    setColumnWidths(state, array) {
        if (!state.cwidth.length)
            return;
        const cwidth = [...state.cwidth];
        if (cwidth.length < state.calign.length) {
            cwidth.push('auto');
        }
        array.arraydef.columnwidth = cwidth.map((w) => w || 'auto').join(' ');
    }
    setColumnSpacing(state, array) {
        if (!state.cspace.length)
            return;
        const cspace = [...state.cspace];
        if (cspace.length < state.calign.length) {
            cspace.push('1em');
        }
        array.arraydef.columnspacing = cspace
            .slice(1)
            .map((d) => d || '1em')
            .join(' ');
    }
    setColumnLines(state, array) {
        if (!state.clines.length)
            return;
        const clines = [...state.clines];
        if (clines[0]) {
            array.frame.push(['left', clines[0]]);
        }
        if (clines.length > state.calign.length) {
            array.frame.push(['right', clines.pop()]);
        }
        else if (clines.length < state.calign.length) {
            clines.push('none');
        }
        if (clines.length > 1) {
            array.arraydef.columnlines = clines
                .slice(1)
                .map((l) => l || 'none')
                .join(' ');
        }
    }
    setPadding(state, array) {
        if (!state.cextra[0] && !state.cextra[state.calign.length - 1])
            return;
        const i = state.calign.length - 1;
        const cspace = state.cspace;
        const space = !state.cextra[i] ? null : cspace[i];
        array.arraydef['data-array-padding'] =
            `${cspace[0] || '.5em'} ${space || '.5em'}`;
    }
    getColumn(state, ralign, calign = 'left') {
        state.calign[state.j] = calign || this.getAlign(state);
        state.cwidth[state.j] = this.getDimen(state);
        state.ralign[state.j] = [
            ralign,
            state.cwidth[state.j],
            state.calign[state.j],
        ];
        state.j++;
    }
    getDimen(state) {
        const dim = this.getBraces(state);
        if (!UnitUtil.matchDimen(dim)[0]) {
            throw new tex_TexError('MissingColumnDimOrUnits', 'Missing dimension or its units for %1 column declaration', state.c);
        }
        return dim;
    }
    getAlign(state) {
        const align = this.getBraces(state);
        return lookup(align.toLowerCase(), { l: 'left', c: 'center', r: 'right' }, '');
    }
    getBraces(state) {
        while (state.template[state.i] === ' ')
            state.i++;
        if (state.i >= state.template.length) {
            throw new tex_TexError('MissingArgForColumn', 'Missing argument for %1 column declaration', state.c);
        }
        if (state.template[state.i] !== '{') {
            return state.template[state.i++];
        }
        const i = ++state.i;
        let braces = 1;
        while (state.i < state.template.length) {
            switch (state.template.charAt(state.i++)) {
                case '\\':
                    state.i++;
                    break;
                case '{':
                    braces++;
                    break;
                case '}':
                    if (--braces === 0) {
                        return state.template.slice(i, state.i - 1);
                    }
                    break;
            }
        }
        throw new tex_TexError('MissingCloseBrace', 'Missing close brace');
    }
    macroColumn(state, macro, n) {
        const args = [];
        while (n > 0 && n--) {
            args.push(this.getBraces(state));
        }
        state.template =
            ParseUtil.substituteArgs(state.parser, args, macro) +
                state.template.slice(state.i);
        state.i = 0;
    }
    addRule(state, rule) {
        if (state.clines[state.j]) {
            this.addAt(state, '\\,');
        }
        state.clines[state.j] = rule;
        if (state.cspace[state.j] === '0') {
            state.cstart[state.j] = '\\hspace{.5em}';
        }
    }
    addAt(state, macro) {
        const { cstart, cspace, j } = state;
        state.cextra[j] = true;
        state.calign[j] = 'center';
        if (state.clines[j]) {
            if (cspace[j] === '.5em') {
                cstart[j - 1] += '\\hspace{.25em}';
            }
            else if (!cspace[j]) {
                state.cend[j - 1] = (state.cend[j - 1] || '') + '\\hspace{.5em}';
            }
        }
        cstart[j] = macro;
        cspace[j] = '0';
        cspace[++state.j] = '0';
    }
    addBang(state, macro) {
        const { cstart, cspace, j } = state;
        state.cextra[j] = true;
        state.calign[j] = 'center';
        cstart[j] =
            (cspace[j] === '0' && state.clines[j] ? '\\hspace{.25em}' : '') + macro;
        if (!cspace[j]) {
            cspace[j] = '.5em';
        }
        cspace[++state.j] = '.5em';
    }
    repeat(state) {
        const num = this.getBraces(state);
        const cols = this.getBraces(state);
        const n = parseInt(num);
        if (String(n) !== num) {
            throw new tex_TexError('ColArgNotNum', 'First argument to %1 column specifier must be a number', '*');
        }
        state.template =
            new Array(n).fill(cols).join('') + state.template.substring(state.i);
        state.i = 0;
    }
}
//# sourceMappingURL=ColumnParser.js.map
;// ./mjs/input/tex/ParseOptions.js






const MATHVARIANT = TexConstant.Variant;
class ParseOptions {
    constructor(configuration, options = []) {
        this.options = {};
        this.columnParser = new ColumnParser();
        this.packageData = new Map();
        this.parsers = [];
        this.root = null;
        this.nodeLists = {};
        this.error = false;
        this.handlers = configuration.handlers;
        this.nodeFactory = new NodeFactory();
        this.nodeFactory.configuration = this;
        this.nodeFactory.setCreators(configuration.nodes);
        this.itemFactory = new tex_StackItemFactory(configuration.items);
        this.itemFactory.configuration = this;
        defaultOptions(this.options, ...options);
        defaultOptions(this.options, configuration.options);
        this.mathStyle =
            ParseOptions.getVariant.get(this.options.mathStyle) ||
                ParseOptions.getVariant.get('TeX');
    }
    pushParser(parser) {
        this.parsers.unshift(parser);
    }
    popParser() {
        this.parsers.shift();
    }
    get parser() {
        return this.parsers[0];
    }
    clear() {
        this.parsers = [];
        this.root = null;
        this.nodeLists = {};
        this.error = false;
        this.tags.resetTag();
    }
    addNode(property, node) {
        let list = this.nodeLists[property];
        if (!list) {
            list = this.nodeLists[property] = [];
        }
        list.push(node);
        if (node.kind !== property) {
            const inlists = tex_NodeUtil.getProperty(node, 'in-lists') || '';
            const lists = (inlists ? inlists.split(/,/) : [])
                .concat(property)
                .join(',');
            tex_NodeUtil.setProperty(node, 'in-lists', lists);
        }
    }
    getList(property) {
        const list = this.nodeLists[property] || [];
        const result = [];
        for (const node of list) {
            if (this.inTree(node)) {
                result.push(node);
            }
        }
        this.nodeLists[property] = result;
        return result;
    }
    removeFromList(property, nodes) {
        const list = this.nodeLists[property] || [];
        for (const node of nodes) {
            const i = list.indexOf(node);
            if (i >= 0) {
                list.splice(i, 1);
            }
        }
    }
    inTree(node) {
        while (node && node !== this.root) {
            node = node.parent;
        }
        return !!node;
    }
}
ParseOptions.getVariant = new Map([
    [
        'TeX',
        (c, b) => b ? (c.match(/^[\u0391-\u03A9\u03F4]/) ? MATHVARIANT.NORMAL : '') : '',
    ],
    ['ISO', (_c) => MATHVARIANT.ITALIC],
    [
        'French',
        (c) => c.normalize('NFD').match(/^[a-z]/)
            ? MATHVARIANT.ITALIC
            : MATHVARIANT.NORMAL,
    ],
    ['upright', (_c) => MATHVARIANT.NORMAL],
]);
/* harmony default export */ const tex_ParseOptions = (ParseOptions);
//# sourceMappingURL=ParseOptions.js.map
;// ./mjs/input/tex/Tags.js

class Label {
    constructor(tag = '???', id = '') {
        this.tag = tag;
        this.id = id;
    }
}
class TagInfo {
    constructor(env = '', taggable = false, defaultTags = false, tag = null, tagId = '', tagFormat = '', noTag = false, labelId = '') {
        this.env = env;
        this.taggable = taggable;
        this.defaultTags = defaultTags;
        this.tag = tag;
        this.tagId = tagId;
        this.tagFormat = tagFormat;
        this.noTag = noTag;
        this.labelId = labelId;
    }
}
class AbstractTags {
    constructor() {
        this.counter = 0;
        this.allCounter = 0;
        this.configuration = null;
        this.ids = {};
        this.allIds = {};
        this.labels = {};
        this.allLabels = {};
        this.redo = false;
        this.refUpdate = false;
        this.currentTag = new TagInfo();
        this.history = [];
        this.stack = [];
        this.enTag = function (node, tag) {
            const nf = this.configuration.nodeFactory;
            const cell = nf.create('node', 'mtd', [node]);
            const row = nf.create('node', 'mlabeledtr', [tag, cell]);
            const table = nf.create('node', 'mtable', [row], {
                side: this.configuration.options['tagSide'],
                minlabelspacing: this.configuration.options['tagIndent'],
                displaystyle: true,
            });
            return table;
        };
    }
    start(env, taggable, defaultTags) {
        if (this.currentTag) {
            this.stack.push(this.currentTag);
        }
        const label = this.label;
        this.currentTag = new TagInfo(env, taggable, defaultTags);
        this.label = label;
    }
    get env() {
        return this.currentTag.env;
    }
    end() {
        this.history.push(this.currentTag);
        const label = this.label;
        this.currentTag = this.stack.pop();
        if (label && !this.label) {
            this.label = label;
        }
    }
    tag(tag, noFormat) {
        this.currentTag.tag = tag;
        this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);
        this.currentTag.noTag = false;
    }
    notag() {
        this.tag('', true);
        this.currentTag.noTag = true;
    }
    get noTag() {
        return this.currentTag.noTag;
    }
    set label(label) {
        this.currentTag.labelId = label;
    }
    get label() {
        return this.currentTag.labelId;
    }
    formatUrl(id, base) {
        return base + '#' + encodeURIComponent(id);
    }
    formatTag(tag) {
        return '(' + tag + ')';
    }
    formatRef(tag) {
        return this.formatTag(tag);
    }
    formatId(id) {
        return 'mjx-eqn:' + id.replace(/\s/g, '_');
    }
    formatNumber(n) {
        return n.toString();
    }
    autoTag() {
        if (this.currentTag.tag == null) {
            this.counter++;
            this.tag(this.formatNumber(this.counter), false);
        }
    }
    clearTag() {
        this.tag(null, true);
        this.currentTag.tagId = '';
    }
    getTag(force = false) {
        if (force) {
            this.autoTag();
            return this.makeTag();
        }
        const ct = this.currentTag;
        if (ct.taggable && !ct.noTag) {
            if (ct.defaultTags) {
                this.autoTag();
            }
            if (ct.tag) {
                return this.makeTag();
            }
        }
        return null;
    }
    resetTag() {
        this.history = [];
        this.redo = false;
        this.refUpdate = false;
        this.clearTag();
    }
    reset(offset = 0) {
        this.resetTag();
        this.counter = this.allCounter = offset;
        this.allLabels = {};
        this.allIds = {};
        this.label = '';
    }
    startEquation(math) {
        this.history = [];
        this.stack = [];
        this.clearTag();
        this.currentTag = new TagInfo('', undefined, undefined);
        this.labels = {};
        this.ids = {};
        this.counter = this.allCounter;
        this.redo = false;
        const recompile = math.inputData.recompile;
        if (recompile) {
            this.refUpdate = true;
            this.counter = recompile.counter;
        }
    }
    finishEquation(math) {
        if (this.redo) {
            math.inputData.recompile = {
                state: math.state(),
                counter: this.allCounter,
            };
        }
        if (!this.refUpdate) {
            this.allCounter = this.counter;
        }
        Object.assign(this.allIds, this.ids);
        Object.assign(this.allLabels, this.labels);
    }
    finalize(node, env) {
        if (!env.display || this.currentTag.env || this.currentTag.tag == null) {
            return node;
        }
        const tag = this.makeTag();
        const table = this.enTag(node, tag);
        return table;
    }
    makeId() {
        this.currentTag.tagId = this.formatId(this.configuration.options['useLabelIds']
            ? this.label || this.currentTag.tag
            : this.currentTag.tag);
    }
    makeTag() {
        this.makeId();
        if (this.label) {
            this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);
            this.label = '';
        }
        const mml = new TexParser('\\text{' + this.currentTag.tagFormat + '}', {}, this.configuration).mml();
        return this.configuration.nodeFactory.create('node', 'mtd', [mml], {
            id: this.currentTag.tagId,
            rowalign: this.configuration.options.tagAlign,
        });
    }
}
class NoTags extends AbstractTags {
    autoTag() { }
    getTag() {
        return !this.currentTag.tag ? null : super.getTag();
    }
}
class AllTags extends AbstractTags {
    finalize(node, env) {
        if (!env.display ||
            this.history.find(function (x) {
                return x.taggable;
            })) {
            return node;
        }
        const tag = this.getTag(true);
        return this.enTag(node, tag);
    }
}
const tagsMapping = new Map([
    ['none', NoTags],
    ['all', AllTags],
]);
let defaultTags = 'none';
const TagsFactory = {
    OPTIONS: {
        tags: defaultTags,
        tagSide: 'right',
        tagIndent: '0.8em',
        useLabelIds: true,
        ignoreDuplicateLabels: false,
        tagAlign: 'baseline',
    },
    add(name, constr) {
        tagsMapping.set(name, constr);
    },
    addTags(tags) {
        for (const key of Object.keys(tags)) {
            TagsFactory.add(key, tags[key]);
        }
    },
    create(name) {
        const constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);
        if (!constr) {
            throw Error('Unknown tags class');
        }
        return new constr();
    },
    setDefault(name) {
        defaultTags = name;
    },
    getDefault() {
        return TagsFactory.create(defaultTags);
    },
};
//# sourceMappingURL=Tags.js.map
;// ./mjs/input/tex/Token.js
class Token {
    constructor(_token, _char, _attributes) {
        this._token = _token;
        this._char = _char;
        this._attributes = _attributes;
    }
    get token() {
        return this._token;
    }
    get char() {
        return this._char;
    }
    get attributes() {
        return this._attributes;
    }
}
class Macro {
    constructor(_token, _func, _args = []) {
        this._token = _token;
        this._func = _func;
        this._args = _args;
    }
    get token() {
        return this._token;
    }
    get func() {
        return this._func;
    }
    get args() {
        return this._args;
    }
}
//# sourceMappingURL=Token.js.map
;// ./mjs/input/tex/TokenMap.js


function parseResult(result) {
    return result === void 0 ? true : result;
}
class AbstractTokenMap {
    constructor(_name, _parser) {
        this._name = _name;
        this._parser = _parser;
        MapHandler.register(this);
    }
    get name() {
        return this._name;
    }
    parserFor(token) {
        return this.contains(token) ? this.parser : null;
    }
    parse([env, token]) {
        const parser = this.parserFor(token);
        const mapped = this.lookup(token);
        return parser && mapped ? parseResult(parser(env, mapped)) : null;
    }
    set parser(parser) {
        this._parser = parser;
    }
    get parser() {
        return this._parser;
    }
}
class RegExpMap extends AbstractTokenMap {
    constructor(name, parser, _regExp) {
        super(name, parser);
        this._regExp = _regExp;
    }
    contains(token) {
        return this._regExp.test(token);
    }
    lookup(token) {
        return this.contains(token) ? token : null;
    }
}
class AbstractParseMap extends AbstractTokenMap {
    constructor() {
        super(...arguments);
        this.map = new Map();
    }
    lookup(token) {
        return this.map.get(token);
    }
    contains(token) {
        return this.map.has(token);
    }
    add(token, object) {
        this.map.set(token, object);
    }
    remove(token) {
        this.map.delete(token);
    }
}
class CharacterMap extends AbstractParseMap {
    constructor(name, parser, json) {
        super(name, parser);
        for (const key of Object.keys(json)) {
            const value = json[key];
            const [char, attrs] = typeof value === 'string' ? [value, null] : value;
            const character = new Token(key, char, attrs);
            this.add(key, character);
        }
    }
}
class DelimiterMap extends CharacterMap {
    parse([env, token]) {
        return super.parse([env, '\\' + token]);
    }
}
class MacroMap extends AbstractParseMap {
    constructor(name, json, functionMap = {}) {
        super(name, null);
        const getMethod = (func) => typeof func === 'string' ? functionMap[func] : func;
        for (const [key, value] of Object.entries(json)) {
            let func;
            let args;
            if (Array.isArray(value)) {
                func = getMethod(value[0]);
                args = value.slice(1);
            }
            else {
                func = getMethod(value);
                args = [];
            }
            const character = new Macro(key, func, args);
            this.add(key, character);
        }
    }
    parserFor(token) {
        const macro = this.lookup(token);
        return macro ? macro.func : null;
    }
    parse([env, token]) {
        const macro = this.lookup(token);
        const parser = this.parserFor(token);
        if (!macro || !parser) {
            return null;
        }
        return parseResult(parser(env, macro.token, ...macro.args));
    }
}
class CommandMap extends MacroMap {
    parse([env, token]) {
        const macro = this.lookup(token);
        const parser = this.parserFor(token);
        if (!macro || !parser) {
            return null;
        }
        const saveCommand = env.currentCS;
        env.currentCS = '\\' + token;
        const result = parser(env, '\\' + macro.token, ...macro.args);
        env.currentCS = saveCommand;
        return parseResult(result);
    }
}
class EnvironmentMap extends MacroMap {
    constructor(name, parser, json, functionMap = {}) {
        super(name, json, functionMap);
        this.parser = parser;
    }
    parse([env, token]) {
        const macro = this.lookup(token);
        const envParser = this.parserFor(token);
        if (!macro || !envParser) {
            return null;
        }
        return parseResult(this.parser(env, macro.token, envParser, macro.args));
    }
}
//# sourceMappingURL=TokenMap.js.map
;// ./mjs/input/tex/MapHandler.js



const maps = new Map();
const MapHandler = {
    register(map) {
        maps.set(map.name, map);
    },
    getMap(name) {
        return maps.get(name);
    },
};
class SubHandler {
    constructor() {
        this._configuration = new PrioritizedList();
        this._fallback = new FunctionList();
    }
    add(maps, fallback, priority = PrioritizedList.DEFAULTPRIORITY) {
        for (const name of maps.slice().reverse()) {
            const map = MapHandler.getMap(name);
            if (!map) {
                this.warn(`Configuration '${name}' not found! Omitted.`);
                return;
            }
            this._configuration.add(map, priority);
        }
        if (fallback) {
            this._fallback.add(fallback, priority);
        }
    }
    remove(maps, fallback = null) {
        for (const name of maps) {
            const map = this.retrieve(name);
            if (map) {
                this._configuration.remove(map);
            }
        }
        if (fallback) {
            this._fallback.remove(fallback);
        }
    }
    parse(input) {
        for (const { item: map } of this._configuration) {
            const result = map.parse(input);
            if (result === SubHandler.FALLBACK) {
                break;
            }
            if (result) {
                return result;
            }
        }
        const [env, token] = input;
        Array.from(this._fallback)[0].item(env, token);
        return;
    }
    lookup(token) {
        const map = this.applicable(token);
        return map ? map.lookup(token) : null;
    }
    contains(token) {
        const map = this.applicable(token);
        return (!!map && !(map instanceof CharacterMap && map.lookup(token).char === null));
    }
    toString() {
        const names = [];
        for (const { item: map } of this._configuration) {
            names.push(map.name);
        }
        return names.join(', ');
    }
    applicable(token) {
        for (const { item: map } of this._configuration) {
            if (map.contains(token)) {
                return map;
            }
        }
        return null;
    }
    retrieve(name) {
        for (const { item: map } of this._configuration) {
            if (map.name === name) {
                return map;
            }
        }
        return null;
    }
    warn(message) {
        console.log('TexParser Warning: ' + message);
    }
}
SubHandler.FALLBACK = Symbol('fallback');
class SubHandlers {
    constructor() {
        this.map = new Map();
    }
    add(handlers, fallbacks, priority = PrioritizedList.DEFAULTPRIORITY) {
        for (const key of Object.keys(handlers)) {
            const name = key;
            let subHandler = this.get(name);
            if (!subHandler) {
                subHandler = new SubHandler();
                this.set(name, subHandler);
            }
            subHandler.add(handlers[name], fallbacks[name], priority);
        }
    }
    remove(handlers, fallbacks) {
        for (const name of Object.keys(handlers)) {
            const subHandler = this.get(name);
            if (subHandler) {
                subHandler.remove(handlers[name], fallbacks[name]);
            }
        }
    }
    set(name, subHandler) {
        this.map.set(name, subHandler);
    }
    get(name) {
        return this.map.get(name);
    }
    retrieve(name) {
        for (const handler of this.map.values()) {
            const map = handler.retrieve(name);
            if (map) {
                return map;
            }
        }
        return null;
    }
    keys() {
        return this.map.keys();
    }
}
//# sourceMappingURL=MapHandler.js.map
;// ./mjs/input/tex/Configuration.js






class Configuration {
    static makeProcessor(func, priority) {
        return Array.isArray(func) ? func : [func, priority];
    }
    static _create(name, config = {}) {
        var _a;
        const priority = (_a = config.priority) !== null && _a !== void 0 ? _a : PrioritizedList.DEFAULTPRIORITY;
        const init = config.init ? this.makeProcessor(config.init, priority) : null;
        const conf = config.config
            ? this.makeProcessor(config.config, priority)
            : null;
        const preprocessors = (config.preprocessors || []).map((pre) => this.makeProcessor(pre, priority));
        const postprocessors = (config.postprocessors || []).map((post) => this.makeProcessor(post, priority));
        const parser = config.parser || 'tex';
        return new Configuration(name, config[ConfigurationType.HANDLER] || {}, config[ConfigurationType.FALLBACK] || {}, config[ConfigurationType.ITEMS] || {}, config[ConfigurationType.TAGS] || {}, config[ConfigurationType.OPTIONS] || {}, config[ConfigurationType.NODES] || {}, preprocessors, postprocessors, init, conf, priority, parser);
    }
    static create(name, config = {}) {
        const configuration = Configuration._create(name, config);
        ConfigurationHandler.set(name, configuration);
        return configuration;
    }
    static local(config = {}) {
        return Configuration._create('', config);
    }
    constructor(name, handler = {}, fallback = {}, items = {}, tags = {}, options = {}, nodes = {}, preprocessors = [], postprocessors = [], initMethod = null, configMethod = null, priority, parser) {
        this.name = name;
        this.handler = handler;
        this.fallback = fallback;
        this.items = items;
        this.tags = tags;
        this.options = options;
        this.nodes = nodes;
        this.preprocessors = preprocessors;
        this.postprocessors = postprocessors;
        this.initMethod = initMethod;
        this.configMethod = configMethod;
        this.priority = priority;
        this.parser = parser;
        this.handler = Object.assign({
            [HandlerType.CHARACTER]: [],
            [HandlerType.DELIMITER]: [],
            [HandlerType.MACRO]: [],
            [HandlerType.ENVIRONMENT]: [],
        }, handler);
    }
    get init() {
        return this.initMethod ? this.initMethod[0] : null;
    }
    get config() {
        return this.configMethod ? this.configMethod[0] : null;
    }
}
const Configuration_maps = new Map();
const ConfigurationHandler = {
    set(name, map) {
        Configuration_maps.set(name, map);
    },
    get(name) {
        return Configuration_maps.get(name);
    },
    keys() {
        return Configuration_maps.keys();
    },
};
class ParserConfiguration {
    constructor(packages, parsers = ['tex']) {
        this.initMethod = new FunctionList();
        this.configMethod = new FunctionList();
        this.configurations = new PrioritizedList();
        this.parsers = [];
        this.handlers = new SubHandlers();
        this.items = {};
        this.tags = {};
        this.options = {};
        this.nodes = {};
        this.parsers = parsers;
        for (const pkg of packages.slice().reverse()) {
            this.addPackage(pkg);
        }
        for (const { item: config, priority: priority } of this.configurations) {
            this.append(config, priority);
        }
    }
    init() {
        this.initMethod.execute(this);
    }
    config(jax) {
        this.configMethod.execute(this, jax);
        for (const config of this.configurations) {
            this.addFilters(jax, config.item);
        }
    }
    addPackage(pkg) {
        const name = typeof pkg === 'string' ? pkg : pkg[0];
        const conf = this.getPackage(name);
        if (conf) {
            this.configurations.add(conf, typeof pkg === 'string' ? conf.priority : pkg[1]);
        }
    }
    add(name, jax, options = {}) {
        const config = this.getPackage(name);
        this.append(config);
        this.configurations.add(config, config.priority);
        this.init();
        const parser = jax.parseOptions;
        parser.nodeFactory.setCreators(config.nodes);
        for (const kind of Object.keys(config.items)) {
            parser.itemFactory.setNodeClass(kind, config.items[kind]);
        }
        TagsFactory.addTags(config.tags);
        defaultOptions(parser.options, config.options);
        userOptions(parser.options, options);
        this.addFilters(jax, config);
        if (config.config) {
            config.config(this, jax);
        }
    }
    getPackage(name) {
        const config = ConfigurationHandler.get(name);
        if (config && !this.parsers.includes(config.parser)) {
            throw Error(`Package '${name}' doesn't target the proper parser`);
        }
        if (!config) {
            this.warn(`Package '${name}' not found.  Omitted.`);
        }
        return config;
    }
    append(config, priority) {
        priority = priority || config.priority;
        if (config.initMethod) {
            this.initMethod.add(config.initMethod[0], config.initMethod[1]);
        }
        if (config.configMethod) {
            this.configMethod.add(config.configMethod[0], config.configMethod[1]);
        }
        this.handlers.add(config.handler, config.fallback, priority);
        Object.assign(this.items, config.items);
        Object.assign(this.tags, config.tags);
        defaultOptions(this.options, config.options);
        Object.assign(this.nodes, config.nodes);
    }
    addFilters(jax, config) {
        for (const [pre, priority] of config.preprocessors) {
            jax.preFilters.add(pre, priority);
        }
        for (const [post, priority] of config.postprocessors) {
            jax.postFilters.add(post, priority);
        }
    }
    warn(message) {
        console.warn('MathJax Warning: ' + message);
    }
}
//# sourceMappingURL=Configuration.js.map
;// ./mjs/input/tex/base/BaseItems.js










class StartItem extends BaseItem {
    constructor(factory, global) {
        super(factory);
        this.global = global;
    }
    get kind() {
        return 'start';
    }
    get isOpen() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('stop')) {
            let node = this.toMml();
            if (!this.global.isInner) {
                node = this.factory.configuration.tags.finalize(node, this.env);
            }
            return [[this.factory.create('mml', node)], true];
        }
        return super.checkItem(item);
    }
}
class StopItem extends BaseItem {
    get kind() {
        return 'stop';
    }
    get isClose() {
        return true;
    }
}
class OpenItem extends BaseItem {
    get kind() {
        return 'open';
    }
    get isOpen() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('close')) {
            const mml = this.toMml();
            const node = this.create('node', 'TeXAtom', [mml]);
            addLatexItem(node, item);
            return [[this.factory.create('mml', node)], true];
        }
        return super.checkItem(item);
    }
}
OpenItem.errors = Object.assign(Object.create(BaseItem.errors), {
    stop: ['ExtraOpenMissingClose', 'Extra open brace or missing close brace'],
});
class CloseItem extends BaseItem {
    get kind() {
        return 'close';
    }
    get isClose() {
        return true;
    }
}
class NullItem extends BaseItem {
    get kind() {
        return 'null';
    }
}
class PrimeItem extends BaseItem {
    get kind() {
        return 'prime';
    }
    checkItem(item) {
        const [top0, top1] = this.Peek(2);
        const isSup = (tex_NodeUtil.isType(top0, 'msubsup') || tex_NodeUtil.isType(top0, 'msup')) &&
            !tex_NodeUtil.getChildAt(top0, top0.sup);
        const isOver = (tex_NodeUtil.isType(top0, 'munderover') || tex_NodeUtil.isType(top0, 'mover')) &&
            !tex_NodeUtil.getChildAt(top0, top0.over) &&
            !tex_NodeUtil.getProperty(top0, 'subsupOK');
        if (!isSup && !isOver) {
            const node = this.create('node', top0.getProperty('movesupsub') ? 'mover' : 'msup', [top0, top1]);
            return [[node, item], true];
        }
        const pos = isSup ? top0.sup : top0.over;
        tex_NodeUtil.setChild(top0, pos, top1);
        return [[top0, item], true];
    }
}
class SubsupItem extends BaseItem {
    get kind() {
        return 'subsup';
    }
    checkItem(item) {
        if (item.isKind('open') || item.isKind('left')) {
            return BaseItem.success;
        }
        const top = this.First;
        const position = this.getProperty('position');
        if (item.isKind('mml')) {
            if (this.getProperty('primes')) {
                if (position !== 2) {
                    tex_NodeUtil.setChild(top, 2, this.getProperty('primes'));
                }
                else {
                    tex_NodeUtil.setProperty(this.getProperty('primes'), 'variantForm', true);
                    const node = this.create('node', 'mrow', [
                        this.getProperty('primes'),
                        item.First,
                    ]);
                    item.First = node;
                }
            }
            tex_NodeUtil.setChild(top, position, item.First);
            if (this.getProperty('movesupsub') != null) {
                tex_NodeUtil.setProperty(top, 'movesupsub', this.getProperty('movesupsub'));
            }
            const result = this.factory.create('mml', top);
            return [[result], true];
        }
        super.checkItem(item);
        const error = this.getErrors(['', 'sub', 'sup'][position]);
        throw new tex_TexError(error[0], error[1], ...error.splice(2));
    }
}
SubsupItem.errors = Object.assign(Object.create(BaseItem.errors), {
    stop: ['MissingScript', 'Missing superscript or subscript argument'],
    sup: ['MissingOpenForSup', 'Missing open brace for superscript'],
    sub: ['MissingOpenForSub', 'Missing open brace for subscript'],
});
class OverItem extends BaseItem {
    constructor(factory) {
        super(factory);
        this.setProperty('name', '\\over');
    }
    get kind() {
        return 'over';
    }
    get isClose() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('over')) {
            throw new tex_TexError('AmbiguousUseOf', 'Ambiguous use of %1', item.getName());
        }
        if (item.isClose) {
            let mml = this.create('node', 'mfrac', [
                this.getProperty('num'),
                this.toMml(false),
            ]);
            if (this.getProperty('thickness') != null) {
                tex_NodeUtil.setAttribute(mml, 'linethickness', this.getProperty('thickness'));
            }
            if (this.getProperty('ldelim') || this.getProperty('rdelim')) {
                tex_NodeUtil.setProperty(mml, 'withDelims', true);
                mml = ParseUtil.fixedFence(this.factory.configuration, this.getProperty('ldelim'), mml, this.getProperty('rdelim'));
            }
            mml.attributes.set(TexConstant.Attr.LATEXITEM, this.getProperty('name'));
            return [[this.factory.create('mml', mml), item], true];
        }
        return super.checkItem(item);
    }
    toString() {
        return ('over[' + this.getProperty('num') + ' / ' + this.nodes.join('; ') + ']');
    }
}
class LeftItem extends BaseItem {
    constructor(factory, delim) {
        super(factory);
        this.setProperty('delim', delim);
    }
    get kind() {
        return 'left';
    }
    get isOpen() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('right')) {
            const fenced = ParseUtil.fenced(this.factory.configuration, this.getProperty('delim'), this.toMml(), item.getProperty('delim'), '', item.getProperty('color'));
            const left = fenced.childNodes[0];
            const right = fenced.childNodes[fenced.childNodes.length - 1];
            const mrow = this.factory.create('mml', fenced);
            addLatexItem(left, this, '\\left');
            addLatexItem(right, item, '\\right');
            mrow
                .Peek()[0]
                .attributes.set(TexConstant.Attr.LATEXITEM, '\\left' + item.startStr.slice(this.startI, item.stopI));
            return [[mrow], true];
        }
        if (item.isKind('middle')) {
            const def = { stretchy: true };
            if (item.getProperty('color')) {
                def.mathcolor = item.getProperty('color');
            }
            const middle = this.create('token', 'mo', def, item.getProperty('delim'));
            addLatexItem(middle, item, '\\middle');
            this.Push(this.create('node', 'TeXAtom', [], { texClass: TEXCLASS.CLOSE }), middle, this.create('node', 'TeXAtom', [], { texClass: TEXCLASS.OPEN }));
            this.env = {};
            return [[this], true];
        }
        return super.checkItem(item);
    }
}
LeftItem.errors = Object.assign(Object.create(BaseItem.errors), {
    stop: ['ExtraLeftMissingRight', 'Extra \\left or missing \\right'],
});
class Middle extends BaseItem {
    constructor(factory, delim, color) {
        super(factory);
        this.setProperty('delim', delim);
        if (color) {
            this.setProperty('color', color);
        }
    }
    get kind() {
        return 'middle';
    }
    get isClose() {
        return true;
    }
}
class RightItem extends BaseItem {
    constructor(factory, delim, color) {
        super(factory);
        this.setProperty('delim', delim);
        if (color) {
            this.setProperty('color', color);
        }
    }
    get kind() {
        return 'right';
    }
    get isClose() {
        return true;
    }
}
class BreakItem extends BaseItem {
    get kind() {
        return 'break';
    }
    constructor(factory, linebreak, insert) {
        super(factory);
        this.setProperty('linebreak', linebreak);
        this.setProperty('insert', insert);
    }
    checkItem(item) {
        var _a, _b;
        const linebreak = this.getProperty('linebreak');
        if (item.isKind('mml')) {
            const mml = item.First;
            if (mml.isKind('mo')) {
                const style = ((_b = (_a = tex_NodeUtil.getOp(mml)) === null || _a === void 0 ? void 0 : _a[3]) === null || _b === void 0 ? void 0 : _b.linebreakstyle) ||
                    tex_NodeUtil.getAttribute(mml, 'linebreakstyle');
                if (style !== 'after') {
                    tex_NodeUtil.setAttribute(mml, 'linebreak', linebreak);
                    return [[item], true];
                }
                if (!this.getProperty('insert')) {
                    return [[item], true];
                }
            }
        }
        const mml = this.create('token', 'mspace', { linebreak });
        return [[this.factory.create('mml', mml), item], true];
    }
}
class BeginItem extends BaseItem {
    get kind() {
        return 'begin';
    }
    get isOpen() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('end')) {
            if (item.getName() !== this.getName()) {
                throw new tex_TexError('EnvBadEnd', '\\begin{%1} ended with \\end{%2}', this.getName(), item.getName());
            }
            const node = this.toMml();
            addLatexItem(node, item);
            return [[this.factory.create('mml', node)], true];
        }
        if (item.isKind('stop')) {
            throw new tex_TexError('EnvMissingEnd', 'Missing \\end{%1}', this.getName());
        }
        return super.checkItem(item);
    }
}
class EndItem extends BaseItem {
    get kind() {
        return 'end';
    }
    get isClose() {
        return true;
    }
}
class StyleItem extends BaseItem {
    get kind() {
        return 'style';
    }
    checkItem(item) {
        if (!item.isClose) {
            return super.checkItem(item);
        }
        const mml = this.create('node', 'mstyle', this.nodes, this.getProperty('styles'));
        return [[this.factory.create('mml', mml), item], true];
    }
}
class PositionItem extends BaseItem {
    get kind() {
        return 'position';
    }
    checkItem(item) {
        if (item.isClose) {
            throw new tex_TexError('MissingBoxFor', 'Missing box for %1', this.getName());
        }
        if (item.isFinal) {
            let mml = item.toMml();
            switch (this.getProperty('move')) {
                case 'vertical':
                    mml = this.create('node', 'mpadded', [mml], {
                        height: this.getProperty('dh'),
                        depth: this.getProperty('dd'),
                        voffset: this.getProperty('dh'),
                    });
                    return [[this.factory.create('mml', mml)], true];
                case 'horizontal':
                    return [
                        [
                            this.factory.create('mml', this.getProperty('left')),
                            item,
                            this.factory.create('mml', this.getProperty('right')),
                        ],
                        true,
                    ];
            }
        }
        return super.checkItem(item);
    }
}
class CellItem extends BaseItem {
    get kind() {
        return 'cell';
    }
    get isClose() {
        return true;
    }
}
class MmlItem extends BaseItem {
    get isFinal() {
        return true;
    }
    get kind() {
        return 'mml';
    }
}
class FnItem extends BaseItem {
    get kind() {
        return 'fn';
    }
    checkItem(item) {
        const top = this.First;
        if (top) {
            if (item.isOpen) {
                return BaseItem.success;
            }
            if (!item.isKind('fn')) {
                let mml = item.First;
                if (!item.isKind('mml') || !mml) {
                    return [[top, item], true];
                }
                if ((tex_NodeUtil.isType(mml, 'mstyle') &&
                    mml.childNodes.length &&
                    tex_NodeUtil.isType(mml.childNodes[0].childNodes[0], 'mspace')) ||
                    tex_NodeUtil.isType(mml, 'mspace')) {
                    return [[top, item], true];
                }
                if (tex_NodeUtil.isEmbellished(mml)) {
                    mml = tex_NodeUtil.getCoreMO(mml);
                }
                const form = tex_NodeUtil.getForm(mml);
                if (form != null && [0, 0, 1, 1, 0, 1, 1, 0, 0, 0][form[2]]) {
                    return [[top, item], true];
                }
            }
            const node = this.create('token', 'mo', { texClass: TEXCLASS.NONE }, entities.ApplyFunction);
            return [[top, node, item], true];
        }
        return super.checkItem(item);
    }
}
class NotItem extends BaseItem {
    constructor() {
        super(...arguments);
        this.remap = MapHandler.getMap('not_remap');
    }
    get kind() {
        return 'not';
    }
    checkItem(item) {
        let mml;
        let c;
        let textNode;
        if (item.isKind('open') || item.isKind('left')) {
            return BaseItem.success;
        }
        if (item.isKind('mml') &&
            (tex_NodeUtil.isType(item.First, 'mo') ||
                tex_NodeUtil.isType(item.First, 'mi') ||
                tex_NodeUtil.isType(item.First, 'mtext'))) {
            mml = item.First;
            c = tex_NodeUtil.getText(mml);
            if (c.length === 1 &&
                !tex_NodeUtil.getProperty(mml, 'movesupsub') &&
                tex_NodeUtil.getChildren(mml).length === 1) {
                if (this.remap.contains(c)) {
                    textNode = this.create('text', this.remap.lookup(c).char);
                    tex_NodeUtil.setChild(mml, 0, textNode);
                }
                else {
                    textNode = this.create('text', '\u0338');
                    tex_NodeUtil.appendChildren(mml, [textNode]);
                }
                return [[item], true];
            }
        }
        textNode = this.create('text', '\u29F8');
        const mtextNode = this.create('node', 'mtext', [], {}, textNode);
        const paddedNode = this.create('node', 'mpadded', [mtextNode], {
            width: 0,
        });
        mml = this.create('node', 'TeXAtom', [paddedNode], {
            texClass: TEXCLASS.REL,
        });
        return [[mml, item], true];
    }
}
class NonscriptItem extends BaseItem {
    get kind() {
        return 'nonscript';
    }
    checkItem(item) {
        if (item.isKind('mml') && item.Size() === 1) {
            let mml = item.First;
            if (mml.isKind('mstyle') && mml.notParent) {
                mml = tex_NodeUtil.getChildren(tex_NodeUtil.getChildren(mml)[0])[0];
            }
            if (mml.isKind('mspace')) {
                if (mml !== item.First) {
                    const mrow = this.create('node', 'mrow', [item.Pop()]);
                    item.Push(mrow);
                }
                this.factory.configuration.addNode('nonscript', item.First);
            }
        }
        return [[item], true];
    }
}
class DotsItem extends BaseItem {
    get kind() {
        return 'dots';
    }
    checkItem(item) {
        if (item.isKind('open') || item.isKind('left')) {
            return BaseItem.success;
        }
        let dots = this.getProperty('ldots');
        const top = item.First;
        if (item.isKind('mml') && tex_NodeUtil.isEmbellished(top)) {
            const tclass = tex_NodeUtil.getTexClass(tex_NodeUtil.getCoreMO(top));
            if (tclass === TEXCLASS.BIN || tclass === TEXCLASS.REL) {
                dots = this.getProperty('cdots');
            }
        }
        return [[dots, item], true];
    }
}
class ArrayItem extends BaseItem {
    constructor() {
        super(...arguments);
        this.table = [];
        this.row = [];
        this.frame = [];
        this.hfill = [];
        this.arraydef = {};
        this.cstart = [];
        this.cend = [];
        this.cextra = [];
        this.atEnd = false;
        this.ralign = [];
        this.breakAlign = {
            cell: '',
            row: '',
            table: '',
        };
        this.templateSubs = 0;
    }
    get kind() {
        return 'array';
    }
    get isOpen() {
        return true;
    }
    get copyEnv() {
        return false;
    }
    checkItem(item) {
        if (item.isClose && !item.isKind('over')) {
            if (item.getProperty('isEntry')) {
                this.EndEntry();
                this.clearEnv();
                this.StartEntry();
                return BaseItem.fail;
            }
            if (item.getProperty('isCR')) {
                this.EndEntry();
                this.EndRow();
                this.clearEnv();
                this.StartEntry();
                return BaseItem.fail;
            }
            this.EndTable();
            this.clearEnv();
            const newItem = this.factory.create('mml', this.createMml());
            if (this.getProperty('requireClose')) {
                if (item.isKind('close')) {
                    return [[newItem], true];
                }
                throw new tex_TexError('MissingCloseBrace', 'Missing close brace');
            }
            return [[newItem, item], true];
        }
        return super.checkItem(item);
    }
    createMml() {
        const scriptlevel = this.arraydef['scriptlevel'];
        delete this.arraydef['scriptlevel'];
        let mml = this.create('node', 'mtable', this.table, this.arraydef);
        if (scriptlevel) {
            mml.setProperty('smallmatrix', true);
        }
        if (this.breakAlign.table) {
            tex_NodeUtil.setAttribute(mml, 'data-break-align', this.breakAlign.table);
        }
        if (this.getProperty('arrayPadding')) {
            tex_NodeUtil.setAttribute(mml, 'data-frame-styles', '');
            tex_NodeUtil.setAttribute(mml, 'framespacing', this.getProperty('arrayPadding'));
        }
        mml = this.handleFrame(mml);
        if (scriptlevel !== undefined) {
            mml = this.create('node', 'mstyle', [mml], { scriptlevel });
        }
        if (this.getProperty('open') || this.getProperty('close')) {
            mml = ParseUtil.fenced(this.factory.configuration, this.getProperty('open'), mml, this.getProperty('close'));
        }
        return mml;
    }
    handleFrame(mml) {
        if (!this.frame.length)
            return mml;
        const sides = new Map(this.frame);
        const fstyle = this.frame.reduce((fstyle, [, style]) => (style === fstyle ? style : ''), this.frame[0][1]);
        if (fstyle) {
            if (this.frame.length === 4) {
                tex_NodeUtil.setAttribute(mml, 'frame', fstyle);
                tex_NodeUtil.removeAttribute(mml, 'data-frame-styles');
                return mml;
            }
            if (fstyle === 'solid') {
                tex_NodeUtil.setAttribute(mml, 'data-frame-styles', '');
                mml = this.create('node', 'menclose', [mml], {
                    notation: Array.from(sides.keys()).join(' '),
                    'data-padding': 0,
                });
                return mml;
            }
        }
        const styles = TRBL.map((side) => sides.get(side) || 'none').join(' ');
        tex_NodeUtil.setAttribute(mml, 'data-frame-styles', styles);
        return mml;
    }
    StartEntry() {
        const n = this.row.length;
        let start = this.cstart[n];
        let end = this.cend[n];
        const ralign = this.ralign[n];
        const cextra = this.cextra;
        if (!start && !end && !ralign && !cextra[n] && !cextra[n + 1])
            return;
        let [prefix, entry, term, found] = this.getEntry();
        if (cextra[n] && (!this.atEnd || cextra[n + 1])) {
            start += '&';
        }
        if (term !== '&') {
            found =
                !!entry.trim() || !!(n || (term && term.substring(0, 4) !== '\\end'));
            if (cextra[n + 1] && !cextra[n]) {
                end = (end || '') + '&';
                this.atEnd = true;
            }
        }
        if (!found && !prefix)
            return;
        const parser = this.parser;
        if (found) {
            if (start) {
                entry = ParseUtil.addArgs(parser, start, entry);
            }
            if (end) {
                entry = ParseUtil.addArgs(parser, entry, end);
            }
            if (ralign) {
                entry = '\\text{' + entry.trim() + '}';
            }
            if (start || end || ralign) {
                if (++this.templateSubs >
                    parser.configuration.options.maxTemplateSubtitutions) {
                    throw new tex_TexError('MaxTemplateSubs', 'Maximum template substitutions exceeded; ' +
                        'is there an invalid use of \\\\ in the template?');
                }
            }
        }
        if (prefix) {
            entry = ParseUtil.addArgs(parser, prefix, entry);
        }
        parser.string = ParseUtil.addArgs(parser, entry, parser.string);
        parser.i = 0;
    }
    getEntry() {
        const parser = this.parser;
        const pattern = /^([^]*?)([&{}]|\\\\|\\(?:begin|end)\s*\{array\}|\\cr|\\)/;
        let braces = 0;
        let envs = 0;
        let i = parser.i;
        let match;
        const fail = ['', '', '', false];
        while ((match = parser.string.slice(i).match(pattern)) !== null) {
            i += match[0].length;
            switch (match[2]) {
                case '\\':
                    i++;
                    break;
                case '{':
                    braces++;
                    break;
                case '}':
                    if (!braces)
                        return fail;
                    braces--;
                    break;
                case '\\begin{array}':
                    if (!braces) {
                        envs++;
                    }
                    break;
                case '\\end{array}':
                    if (!braces && envs) {
                        envs--;
                        break;
                    }
                default: {
                    if (braces || envs)
                        continue;
                    i -= match[2].length;
                    let entry = parser.string.slice(parser.i, i).trim();
                    const prefix = entry.match(/^(?:\s*\\(?:h(?:dash)?line|hfil{1,3}|rowcolor\s*\{.*?\}))+/);
                    if (prefix) {
                        entry = entry.slice(prefix[0].length);
                    }
                    parser.string = parser.string.slice(i);
                    parser.i = 0;
                    return [(prefix === null || prefix === void 0 ? void 0 : prefix[0]) || '', entry, match[2], true];
                }
            }
        }
        return fail;
    }
    EndEntry() {
        const mtd = this.create('node', 'mtd', this.nodes);
        if (this.hfill.length) {
            if (this.hfill[0] === 0) {
                tex_NodeUtil.setAttribute(mtd, 'columnalign', 'right');
            }
            if (this.hfill[this.hfill.length - 1] === this.Size()) {
                tex_NodeUtil.setAttribute(mtd, 'columnalign', tex_NodeUtil.getAttribute(mtd, 'columnalign') ? 'center' : 'left');
            }
        }
        const ralign = this.ralign[this.row.length];
        if (ralign) {
            const [valign, cwidth, calign] = ralign;
            const box = this.create('node', 'mpadded', mtd.childNodes[0].childNodes, {
                width: cwidth,
                'data-overflow': 'auto',
                'data-align': calign,
                'data-vertical-align': valign,
            });
            box.setProperty('vbox', valign);
            mtd.childNodes[0].childNodes = [];
            mtd.appendChild(box);
        }
        else if (this.breakAlign.cell) {
            tex_NodeUtil.setAttribute(mtd, 'data-vertical-align', this.breakAlign.cell);
        }
        this.breakAlign.cell = '';
        this.row.push(mtd);
        this.Clear();
        this.hfill = [];
    }
    EndRow() {
        let type = 'mtr';
        if (this.getProperty('isNumbered') && this.row.length === 3) {
            this.row.unshift(this.row.pop());
            type = 'mlabeledtr';
        }
        else if (this.getProperty('isLabeled')) {
            type = 'mlabeledtr';
            this.setProperty('isLabeled', false);
        }
        const node = this.create('node', type, this.row);
        if (this.breakAlign.row) {
            tex_NodeUtil.setAttribute(node, 'data-break-align', this.breakAlign.row);
            this.breakAlign.row = '';
        }
        addLatexItem(node, this);
        this.table.push(node);
        this.row = [];
        this.atEnd = false;
    }
    EndTable() {
        if (this.Size() || this.row.length) {
            this.EndEntry();
            this.EndRow();
        }
        this.checkLines();
    }
    checkLines() {
        if (this.arraydef.rowlines) {
            const lines = this.arraydef.rowlines.split(/ /);
            if (lines.length === this.table.length) {
                this.frame.push(['bottom', lines.pop()]);
                if (lines.length) {
                    this.arraydef.rowlines = lines.join(' ');
                }
                else {
                    delete this.arraydef.rowlines;
                }
            }
            else if (lines.length < this.table.length - 1) {
                this.arraydef.rowlines += ' none';
            }
        }
        if (this.getProperty('rowspacing')) {
            const rows = this.arraydef.rowspacing.split(/ /);
            while (rows.length < this.table.length) {
                rows.push(this.getProperty('rowspacing') + 'em');
            }
            this.arraydef.rowspacing = rows.join(' ');
        }
    }
    addRowSpacing(spacing) {
        if (this.arraydef['rowspacing']) {
            const rows = this.arraydef['rowspacing'].split(/ /);
            if (!this.getProperty('rowspacing')) {
                const dimem = UnitUtil.dimen2em(rows[0]);
                this.setProperty('rowspacing', dimem);
            }
            const rowspacing = this.getProperty('rowspacing');
            while (rows.length < this.table.length) {
                rows.push(UnitUtil.em(rowspacing));
            }
            rows[this.table.length - 1] = UnitUtil.em(Math.max(0, rowspacing + UnitUtil.dimen2em(spacing)));
            this.arraydef['rowspacing'] = rows.join(' ');
        }
    }
}
class EqnArrayItem extends ArrayItem {
    constructor(factory, ...args) {
        super(factory);
        this.maxrow = 0;
        this.factory.configuration.tags.start(args[0], args[2], args[1]);
    }
    get kind() {
        return 'eqnarray';
    }
    EndEntry() {
        const calign = this.arraydef.columnalign.split(/ /);
        const align = this.row.length && calign.length
            ? calign[this.row.length % calign.length]
            : 'right';
        if (align !== 'right') {
            ParseUtil.fixInitialMO(this.factory.configuration, this.nodes);
        }
        super.EndEntry();
    }
    EndRow() {
        if (this.row.length > this.maxrow) {
            this.maxrow = this.row.length;
        }
        const tag = this.factory.configuration.tags.getTag();
        if (tag) {
            this.row = [tag].concat(this.row);
            this.setProperty('isLabeled', true);
        }
        this.factory.configuration.tags.clearTag();
        super.EndRow();
    }
    EndTable() {
        super.EndTable();
        this.factory.configuration.tags.end();
        this.extendArray('columnalign', this.maxrow);
        this.extendArray('columnwidth', this.maxrow);
        this.extendArray('columnspacing', this.maxrow - 1);
        this.extendArray('data-break-align', this.maxrow);
        this.addIndentshift();
    }
    extendArray(name, max) {
        if (!this.arraydef[name])
            return;
        const repeat = this.arraydef[name].split(/ /);
        const columns = [...repeat];
        if (columns.length > 1) {
            while (columns.length < max) {
                columns.push(...repeat);
            }
            this.arraydef[name] = columns.slice(0, max).join(' ');
        }
    }
    addIndentshift() {
        const align = this.arraydef.columnalign.split(/ /);
        let prev = '';
        for (const i of align.keys()) {
            if (align[i] === 'left' && i > 0) {
                const indentshift = prev === 'center' ? '.7em' : '2em';
                for (const row of this.table) {
                    const cell = row.childNodes[row.isKind('mlabeledtr') ? i + 1 : i];
                    if (cell) {
                        const mstyle = this.create('node', 'mstyle', cell.childNodes[0].childNodes, { indentshift });
                        cell.childNodes[0].childNodes = [];
                        cell.appendChild(mstyle);
                    }
                }
            }
            prev = align[i];
        }
    }
}
class MstyleItem extends BeginItem {
    get kind() {
        return 'mstyle';
    }
    constructor(factory, attr, name) {
        super(factory);
        this.attrList = attr;
        this.setProperty('name', name);
    }
    checkItem(item) {
        if (item.isKind('end') && item.getName() === this.getName()) {
            const mml = this.create('node', 'mstyle', [this.toMml()], this.attrList);
            return [[mml], true];
        }
        return super.checkItem(item);
    }
}
class EquationItem extends BaseItem {
    constructor(factory, ...args) {
        super(factory);
        this.factory.configuration.tags.start('equation', true, args[0]);
    }
    get kind() {
        return 'equation';
    }
    get isOpen() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('end')) {
            const mml = this.toMml();
            const tag = this.factory.configuration.tags.getTag();
            this.factory.configuration.tags.end();
            return [
                [tag ? this.factory.configuration.tags.enTag(mml, tag) : mml, item],
                true,
            ];
        }
        if (item.isKind('stop')) {
            throw new tex_TexError('EnvMissingEnd', 'Missing \\end{%1}', this.getName());
        }
        return super.checkItem(item);
    }
}
function addLatexItem(node, item, prefix = '') {
    const str = item.startStr.slice(item.startI, item.stopI);
    if (str) {
        node.attributes.set(TexConstant.Attr.LATEXITEM, prefix ? prefix + str : str);
        node.attributes.set(TexConstant.Attr.LATEX, prefix ? prefix + str : str);
    }
}
//# sourceMappingURL=BaseItems.js.map
;// ./mjs/input/tex/base/BaseMethods.js















const P_HEIGHT = 1.2 / 0.85;
const MmlTokenAllow = {
    fontfamily: 1,
    fontsize: 1,
    fontweight: 1,
    fontstyle: 1,
    color: 1,
    background: 1,
    id: 1,
    class: 1,
    href: 1,
    style: 1,
};
function splitAlignArray(align, n = Infinity) {
    const list = align
        .replace(/\s+/g, '')
        .split('')
        .map((s) => {
        const name = { t: 'top', b: 'bottom', m: 'middle', c: 'center' }[s];
        if (!name) {
            throw new tex_TexError('BadBreakAlign', 'Invalid alignment character: %1', s);
        }
        return name;
    });
    if (list.length > n) {
        throw new tex_TexError('TooManyAligns', 'Too many alignment characters: %1', align);
    }
    return n === 1 ? list[0] : list.join(' ');
}
function parseRoot(parser, n) {
    const env = parser.stack.env;
    const inRoot = env['inRoot'];
    env['inRoot'] = true;
    const newParser = new TexParser(n, env, parser.configuration);
    let node = newParser.mml();
    const global = newParser.stack.global;
    if (global['leftRoot'] || global['upRoot']) {
        const def = {};
        if (global['leftRoot']) {
            def['width'] = global['leftRoot'];
        }
        if (global['upRoot']) {
            def['voffset'] = global['upRoot'];
            def['height'] = global['upRoot'];
        }
        node = parser.create('node', 'mpadded', [node], def);
    }
    env['inRoot'] = inRoot;
    return node;
}
const BaseMethods = {
    Open(parser, _c) {
        parser.Push(parser.itemFactory.create('open'));
    },
    Close(parser, _c) {
        parser.Push(parser.itemFactory.create('close'));
    },
    Bar(parser, c) {
        parser.Push(parser.create('token', 'mo', { stretchy: false, texClass: TEXCLASS.ORD }, c));
    },
    Tilde(parser, _c) {
        parser.Push(parser.create('token', 'mtext', {}, entities.nbsp));
    },
    Space(_parser, _c) { },
    Superscript(parser, _c) {
        if (parser.GetNext().match(/\d/)) {
            parser.string =
                parser.string.substring(0, parser.i + 1) +
                    ' ' +
                    parser.string.substring(parser.i + 1);
        }
        let primes;
        let base;
        const top = parser.stack.Top();
        if (top.isKind('prime')) {
            [base, primes] = top.Peek(2);
            parser.stack.Pop();
        }
        else {
            base = parser.stack.Prev();
            if (!base) {
                base = parser.create('token', 'mi', {}, '');
            }
        }
        const movesupsub = tex_NodeUtil.getProperty(base, 'movesupsub');
        let position = tex_NodeUtil.isType(base, 'msubsup')
            ? base.sup
            : base.over;
        if ((tex_NodeUtil.isType(base, 'msubsup') &&
            !tex_NodeUtil.isType(base, 'msup') &&
            tex_NodeUtil.getChildAt(base, base.sup)) ||
            (tex_NodeUtil.isType(base, 'munderover') &&
                !tex_NodeUtil.isType(base, 'mover') &&
                tex_NodeUtil.getChildAt(base, base.over) &&
                !tex_NodeUtil.getProperty(base, 'subsupOK'))) {
            throw new tex_TexError('DoubleExponent', 'Double exponent: use braces to clarify');
        }
        if (!tex_NodeUtil.isType(base, 'msubsup') || tex_NodeUtil.isType(base, 'msup')) {
            if (movesupsub) {
                if (!tex_NodeUtil.isType(base, 'munderover') ||
                    tex_NodeUtil.isType(base, 'mover') ||
                    tex_NodeUtil.getChildAt(base, base.over)) {
                    base = parser.create('node', 'munderover', [base], {
                        movesupsub: true,
                    });
                }
                position = base.over;
            }
            else {
                base = parser.create('node', 'msubsup', [base]);
                position = base.sup;
            }
        }
        parser.Push(parser.itemFactory.create('subsup', base).setProperties({
            position: position,
            primes: primes,
            movesupsub: movesupsub,
        }));
    },
    Subscript(parser, _c) {
        if (parser.GetNext().match(/\d/)) {
            parser.string =
                parser.string.substring(0, parser.i + 1) +
                    ' ' +
                    parser.string.substring(parser.i + 1);
        }
        let primes, base;
        const top = parser.stack.Top();
        if (top.isKind('prime')) {
            [base, primes] = top.Peek(2);
            parser.stack.Pop();
        }
        else {
            base = parser.stack.Prev();
            if (!base) {
                base = parser.create('token', 'mi', {}, '');
            }
        }
        const movesupsub = tex_NodeUtil.getProperty(base, 'movesupsub');
        let position = tex_NodeUtil.isType(base, 'msubsup')
            ? base.sub
            : base.under;
        if ((tex_NodeUtil.isType(base, 'msubsup') &&
            !tex_NodeUtil.isType(base, 'msup') &&
            tex_NodeUtil.getChildAt(base, base.sub)) ||
            (tex_NodeUtil.isType(base, 'munderover') &&
                !tex_NodeUtil.isType(base, 'mover') &&
                tex_NodeUtil.getChildAt(base, base.under) &&
                !tex_NodeUtil.getProperty(base, 'subsupOK'))) {
            throw new tex_TexError('DoubleSubscripts', 'Double subscripts: use braces to clarify');
        }
        if (!tex_NodeUtil.isType(base, 'msubsup') || tex_NodeUtil.isType(base, 'msup')) {
            if (movesupsub) {
                if (!tex_NodeUtil.isType(base, 'munderover') ||
                    tex_NodeUtil.isType(base, 'mover') ||
                    tex_NodeUtil.getChildAt(base, base.under)) {
                    base = parser.create('node', 'munderover', [base], {
                        movesupsub: true,
                    });
                }
                position = base.under;
            }
            else {
                base = parser.create('node', 'msubsup', [base]);
                position = base.sub;
            }
        }
        parser.Push(parser.itemFactory.create('subsup', base).setProperties({
            position: position,
            primes: primes,
            movesupsub: movesupsub,
        }));
    },
    Prime(parser, c) {
        let base = parser.stack.Prev();
        if (!base) {
            base = parser.create('token', 'mi');
        }
        if ((tex_NodeUtil.isType(base, 'msubsup') &&
            !tex_NodeUtil.isType(base, 'msup') &&
            tex_NodeUtil.getChildAt(base, base.sup)) ||
            (tex_NodeUtil.isType(base, 'munderover') &&
                !tex_NodeUtil.isType(base, 'mover') &&
                tex_NodeUtil.getChildAt(base, base.over) &&
                !tex_NodeUtil.getProperty(base, 'subsupOK'))) {
            throw new tex_TexError('DoubleExponentPrime', 'Prime causes double exponent: use braces to clarify');
        }
        let sup = '';
        parser.i--;
        do {
            sup += entities.prime;
            parser.i++;
            c = parser.GetNext();
        } while (c === "'" || c === entities.rsquo);
        sup = ['', '\u2032', '\u2033', '\u2034', '\u2057'][sup.length] || sup;
        const node = parser.create('token', 'mo', { variantForm: true }, sup);
        parser.Push(parser.itemFactory.create('prime', base, node));
    },
    Comment(parser, _c) {
        while (parser.i < parser.string.length &&
            parser.string.charAt(parser.i) !== '\n') {
            parser.i++;
        }
    },
    Hash(_parser, _c) {
        throw new tex_TexError('CantUseHash1', "You can't use 'macro parameter character #' in math mode");
    },
    MathFont(parser, name, variant, italic = '') {
        const text = parser.GetArgument(name);
        const mml = new TexParser(text, Object.assign(Object.assign({ multiLetterIdentifiers: parser.options.identifierPattern }, parser.stack.env), { font: variant, italicFont: italic, noAutoOP: true }), parser.configuration).mml();
        parser.Push(parser.create('node', 'TeXAtom', [mml]));
    },
    SetFont(parser, _name, font) {
        parser.stack.env['font'] = font;
        parser.Push(parser.itemFactory.create('null'));
    },
    SetStyle(parser, _name, texStyle, style, level) {
        parser.stack.env['style'] = texStyle;
        parser.stack.env['level'] = level;
        parser.Push(parser.itemFactory
            .create('style')
            .setProperty('styles', { displaystyle: style, scriptlevel: level }));
    },
    SetSize(parser, _name, size) {
        parser.stack.env['size'] = size;
        parser.Push(parser.itemFactory
            .create('style')
            .setProperty('styles', { mathsize: em(size) }));
    },
    Spacer(parser, _name, space) {
        const node = parser.create('node', 'mspace', [], { width: em(space) });
        const style = parser.create('node', 'mstyle', [node], { scriptlevel: 0 });
        parser.Push(style);
    },
    DiscretionaryTimes(parser, _name) {
        parser.Push(parser.create('token', 'mo', { linebreakmultchar: '\u00D7' }, '\u2062'));
    },
    AllowBreak(parser, _name) {
        parser.Push(parser.create('token', 'mspace'));
    },
    Break(parser, _name) {
        parser.Push(parser.create('token', 'mspace', {
            linebreak: TexConstant.LineBreak.NEWLINE,
        }));
    },
    Linebreak(parser, _name, linebreak) {
        let insert = true;
        const prev = parser.stack.Prev(true);
        if (prev && prev.isKind('mo')) {
            const style = tex_NodeUtil.getMoAttribute(prev, 'linebreakstyle');
            if (style !== TexConstant.LineBreakStyle.BEFORE) {
                prev.attributes.set('linebreak', linebreak);
                insert = false;
            }
        }
        parser.Push(parser.itemFactory.create('break', linebreak, insert));
    },
    LeftRight(parser, name) {
        const first = name.substring(1);
        parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));
    },
    NamedFn(parser, name, id) {
        if (!id) {
            id = name.substring(1);
        }
        const mml = parser.create('token', 'mi', { texClass: TEXCLASS.OP }, id);
        parser.Push(parser.itemFactory.create('fn', mml));
    },
    NamedOp(parser, name, id) {
        if (!id) {
            id = name.substring(1);
        }
        id = id.replace(/&thinsp;/, '\u2006');
        const mml = parser.create('token', 'mo', {
            movablelimits: true,
            movesupsub: true,
            form: TexConstant.Form.PREFIX,
            texClass: TEXCLASS.OP,
        }, id);
        parser.Push(mml);
    },
    Limits(parser, _name, limits) {
        let op = parser.stack.Prev(true);
        if (!op ||
            (tex_NodeUtil.getTexClass(tex_NodeUtil.getCoreMO(op)) !== TEXCLASS.OP &&
                tex_NodeUtil.getProperty(op, 'movesupsub') == null)) {
            throw new tex_TexError('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);
        }
        const top = parser.stack.Top();
        let node;
        if (tex_NodeUtil.isType(op, 'munderover') && !limits) {
            node = parser.create('node', 'msubsup');
            tex_NodeUtil.copyChildren(op, node);
            op = top.Last = node;
        }
        else if (tex_NodeUtil.isType(op, 'msubsup') && limits) {
            node = parser.create('node', 'munderover');
            tex_NodeUtil.copyChildren(op, node);
            op = top.Last = node;
        }
        tex_NodeUtil.setProperty(op, 'movesupsub', limits ? true : false);
        tex_NodeUtil.setProperties(tex_NodeUtil.getCoreMO(op), { movablelimits: false });
        if ((tex_NodeUtil.isType(op, 'mo')
            ? tex_NodeUtil.getMoAttribute(op, 'movableLimits')
            : tex_NodeUtil.getAttribute(op, 'movablelimits')) ||
            tex_NodeUtil.getProperty(op, 'movablelimits')) {
            tex_NodeUtil.setProperties(op, { movablelimits: false });
        }
    },
    Over(parser, name, open, close) {
        const mml = parser.itemFactory
            .create('over')
            .setProperty('name', parser.currentCS);
        if (open || close) {
            mml.setProperty('ldelim', open);
            mml.setProperty('rdelim', close);
        }
        else if (name.match(/withdelims$/)) {
            mml.setProperty('ldelim', parser.GetDelimiter(name));
            mml.setProperty('rdelim', parser.GetDelimiter(name));
        }
        if (name.match(/^\\above/)) {
            mml.setProperty('thickness', parser.GetDimen(name));
        }
        else if (name.match(/^\\atop/) || open || close) {
            mml.setProperty('thickness', 0);
        }
        parser.Push(mml);
    },
    Frac(parser, name) {
        const num = parser.ParseArg(name);
        const den = parser.ParseArg(name);
        const node = parser.create('node', 'mfrac', [num, den]);
        parser.Push(node);
    },
    Sqrt(parser, name) {
        const n = parser.GetBrackets(name);
        let arg = parser.GetArgument(name);
        if (arg === '\\frac') {
            arg +=
                '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';
        }
        let mml = new TexParser(arg, parser.stack.env, parser.configuration).mml();
        if (!n) {
            mml = parser.create('node', 'msqrt', [mml]);
        }
        else {
            mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);
        }
        parser.Push(mml);
    },
    Root(parser, name) {
        const n = parser.GetUpTo(name, '\\of');
        const arg = parser.ParseArg(name);
        const node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);
        parser.Push(node);
    },
    MoveRoot(parser, name, id) {
        if (!parser.stack.env['inRoot']) {
            throw new tex_TexError('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);
        }
        if (parser.stack.global[id]) {
            throw new tex_TexError('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);
        }
        let n = parser.GetArgument(name);
        if (!n.match(/-?[0-9]+/)) {
            throw new tex_TexError('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);
        }
        n = parseInt(n, 10) / 15 + 'em';
        if (n.substring(0, 1) !== '-') {
            n = '+' + n;
        }
        parser.stack.global[id] = n;
    },
    Accent(parser, name, accent, stretchy) {
        const c = parser.ParseArg(name);
        const def = Object.assign(Object.assign({}, ParseUtil.getFontDef(parser)), { accent: true, mathaccent: stretchy === undefined ? true : stretchy });
        const entity = tex_NodeUtil.createEntity(accent);
        const mml = parser.create('token', 'mo', def, entity);
        tex_NodeUtil.setAttribute(mml, 'stretchy', stretchy ? true : false);
        const mo = tex_NodeUtil.isEmbellished(c) ? tex_NodeUtil.getCoreMO(c) : c;
        if (tex_NodeUtil.isType(mo, 'mo') ||
            tex_NodeUtil.getProperty(mo, 'movablelimits')) {
            tex_NodeUtil.setProperties(mo, { movablelimits: false });
        }
        const muoNode = parser.create('node', 'munderover');
        tex_NodeUtil.setChild(muoNode, 0, c);
        tex_NodeUtil.setChild(muoNode, 1, null);
        tex_NodeUtil.setChild(muoNode, 2, mml);
        const texAtom = parser.create('node', 'TeXAtom', [muoNode]);
        parser.Push(texAtom);
    },
    UnderOver(parser, name, c, stack) {
        const entity = tex_NodeUtil.createEntity(c);
        const mo = parser.create('token', 'mo', { stretchy: true, accent: true }, entity);
        if (entity.match(MmlMo.mathaccentsWithWidth)) {
            mo.setProperty('mathaccent', false);
        }
        const pos = name.charAt(1) === 'o' ? 'over' : 'under';
        const base = parser.ParseArg(name);
        parser.Push(ParseUtil.underOver(parser, base, mo, pos, stack));
    },
    Overset(parser, name) {
        const top = parser.ParseArg(name);
        const base = parser.ParseArg(name);
        const topMo = top.coreMO();
        const accent = topMo.isKind('mo') && tex_NodeUtil.getMoAttribute(topMo, 'accent') === true;
        ParseUtil.checkMovableLimits(base);
        const node = parser.create('node', 'mover', [base, top], { accent });
        parser.Push(node);
    },
    Underset(parser, name) {
        const bot = parser.ParseArg(name);
        const base = parser.ParseArg(name);
        const botMo = bot.coreMO();
        const accentunder = botMo.isKind('mo') && tex_NodeUtil.getMoAttribute(botMo, 'accent') === true;
        ParseUtil.checkMovableLimits(base);
        const node = parser.create('node', 'munder', [base, bot], { accentunder });
        parser.Push(node);
    },
    Overunderset(parser, name) {
        const top = parser.ParseArg(name);
        const bot = parser.ParseArg(name);
        const base = parser.ParseArg(name);
        const topMo = top.coreMO();
        const botMo = bot.coreMO();
        const accent = topMo.isKind('mo') && tex_NodeUtil.getMoAttribute(topMo, 'accent') === true;
        const accentunder = botMo.isKind('mo') && tex_NodeUtil.getMoAttribute(botMo, 'accent') === true;
        ParseUtil.checkMovableLimits(base);
        const node = parser.create('node', 'munderover', [base, bot, top], {
            accent,
            accentunder,
        });
        parser.Push(node);
    },
    TeXAtom(parser, name, mclass) {
        const def = { texClass: mclass };
        let mml;
        let node;
        if (mclass === TEXCLASS.OP) {
            def['movesupsub'] = def['movablelimits'] = true;
            const arg = parser.GetArgument(name);
            const match = arg.match(/^\s*\\rm\s+([a-zA-Z0-9 ]+)$/);
            if (match) {
                def['mathvariant'] = TexConstant.Variant.NORMAL;
                node = parser.create('token', 'mi', def, match[1]);
            }
            else {
                const parsed = new TexParser(arg, parser.stack.env, parser.configuration).mml();
                node = parser.create('node', 'TeXAtom', [parsed], def);
            }
            mml = parser.itemFactory.create('fn', node);
        }
        else {
            mml = parser.create('node', 'TeXAtom', [parser.ParseArg(name)], def);
        }
        parser.Push(mml);
    },
    VBox(parser, name, align) {
        const arg = new TexParser(parser.GetArgument(name), parser.stack.env, parser.configuration);
        const def = {
            'data-vertical-align': align,
            texClass: TEXCLASS.ORD,
        };
        if (arg.stack.env.hsize) {
            def.width = arg.stack.env.hsize;
            def['data-overflow'] = 'linebreak';
        }
        const mml = parser.create('node', 'mpadded', [arg.mml()], def);
        mml.setProperty('vbox', align);
        parser.Push(mml);
    },
    Hsize(parser, name) {
        if (parser.GetNext() === '=') {
            parser.i++;
        }
        parser.stack.env.hsize = parser.GetDimen(name);
        parser.Push(parser.itemFactory.create('null'));
    },
    ParBox(parser, name) {
        const c = parser.GetBrackets(name, 'c');
        const width = parser.GetDimen(name);
        const text = ParseUtil.internalMath(parser, parser.GetArgument(name));
        const align = splitAlignArray(c, 1);
        const mml = parser.create('node', 'mpadded', text, {
            width: width,
            'data-overflow': 'linebreak',
            'data-vertical-align': align,
        });
        mml.setProperty('vbox', align);
        parser.Push(mml);
    },
    BreakAlign(parser, name) {
        const top = parser.stack.Top();
        if (!(top instanceof ArrayItem)) {
            throw new tex_TexError('BreakNotInArray', '%1 must be used in an alignment environment', parser.currentCS);
        }
        const type = parser.GetArgument(name).trim();
        switch (type) {
            case 'c':
                if (top.First) {
                    throw new tex_TexError('BreakFirstInEntry', '%1 must be at the beginning of an alignment entry', parser.currentCS + '{c}');
                }
                top.breakAlign.cell = splitAlignArray(parser.GetArgument(name), 1);
                break;
            case 'r':
                if (top.row.length || top.First) {
                    throw new tex_TexError('BreakFirstInRow', '%1 must be at the beginning of an alignment row', parser.currentCS + '{r}');
                }
                top.breakAlign.row = splitAlignArray(parser.GetArgument(name));
                break;
            case 't':
                if (top.table.length || top.row.length || top.First) {
                    throw new tex_TexError('BreakFirstInTable', '%1 must be at the beginning of an alignment', parser.currentCS + '{t}');
                }
                top.breakAlign.table = splitAlignArray(parser.GetArgument(name));
                break;
            default:
                throw new tex_TexError('BreakType', 'First argument to %1 must be one of c, r, or t', parser.currentCS);
        }
    },
    MmlToken(parser, name) {
        const kind = parser.GetArgument(name);
        let attr = parser.GetBrackets(name, '').replace(/^\s+/, '');
        const text = parser.GetArgument(name);
        const def = {};
        const keep = [];
        let node;
        try {
            node = parser.create('node', kind);
        }
        catch (_e) {
            node = null;
        }
        if (!node || !node.isToken) {
            throw new tex_TexError('NotMathMLToken', '%1 is not a token element', kind);
        }
        while (attr !== '') {
            const match = attr.match(/^([a-z]+)\s*=\s*('[^']*'|"[^"]*"|[^ ,]*)\s*,?\s*/i);
            if (!match) {
                throw new tex_TexError('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);
            }
            if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {
                throw new tex_TexError('UnknownAttrForElement', '%1 is not a recognized attribute for %2', match[1], kind);
            }
            let value = ParseUtil.mmlFilterAttribute(parser, match[1], match[2].replace(/^(['"])(.*)\1$/, '$2'));
            if (value) {
                if (value.toLowerCase() === 'true') {
                    value = true;
                }
                else if (value.toLowerCase() === 'false') {
                    value = false;
                }
                def[match[1]] = value;
                keep.push(match[1]);
            }
            attr = attr.substring(match[0].length);
        }
        if (keep.length) {
            def['mjx-keep-attrs'] = keep.join(' ');
        }
        const textNode = parser.create('text', replaceUnicode(text));
        node.appendChild(textNode);
        tex_NodeUtil.setProperties(node, def);
        parser.Push(node);
    },
    Strut(parser, _name) {
        const row = parser.create('node', 'mrow');
        const padded = parser.create('node', 'mpadded', [row], {
            height: '8.6pt',
            depth: '3pt',
            width: 0,
        });
        parser.Push(padded);
    },
    Phantom(parser, name, v, h) {
        let box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);
        if (v || h) {
            box = parser.create('node', 'mpadded', [box]);
            if (h) {
                tex_NodeUtil.setAttribute(box, 'height', 0);
                tex_NodeUtil.setAttribute(box, 'depth', 0);
            }
            if (v) {
                tex_NodeUtil.setAttribute(box, 'width', 0);
            }
        }
        const atom = parser.create('node', 'TeXAtom', [box]);
        parser.Push(atom);
    },
    Smash(parser, name) {
        const bt = UnitUtil.trimSpaces(parser.GetBrackets(name, ''));
        const smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);
        switch (bt) {
            case 'b':
                tex_NodeUtil.setAttribute(smash, 'depth', 0);
                break;
            case 't':
                tex_NodeUtil.setAttribute(smash, 'height', 0);
                break;
            default:
                tex_NodeUtil.setAttribute(smash, 'height', 0);
                tex_NodeUtil.setAttribute(smash, 'depth', 0);
        }
        const atom = parser.create('node', 'TeXAtom', [smash]);
        parser.Push(atom);
    },
    Lap(parser, name) {
        const mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {
            width: 0,
        });
        if (name === '\\llap') {
            tex_NodeUtil.setAttribute(mml, 'lspace', '-1width');
        }
        const atom = parser.create('node', 'TeXAtom', [mml]);
        parser.Push(atom);
    },
    RaiseLower(parser, name) {
        let h = parser.GetDimen(name);
        const item = parser.itemFactory
            .create('position')
            .setProperties({ name: parser.currentCS, move: 'vertical' });
        if (h.charAt(0) === '-') {
            h = h.slice(1);
            name = name.substring(1) === 'raise' ? '\\lower' : '\\raise';
        }
        if (name === '\\lower') {
            item.setProperty('dh', '-' + h);
            item.setProperty('dd', '+' + h);
        }
        else {
            item.setProperty('dh', '+' + h);
            item.setProperty('dd', '-' + h);
        }
        parser.Push(item);
    },
    MoveLeftRight(parser, name) {
        let h = parser.GetDimen(name);
        let nh = h.charAt(0) === '-' ? h.slice(1) : '-' + h;
        if (name === '\\moveleft') {
            const tmp = h;
            h = nh;
            nh = tmp;
        }
        parser.Push(parser.itemFactory.create('position').setProperties({
            name: parser.currentCS,
            move: 'horizontal',
            left: parser.create('node', 'mspace', [], { width: h }),
            right: parser.create('node', 'mspace', [], { width: nh }),
        }));
    },
    Hskip(parser, name, nobreak = false) {
        const node = parser.create('node', 'mspace', [], {
            width: parser.GetDimen(name),
        });
        if (nobreak) {
            tex_NodeUtil.setAttribute(node, 'linebreak', 'nobreak');
        }
        parser.Push(node);
    },
    Nonscript(parser, _name) {
        parser.Push(parser.itemFactory.create('nonscript'));
    },
    Rule(parser, name, style) {
        const w = parser.GetDimen(name), h = parser.GetDimen(name), d = parser.GetDimen(name);
        const def = { width: w, height: h, depth: d };
        if (style !== 'blank') {
            def['mathbackground'] = parser.stack.env['color'] || 'black';
        }
        const node = parser.create('node', 'mspace', [], def);
        parser.Push(node);
    },
    rule(parser, name) {
        const v = parser.GetBrackets(name), w = parser.GetDimen(name), h = parser.GetDimen(name);
        let mml = parser.create('node', 'mspace', [], {
            width: w,
            height: h,
            mathbackground: parser.stack.env['color'] || 'black',
        });
        if (v) {
            mml = parser.create('node', 'mpadded', [mml], { voffset: v });
            if (v.match(/^-/)) {
                tex_NodeUtil.setAttribute(mml, 'height', v);
                tex_NodeUtil.setAttribute(mml, 'depth', '+' + v.substring(1));
            }
            else {
                tex_NodeUtil.setAttribute(mml, 'height', '+' + v);
            }
        }
        parser.Push(mml);
    },
    MakeBig(parser, name, mclass, size) {
        size *= P_HEIGHT;
        const sizeStr = String(size).replace(/(\.\d\d\d).+/, '$1') + 'em';
        const delim = parser.GetDelimiter(name, true);
        const mo = parser.create('token', 'mo', {
            minsize: sizeStr,
            maxsize: sizeStr,
            fence: true,
            stretchy: true,
            symmetric: true,
        }, delim);
        const node = parser.create('node', 'TeXAtom', [mo], { texClass: mclass });
        parser.Push(node);
    },
    BuildRel(parser, name) {
        const top = parser.ParseUpTo(name, '\\over');
        const bot = parser.ParseArg(name);
        const node = parser.create('node', 'munderover');
        tex_NodeUtil.setChild(node, 0, bot);
        tex_NodeUtil.setChild(node, 1, null);
        tex_NodeUtil.setChild(node, 2, top);
        const atom = parser.create('node', 'TeXAtom', [node], {
            texClass: TEXCLASS.REL,
        });
        parser.Push(atom);
    },
    HBox(parser, name, style, font) {
        parser.PushAll(ParseUtil.internalMath(parser, parser.GetArgument(name), style, font));
    },
    FBox(parser, name) {
        const internal = ParseUtil.internalMath(parser, parser.GetArgument(name));
        const node = parser.create('node', 'menclose', internal, {
            notation: 'box',
        });
        parser.Push(node);
    },
    FrameBox(parser, name) {
        const width = parser.GetBrackets(name);
        const pos = parser.GetBrackets(name) || 'c';
        let mml = ParseUtil.internalMath(parser, parser.GetArgument(name));
        if (width) {
            mml = [
                parser.create('node', 'mpadded', mml, {
                    width,
                    'data-align': lookup(pos, { l: 'left', r: 'right' }, 'center'),
                }),
            ];
        }
        const node = parser.create('node', 'TeXAtom', [parser.create('node', 'menclose', mml, { notation: 'box' })], { texClass: TEXCLASS.ORD });
        parser.Push(node);
    },
    MakeBox(parser, name) {
        const width = parser.GetBrackets(name);
        const pos = parser.GetBrackets(name, 'c');
        const mml = parser.create('node', 'mpadded', ParseUtil.internalMath(parser, parser.GetArgument(name)));
        if (width) {
            tex_NodeUtil.setAttribute(mml, 'width', width);
        }
        const align = lookup(pos.toLowerCase(), { c: 'center', r: 'right' }, '');
        if (align) {
            tex_NodeUtil.setAttribute(mml, 'data-align', align);
        }
        if (pos.toLowerCase() !== pos) {
            tex_NodeUtil.setAttribute(mml, 'data-overflow', 'linebreak');
        }
        parser.Push(mml);
    },
    Not(parser, _name) {
        parser.Push(parser.itemFactory.create('not'));
    },
    Dots(parser, _name) {
        const ldotsEntity = tex_NodeUtil.createEntity('2026');
        const cdotsEntity = tex_NodeUtil.createEntity('22EF');
        const ldots = parser.create('token', 'mo', { stretchy: false }, ldotsEntity);
        const cdots = parser.create('token', 'mo', { stretchy: false }, cdotsEntity);
        parser.Push(parser.itemFactory.create('dots').setProperties({
            ldots: ldots,
            cdots: cdots,
        }));
    },
    Matrix(parser, _name, open, close, align, spacing, vspacing, style, cases, numbered) {
        const c = parser.GetNext();
        if (c === '') {
            throw new tex_TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);
        }
        if (c === '{') {
            parser.i++;
        }
        else {
            parser.string = c + '}' + parser.string.slice(parser.i + 1);
            parser.i = 0;
        }
        const array = parser.itemFactory
            .create('array')
            .setProperty('requireClose', true);
        if (open || !align) {
            array.setProperty('arrayPadding', '.2em .125em');
        }
        array.arraydef = {
            rowspacing: vspacing || '4pt',
            columnspacing: spacing || '1em',
        };
        if (cases) {
            array.setProperty('isCases', true);
        }
        if (numbered) {
            array.setProperty('isNumbered', true);
            array.arraydef.side = numbered;
        }
        if (open || close) {
            array.setProperty('open', open);
            array.setProperty('close', close);
        }
        if (style === 'D') {
            array.arraydef.displaystyle = true;
        }
        if (align != null) {
            array.arraydef.columnalign = align;
        }
        parser.Push(array);
    },
    Entry(parser, name) {
        parser.Push(parser.itemFactory
            .create('cell')
            .setProperties({ isEntry: true, name: name }));
        const top = parser.stack.Top();
        const env = top.getProperty('casesEnv');
        const cases = top.getProperty('isCases');
        if (!cases && !env)
            return;
        const str = parser.string;
        let braces = 0;
        let close = -1;
        let i = parser.i;
        let m = str.length;
        const end = env
            ? new RegExp(`^\\\\end\\s*\\{${env.replace(/\*/, '\\*')}\\}`)
            : null;
        while (i < m) {
            const c = str.charAt(i);
            if (c === '{') {
                braces++;
                i++;
            }
            else if (c === '}') {
                if (braces === 0) {
                    m = 0;
                }
                else {
                    braces--;
                    if (braces === 0 && close < 0) {
                        close = i - parser.i;
                    }
                    i++;
                }
            }
            else if (c === '&' && braces === 0) {
                throw new tex_TexError('ExtraAlignTab', 'Extra alignment tab in \\cases text');
            }
            else if (c === '\\') {
                const rest = str.substring(i);
                if (rest.match(/^((\\cr)[^a-zA-Z]|\\\\)/) || (end && rest.match(end))) {
                    m = 0;
                }
                else {
                    i += 2;
                }
            }
            else {
                i++;
            }
        }
        const text = str.substring(parser.i, i);
        if (!text.match(/^\s*\\text[^a-zA-Z]/) ||
            close !== text.replace(/\s+$/, '').length - 1) {
            const internal = ParseUtil.internalMath(parser, UnitUtil.trimSpaces(text), 0);
            parser.PushAll(internal);
            parser.i = i;
        }
    },
    Cr(parser, name) {
        parser.Push(parser.itemFactory
            .create('cell')
            .setProperties({ isCR: true, name: name }));
    },
    CrLaTeX(parser, name, nobrackets = false) {
        let n;
        if (!nobrackets) {
            if (parser.string.charAt(parser.i) === '*') {
                parser.i++;
            }
            if (parser.string.charAt(parser.i) === '[') {
                const dim = parser.GetBrackets(name, '');
                const [value, unit] = UnitUtil.matchDimen(dim);
                if (dim && !value) {
                    throw new tex_TexError('BracketMustBeDimension', 'Bracket argument to %1 must be a dimension', parser.currentCS);
                }
                n = value + unit;
            }
        }
        parser.Push(parser.itemFactory
            .create('cell')
            .setProperties({ isCR: true, name: name, linebreak: true }));
        const top = parser.stack.Top();
        let node;
        if (top instanceof ArrayItem) {
            if (n) {
                top.addRowSpacing(n);
            }
        }
        else {
            node = parser.create('node', 'mspace', [], {
                linebreak: TexConstant.LineBreak.NEWLINE,
            });
            if (n) {
                tex_NodeUtil.setAttribute(node, 'data-lineleading', n);
            }
            parser.Push(node);
        }
    },
    HLine(parser, _name, style) {
        if (style == null) {
            style = 'solid';
        }
        const top = parser.stack.Top();
        if (!(top instanceof ArrayItem) || top.Size()) {
            throw new tex_TexError('Misplaced', 'Misplaced %1', parser.currentCS);
        }
        if (!top.table.length) {
            top.frame.push(['top', style]);
        }
        else {
            const lines = top.arraydef['rowlines']
                ? top.arraydef['rowlines'].split(/ /)
                : [];
            while (lines.length < top.table.length) {
                lines.push('none');
            }
            lines[top.table.length - 1] = style;
            top.arraydef['rowlines'] = lines.join(' ');
        }
    },
    HFill(parser, _name) {
        const top = parser.stack.Top();
        if (top instanceof ArrayItem) {
            top.hfill.push(top.Size());
        }
        else {
            throw new tex_TexError('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);
        }
    },
    NewColumnType(parser, name) {
        const c = parser.GetArgument(name);
        const n = parser.GetBrackets(name, '0');
        const macro = parser.GetArgument(name);
        if (c.length !== 1) {
            throw new tex_TexError('BadColumnName', 'Column specifier must be exactly one character: %1', c);
        }
        if (!n.match(/^\d+$/)) {
            throw new tex_TexError('PositiveIntegerArg', 'Argument to %1 must be a positive integer', n);
        }
        const cparser = parser.configuration.columnParser;
        cparser.columnHandler[c] = (state) => cparser.macroColumn(state, macro, parseInt(n));
        parser.Push(parser.itemFactory.create('null'));
    },
    BeginEnd(parser, name) {
        const env = parser.GetArgument(name);
        if (env.match(/\\/)) {
            throw new tex_TexError('InvalidEnv', "Invalid environment name '%1'", env);
        }
        const macro = parser.configuration.handlers
            .get(HandlerType.ENVIRONMENT)
            .lookup(env);
        if (macro && name === '\\end') {
            if (!macro.args[0]) {
                const mml = parser.itemFactory.create('end').setProperty('name', env);
                parser.Push(mml);
                return;
            }
            parser.stack.env['closing'] = env;
        }
        ParseUtil.checkMaxMacros(parser, false);
        parser.parse(HandlerType.ENVIRONMENT, [parser, env]);
    },
    Array(parser, begin, open, close, align, spacing, vspacing, style, raggedHeight) {
        if (!align) {
            align = parser.GetArgument('\\begin{' + begin.getName() + '}');
        }
        const array = parser.itemFactory.create('array');
        if (begin.getName() === 'array') {
            array.setProperty('arrayPadding', '.5em .125em');
        }
        array.parser = parser;
        array.arraydef = {
            columnspacing: spacing || '1em',
            rowspacing: vspacing || '4pt',
        };
        parser.configuration.columnParser.process(parser, align, array);
        if (open) {
            array.setProperty('open', parser.convertDelimiter(open));
        }
        if (close) {
            array.setProperty('close', parser.convertDelimiter(close));
        }
        if ((style || '').charAt(1) === "'") {
            array.arraydef['data-cramped'] = true;
            style = style.charAt(0);
        }
        if (style === 'D') {
            array.arraydef['displaystyle'] = true;
        }
        else if (style) {
            array.arraydef['displaystyle'] = false;
        }
        array.arraydef['scriptlevel'] = style === 'S' ? 1 : 0;
        if (raggedHeight) {
            array.arraydef['useHeight'] = false;
        }
        parser.Push(begin);
        array.StartEntry();
        return array;
    },
    AlignedArray(parser, begin, style = '') {
        const align = parser.GetBrackets('\\begin{' + begin.getName() + '}');
        const item = BaseMethods.Array(parser, begin, null, null, null, null, null, style);
        return ParseUtil.setArrayAlign(item, align);
    },
    IndentAlign(parser, begin) {
        const name = `\\begin{${begin.getName()}}`;
        const first = parser.GetBrackets(name, '');
        const shift = parser.GetBrackets(name, '');
        const last = parser.GetBrackets(name, '');
        if ((first && !UnitUtil.matchDimen(first)[0]) ||
            (shift && !UnitUtil.matchDimen(shift)[0]) ||
            (last && !UnitUtil.matchDimen(last)[0])) {
            throw new tex_TexError('BracketMustBeDimension', 'Bracket argument to %1 must be a dimension', name);
        }
        const lcr = parser.GetArgument(name);
        if (lcr && !lcr.match(/^([lcr]{1,3})?$/)) {
            throw new tex_TexError('BadAlignment', 'Alignment must be one to three copies of l, c, or r');
        }
        const align = [...lcr].map((c) => ({ l: 'left', c: 'center', r: 'right' })[c]);
        if (align.length === 1) {
            align.push(align[0]);
        }
        const attr = {};
        for (const [name, value] of [
            ['indentshiftfirst', first],
            ['indentshift', shift || first],
            ['indentshiftlast', last],
            ['indentalignfirst', align[0]],
            ['indentalign', align[1]],
            ['indentalignlast', align[2]],
        ]) {
            if (value) {
                attr[name] = value;
            }
        }
        parser.Push(parser.itemFactory.create('mstyle', attr, begin.getName()));
    },
    Equation(parser, begin, numbered, display = true) {
        parser.configuration.mathItem.display = display;
        parser.stack.env.display = display;
        ParseUtil.checkEqnEnv(parser);
        parser.Push(begin);
        return parser.itemFactory
            .create('equation', numbered)
            .setProperty('name', begin.getName());
    },
    EqnArray(parser, begin, numbered, taggable, align, balign, spacing) {
        const name = begin.getName();
        const isGather = name === 'gather' || name === 'gather*';
        if (taggable) {
            ParseUtil.checkEqnEnv(parser, !isGather);
        }
        parser.Push(begin);
        align = align
            .replace(/[^clr]/g, '')
            .split('')
            .join(' ');
        align = align
            .replace(/l/g, 'left')
            .replace(/r/g, 'right')
            .replace(/c/g, 'center');
        balign = splitAlignArray(balign);
        const newItem = parser.itemFactory.create('eqnarray', name, numbered, taggable, parser.stack.global);
        newItem.arraydef = {
            displaystyle: true,
            columnalign: align,
            columnspacing: spacing || '1em',
            rowspacing: '3pt',
            'data-break-align': balign,
            side: parser.options['tagSide'],
            minlabelspacing: parser.options['tagIndent'],
        };
        if (isGather) {
            newItem.setProperty('nestable', true);
        }
        return newItem;
    },
    HandleNoTag(parser, _name) {
        parser.tags.notag();
    },
    HandleLabel(parser, name) {
        const label = parser.GetArgument(name);
        if (label === '') {
            return;
        }
        if (!parser.tags.refUpdate) {
            if (parser.tags.label) {
                throw new tex_TexError('MultipleCommand', 'Multiple %1', parser.currentCS);
            }
            parser.tags.label = label;
            if ((parser.tags.allLabels[label] || parser.tags.labels[label]) &&
                !parser.options['ignoreDuplicateLabels']) {
                throw new tex_TexError('MultipleLabel', "Label '%1' multiply defined", label);
            }
            parser.tags.labels[label] = new Label();
        }
    },
    HandleRef(parser, name, eqref) {
        const label = parser.GetArgument(name);
        let ref = parser.tags.allLabels[label] || parser.tags.labels[label];
        if (!ref) {
            if (!parser.tags.refUpdate) {
                parser.tags.redo = true;
            }
            ref = new Label();
        }
        let tag = ref.tag;
        if (eqref) {
            tag = parser.tags.formatRef(tag);
        }
        const node = parser.create('node', 'mrow', ParseUtil.internalMath(parser, tag), {
            href: parser.tags.formatUrl(ref.id, parser.options.baseURL),
            class: 'MathJax_ref',
        });
        parser.Push(node);
    },
    Macro(parser, name, macro, argcount, def) {
        if (argcount) {
            const args = [];
            if (def != null) {
                const optional = parser.GetBrackets(name);
                args.push(optional == null ? def : optional);
            }
            for (let i = args.length; i < argcount; i++) {
                args.push(parser.GetArgument(name));
            }
            macro = ParseUtil.substituteArgs(parser, args, macro);
        }
        parser.string = ParseUtil.addArgs(parser, macro, parser.string.slice(parser.i));
        parser.i = 0;
        ParseUtil.checkMaxMacros(parser);
    },
    MathChoice(parser, name) {
        const D = parser.ParseArg(name);
        const T = parser.ParseArg(name);
        const S = parser.ParseArg(name);
        const SS = parser.ParseArg(name);
        parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));
    },
};
/* harmony default export */ const base_BaseMethods = (BaseMethods);
//# sourceMappingURL=BaseMethods.js.map
;// ./mjs/input/tex/ParseMethods.js




const ParseMethods_MATHVARIANT = TexConstant.Variant;
const ParseMethods = {
    variable(parser, c) {
        var _a;
        const def = ParseUtil.getFontDef(parser);
        const env = parser.stack.env;
        if (env.multiLetterIdentifiers && env.font !== '') {
            c =
                ((_a = parser.string
                    .substring(parser.i - 1)
                    .match(env.multiLetterIdentifiers)) === null || _a === void 0 ? void 0 : _a[0]) || c;
            parser.i += c.length - 1;
            if (def.mathvariant === ParseMethods_MATHVARIANT.NORMAL &&
                env.noAutoOP &&
                c.length > 1) {
                def.autoOP = false;
            }
        }
        if (!def.mathvariant && ParseUtil.isLatinOrGreekChar(c)) {
            const variant = parser.configuration.mathStyle(c);
            if (variant) {
                def.mathvariant = variant;
            }
        }
        const node = parser.create('token', 'mi', def, c);
        parser.Push(node);
    },
    digit(parser, _c) {
        const pattern = parser.configuration.options['numberPattern'];
        const n = parser.string.slice(parser.i - 1).match(pattern);
        const def = ParseUtil.getFontDef(parser);
        if (!n) {
            return false;
        }
        const mml = parser.create('token', 'mn', def, n[0].replace(/[{}]/g, ''));
        parser.i += n[0].length - 1;
        parser.Push(mml);
        return true;
    },
    controlSequence(parser, _c) {
        const name = parser.GetCS();
        parser.parse(HandlerType.MACRO, [parser, name]);
    },
    lcGreek(parser, mchar) {
        const def = {
            mathvariant: parser.configuration.mathStyle(mchar.char) || ParseMethods_MATHVARIANT.ITALIC,
        };
        const node = parser.create('token', 'mi', def, mchar.char);
        parser.Push(node);
    },
    ucGreek(parser, mchar) {
        const def = {
            mathvariant: parser.stack.env['font'] ||
                parser.configuration.mathStyle(mchar.char, true) ||
                ParseMethods_MATHVARIANT.NORMAL,
        };
        const node = parser.create('token', 'mi', def, mchar.char);
        parser.Push(node);
    },
    mathchar0mi(parser, mchar) {
        const def = mchar.attributes || { mathvariant: ParseMethods_MATHVARIANT.ITALIC };
        const node = parser.create('token', 'mi', def, mchar.char);
        parser.Push(node);
    },
    mathchar0mo(parser, mchar) {
        const def = mchar.attributes || {};
        def['stretchy'] = false;
        const node = parser.create('token', 'mo', def, mchar.char);
        tex_NodeUtil.setProperty(node, 'fixStretchy', true);
        parser.configuration.addNode('fixStretchy', node);
        parser.Push(node);
    },
    mathchar7(parser, mchar) {
        const def = mchar.attributes || { mathvariant: ParseMethods_MATHVARIANT.NORMAL };
        if (parser.stack.env['font']) {
            def['mathvariant'] = parser.stack.env['font'];
        }
        const node = parser.create('token', 'mi', def, mchar.char);
        parser.Push(node);
    },
    delimiter(parser, delim) {
        let def = delim.attributes || {};
        def = Object.assign({ fence: false, stretchy: false }, def);
        const node = parser.create('token', 'mo', def, delim.char);
        parser.Push(node);
    },
    environment(parser, env, func, args) {
        const mml = parser.itemFactory.create('begin').setProperty('name', env);
        parser.Push(func(parser, mml, ...args.slice(1)));
    },
};
/* harmony default export */ const tex_ParseMethods = (ParseMethods);
//# sourceMappingURL=ParseMethods.js.map
;// ./mjs/input/tex/base/BaseMappings.js







const THICKMATHSPACE = em(MATHSPACE.thickmathspace);
const VARIANT = TexConstant.Variant;
new RegExpMap('letter', tex_ParseMethods.variable, /[a-z]/i);
new RegExpMap('digit', tex_ParseMethods.digit, /[0-9.,]/);
new RegExpMap('command', tex_ParseMethods.controlSequence, /^\\/);
new MacroMap('special', {
    '{': base_BaseMethods.Open,
    '}': base_BaseMethods.Close,
    '~': base_BaseMethods.Tilde,
    '^': base_BaseMethods.Superscript,
    _: base_BaseMethods.Subscript,
    '|': base_BaseMethods.Bar,
    ' ': base_BaseMethods.Space,
    '\t': base_BaseMethods.Space,
    '\r': base_BaseMethods.Space,
    '\n': base_BaseMethods.Space,
    "'": base_BaseMethods.Prime,
    '%': base_BaseMethods.Comment,
    '&': base_BaseMethods.Entry,
    '#': base_BaseMethods.Hash,
    '\u00A0': base_BaseMethods.Space,
    '\u2019': base_BaseMethods.Prime,
});
new CharacterMap('lcGreek', tex_ParseMethods.lcGreek, {
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03F5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03D5',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    varepsilon: '\u03B5',
    vartheta: '\u03D1',
    varpi: '\u03D6',
    varrho: '\u03F1',
    varsigma: '\u03C2',
    varphi: '\u03C6',
});
new CharacterMap('ucGreek', tex_ParseMethods.ucGreek, {
    Gamma: '\u0393',
    Delta: '\u0394',
    Theta: '\u0398',
    Lambda: '\u039B',
    Xi: '\u039E',
    Pi: '\u03A0',
    Sigma: '\u03A3',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Psi: '\u03A8',
    Omega: '\u03A9',
});
new CharacterMap('mathchar0mi', tex_ParseMethods.mathchar0mi, {
    AA: '\u212B',
    S: ['\u00A7', { mathvariant: VARIANT.NORMAL }],
    aleph: ['\u2135', { mathvariant: VARIANT.NORMAL }],
    hbar: ['\u210F', { variantForm: true }],
    imath: '\u0131',
    jmath: '\u0237',
    ell: '\u2113',
    wp: ['\u2118', { mathvariant: VARIANT.NORMAL }],
    Re: ['\u211C', { mathvariant: VARIANT.NORMAL }],
    Im: ['\u2111', { mathvariant: VARIANT.NORMAL }],
    partial: ['\u2202', { mathvariant: VARIANT.ITALIC }],
    infty: ['\u221E', { mathvariant: VARIANT.NORMAL }],
    prime: ['\u2032', { variantForm: true }],
    emptyset: ['\u2205', { mathvariant: VARIANT.NORMAL }],
    nabla: ['\u2207', { mathvariant: VARIANT.NORMAL }],
    top: ['\u22A4', { mathvariant: VARIANT.NORMAL }],
    bot: ['\u22A5', { mathvariant: VARIANT.NORMAL }],
    angle: ['\u2220', { mathvariant: VARIANT.NORMAL }],
    triangle: ['\u25B3', { mathvariant: VARIANT.NORMAL }],
    backslash: ['\\', { mathvariant: VARIANT.NORMAL }],
    forall: ['\u2200', { mathvariant: VARIANT.NORMAL }],
    exists: ['\u2203', { mathvariant: VARIANT.NORMAL }],
    neg: ['\u00AC', { mathvariant: VARIANT.NORMAL }],
    lnot: ['\u00AC', { mathvariant: VARIANT.NORMAL }],
    flat: ['\u266D', { mathvariant: VARIANT.NORMAL }],
    natural: ['\u266E', { mathvariant: VARIANT.NORMAL }],
    sharp: ['\u266F', { mathvariant: VARIANT.NORMAL }],
    clubsuit: ['\u2663', { mathvariant: VARIANT.NORMAL }],
    diamondsuit: ['\u2662', { mathvariant: VARIANT.NORMAL }],
    heartsuit: ['\u2661', { mathvariant: VARIANT.NORMAL }],
    spadesuit: ['\u2660', { mathvariant: VARIANT.NORMAL }],
});
new CharacterMap('mathchar0mo', tex_ParseMethods.mathchar0mo, {
    surd: '\u221A',
    coprod: ['\u2210', { movesupsub: true }],
    bigvee: ['\u22C1', { movesupsub: true }],
    bigwedge: ['\u22C0', { movesupsub: true }],
    biguplus: ['\u2A04', { movesupsub: true }],
    bigcap: ['\u22C2', { movesupsub: true }],
    bigcup: ['\u22C3', { movesupsub: true }],
    int: '\u222B',
    intop: ['\u222B', { movesupsub: true, movablelimits: true }],
    iint: '\u222C',
    iiint: '\u222D',
    prod: ['\u220F', { movesupsub: true }],
    sum: ['\u2211', { movesupsub: true }],
    bigotimes: ['\u2A02', { movesupsub: true }],
    bigoplus: ['\u2A01', { movesupsub: true }],
    bigodot: ['\u2A00', { movesupsub: true }],
    oint: '\u222E',
    ointop: ['\u222E', { movesupsub: true, movablelimits: true }],
    oiint: '\u222F',
    oiiint: '\u2230',
    bigsqcup: ['\u2A06', { movesupsub: true }],
    smallint: ['\u222B', { largeop: false }],
    triangleleft: '\u25C3',
    triangleright: '\u25B9',
    bigtriangleup: '\u25B3',
    bigtriangledown: '\u25BD',
    wedge: '\u2227',
    land: '\u2227',
    vee: '\u2228',
    lor: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    ddagger: '\u2021',
    dagger: '\u2020',
    sqcap: '\u2293',
    sqcup: '\u2294',
    uplus: '\u228E',
    amalg: '\u2A3F',
    diamond: '\u22C4',
    bullet: '\u2219',
    wr: '\u2240',
    div: '\u00F7',
    odot: ['\u2299', { largeop: false }],
    oslash: ['\u2298', { largeop: false }],
    otimes: ['\u2297', { largeop: false }],
    ominus: ['\u2296', { largeop: false }],
    oplus: ['\u2295', { largeop: false }],
    mp: '\u2213',
    pm: '\u00B1',
    circ: '\u2218',
    bigcirc: '\u25EF',
    setminus: '\u2216',
    cdot: '\u22C5',
    ast: '\u2217',
    times: '\u00D7',
    star: '\u22C6',
    propto: '\u221D',
    sqsubseteq: '\u2291',
    sqsupseteq: '\u2292',
    parallel: '\u2225',
    mid: '\u2223',
    dashv: '\u22A3',
    vdash: '\u22A2',
    leq: '\u2264',
    le: '\u2264',
    geq: '\u2265',
    ge: '\u2265',
    lt: '\u003C',
    gt: '\u003E',
    succ: '\u227B',
    prec: '\u227A',
    approx: '\u2248',
    succeq: '\u2AB0',
    preceq: '\u2AAF',
    supset: '\u2283',
    subset: '\u2282',
    supseteq: '\u2287',
    subseteq: '\u2286',
    in: '\u2208',
    ni: '\u220B',
    notin: '\u2209',
    owns: '\u220B',
    gg: '\u226B',
    ll: '\u226A',
    sim: '\u223C',
    simeq: '\u2243',
    perp: '\u27C2',
    equiv: '\u2261',
    asymp: '\u224D',
    smile: '\u2323',
    frown: '\u2322',
    ne: '\u2260',
    neq: '\u2260',
    cong: '\u2245',
    doteq: '\u2250',
    bowtie: '\u22C8',
    models: '\u22A7',
    notChar: '\u29F8',
    Leftrightarrow: '\u21D4',
    Leftarrow: '\u21D0',
    Rightarrow: '\u21D2',
    leftrightarrow: '\u2194',
    leftarrow: '\u2190',
    gets: '\u2190',
    rightarrow: '\u2192',
    to: ['\u2192', { accent: false }],
    mapsto: '\u21A6',
    leftharpoonup: '\u21BC',
    leftharpoondown: '\u21BD',
    rightharpoonup: '\u21C0',
    rightharpoondown: '\u21C1',
    nearrow: '\u2197',
    searrow: '\u2198',
    nwarrow: '\u2196',
    swarrow: '\u2199',
    rightleftharpoons: '\u21CC',
    hookrightarrow: '\u21AA',
    hookleftarrow: '\u21A9',
    longleftarrow: '\u27F5',
    Longleftarrow: '\u27F8',
    longrightarrow: '\u27F6',
    Longrightarrow: '\u27F9',
    Longleftrightarrow: '\u27FA',
    longleftrightarrow: '\u27F7',
    longmapsto: '\u27FC',
    ldots: '\u2026',
    cdots: '\u22EF',
    vdots: '\u22EE',
    ddots: '\u22F1',
    iddots: '\u22F0',
    dotsc: '\u2026',
    dotsb: '\u22EF',
    dotsm: '\u22EF',
    dotsi: '\u22EF',
    dotso: '\u2026',
    ldotp: ['\u002E', { texClass: TEXCLASS.PUNCT }],
    cdotp: ['\u22C5', { texClass: TEXCLASS.PUNCT }],
    colon: ['\u003A', { texClass: TEXCLASS.PUNCT }],
});
new CharacterMap('mathchar7', tex_ParseMethods.mathchar7, {
    _: '\u005F',
    '#': '\u0023',
    $: '\u0024',
    '%': '\u0025',
    '&': '\u0026',
    And: '\u0026',
});
new DelimiterMap('delimiter', tex_ParseMethods.delimiter, {
    '(': '(',
    ')': ')',
    '[': '[',
    ']': ']',
    '<': '\u27E8',
    '>': '\u27E9',
    '\\lt': '\u27E8',
    '\\gt': '\u27E9',
    '/': '/',
    '|': ['|', { texClass: TEXCLASS.ORD }],
    '.': '',
    '\\lmoustache': '\u23B0',
    '\\rmoustache': '\u23B1',
    '\\lgroup': '\u27EE',
    '\\rgroup': '\u27EF',
    '\\arrowvert': '\u23D0',
    '\\Arrowvert': '\u2016',
    '\\bracevert': '\u23AA',
    '\\Vert': ['\u2016', { texClass: TEXCLASS.ORD }],
    '\\|': ['\u2016', { texClass: TEXCLASS.ORD }],
    '\\vert': ['|', { texClass: TEXCLASS.ORD }],
    '\\uparrow': '\u2191',
    '\\downarrow': '\u2193',
    '\\updownarrow': '\u2195',
    '\\Uparrow': '\u21D1',
    '\\Downarrow': '\u21D3',
    '\\Updownarrow': '\u21D5',
    '\\backslash': '\\',
    '\\rangle': '\u27E9',
    '\\langle': '\u27E8',
    '\\rbrace': '}',
    '\\lbrace': '{',
    '\\}': '}',
    '\\{': '{',
    '\\rceil': '\u2309',
    '\\lceil': '\u2308',
    '\\rfloor': '\u230B',
    '\\lfloor': '\u230A',
    '\\lbrack': '[',
    '\\rbrack': ']',
});
new CommandMap('macros', {
    displaystyle: [base_BaseMethods.SetStyle, 'D', true, 0],
    textstyle: [base_BaseMethods.SetStyle, 'T', false, 0],
    scriptstyle: [base_BaseMethods.SetStyle, 'S', false, 1],
    scriptscriptstyle: [base_BaseMethods.SetStyle, 'SS', false, 2],
    rm: [base_BaseMethods.SetFont, VARIANT.NORMAL],
    mit: [base_BaseMethods.SetFont, VARIANT.ITALIC],
    oldstyle: [base_BaseMethods.SetFont, VARIANT.OLDSTYLE],
    cal: [base_BaseMethods.SetFont, VARIANT.CALLIGRAPHIC],
    it: [base_BaseMethods.SetFont, VARIANT.MATHITALIC],
    bf: [base_BaseMethods.SetFont, VARIANT.BOLD],
    sf: [base_BaseMethods.SetFont, VARIANT.SANSSERIF],
    tt: [base_BaseMethods.SetFont, VARIANT.MONOSPACE],
    frak: [base_BaseMethods.MathFont, VARIANT.FRAKTUR],
    Bbb: [base_BaseMethods.MathFont, VARIANT.DOUBLESTRUCK],
    mathrm: [base_BaseMethods.MathFont, VARIANT.NORMAL],
    mathup: [base_BaseMethods.MathFont, VARIANT.NORMAL],
    mathnormal: [base_BaseMethods.MathFont, ''],
    mathbf: [base_BaseMethods.MathFont, VARIANT.BOLD],
    mathbfup: [base_BaseMethods.MathFont, VARIANT.BOLD],
    mathit: [base_BaseMethods.MathFont, VARIANT.MATHITALIC],
    mathbfit: [base_BaseMethods.MathFont, VARIANT.BOLDITALIC],
    mathbb: [base_BaseMethods.MathFont, VARIANT.DOUBLESTRUCK],
    mathfrak: [base_BaseMethods.MathFont, VARIANT.FRAKTUR],
    mathbffrak: [base_BaseMethods.MathFont, VARIANT.BOLDFRAKTUR],
    mathscr: [base_BaseMethods.MathFont, VARIANT.SCRIPT],
    mathbfscr: [base_BaseMethods.MathFont, VARIANT.BOLDSCRIPT],
    mathsf: [base_BaseMethods.MathFont, VARIANT.SANSSERIF],
    mathsfup: [base_BaseMethods.MathFont, VARIANT.SANSSERIF],
    mathbfsf: [base_BaseMethods.MathFont, VARIANT.BOLDSANSSERIF],
    mathbfsfup: [base_BaseMethods.MathFont, VARIANT.BOLDSANSSERIF],
    mathsfit: [base_BaseMethods.MathFont, VARIANT.SANSSERIFITALIC],
    mathbfsfit: [base_BaseMethods.MathFont, VARIANT.SANSSERIFBOLDITALIC],
    mathtt: [base_BaseMethods.MathFont, VARIANT.MONOSPACE],
    mathcal: [base_BaseMethods.MathFont, VARIANT.CALLIGRAPHIC],
    mathbfcal: [base_BaseMethods.MathFont, VARIANT.BOLDCALLIGRAPHIC],
    symrm: [base_BaseMethods.MathFont, VARIANT.NORMAL],
    symup: [base_BaseMethods.MathFont, VARIANT.NORMAL],
    symnormal: [base_BaseMethods.MathFont, ''],
    symbf: [base_BaseMethods.MathFont, VARIANT.BOLD, VARIANT.BOLDITALIC],
    symbfup: [base_BaseMethods.MathFont, VARIANT.BOLD],
    symit: [base_BaseMethods.MathFont, VARIANT.ITALIC],
    symbfit: [base_BaseMethods.MathFont, VARIANT.BOLDITALIC],
    symbb: [base_BaseMethods.MathFont, VARIANT.DOUBLESTRUCK],
    symfrak: [base_BaseMethods.MathFont, VARIANT.FRAKTUR],
    symbffrak: [base_BaseMethods.MathFont, VARIANT.BOLDFRAKTUR],
    symscr: [base_BaseMethods.MathFont, VARIANT.SCRIPT],
    symbfscr: [base_BaseMethods.MathFont, VARIANT.BOLDSCRIPT],
    symsf: [base_BaseMethods.MathFont, VARIANT.SANSSERIF, VARIANT.SANSSERIFITALIC],
    symsfup: [base_BaseMethods.MathFont, VARIANT.SANSSERIF],
    symbfsf: [base_BaseMethods.MathFont, VARIANT.BOLDSANSSERIF],
    symbfsfup: [base_BaseMethods.MathFont, VARIANT.BOLDSANSSERIF],
    symsfit: [base_BaseMethods.MathFont, VARIANT.SANSSERIFITALIC],
    symbfsfit: [base_BaseMethods.MathFont, VARIANT.SANSSERIFBOLDITALIC],
    symtt: [base_BaseMethods.MathFont, VARIANT.MONOSPACE],
    symcal: [base_BaseMethods.MathFont, VARIANT.CALLIGRAPHIC],
    symbfcal: [base_BaseMethods.MathFont, VARIANT.BOLDCALLIGRAPHIC],
    textrm: [base_BaseMethods.HBox, null, VARIANT.NORMAL],
    textup: [base_BaseMethods.HBox, null, VARIANT.NORMAL],
    textnormal: [base_BaseMethods.HBox],
    textit: [base_BaseMethods.HBox, null, VARIANT.ITALIC],
    textbf: [base_BaseMethods.HBox, null, VARIANT.BOLD],
    textsf: [base_BaseMethods.HBox, null, VARIANT.SANSSERIF],
    texttt: [base_BaseMethods.HBox, null, VARIANT.MONOSPACE],
    tiny: [base_BaseMethods.SetSize, 0.5],
    Tiny: [base_BaseMethods.SetSize, 0.6],
    scriptsize: [base_BaseMethods.SetSize, 0.7],
    small: [base_BaseMethods.SetSize, 0.85],
    normalsize: [base_BaseMethods.SetSize, 1.0],
    large: [base_BaseMethods.SetSize, 1.2],
    Large: [base_BaseMethods.SetSize, 1.44],
    LARGE: [base_BaseMethods.SetSize, 1.73],
    huge: [base_BaseMethods.SetSize, 2.07],
    Huge: [base_BaseMethods.SetSize, 2.49],
    arcsin: base_BaseMethods.NamedFn,
    arccos: base_BaseMethods.NamedFn,
    arctan: base_BaseMethods.NamedFn,
    arg: base_BaseMethods.NamedFn,
    cos: base_BaseMethods.NamedFn,
    cosh: base_BaseMethods.NamedFn,
    cot: base_BaseMethods.NamedFn,
    coth: base_BaseMethods.NamedFn,
    csc: base_BaseMethods.NamedFn,
    deg: base_BaseMethods.NamedFn,
    det: base_BaseMethods.NamedOp,
    dim: base_BaseMethods.NamedFn,
    exp: base_BaseMethods.NamedFn,
    gcd: base_BaseMethods.NamedOp,
    hom: base_BaseMethods.NamedFn,
    inf: base_BaseMethods.NamedOp,
    ker: base_BaseMethods.NamedFn,
    lg: base_BaseMethods.NamedFn,
    lim: base_BaseMethods.NamedOp,
    liminf: [base_BaseMethods.NamedOp, 'lim&thinsp;inf'],
    limsup: [base_BaseMethods.NamedOp, 'lim&thinsp;sup'],
    ln: base_BaseMethods.NamedFn,
    log: base_BaseMethods.NamedFn,
    max: base_BaseMethods.NamedOp,
    min: base_BaseMethods.NamedOp,
    Pr: base_BaseMethods.NamedOp,
    sec: base_BaseMethods.NamedFn,
    sin: base_BaseMethods.NamedFn,
    sinh: base_BaseMethods.NamedFn,
    sup: base_BaseMethods.NamedOp,
    tan: base_BaseMethods.NamedFn,
    tanh: base_BaseMethods.NamedFn,
    limits: [base_BaseMethods.Limits, true],
    nolimits: [base_BaseMethods.Limits, false],
    overline: [base_BaseMethods.UnderOver, '2015'],
    underline: [base_BaseMethods.UnderOver, '2015'],
    overbrace: [base_BaseMethods.UnderOver, '23DE', true],
    underbrace: [base_BaseMethods.UnderOver, '23DF', true],
    overparen: [base_BaseMethods.UnderOver, '23DC'],
    underparen: [base_BaseMethods.UnderOver, '23DD'],
    overrightarrow: [base_BaseMethods.UnderOver, '2192'],
    underrightarrow: [base_BaseMethods.UnderOver, '2192'],
    overleftarrow: [base_BaseMethods.UnderOver, '2190'],
    underleftarrow: [base_BaseMethods.UnderOver, '2190'],
    overleftrightarrow: [base_BaseMethods.UnderOver, '2194'],
    underleftrightarrow: [base_BaseMethods.UnderOver, '2194'],
    overset: base_BaseMethods.Overset,
    underset: base_BaseMethods.Underset,
    overunderset: base_BaseMethods.Overunderset,
    stackrel: [base_BaseMethods.Macro, '\\mathrel{\\mathop{#2}\\limits^{#1}}', 2],
    stackbin: [base_BaseMethods.Macro, '\\mathbin{\\mathop{#2}\\limits^{#1}}', 2],
    over: base_BaseMethods.Over,
    overwithdelims: base_BaseMethods.Over,
    atop: base_BaseMethods.Over,
    atopwithdelims: base_BaseMethods.Over,
    above: base_BaseMethods.Over,
    abovewithdelims: base_BaseMethods.Over,
    brace: [base_BaseMethods.Over, '{', '}'],
    brack: [base_BaseMethods.Over, '[', ']'],
    choose: [base_BaseMethods.Over, '(', ')'],
    frac: base_BaseMethods.Frac,
    sqrt: base_BaseMethods.Sqrt,
    root: base_BaseMethods.Root,
    uproot: [base_BaseMethods.MoveRoot, 'upRoot'],
    leftroot: [base_BaseMethods.MoveRoot, 'leftRoot'],
    left: base_BaseMethods.LeftRight,
    right: base_BaseMethods.LeftRight,
    middle: base_BaseMethods.LeftRight,
    llap: base_BaseMethods.Lap,
    rlap: base_BaseMethods.Lap,
    raise: base_BaseMethods.RaiseLower,
    lower: base_BaseMethods.RaiseLower,
    moveleft: base_BaseMethods.MoveLeftRight,
    moveright: base_BaseMethods.MoveLeftRight,
    ',': [base_BaseMethods.Spacer, MATHSPACE.thinmathspace],
    ':': [base_BaseMethods.Spacer, MATHSPACE.mediummathspace],
    '>': [base_BaseMethods.Spacer, MATHSPACE.mediummathspace],
    ';': [base_BaseMethods.Spacer, MATHSPACE.thickmathspace],
    '!': [base_BaseMethods.Spacer, MATHSPACE.negativethinmathspace],
    enspace: [base_BaseMethods.Spacer, 0.5],
    quad: [base_BaseMethods.Spacer, 1],
    qquad: [base_BaseMethods.Spacer, 2],
    thinspace: [base_BaseMethods.Spacer, MATHSPACE.thinmathspace],
    negthinspace: [base_BaseMethods.Spacer, MATHSPACE.negativethinmathspace],
    '*': base_BaseMethods.DiscretionaryTimes,
    allowbreak: base_BaseMethods.AllowBreak,
    goodbreak: [base_BaseMethods.Linebreak, TexConstant.LineBreak.GOODBREAK],
    badbreak: [base_BaseMethods.Linebreak, TexConstant.LineBreak.BADBREAK],
    nobreak: [base_BaseMethods.Linebreak, TexConstant.LineBreak.NOBREAK],
    break: base_BaseMethods.Break,
    hskip: base_BaseMethods.Hskip,
    hspace: base_BaseMethods.Hskip,
    kern: [base_BaseMethods.Hskip, true],
    mskip: base_BaseMethods.Hskip,
    mspace: base_BaseMethods.Hskip,
    mkern: [base_BaseMethods.Hskip, true],
    rule: base_BaseMethods.rule,
    Rule: [base_BaseMethods.Rule],
    Space: [base_BaseMethods.Rule, 'blank'],
    nonscript: base_BaseMethods.Nonscript,
    big: [base_BaseMethods.MakeBig, TEXCLASS.ORD, 0.85],
    Big: [base_BaseMethods.MakeBig, TEXCLASS.ORD, 1.15],
    bigg: [base_BaseMethods.MakeBig, TEXCLASS.ORD, 1.45],
    Bigg: [base_BaseMethods.MakeBig, TEXCLASS.ORD, 1.75],
    bigl: [base_BaseMethods.MakeBig, TEXCLASS.OPEN, 0.85],
    Bigl: [base_BaseMethods.MakeBig, TEXCLASS.OPEN, 1.15],
    biggl: [base_BaseMethods.MakeBig, TEXCLASS.OPEN, 1.45],
    Biggl: [base_BaseMethods.MakeBig, TEXCLASS.OPEN, 1.75],
    bigr: [base_BaseMethods.MakeBig, TEXCLASS.CLOSE, 0.85],
    Bigr: [base_BaseMethods.MakeBig, TEXCLASS.CLOSE, 1.15],
    biggr: [base_BaseMethods.MakeBig, TEXCLASS.CLOSE, 1.45],
    Biggr: [base_BaseMethods.MakeBig, TEXCLASS.CLOSE, 1.75],
    bigm: [base_BaseMethods.MakeBig, TEXCLASS.REL, 0.85],
    Bigm: [base_BaseMethods.MakeBig, TEXCLASS.REL, 1.15],
    biggm: [base_BaseMethods.MakeBig, TEXCLASS.REL, 1.45],
    Biggm: [base_BaseMethods.MakeBig, TEXCLASS.REL, 1.75],
    mathord: [base_BaseMethods.TeXAtom, TEXCLASS.ORD],
    mathop: [base_BaseMethods.TeXAtom, TEXCLASS.OP],
    mathopen: [base_BaseMethods.TeXAtom, TEXCLASS.OPEN],
    mathclose: [base_BaseMethods.TeXAtom, TEXCLASS.CLOSE],
    mathbin: [base_BaseMethods.TeXAtom, TEXCLASS.BIN],
    mathrel: [base_BaseMethods.TeXAtom, TEXCLASS.REL],
    mathpunct: [base_BaseMethods.TeXAtom, TEXCLASS.PUNCT],
    mathinner: [base_BaseMethods.TeXAtom, TEXCLASS.INNER],
    vtop: [base_BaseMethods.VBox, 'top'],
    vcenter: [base_BaseMethods.VBox, 'center'],
    vbox: [base_BaseMethods.VBox, 'bottom'],
    hsize: base_BaseMethods.Hsize,
    parbox: base_BaseMethods.ParBox,
    breakAlign: base_BaseMethods.BreakAlign,
    buildrel: base_BaseMethods.BuildRel,
    hbox: [base_BaseMethods.HBox, 0],
    text: base_BaseMethods.HBox,
    mbox: [base_BaseMethods.HBox, 0],
    fbox: base_BaseMethods.FBox,
    boxed: [base_BaseMethods.Macro, '\\fbox{$\\displaystyle{#1}$}', 1],
    framebox: base_BaseMethods.FrameBox,
    makebox: base_BaseMethods.MakeBox,
    strut: base_BaseMethods.Strut,
    mathstrut: [base_BaseMethods.Macro, '\\vphantom{(}'],
    phantom: base_BaseMethods.Phantom,
    vphantom: [base_BaseMethods.Phantom, 1, 0],
    hphantom: [base_BaseMethods.Phantom, 0, 1],
    smash: base_BaseMethods.Smash,
    acute: [base_BaseMethods.Accent, '00B4'],
    grave: [base_BaseMethods.Accent, '0060'],
    ddot: [base_BaseMethods.Accent, '00A8'],
    dddot: [base_BaseMethods.Accent, '20DB'],
    ddddot: [base_BaseMethods.Accent, '20DC'],
    tilde: [base_BaseMethods.Accent, '007E'],
    bar: [base_BaseMethods.Accent, '00AF'],
    breve: [base_BaseMethods.Accent, '02D8'],
    check: [base_BaseMethods.Accent, '02C7'],
    hat: [base_BaseMethods.Accent, '005E'],
    vec: [base_BaseMethods.Accent, '2192', false],
    dot: [base_BaseMethods.Accent, '02D9'],
    widetilde: [base_BaseMethods.Accent, '007E', true],
    widehat: [base_BaseMethods.Accent, '005E', true],
    matrix: base_BaseMethods.Matrix,
    array: base_BaseMethods.Matrix,
    pmatrix: [base_BaseMethods.Matrix, '(', ')'],
    cases: [base_BaseMethods.Matrix, '{', '', 'left left', null, '.2em', null, true],
    eqalign: [
        base_BaseMethods.Matrix,
        null,
        null,
        'right left',
        THICKMATHSPACE,
        '.5em',
        'D',
    ],
    displaylines: [base_BaseMethods.Matrix, null, null, 'center', null, '.5em', 'D'],
    cr: base_BaseMethods.Cr,
    '\\': base_BaseMethods.CrLaTeX,
    newline: [base_BaseMethods.CrLaTeX, true],
    hline: base_BaseMethods.HLine,
    hdashline: [base_BaseMethods.HLine, 'dashed'],
    eqalignno: [
        base_BaseMethods.Matrix,
        null,
        null,
        'right left',
        THICKMATHSPACE,
        '.5em',
        'D',
        null,
        'right',
    ],
    leqalignno: [
        base_BaseMethods.Matrix,
        null,
        null,
        'right left',
        THICKMATHSPACE,
        '.5em',
        'D',
        null,
        'left',
    ],
    hfill: base_BaseMethods.HFill,
    hfil: base_BaseMethods.HFill,
    hfilll: base_BaseMethods.HFill,
    bmod: [
        base_BaseMethods.Macro,
        '\\mmlToken{mo}[lspace="' +
            THICKMATHSPACE +
            '"' +
            ' rspace="' +
            THICKMATHSPACE +
            '"]{mod}',
    ],
    pmod: [base_BaseMethods.Macro, '\\pod{\\mmlToken{mi}{mod}\\kern 6mu #1}', 1],
    mod: [
        base_BaseMethods.Macro,
        '\\mathchoice{\\kern18mu}{\\kern12mu}' +
            '{\\kern12mu}{\\kern12mu}\\mmlToken{mi}{mod}\\,\\,#1',
        1,
    ],
    pod: [
        base_BaseMethods.Macro,
        '\\mathchoice{\\kern18mu}{\\kern8mu}' + '{\\kern8mu}{\\kern8mu}(#1)',
        1,
    ],
    iff: [base_BaseMethods.Macro, '\\;\\Longleftrightarrow\\;'],
    skew: [base_BaseMethods.Macro, '{{#2{#3\\mkern#1mu}\\mkern-#1mu}{}}', 3],
    pmb: [base_BaseMethods.Macro, '\\rlap{#1}\\kern1px{#1}', 1],
    TeX: [base_BaseMethods.Macro, 'T\\kern-.14em\\lower.5ex{E}\\kern-.115em X'],
    LaTeX: [
        base_BaseMethods.Macro,
        'L\\kern-.325em\\raise.21em' + '{\\scriptstyle{A}}\\kern-.17em\\TeX',
    ],
    not: base_BaseMethods.Not,
    dots: base_BaseMethods.Dots,
    space: base_BaseMethods.Tilde,
    '\u00A0': base_BaseMethods.Tilde,
    ' ': base_BaseMethods.Tilde,
    begin: base_BaseMethods.BeginEnd,
    end: base_BaseMethods.BeginEnd,
    label: base_BaseMethods.HandleLabel,
    ref: base_BaseMethods.HandleRef,
    nonumber: base_BaseMethods.HandleNoTag,
    newcolumntype: base_BaseMethods.NewColumnType,
    mathchoice: base_BaseMethods.MathChoice,
    mmlToken: base_BaseMethods.MmlToken,
});
new EnvironmentMap('environment', tex_ParseMethods.environment, {
    displaymath: [base_BaseMethods.Equation, null, false],
    math: [base_BaseMethods.Equation, null, false, false],
    array: [base_BaseMethods.AlignedArray],
    darray: [base_BaseMethods.AlignedArray, null, 'D'],
    equation: [base_BaseMethods.Equation, null, true],
    eqnarray: [
        base_BaseMethods.EqnArray,
        null,
        true,
        true,
        'rcl',
        'bmt',
        ParseUtil.cols(0, MATHSPACE.thickmathspace),
        '.5em',
    ],
    indentalign: [base_BaseMethods.IndentAlign],
});
new CharacterMap('not_remap', null, {
    '\u2190': '\u219A',
    '\u2192': '\u219B',
    '\u2194': '\u21AE',
    '\u21D0': '\u21CD',
    '\u21D2': '\u21CF',
    '\u21D4': '\u21CE',
    '\u2208': '\u2209',
    '\u220B': '\u220C',
    '\u2223': '\u2224',
    '\u2225': '\u2226',
    '\u223C': '\u2241',
    '\u007E': '\u2241',
    '\u2243': '\u2244',
    '\u2245': '\u2247',
    '\u2248': '\u2249',
    '\u224D': '\u226D',
    '\u003D': '\u2260',
    '\u2261': '\u2262',
    '\u003C': '\u226E',
    '\u003E': '\u226F',
    '\u2264': '\u2270',
    '\u2265': '\u2271',
    '\u2272': '\u2274',
    '\u2273': '\u2275',
    '\u2276': '\u2278',
    '\u2277': '\u2279',
    '\u227A': '\u2280',
    '\u227B': '\u2281',
    '\u2282': '\u2284',
    '\u2283': '\u2285',
    '\u2286': '\u2288',
    '\u2287': '\u2289',
    '\u22A2': '\u22AC',
    '\u22A8': '\u22AD',
    '\u22A9': '\u22AE',
    '\u22AB': '\u22AF',
    '\u227C': '\u22E0',
    '\u227D': '\u22E1',
    '\u2291': '\u22E2',
    '\u2292': '\u22E3',
    '\u22B2': '\u22EA',
    '\u22B3': '\u22EB',
    '\u22B4': '\u22EC',
    '\u22B5': '\u22ED',
    '\u2203': '\u2204',
});
//# sourceMappingURL=BaseMappings.js.map
;// ./mjs/input/tex/base/BaseConfiguration.js














const BaseConfiguration_MATHVARIANT = TexConstant.Variant;
new CharacterMap('remap', null, {
    '-': '\u2212',
    '*': '\u2217',
    '`': '\u2018',
});
function Other(parser, char) {
    const font = parser.stack.env['font'];
    const ifont = parser.stack.env['italicFont'];
    const def = font ? { mathvariant: font } : {};
    const remap = MapHandler.getMap('remap').lookup(char);
    const range = getRange(char);
    const type = range[3];
    const mo = parser.create('token', type, def, remap ? remap.char : char);
    const style = ParseUtil.isLatinOrGreekChar(char)
        ? parser.configuration.mathStyle(char, true) || ifont
        : '';
    const variant = range[4] || (font && style === BaseConfiguration_MATHVARIANT.NORMAL ? '' : style);
    if (variant) {
        mo.attributes.set('mathvariant', variant);
    }
    if (type === 'mo') {
        tex_NodeUtil.setProperty(mo, 'fixStretchy', true);
        parser.configuration.addNode('fixStretchy', mo);
    }
    parser.Push(mo);
}
function csUndefined(_parser, name) {
    throw new tex_TexError('UndefinedControlSequence', 'Undefined control sequence %1', '\\' + name);
}
function envUndefined(_parser, env) {
    throw new tex_TexError('UnknownEnv', "Unknown environment '%1'", env);
}
function filterNonscript({ data }) {
    for (const mml of data.getList('nonscript')) {
        if (mml.attributes.get('scriptlevel') > 0) {
            const parent = mml.parent;
            parent.childNodes.splice(parent.childIndex(mml), 1);
            data.removeFromList(mml.kind, [mml]);
            if (mml.isKind('mrow')) {
                const mstyle = mml.childNodes[0];
                data.removeFromList('mstyle', [mstyle]);
                data.removeFromList('mspace', mstyle.childNodes[0].childNodes);
            }
        }
        else if (mml.isKind('mrow')) {
            mml.parent.replaceChild(mml.childNodes[0], mml);
            data.removeFromList('mrow', [mml]);
        }
    }
}
class BaseTags extends AbstractTags {
}
const BaseConfiguration = Configuration.create('base', {
    [ConfigurationType.CONFIG]: function (config, jax) {
        const options = jax.parseOptions.options;
        if (options.digits) {
            options.numberPattern = options.digits;
        }
        new RegExpMap('digit', tex_ParseMethods.digit, options.initialDigit);
        new RegExpMap('letter', tex_ParseMethods.variable, options.initialLetter);
        const handler = config.handlers.get(HandlerType.CHARACTER);
        handler.add(['letter', 'digit'], null, 4);
    },
    [ConfigurationType.HANDLER]: {
        [HandlerType.CHARACTER]: ['command', 'special'],
        [HandlerType.DELIMITER]: ['delimiter'],
        [HandlerType.MACRO]: [
            'delimiter',
            'macros',
            'lcGreek',
            'ucGreek',
            'mathchar0mi',
            'mathchar0mo',
            'mathchar7',
        ],
        [HandlerType.ENVIRONMENT]: ['environment'],
    },
    [ConfigurationType.FALLBACK]: {
        [HandlerType.CHARACTER]: Other,
        [HandlerType.MACRO]: csUndefined,
        [HandlerType.ENVIRONMENT]: envUndefined,
    },
    [ConfigurationType.ITEMS]: {
        [StartItem.prototype.kind]: StartItem,
        [StopItem.prototype.kind]: StopItem,
        [OpenItem.prototype.kind]: OpenItem,
        [CloseItem.prototype.kind]: CloseItem,
        [NullItem.prototype.kind]: NullItem,
        [PrimeItem.prototype.kind]: PrimeItem,
        [SubsupItem.prototype.kind]: SubsupItem,
        [OverItem.prototype.kind]: OverItem,
        [LeftItem.prototype.kind]: LeftItem,
        [Middle.prototype.kind]: Middle,
        [RightItem.prototype.kind]: RightItem,
        [BreakItem.prototype.kind]: BreakItem,
        [BeginItem.prototype.kind]: BeginItem,
        [EndItem.prototype.kind]: EndItem,
        [StyleItem.prototype.kind]: StyleItem,
        [PositionItem.prototype.kind]: PositionItem,
        [CellItem.prototype.kind]: CellItem,
        [MmlItem.prototype.kind]: MmlItem,
        [FnItem.prototype.kind]: FnItem,
        [NotItem.prototype.kind]: NotItem,
        [NonscriptItem.prototype.kind]: NonscriptItem,
        [DotsItem.prototype.kind]: DotsItem,
        [ArrayItem.prototype.kind]: ArrayItem,
        [EqnArrayItem.prototype.kind]: EqnArrayItem,
        [EquationItem.prototype.kind]: EquationItem,
        [MstyleItem.prototype.kind]: MstyleItem,
    },
    [ConfigurationType.OPTIONS]: {
        maxMacros: 1000,
        digits: '',
        numberPattern: /^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/,
        initialDigit: /[0-9.,]/,
        identifierPattern: /^[a-zA-Z]+/,
        initialLetter: /[a-zA-Z]/,
        baseURL: !context.document ||
            context.document.getElementsByTagName('base').length === 0
            ? ''
            : String(context.document.location).replace(/#.*$/, ''),
    },
    [ConfigurationType.TAGS]: {
        base: BaseTags,
    },
    [ConfigurationType.POSTPROCESSORS]: [[filterNonscript, -4]],
});
//# sourceMappingURL=BaseConfiguration.js.map
;// ./mjs/input/tex.js












class TeX extends AbstractInputJax {
    static configure(packages) {
        const configuration = new ParserConfiguration(packages, ['tex']);
        configuration.init();
        return configuration;
    }
    static tags(options, configuration) {
        TagsFactory.addTags(configuration.tags);
        TagsFactory.setDefault(options.options.tags);
        options.tags = TagsFactory.getDefault();
        options.tags.configuration = options;
    }
    constructor(options = {}) {
        const [rest, tex, find] = separateOptions(options, TeX.OPTIONS, FindTeX.OPTIONS);
        super(tex);
        this.findTeX = this.options['FindTeX'] || new FindTeX(find);
        const packages = this.options.packages;
        const configuration = (this.configuration = TeX.configure(packages));
        const parseOptions = (this._parseOptions = new tex_ParseOptions(configuration, [
            this.options,
            TagsFactory.OPTIONS,
        ]));
        userOptions(parseOptions.options, rest);
        configuration.config(this);
        TeX.tags(parseOptions, configuration);
        this.postFilters.addList([
            [tex_FilterUtil.cleanSubSup, -7],
            [tex_FilterUtil.setInherited, -6],
            [tex_FilterUtil.checkScriptlevel, -5],
            [tex_FilterUtil.moveLimits, -4],
            [tex_FilterUtil.cleanStretchy, -3],
            [tex_FilterUtil.cleanAttributes, -2],
            [tex_FilterUtil.combineRelations, -1],
        ]);
    }
    setMmlFactory(mmlFactory) {
        super.setMmlFactory(mmlFactory);
        this._parseOptions.nodeFactory.setMmlFactory(mmlFactory);
    }
    get parseOptions() {
        return this._parseOptions;
    }
    reset(tag = 0) {
        this.parseOptions.tags.reset(tag);
    }
    compile(math, document) {
        this.parseOptions.clear();
        this.parseOptions.mathItem = math;
        this.executeFilters(this.preFilters, math, document, this.parseOptions);
        this.latex = math.math;
        let node;
        this.parseOptions.tags.startEquation(math);
        let parser;
        try {
            parser = new TexParser(this.latex, { display: math.display, isInner: false }, this.parseOptions);
            node = parser.mml();
        }
        catch (err) {
            if (!(err instanceof tex_TexError)) {
                throw err;
            }
            this.parseOptions.error = true;
            node = this.options.formatError(this, err);
        }
        node = this.parseOptions.nodeFactory.create('node', 'math', [node]);
        node.attributes.set(TexConstant.Attr.LATEX, this.latex);
        if (math.display) {
            tex_NodeUtil.setAttribute(node, 'display', 'block');
        }
        this.parseOptions.tags.finishEquation(math);
        this.parseOptions.root = node;
        this.executeFilters(this.postFilters, math, document, this.parseOptions);
        if (parser && parser.stack.env.hsize) {
            tex_NodeUtil.setAttribute(node, 'maxwidth', parser.stack.env.hsize);
            tex_NodeUtil.setAttribute(node, 'overflow', 'linebreak');
        }
        this.mathNode = this.parseOptions.root;
        return this.mathNode;
    }
    findMath(strings) {
        return this.findTeX.findMath(strings);
    }
    formatError(err) {
        const message = err.message.replace(/\n.*/, '');
        return this.parseOptions.nodeFactory.create('error', message, err.id, this.latex);
    }
}
TeX.NAME = 'TeX';
TeX.OPTIONS = Object.assign(Object.assign({}, AbstractInputJax.OPTIONS), { FindTeX: null, packages: ['base'], maxBuffer: 5 * 1024, maxTemplateSubtitutions: 10000, mathStyle: 'TeX', formatError: (jax, err) => jax.formatError(err) });
//# sourceMappingURL=tex.js.map
;// ./mjs/input/tex/ams/AmsItems.js





class MultlineItem extends ArrayItem {
    constructor(factory, ...args) {
        super(factory);
        this.factory.configuration.tags.start('multline', true, args[0]);
    }
    get kind() {
        return 'multline';
    }
    EndEntry() {
        if (this.table.length) {
            ParseUtil.fixInitialMO(this.factory.configuration, this.nodes);
        }
        const shove = this.getProperty('shove');
        const mtd = this.create('node', 'mtd', this.nodes, shove ? { columnalign: shove } : {});
        this.setProperty('shove', null);
        this.row.push(mtd);
        this.Clear();
    }
    EndRow() {
        if (this.row.length !== 1) {
            throw new tex_TexError('MultlineRowsOneCol', 'The rows within the %1 environment must have exactly one column', 'multline');
        }
        const row = this.create('node', 'mtr', this.row);
        this.table.push(row);
        this.row = [];
    }
    EndTable() {
        super.EndTable();
        if (this.table.length) {
            const m = this.table.length - 1;
            let label = -1;
            if (!tex_NodeUtil.getAttribute(tex_NodeUtil.getChildren(this.table[0])[0], 'columnalign')) {
                tex_NodeUtil.setAttribute(tex_NodeUtil.getChildren(this.table[0])[0], 'columnalign', TexConstant.Align.LEFT);
            }
            if (!tex_NodeUtil.getAttribute(tex_NodeUtil.getChildren(this.table[m])[0], 'columnalign')) {
                tex_NodeUtil.setAttribute(tex_NodeUtil.getChildren(this.table[m])[0], 'columnalign', TexConstant.Align.RIGHT);
            }
            const tag = this.factory.configuration.tags.getTag();
            if (tag) {
                label =
                    this.arraydef.side === TexConstant.Align.LEFT
                        ? 0
                        : this.table.length - 1;
                const mtr = this.table[label];
                const mlabel = this.create('node', 'mlabeledtr', [tag].concat(tex_NodeUtil.getChildren(mtr)));
                tex_NodeUtil.copyAttributes(mtr, mlabel);
                this.table[label] = mlabel;
            }
        }
        this.factory.configuration.tags.end();
    }
}
class FlalignItem extends EqnArrayItem {
    get kind() {
        return 'flalign';
    }
    constructor(factory, name, numbered, padded, center) {
        super(factory);
        this.name = name;
        this.numbered = numbered;
        this.padded = padded;
        this.center = center;
        this.factory.configuration.tags.start(name, numbered, numbered);
    }
    EndEntry() {
        super.EndEntry();
        const n = this.getProperty('xalignat');
        if (!n)
            return;
        if (this.row.length > n) {
            throw new tex_TexError('XalignOverflow', 'Extra %1 in row of %2', '&', this.name);
        }
    }
    EndRow() {
        let cell;
        const row = this.row;
        const n = this.getProperty('xalignat');
        while (row.length < n) {
            row.push(this.create('node', 'mtd'));
        }
        this.row = [];
        if (this.padded) {
            this.row.push(this.create('node', 'mtd'));
        }
        while ((cell = row.shift())) {
            this.row.push(cell);
            cell = row.shift();
            if (cell)
                this.row.push(cell);
            if (row.length || this.padded) {
                this.row.push(this.create('node', 'mtd'));
            }
        }
        if (this.row.length > this.maxrow) {
            this.maxrow = this.row.length;
        }
        super.EndRow();
        const mtr = this.table[this.table.length - 1];
        if (this.getProperty('zeroWidthLabel') && mtr.isKind('mlabeledtr')) {
            const mtd = tex_NodeUtil.getChildren(mtr)[0];
            const side = this.factory.configuration.options['tagSide'];
            const def = Object.assign({ width: 0 }, (side === 'right' ? { lspace: '-1width' } : {}));
            const mpadded = this.create('node', 'mpadded', tex_NodeUtil.getChildren(mtd), def);
            mtd.setChildren([mpadded]);
        }
    }
    EndTable() {
        super.EndTable();
        if (this.center) {
            if (this.maxrow <= 2) {
                const def = this.arraydef;
                delete def.width;
                delete this.global.indentalign;
            }
        }
    }
}
//# sourceMappingURL=AmsItems.js.map
;// ./mjs/input/tex/newcommand/NewcommandUtil.js





var NewcommandTables;
(function (NewcommandTables) {
    NewcommandTables["NEW_DELIMITER"] = "new-Delimiter";
    NewcommandTables["NEW_COMMAND"] = "new-Command";
    NewcommandTables["NEW_ENVIRONMENT"] = "new-Environment";
})(NewcommandTables || (NewcommandTables = {}));
const NewcommandPriority = -100;
const NewcommandUtil = {
    GetCSname(parser, cmd) {
        const c = parser.GetNext();
        if (c !== '\\') {
            throw new tex_TexError('MissingCS', '%1 must be followed by a control sequence', cmd);
        }
        const cs = UnitUtil.trimSpaces(parser.GetArgument(cmd)).substring(1);
        this.checkProtectedMacros(parser, cs);
        return cs;
    },
    GetCsNameArgument(parser, name) {
        let cs = UnitUtil.trimSpaces(parser.GetArgument(name));
        if (cs.charAt(0) === '\\') {
            cs = cs.substring(1);
        }
        if (!cs.match(/^(.|[a-z]+)$/i)) {
            throw new tex_TexError('IllegalControlSequenceName', 'Illegal control sequence name for %1', name);
        }
        this.checkProtectedMacros(parser, cs);
        return cs;
    },
    GetArgCount(parser, name) {
        let n = parser.GetBrackets(name);
        if (n) {
            n = UnitUtil.trimSpaces(n);
            if (!n.match(/^[0-9]+$/)) {
                throw new tex_TexError('IllegalParamNumber', 'Illegal number of parameters specified in %1', name);
            }
        }
        return n;
    },
    GetTemplate(parser, cmd, cs) {
        let c = parser.GetNext();
        const params = [];
        let n = 0;
        let i = parser.i;
        while (parser.i < parser.string.length) {
            c = parser.GetNext();
            if (c === '#') {
                if (i !== parser.i) {
                    params[n] = parser.string.substring(i, parser.i);
                }
                c = parser.string.charAt(++parser.i);
                if (!c.match(/^[1-9]$/)) {
                    throw new tex_TexError('CantUseHash2', 'Illegal use of # in template for %1', cs);
                }
                if (parseInt(c) !== ++n) {
                    throw new tex_TexError('SequentialParam', 'Parameters for %1 must be numbered sequentially', cs);
                }
                i = parser.i + 1;
            }
            else if (c === '{') {
                if (i !== parser.i) {
                    params[n] = parser.string.substring(i, parser.i);
                }
                if (params.length > 0) {
                    return [n.toString()].concat(params);
                }
                else {
                    return n;
                }
            }
            parser.i++;
        }
        throw new tex_TexError('MissingReplacementString', 'Missing replacement string for definition of %1', cmd);
    },
    GetParameter(parser, name, param) {
        if (param == null) {
            return parser.GetArgument(name);
        }
        let i = parser.i;
        let j = 0;
        let hasBraces = false;
        while (parser.i < parser.string.length) {
            const c = parser.string.charAt(parser.i);
            if (c === '{') {
                hasBraces = parser.i === i;
                parser.GetArgument(name);
                j = parser.i - i;
            }
            else if (this.MatchParam(parser, param)) {
                if (hasBraces) {
                    i++;
                    j -= 2;
                }
                return parser.string.substring(i, i + j);
            }
            else if (c === '\\') {
                parser.i++;
                j++;
                hasBraces = false;
                const match = parser.string.substring(parser.i).match(/[a-z]+|./i);
                if (match) {
                    parser.i += match[0].length;
                    j = parser.i - i;
                }
            }
            else {
                parser.i++;
                j++;
                hasBraces = false;
            }
        }
        throw new tex_TexError('RunawayArgument', 'Runaway argument for %1?', name);
    },
    MatchParam(parser, param) {
        if (parser.string.substring(parser.i, parser.i + param.length) !== param) {
            return 0;
        }
        if (param.match(/\\[a-z]+$/i) &&
            parser.string.charAt(parser.i + param.length).match(/[a-z]/i)) {
            return 0;
        }
        parser.i += param.length;
        return 1;
    },
    checkGlobal(parser, tokens, maps) {
        return (parser.stack.env.isGlobal
            ? parser.configuration.packageData
                .get('begingroup')
                .stack.checkGlobal(tokens, maps)
            : maps.map((name) => parser.configuration.handlers.retrieve(name)));
    },
    checkProtectedMacros(parser, cs) {
        var _a;
        if ((_a = parser.options.protectedMacros) === null || _a === void 0 ? void 0 : _a.includes(cs)) {
            throw new tex_TexError('ProtectedMacro', "The control sequence %1 can't be redefined", `\\${cs}`);
        }
    },
    addDelimiter(parser, cs, char, attr) {
        const name = cs.substring(1);
        this.checkProtectedMacros(parser, name);
        const [macros, delims] = NewcommandUtil.checkGlobal(parser, [name, cs], [NewcommandTables.NEW_COMMAND, NewcommandTables.NEW_DELIMITER]);
        if (name !== cs) {
            macros.remove(name);
        }
        delims.add(cs, new Token(cs, char, attr));
        delete parser.stack.env.isGlobal;
    },
    addMacro(parser, cs, func, attr, token = '') {
        this.checkProtectedMacros(parser, cs);
        const macros = NewcommandUtil.checkGlobal(parser, [cs], [NewcommandTables.NEW_COMMAND])[0];
        this.undefineDelimiter(parser, '\\' + cs);
        macros.add(cs, new Macro(token ? token : cs, func, attr));
        delete parser.stack.env.isGlobal;
    },
    addEnvironment(parser, env, func, attr) {
        const envs = NewcommandUtil.checkGlobal(parser, [env], [NewcommandTables.NEW_ENVIRONMENT])[0];
        envs.add(env, new Macro(env, func, attr));
        delete parser.stack.env.isGlobal;
    },
    undefineMacro(parser, cs) {
        const macros = NewcommandUtil.checkGlobal(parser, [cs], [NewcommandTables.NEW_COMMAND])[0];
        macros.remove(cs);
        if (parser.configuration.handlers.get(HandlerType.MACRO).applicable(cs)) {
            macros.add(cs, new Macro(cs, () => SubHandler.FALLBACK, []));
            this.undefineDelimiter(parser, '\\' + cs);
        }
        delete parser.stack.env.isGlobal;
    },
    undefineDelimiter(parser, cs) {
        const delims = NewcommandUtil.checkGlobal(parser, [cs], [NewcommandTables.NEW_DELIMITER])[0];
        delims.remove(cs);
        if (parser.configuration.handlers.get(HandlerType.DELIMITER).applicable(cs)) {
            delims.add(cs, new Token(cs, null, {}));
        }
        delete parser.stack.env.isGlobal;
    },
};
//# sourceMappingURL=NewcommandUtil.js.map
;// ./mjs/input/tex/ams/AmsMethods.js











function splitSideSet(mml) {
    if (!mml || (mml.isInferred && mml.childNodes.length === 0)) {
        return [null, null];
    }
    if (mml.isKind('msubsup') && checkSideSetBase(mml)) {
        return [mml, null];
    }
    const child = tex_NodeUtil.getChildAt(mml, 0);
    if (!(mml.isInferred && child && checkSideSetBase(child))) {
        return [null, mml];
    }
    mml.childNodes.splice(0, 1);
    return [child, mml];
}
function checkSideSetBase(mml) {
    const base = mml.childNodes[0];
    return (base && base.isKind('mi') && base.getText() === '');
}
const AmsMethods = {
    AmsEqnArray(parser, begin, numbered, taggable, align, balign, spacing, style) {
        const args = parser.GetBrackets('\\begin{' + begin.getName() + '}');
        const array = base_BaseMethods.EqnArray(parser, begin, numbered, taggable, align, balign, spacing, style);
        return ParseUtil.setArrayAlign(array, args, parser);
    },
    AlignAt(parser, begin, numbered, taggable) {
        const name = begin.getName();
        let valign;
        let align = '';
        let balign = '';
        const spacing = [];
        if (!taggable) {
            valign = parser.GetBrackets('\\begin{' + name + '}');
        }
        const n = parser.GetArgument('\\begin{' + name + '}');
        if (n.match(/[^0-9]/)) {
            throw new tex_TexError('PositiveIntegerArg', 'Argument to %1 must be a positive integer', '\\begin{' + name + '}');
        }
        let count = parseInt(n, 10);
        while (count > 0) {
            align += 'rl';
            balign += 'bt';
            spacing.push('0em 0em');
            count--;
        }
        const spaceStr = spacing.join(' ');
        if (taggable) {
            return AmsMethods.EqnArray(parser, begin, numbered, taggable, align, balign, spaceStr);
        }
        const array = AmsMethods.EqnArray(parser, begin, numbered, taggable, align, balign, spaceStr);
        return ParseUtil.setArrayAlign(array, valign, parser);
    },
    Multline(parser, begin, numbered) {
        ParseUtil.checkEqnEnv(parser);
        parser.Push(begin);
        const padding = parser.options.ams['multlineIndent'];
        const item = parser.itemFactory.create('multline', numbered, parser.stack);
        item.arraydef = {
            displaystyle: true,
            rowspacing: '.5em',
            columnspacing: '100%',
            width: parser.options.ams['multlineWidth'],
            side: parser.options['tagSide'],
            minlabelspacing: parser.options['tagIndent'],
            'data-array-padding': `${padding} ${padding}`,
            'data-width-includes-label': true,
        };
        return item;
    },
    XalignAt(parser, begin, numbered, padded) {
        const n = parser.GetArgument('\\begin{' + begin.getName() + '}');
        if (n.match(/[^0-9]/)) {
            throw new tex_TexError('PositiveIntegerArg', 'Argument to %1 must be a positive integer', '\\begin{' + begin.getName() + '}');
        }
        const align = padded ? 'crl' : 'rlc';
        const balign = padded ? 'mbt' : 'btm';
        const width = padded ? 'fit auto auto' : 'auto auto fit';
        const item = AmsMethods.FlalignArray(parser, begin, numbered, padded, false, align, balign, width, true);
        item.setProperty('xalignat', 2 * parseInt(n));
        return item;
    },
    FlalignArray(parser, begin, numbered, padded, center, align, balign, width, zeroWidthLabel = false) {
        ParseUtil.checkEqnEnv(parser);
        parser.Push(begin);
        align = align
            .split('')
            .join(' ')
            .replace(/r/g, 'right')
            .replace(/l/g, 'left')
            .replace(/c/g, 'center');
        balign = splitAlignArray(balign);
        const item = parser.itemFactory.create('flalign', begin.getName(), numbered, padded, center, parser.stack);
        item.arraydef = {
            width: '100%',
            displaystyle: true,
            columnalign: align,
            columnspacing: '0em',
            columnwidth: width,
            rowspacing: '3pt',
            'data-break-align': balign,
            side: parser.options['tagSide'],
            minlabelspacing: zeroWidthLabel ? '0' : parser.options['tagIndent'],
            'data-width-includes-label': true,
        };
        item.setProperty('zeroWidthLabel', zeroWidthLabel);
        return item;
    },
    HandleDeclareOp(parser, name) {
        const star = parser.GetStar() ? '*' : '';
        const cs = NewcommandUtil.GetCsNameArgument(parser, name);
        const op = parser.GetArgument(name);
        NewcommandUtil.addMacro(parser, cs, AmsMethods.Macro, [
            `\\operatorname${star}{${op}}`,
        ]);
        parser.Push(parser.itemFactory.create('null'));
    },
    HandleOperatorName(parser, name) {
        const star = parser.GetStar();
        const op = UnitUtil.trimSpaces(parser.GetArgument(name));
        let mml = new TexParser(op, Object.assign(Object.assign({}, parser.stack.env), { font: TexConstant.Variant.NORMAL, multiLetterIdentifiers: parser.options.ams.operatornamePattern, operatorLetters: true }), parser.configuration).mml();
        if (!mml.isKind('mi')) {
            mml = parser.create('node', 'TeXAtom', [mml]);
        }
        tex_NodeUtil.setProperties(mml, {
            movesupsub: star,
            movablelimits: true,
            texClass: TEXCLASS.OP,
        });
        if (!star) {
            const c = parser.GetNext();
            const i = parser.i;
            if (c === '\\' && ++parser.i && parser.GetCS() !== 'limits') {
                parser.i = i;
            }
        }
        parser.Push(parser.itemFactory.create('fn', mml));
    },
    SideSet(parser, name) {
        const [preScripts, preRest] = splitSideSet(parser.ParseArg(name));
        const [postScripts, postRest] = splitSideSet(parser.ParseArg(name));
        const base = parser.ParseArg(name);
        let mml = base;
        if (preScripts) {
            if (preRest) {
                preScripts.replaceChild(parser.create('node', 'mphantom', [
                    parser.create('node', 'mpadded', [ParseUtil.copyNode(base, parser)], { width: 0 }),
                ]), tex_NodeUtil.getChildAt(preScripts, 0));
            }
            else {
                mml = parser.create('node', 'mmultiscripts', [base]);
                if (postScripts) {
                    tex_NodeUtil.appendChildren(mml, [
                        tex_NodeUtil.getChildAt(postScripts, 1) ||
                            parser.create('node', 'none'),
                        tex_NodeUtil.getChildAt(postScripts, 2) ||
                            parser.create('node', 'none'),
                    ]);
                }
                tex_NodeUtil.setProperty(mml, 'scriptalign', 'left');
                tex_NodeUtil.appendChildren(mml, [
                    parser.create('node', 'mprescripts'),
                    tex_NodeUtil.getChildAt(preScripts, 1) || parser.create('node', 'none'),
                    tex_NodeUtil.getChildAt(preScripts, 2) || parser.create('node', 'none'),
                ]);
            }
        }
        if (postScripts && mml === base) {
            postScripts.replaceChild(base, tex_NodeUtil.getChildAt(postScripts, 0));
            mml = postScripts;
        }
        const mrow = parser.create('node', 'TeXAtom', [], {
            texClass: TEXCLASS.OP,
            movesupsub: true,
            movablelimits: true,
        });
        if (preRest) {
            if (preScripts) {
                mrow.appendChild(preScripts);
            }
            mrow.appendChild(preRest);
        }
        mrow.appendChild(mml);
        if (postRest) {
            mrow.appendChild(postRest);
        }
        parser.Push(mrow);
    },
    operatorLetter(parser, c) {
        return parser.stack.env.operatorLetters
            ? tex_ParseMethods.variable(parser, c)
            : false;
    },
    MultiIntegral(parser, name, integral) {
        let next = parser.GetNext();
        if (next === '\\') {
            const i = parser.i;
            next = parser.GetArgument(name);
            parser.i = i;
            if (next === '\\limits') {
                integral = '\\!\\!\\mathop{\\,\\,' + integral + '}';
            }
        }
        parser.string = integral + ' ' + parser.string.slice(parser.i);
        parser.i = 0;
    },
    xArrow(parser, name, chr, l, r, m = 0) {
        const def = {
            width: '+' + UnitUtil.em((l + r) / 18),
            lspace: UnitUtil.em(l / 18),
        };
        const bot = parser.GetBrackets(name);
        const first = parser.ParseArg(name);
        const dstrut = parser.create('node', 'mspace', [], { depth: '.2em' });
        let arrow = parser.create('token', 'mo', { stretchy: true, texClass: TEXCLASS.REL }, String.fromCodePoint(chr));
        if (m) {
            arrow.attributes.set('minsize', UnitUtil.em(m));
        }
        arrow = parser.create('node', 'mstyle', [arrow], { scriptlevel: 0 });
        const mml = parser.create('node', 'munderover', [arrow]);
        let mpadded = parser.create('node', 'mpadded', [first, dstrut], def);
        tex_NodeUtil.setAttribute(mpadded, 'voffset', '-.2em');
        tex_NodeUtil.setAttribute(mpadded, 'height', '-.2em');
        tex_NodeUtil.setChild(mml, mml.over, mpadded);
        if (bot) {
            const bottom = new TexParser(bot, parser.stack.env, parser.configuration).mml();
            const bstrut = parser.create('node', 'mspace', [], { height: '.75em' });
            mpadded = parser.create('node', 'mpadded', [bottom, bstrut], def);
            tex_NodeUtil.setAttribute(mpadded, 'voffset', '.15em');
            tex_NodeUtil.setAttribute(mpadded, 'depth', '-.15em');
            tex_NodeUtil.setChild(mml, mml.under, mpadded);
        }
        tex_NodeUtil.setProperty(mml, 'subsupOK', true);
        parser.Push(mml);
    },
    HandleShove(parser, _name, shove) {
        const top = parser.stack.Top();
        if (top.kind !== 'multline') {
            throw new tex_TexError('CommandOnlyAllowedInEnv', '%1 only allowed in %2 environment', parser.currentCS, 'multline');
        }
        if (top.Size()) {
            throw new tex_TexError('CommandAtTheBeginingOfLine', '%1 must come at the beginning of the line', parser.currentCS);
        }
        top.setProperty('shove', shove);
    },
    CFrac(parser, name) {
        let lr = UnitUtil.trimSpaces(parser.GetBrackets(name, ''));
        const num = parser.GetArgument(name);
        const den = parser.GetArgument(name);
        const lrMap = {
            l: TexConstant.Align.LEFT,
            r: TexConstant.Align.RIGHT,
            '': '',
        };
        const numNode = new TexParser('\\strut\\textstyle{' + num + '}', parser.stack.env, parser.configuration).mml();
        const denNode = new TexParser('\\strut\\textstyle{' + den + '}', parser.stack.env, parser.configuration).mml();
        const frac = parser.create('node', 'mfrac', [numNode, denNode]);
        lr = lrMap[lr];
        if (lr == null) {
            throw new tex_TexError('IllegalAlign', 'Illegal alignment specified in %1', parser.currentCS);
        }
        if (lr) {
            tex_NodeUtil.setProperties(frac, { numalign: lr, denomalign: lr });
        }
        parser.Push(frac);
    },
    Genfrac(parser, name, left, right, thick, style) {
        if (left == null) {
            left = parser.GetDelimiterArg(name);
        }
        if (right == null) {
            right = parser.GetDelimiterArg(name);
        }
        if (thick == null) {
            thick = parser.GetArgument(name);
        }
        if (style == null) {
            style = UnitUtil.trimSpaces(parser.GetArgument(name));
        }
        const num = parser.ParseArg(name);
        const den = parser.ParseArg(name);
        let frac = parser.create('node', 'mfrac', [num, den]);
        if (thick !== '') {
            tex_NodeUtil.setAttribute(frac, 'linethickness', thick);
        }
        if (left || right) {
            tex_NodeUtil.setProperty(frac, 'withDelims', true);
            frac = ParseUtil.fixedFence(parser.configuration, left, frac, right);
        }
        if (style !== '') {
            const styleDigit = parseInt(style, 10);
            const styleAlpha = ['D', 'T', 'S', 'SS'][styleDigit];
            if (styleAlpha == null) {
                throw new tex_TexError('BadMathStyleFor', 'Bad math style for %1', parser.currentCS);
            }
            frac = parser.create('node', 'mstyle', [frac]);
            if (styleAlpha === 'D') {
                tex_NodeUtil.setProperties(frac, { displaystyle: true, scriptlevel: 0 });
            }
            else {
                tex_NodeUtil.setProperties(frac, {
                    displaystyle: false,
                    scriptlevel: styleDigit - 1,
                });
            }
        }
        parser.Push(frac);
    },
    HandleTag(parser, name) {
        if (!parser.tags.currentTag.taggable && parser.tags.env) {
            throw new tex_TexError('CommandNotAllowedInEnv', '%1 not allowed in %2 environment', parser.currentCS, parser.tags.env);
        }
        if (parser.tags.currentTag.tag) {
            throw new tex_TexError('MultipleCommand', 'Multiple %1', parser.currentCS);
        }
        const star = parser.GetStar();
        const tagId = UnitUtil.trimSpaces(parser.GetArgument(name));
        parser.tags.tag(tagId, star);
        parser.Push(parser.itemFactory.create('null'));
    },
    HandleNoTag: base_BaseMethods.HandleNoTag,
    HandleRef: base_BaseMethods.HandleRef,
    Macro: base_BaseMethods.Macro,
    Accent: base_BaseMethods.Accent,
    Tilde: base_BaseMethods.Tilde,
    Array: base_BaseMethods.Array,
    Spacer: base_BaseMethods.Spacer,
    NamedOp: base_BaseMethods.NamedOp,
    EqnArray: base_BaseMethods.EqnArray,
    Equation: base_BaseMethods.Equation,
};
//# sourceMappingURL=AmsMethods.js.map
;// ./mjs/input/tex/ams/AmsMappings.js







new CharacterMap('AMSmath-mathchar0mo', tex_ParseMethods.mathchar0mo, {
    iiiint: ['\u2A0C', { texClass: TEXCLASS.OP }],
});
new RegExpMap('AMSmath-operatorLetter', AmsMethods.operatorLetter, /[-*]/i);
new CommandMap('AMSmath-macros', {
    mathring: [AmsMethods.Accent, '02DA'],
    nobreakspace: AmsMethods.Tilde,
    negmedspace: [AmsMethods.Spacer, MATHSPACE.negativemediummathspace],
    negthickspace: [AmsMethods.Spacer, MATHSPACE.negativethickmathspace],
    idotsint: [AmsMethods.MultiIntegral, '\\int\\cdots\\int'],
    dddot: [AmsMethods.Accent, '20DB'],
    ddddot: [AmsMethods.Accent, '20DC'],
    sideset: AmsMethods.SideSet,
    boxed: [AmsMethods.Macro, '\\fbox{$\\displaystyle{#1}$}', 1],
    tag: AmsMethods.HandleTag,
    notag: AmsMethods.HandleNoTag,
    eqref: [AmsMethods.HandleRef, true],
    substack: [AmsMethods.Macro, '\\begin{subarray}{c}#1\\end{subarray}', 1],
    injlim: [AmsMethods.NamedOp, 'inj&thinsp;lim'],
    projlim: [AmsMethods.NamedOp, 'proj&thinsp;lim'],
    varliminf: [AmsMethods.Macro, '\\mathop{\\underline{\\mmlToken{mi}{lim}}}'],
    varlimsup: [AmsMethods.Macro, '\\mathop{\\overline{\\mmlToken{mi}{lim}}}'],
    varinjlim: [
        AmsMethods.Macro,
        '\\mathop{\\underrightarrow{\\mmlToken{mi}{lim}}}',
    ],
    varprojlim: [
        AmsMethods.Macro,
        '\\mathop{\\underleftarrow{\\mmlToken{mi}{lim}}}',
    ],
    DeclareMathOperator: AmsMethods.HandleDeclareOp,
    operatorname: AmsMethods.HandleOperatorName,
    genfrac: AmsMethods.Genfrac,
    frac: [AmsMethods.Genfrac, '', '', '', ''],
    tfrac: [AmsMethods.Genfrac, '', '', '', '1'],
    dfrac: [AmsMethods.Genfrac, '', '', '', '0'],
    binom: [AmsMethods.Genfrac, '(', ')', '0', ''],
    tbinom: [AmsMethods.Genfrac, '(', ')', '0', '1'],
    dbinom: [AmsMethods.Genfrac, '(', ')', '0', '0'],
    cfrac: AmsMethods.CFrac,
    shoveleft: [AmsMethods.HandleShove, TexConstant.Align.LEFT],
    shoveright: [AmsMethods.HandleShove, TexConstant.Align.RIGHT],
    xrightarrow: [AmsMethods.xArrow, 0x2192, 5, 10],
    xleftarrow: [AmsMethods.xArrow, 0x2190, 10, 5],
});
new EnvironmentMap('AMSmath-environment', tex_ParseMethods.environment, {
    'equation*': [AmsMethods.Equation, null, false],
    'eqnarray*': [
        AmsMethods.EqnArray,
        null,
        false,
        true,
        'rcl',
        'bmt',
        ParseUtil.cols(0, MATHSPACE.thickmathspace),
        '.5em',
    ],
    align: [
        AmsMethods.EqnArray,
        null,
        true,
        true,
        'rl',
        'bt',
        ParseUtil.cols(0, 2),
    ],
    'align*': [
        AmsMethods.EqnArray,
        null,
        false,
        true,
        'rl',
        'bt',
        ParseUtil.cols(0, 2),
    ],
    multline: [AmsMethods.Multline, null, true],
    'multline*': [AmsMethods.Multline, null, false],
    split: [
        AmsMethods.EqnArray,
        null,
        false,
        false,
        'rl',
        'bt',
        ParseUtil.cols(0),
    ],
    gather: [AmsMethods.EqnArray, null, true, true, 'c', 'm'],
    'gather*': [AmsMethods.EqnArray, null, false, true, 'c', 'm'],
    alignat: [AmsMethods.AlignAt, null, true, true],
    'alignat*': [AmsMethods.AlignAt, null, false, true],
    alignedat: [AmsMethods.AlignAt, null, false, false],
    aligned: [
        AmsMethods.AmsEqnArray,
        null,
        null,
        null,
        'rl',
        'bt',
        ParseUtil.cols(0, 2),
        '.5em',
        'D',
    ],
    gathered: [
        AmsMethods.AmsEqnArray,
        null,
        null,
        null,
        'c',
        'm',
        null,
        '.5em',
        'D',
    ],
    xalignat: [AmsMethods.XalignAt, null, true, true],
    'xalignat*': [AmsMethods.XalignAt, null, false, true],
    xxalignat: [AmsMethods.XalignAt, null, false, false],
    flalign: [
        AmsMethods.FlalignArray,
        null,
        true,
        false,
        true,
        'rlc',
        'btm',
        'auto auto fit',
    ],
    'flalign*': [
        AmsMethods.FlalignArray,
        null,
        false,
        false,
        true,
        'rlc',
        'btm',
        'auto auto fit',
    ],
    subarray: [
        AmsMethods.Array,
        null,
        null,
        null,
        null,
        ParseUtil.cols(0),
        '0.1em',
        'S',
        true,
    ],
    smallmatrix: [
        AmsMethods.Array,
        null,
        null,
        null,
        'c',
        ParseUtil.cols(1 / 3),
        '.2em',
        'S',
        true,
    ],
    matrix: [AmsMethods.Array, null, null, null, 'c'],
    pmatrix: [AmsMethods.Array, null, '(', ')', 'c'],
    bmatrix: [AmsMethods.Array, null, '[', ']', 'c'],
    Bmatrix: [AmsMethods.Array, null, '\\{', '\\}', 'c'],
    vmatrix: [AmsMethods.Array, null, '\\vert', '\\vert', 'c'],
    Vmatrix: [AmsMethods.Array, null, '\\Vert', '\\Vert', 'c'],
    cases: [AmsMethods.Array, null, '\\{', '.', 'll', null, '.2em', 'T'],
});
new DelimiterMap('AMSmath-delimiter', tex_ParseMethods.delimiter, {
    '\\lvert': ['\u007C', { texClass: TEXCLASS.OPEN }],
    '\\rvert': ['\u007C', { texClass: TEXCLASS.CLOSE }],
    '\\lVert': ['\u2016', { texClass: TEXCLASS.OPEN }],
    '\\rVert': ['\u2016', { texClass: TEXCLASS.CLOSE }],
});
new CharacterMap('AMSsymbols-mathchar0mi', tex_ParseMethods.mathchar0mi, {
    digamma: '\u03DD',
    varkappa: '\u03F0',
    varGamma: ['\u0393', { mathvariant: TexConstant.Variant.ITALIC }],
    varDelta: ['\u0394', { mathvariant: TexConstant.Variant.ITALIC }],
    varTheta: ['\u0398', { mathvariant: TexConstant.Variant.ITALIC }],
    varLambda: ['\u039B', { mathvariant: TexConstant.Variant.ITALIC }],
    varXi: ['\u039E', { mathvariant: TexConstant.Variant.ITALIC }],
    varPi: ['\u03A0', { mathvariant: TexConstant.Variant.ITALIC }],
    varSigma: ['\u03A3', { mathvariant: TexConstant.Variant.ITALIC }],
    varUpsilon: ['\u03A5', { mathvariant: TexConstant.Variant.ITALIC }],
    varPhi: ['\u03A6', { mathvariant: TexConstant.Variant.ITALIC }],
    varPsi: ['\u03A8', { mathvariant: TexConstant.Variant.ITALIC }],
    varOmega: ['\u03A9', { mathvariant: TexConstant.Variant.ITALIC }],
    beth: '\u2136',
    gimel: '\u2137',
    daleth: '\u2138',
    backprime: ['\u2035', { variantForm: true }],
    hslash: '\u210F',
    varnothing: ['\u2205', { variantForm: true }],
    blacktriangle: '\u25B4',
    triangledown: ['\u25BD', { variantForm: true }],
    blacktriangledown: '\u25BE',
    square: '\u25FB',
    Box: '\u25FB',
    blacksquare: '\u25FC',
    lozenge: '\u25CA',
    Diamond: '\u25CA',
    blacklozenge: '\u29EB',
    circledS: ['\u24C8', { mathvariant: TexConstant.Variant.NORMAL }],
    bigstar: '\u2605',
    sphericalangle: '\u2222',
    measuredangle: '\u2221',
    nexists: '\u2204',
    complement: '\u2201',
    mho: '\u2127',
    eth: ['\u00F0', { mathvariant: TexConstant.Variant.NORMAL }],
    Finv: '\u2132',
    diagup: '\u2571',
    Game: '\u2141',
    diagdown: '\u2572',
    Bbbk: ['\u006B', { mathvariant: TexConstant.Variant.DOUBLESTRUCK }],
    yen: '\u00A5',
    circledR: '\u00AE',
    checkmark: '\u2713',
    maltese: '\u2720',
});
new CharacterMap('AMSsymbols-mathchar0mo', tex_ParseMethods.mathchar0mo, {
    dotplus: '\u2214',
    ltimes: '\u22C9',
    smallsetminus: ['\u2216', { variantForm: true }],
    rtimes: '\u22CA',
    Cap: '\u22D2',
    doublecap: '\u22D2',
    leftthreetimes: '\u22CB',
    Cup: '\u22D3',
    doublecup: '\u22D3',
    rightthreetimes: '\u22CC',
    barwedge: '\u22BC',
    curlywedge: '\u22CF',
    veebar: '\u22BB',
    curlyvee: '\u22CE',
    doublebarwedge: '\u2A5E',
    boxminus: '\u229F',
    circleddash: '\u229D',
    boxtimes: '\u22A0',
    circledast: '\u229B',
    boxdot: '\u22A1',
    circledcirc: '\u229A',
    boxplus: '\u229E',
    centerdot: ['\u22C5', { variantForm: true }],
    divideontimes: '\u22C7',
    intercal: '\u22BA',
    leqq: '\u2266',
    geqq: '\u2267',
    leqslant: '\u2A7D',
    geqslant: '\u2A7E',
    eqslantless: '\u2A95',
    eqslantgtr: '\u2A96',
    lesssim: '\u2272',
    gtrsim: '\u2273',
    lessapprox: '\u2A85',
    gtrapprox: '\u2A86',
    approxeq: '\u224A',
    lessdot: '\u22D6',
    gtrdot: '\u22D7',
    lll: '\u22D8',
    llless: '\u22D8',
    ggg: '\u22D9',
    gggtr: '\u22D9',
    lessgtr: '\u2276',
    gtrless: '\u2277',
    lesseqgtr: '\u22DA',
    gtreqless: '\u22DB',
    lesseqqgtr: '\u2A8B',
    gtreqqless: '\u2A8C',
    doteqdot: '\u2251',
    Doteq: '\u2251',
    eqcirc: '\u2256',
    risingdotseq: '\u2253',
    circeq: '\u2257',
    fallingdotseq: '\u2252',
    triangleq: '\u225C',
    backsim: '\u223D',
    thicksim: ['\u223C', { variantForm: true }],
    backsimeq: '\u22CD',
    thickapprox: ['\u2248', { variantForm: true }],
    subseteqq: '\u2AC5',
    supseteqq: '\u2AC6',
    Subset: '\u22D0',
    Supset: '\u22D1',
    sqsubset: '\u228F',
    sqsupset: '\u2290',
    preccurlyeq: '\u227C',
    succcurlyeq: '\u227D',
    curlyeqprec: '\u22DE',
    curlyeqsucc: '\u22DF',
    precsim: '\u227E',
    succsim: '\u227F',
    precapprox: '\u2AB7',
    succapprox: '\u2AB8',
    vartriangleleft: '\u22B2',
    lhd: '\u22B2',
    vartriangleright: '\u22B3',
    rhd: '\u22B3',
    trianglelefteq: '\u22B4',
    unlhd: '\u22B4',
    trianglerighteq: '\u22B5',
    unrhd: '\u22B5',
    vDash: '\u22A8',
    Vdash: '\u22A9',
    Vvdash: '\u22AA',
    smallsmile: ['\u2323', { variantForm: true }],
    shortmid: ['\u2223', { variantForm: true }],
    smallfrown: ['\u2322', { variantForm: true }],
    shortparallel: ['\u2225', { variantForm: true }],
    bumpeq: '\u224F',
    between: '\u226C',
    Bumpeq: '\u224E',
    pitchfork: '\u22D4',
    varpropto: ['\u221D', { variantForm: true }],
    backepsilon: '\u220D',
    blacktriangleleft: '\u25C2',
    blacktriangleright: '\u25B8',
    therefore: '\u2234',
    because: '\u2235',
    eqsim: '\u2242',
    vartriangle: ['\u25B3', { variantForm: true }],
    Join: '\u22C8',
    nless: '\u226E',
    ngtr: '\u226F',
    nleq: '\u2270',
    ngeq: '\u2271',
    nleqslant: ['\u2A87', { variantForm: true }],
    ngeqslant: ['\u2A88', { variantForm: true }],
    nleqq: ['\u2270', { variantForm: true }],
    ngeqq: ['\u2271', { variantForm: true }],
    lneq: '\u2A87',
    gneq: '\u2A88',
    lneqq: '\u2268',
    gneqq: '\u2269',
    lvertneqq: ['\u2268', { variantForm: true }],
    gvertneqq: ['\u2269', { variantForm: true }],
    lnsim: '\u22E6',
    gnsim: '\u22E7',
    lnapprox: '\u2A89',
    gnapprox: '\u2A8A',
    nprec: '\u2280',
    nsucc: '\u2281',
    npreceq: ['\u22E0', { variantForm: true }],
    nsucceq: ['\u22E1', { variantForm: true }],
    precneqq: '\u2AB5',
    succneqq: '\u2AB6',
    precnsim: '\u22E8',
    succnsim: '\u22E9',
    precnapprox: '\u2AB9',
    succnapprox: '\u2ABA',
    nsim: '\u2241',
    ncong: '\u2247',
    nshortmid: ['\u2224', { variantForm: true }],
    nshortparallel: ['\u2226', { variantForm: true }],
    nmid: '\u2224',
    nparallel: '\u2226',
    nvdash: '\u22AC',
    nvDash: '\u22AD',
    nVdash: '\u22AE',
    nVDash: '\u22AF',
    ntriangleleft: '\u22EA',
    ntriangleright: '\u22EB',
    ntrianglelefteq: '\u22EC',
    ntrianglerighteq: '\u22ED',
    nsubseteq: '\u2288',
    nsupseteq: '\u2289',
    nsubseteqq: ['\u2288', { variantForm: true }],
    nsupseteqq: ['\u2289', { variantForm: true }],
    subsetneq: '\u228A',
    supsetneq: '\u228B',
    varsubsetneq: ['\u228A', { variantForm: true }],
    varsupsetneq: ['\u228B', { variantForm: true }],
    subsetneqq: '\u2ACB',
    supsetneqq: '\u2ACC',
    varsubsetneqq: ['\u2ACB', { variantForm: true }],
    varsupsetneqq: ['\u2ACC', { variantForm: true }],
    leftleftarrows: '\u21C7',
    rightrightarrows: '\u21C9',
    leftrightarrows: '\u21C6',
    rightleftarrows: '\u21C4',
    Lleftarrow: '\u21DA',
    Rrightarrow: '\u21DB',
    twoheadleftarrow: '\u219E',
    twoheadrightarrow: '\u21A0',
    leftarrowtail: '\u21A2',
    rightarrowtail: '\u21A3',
    looparrowleft: '\u21AB',
    looparrowright: '\u21AC',
    leftrightharpoons: '\u21CB',
    rightleftharpoons: ['\u21CC', { variantForm: true }],
    curvearrowleft: '\u21B6',
    curvearrowright: '\u21B7',
    circlearrowleft: '\u21BA',
    circlearrowright: '\u21BB',
    Lsh: '\u21B0',
    Rsh: '\u21B1',
    upuparrows: '\u21C8',
    downdownarrows: '\u21CA',
    upharpoonleft: '\u21BF',
    upharpoonright: '\u21BE',
    downharpoonleft: '\u21C3',
    restriction: '\u21BE',
    multimap: '\u22B8',
    downharpoonright: '\u21C2',
    leftrightsquigarrow: '\u21AD',
    rightsquigarrow: '\u21DD',
    leadsto: '\u21DD',
    dashrightarrow: '\u21E2',
    dashleftarrow: '\u21E0',
    nleftarrow: '\u219A',
    nrightarrow: '\u219B',
    nLeftarrow: '\u21CD',
    nRightarrow: '\u21CF',
    nleftrightarrow: '\u21AE',
    nLeftrightarrow: '\u21CE',
});
new DelimiterMap('AMSsymbols-delimiter', tex_ParseMethods.delimiter, {
    '\\ulcorner': '\u231C',
    '\\urcorner': '\u231D',
    '\\llcorner': '\u231E',
    '\\lrcorner': '\u231F',
});
new CommandMap('AMSsymbols-macros', {
    implies: [AmsMethods.Macro, '\\;\\Longrightarrow\\;'],
    impliedby: [AmsMethods.Macro, '\\;\\Longleftarrow\\;'],
});
//# sourceMappingURL=AmsMappings.js.map
;// ./mjs/input/tex/newcommand/NewcommandItems.js


class BeginEnvItem extends BaseItem {
    get kind() {
        return 'beginEnv';
    }
    get isOpen() {
        return true;
    }
    checkItem(item) {
        if (item.isKind('end')) {
            if (item.getName() !== this.getName()) {
                throw new tex_TexError('EnvBadEnd', '\\begin{%1} ended with \\end{%2}', this.getName(), item.getName());
            }
            return [[this.factory.create('mml', this.toMml())], true];
        }
        if (item.isKind('stop')) {
            throw new tex_TexError('EnvMissingEnd', 'Missing \\end{%1}', this.getName());
        }
        return super.checkItem(item);
    }
}
//# sourceMappingURL=NewcommandItems.js.map
;// ./mjs/input/tex/newcommand/NewcommandMethods.js







const NewcommandMethods = {
    NewCommand(parser, name) {
        const cs = NewcommandUtil.GetCsNameArgument(parser, name);
        const n = NewcommandUtil.GetArgCount(parser, name);
        const opt = parser.GetBrackets(name);
        const def = parser.GetArgument(name);
        NewcommandUtil.addMacro(parser, cs, NewcommandMethods.Macro, [def, n, opt]);
        parser.Push(parser.itemFactory.create('null'));
    },
    NewEnvironment(parser, name) {
        const env = UnitUtil.trimSpaces(parser.GetArgument(name));
        const n = NewcommandUtil.GetArgCount(parser, name);
        const opt = parser.GetBrackets(name);
        const bdef = parser.GetArgument(name);
        const edef = parser.GetArgument(name);
        NewcommandUtil.addEnvironment(parser, env, NewcommandMethods.BeginEnv, [
            true,
            bdef,
            edef,
            n,
            opt,
        ]);
        parser.Push(parser.itemFactory.create('null'));
    },
    MacroDef(parser, name) {
        const cs = NewcommandUtil.GetCSname(parser, name);
        const params = NewcommandUtil.GetTemplate(parser, name, '\\' + cs);
        const def = parser.GetArgument(name);
        !(params instanceof Array)
            ?
                NewcommandUtil.addMacro(parser, cs, NewcommandMethods.Macro, [
                    def,
                    params,
                ])
            :
                NewcommandUtil.addMacro(parser, cs, NewcommandMethods.MacroWithTemplate, [def].concat(params));
        parser.Push(parser.itemFactory.create('null'));
    },
    Let(parser, name) {
        const cs = NewcommandUtil.GetCSname(parser, name);
        let c = parser.GetNext();
        if (c === '=') {
            parser.i++;
            c = parser.GetNext();
        }
        const handlers = parser.configuration.handlers;
        parser.Push(parser.itemFactory.create('null'));
        if (c === '\\') {
            name = NewcommandUtil.GetCSname(parser, name);
            if (cs === name) {
                return;
            }
            const map = handlers.get(HandlerType.MACRO).applicable(name);
            if (map instanceof MacroMap) {
                const macro = map.lookup(name);
                NewcommandUtil.addMacro(parser, cs, macro.func, macro.args, macro.token);
                return;
            }
            if (map instanceof CharacterMap && !(map instanceof DelimiterMap)) {
                const macro = map.lookup(name);
                const method = (p) => map.parser(p, macro);
                NewcommandUtil.addMacro(parser, cs, method, [cs, macro.char]);
                return;
            }
            const macro = handlers
                .get(HandlerType.DELIMITER)
                .lookup('\\' + name);
            if (macro) {
                NewcommandUtil.addDelimiter(parser, '\\' + cs, macro.char, macro.attributes);
                return;
            }
            NewcommandUtil.checkProtectedMacros(parser, cs);
            NewcommandUtil.undefineMacro(parser, cs);
            NewcommandUtil.undefineDelimiter(parser, '\\' + cs);
            return;
        }
        parser.i++;
        const macro = handlers.get(HandlerType.DELIMITER).lookup(c);
        if (macro) {
            NewcommandUtil.addDelimiter(parser, '\\' + cs, macro.char, macro.attributes);
            return;
        }
        NewcommandUtil.addMacro(parser, cs, NewcommandMethods.Macro, [c]);
    },
    MacroWithTemplate(parser, name, text, n, ...params) {
        const argCount = parseInt(n, 10);
        if (params.length) {
            const args = [];
            parser.GetNext();
            if (params[0] && !NewcommandUtil.MatchParam(parser, params[0])) {
                throw new tex_TexError('MismatchUseDef', "Use of %1 doesn't match its definition", name);
            }
            if (argCount) {
                for (let i = 0; i < argCount; i++) {
                    args.push(NewcommandUtil.GetParameter(parser, name, params[i + 1]));
                }
                text = ParseUtil.substituteArgs(parser, args, text);
            }
        }
        parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
        parser.i = 0;
        ParseUtil.checkMaxMacros(parser);
    },
    BeginEnv(parser, begin, bdef, edef, n, def) {
        const name = begin.getName();
        if (parser.stack.env['closing'] === name) {
            delete parser.stack.env['closing'];
            const beginN = parser.stack.global['beginEnv'];
            if (beginN) {
                parser.stack.global['beginEnv']--;
                if (edef) {
                    const rest = parser.string.slice(parser.i);
                    parser.string = ParseUtil.addArgs(parser, parser.string.substring(0, parser.i), edef);
                    parser.Parse();
                    parser.string = rest;
                    parser.i = 0;
                }
            }
            return parser.itemFactory.create('end').setProperty('name', name);
        }
        if (n) {
            const args = [];
            if (def != null) {
                const optional = parser.GetBrackets(`\\begin{${name}}`);
                args.push(optional == null ? def : optional);
            }
            for (let i = args.length; i < n; i++) {
                args.push(parser.GetArgument(`\\begin{${name}}`));
            }
            bdef = ParseUtil.substituteArgs(parser, args, bdef);
            edef = ParseUtil.substituteArgs(parser, [], edef);
        }
        parser.string = ParseUtil.addArgs(parser, bdef, parser.string.slice(parser.i));
        parser.i = 0;
        parser.stack.global['beginEnv'] =
            (parser.stack.global['beginEnv'] || 0) + 1;
        return parser.itemFactory.create('beginEnv').setProperty('name', name);
    },
    Macro: base_BaseMethods.Macro,
};
/* harmony default export */ const newcommand_NewcommandMethods = (NewcommandMethods);
//# sourceMappingURL=NewcommandMethods.js.map
;// ./mjs/input/tex/newcommand/NewcommandMappings.js


new CommandMap('Newcommand-macros', {
    newcommand: newcommand_NewcommandMethods.NewCommand,
    renewcommand: newcommand_NewcommandMethods.NewCommand,
    newenvironment: newcommand_NewcommandMethods.NewEnvironment,
    renewenvironment: newcommand_NewcommandMethods.NewEnvironment,
    def: newcommand_NewcommandMethods.MacroDef,
    let: newcommand_NewcommandMethods.Let,
});
//# sourceMappingURL=NewcommandMappings.js.map
;// ./mjs/input/tex/newcommand/NewcommandConfiguration.js







function NewcommandConfig(_config, jax) {
    if (jax.parseOptions.packageData.has('newcommand')) {
        return;
    }
    jax.parseOptions.packageData.set('newcommand', {});
    new DelimiterMap(NewcommandTables.NEW_DELIMITER, tex_ParseMethods.delimiter, {});
    new CommandMap(NewcommandTables.NEW_COMMAND, {});
    new EnvironmentMap(NewcommandTables.NEW_ENVIRONMENT, tex_ParseMethods.environment, {});
    jax.parseOptions.handlers.add({
        [HandlerType.CHARACTER]: [],
        [HandlerType.DELIMITER]: [NewcommandTables.NEW_DELIMITER],
        [HandlerType.MACRO]: [
            NewcommandTables.NEW_DELIMITER,
            NewcommandTables.NEW_COMMAND,
        ],
        [HandlerType.ENVIRONMENT]: [NewcommandTables.NEW_ENVIRONMENT],
    }, {}, NewcommandPriority);
}
const NewcommandConfiguration = Configuration.create('newcommand', {
    [ConfigurationType.HANDLER]: {
        macro: ['Newcommand-macros'],
    },
    [ConfigurationType.ITEMS]: {
        [BeginEnvItem.prototype.kind]: BeginEnvItem,
    },
    [ConfigurationType.OPTIONS]: {
        maxMacros: 1000,
        protectedMacros: ['begingroupSandbox'],
    },
    [ConfigurationType.CONFIG]: NewcommandConfig,
});
//# sourceMappingURL=NewcommandConfiguration.js.map
;// ./mjs/input/tex/ams/AmsConfiguration.js






class AmsTags extends AbstractTags {
}
const AmsConfiguration = Configuration.create('ams', {
    [ConfigurationType.HANDLER]: {
        [HandlerType.CHARACTER]: ['AMSmath-operatorLetter'],
        [HandlerType.DELIMITER]: ['AMSsymbols-delimiter', 'AMSmath-delimiter'],
        [HandlerType.MACRO]: [
            'AMSsymbols-mathchar0mi',
            'AMSsymbols-mathchar0mo',
            'AMSsymbols-delimiter',
            'AMSsymbols-macros',
            'AMSmath-mathchar0mo',
            'AMSmath-macros',
            'AMSmath-delimiter',
        ],
        [HandlerType.ENVIRONMENT]: ['AMSmath-environment'],
    },
    [ConfigurationType.ITEMS]: {
        [MultlineItem.prototype.kind]: MultlineItem,
        [FlalignItem.prototype.kind]: FlalignItem,
    },
    [ConfigurationType.TAGS]: { ams: AmsTags },
    [ConfigurationType.OPTIONS]: {
        multlineWidth: '',
        ams: {
            operatornamePattern: /^[-*a-zA-Z]+/,
            multlineWidth: '100%',
            multlineIndent: '1em',
        },
    },
    [ConfigurationType.CONFIG]: NewcommandConfig,
});
//# sourceMappingURL=AmsConfiguration.js.map
;// ./mjs/input/tex/require/RequireConfiguration.js









const MJCONFIG = startup_MathJax.config;
function RegisterExtension(jax, name) {
    const require = jax.parseOptions.options.require;
    const required = jax.parseOptions.packageData.get('require')
        .required;
    const extension = name.substring(require.prefix.length);
    if (!required.includes(extension)) {
        required.push(extension);
        const retry = RegisterDependencies(jax, CONFIG.dependencies[name]);
        if (retry) {
            mathjax.retryAfter(retry.then(() => ProcessExtension(jax, name, extension)));
        }
        else {
            ProcessExtension(jax, name, extension);
        }
    }
}
function ProcessExtension(jax, name, extension) {
    const handler = ConfigurationHandler.get(extension);
    if (handler) {
        let options = MJCONFIG[name] || {};
        if (handler.options &&
            Object.keys(handler.options).length === 1 &&
            handler.options[extension]) {
            options = { [extension]: options };
        }
        jax.configuration.add(extension, jax, options);
        const configured = jax.parseOptions.packageData.get('require').configured;
        if (handler.preprocessors.length && !configured.has(extension)) {
            configured.set(extension, true);
            mathjax.retryAfter(Promise.resolve());
        }
    }
}
function RegisterDependencies(jax, names = []) {
    const prefix = jax.parseOptions.options.require.prefix;
    const retries = [];
    for (const name of names) {
        if (name.substring(0, prefix.length) === prefix) {
            try {
                RegisterExtension(jax, name);
            }
            catch (err) {
                if (!err.retry)
                    throw err;
                retries.push(err.retry);
            }
        }
    }
    return retries.length ? Promise.all(retries) : null;
}
function RequireLoad(parser, name) {
    var _a, _b;
    const options = parser.options.require;
    const allow = options.allow;
    const extension = (name.substring(0, 1) === '[' ? '' : options.prefix) + name;
    const allowed = Object.hasOwn(allow, extension)
        ? allow[extension]
        : Object.hasOwn(allow, name)
            ? allow[name]
            : options.defaultAllow;
    if (!allowed) {
        throw new tex_TexError('BadRequire', 'Extension "%1" is not allowed to be loaded', extension);
    }
    const data = Package.packages.get(extension);
    if (!data) {
        mathjax.retryAfter(Loader.load(extension).catch((_) => { }));
    }
    if (data.hasFailed) {
        throw new tex_TexError('RequireFail', 'Extension "%1" failed to load', name);
    }
    const require = (_a = CONFIG[extension]) === null || _a === void 0 ? void 0 : _a.rendererExtensions;
    const menu = (_b = startup_MathJax.startup.document) === null || _b === void 0 ? void 0 : _b.menu;
    if (require && menu) {
        menu.addRequiredExtensions(require);
    }
    RegisterExtension(parser.configuration.packageData.get('require').jax, extension);
}
function RequireConfiguration_config(_config, jax) {
    jax.parseOptions.packageData.set('require', {
        jax: jax,
        required: [...jax.options.packages],
        configured: new Map()
    });
    const options = jax.parseOptions.options.require;
    const prefix = options.prefix;
    if (prefix.match(/[^_a-zA-Z0-9]/)) {
        throw Error('Illegal characters used in \\require prefix');
    }
    if (!CONFIG.paths[prefix]) {
        CONFIG.paths[prefix] = '[mathjax]/input/tex/extensions';
    }
    options.prefix = '[' + prefix + ']/';
}
const RequireMethods = {
    Require(parser, name) {
        const required = parser.GetArgument(name);
        if (required.match(/[^_a-zA-Z0-9]/) || required === '') {
            throw new tex_TexError('BadPackageName', 'Argument for %1 is not a valid package name', name);
        }
        RequireLoad(parser, required);
        parser.Push(parser.itemFactory.create('null'));
    },
};
const RequireConfiguration_options = {
    require: {
        allow: expandable({
            base: false,
            autoload: false,
            configmacros: false,
            tagformat: false,
            setoptions: false,
            texhtml: false,
        }),
        defaultAllow: true,
        prefix: 'tex',
    },
};
new CommandMap('require', { require: RequireMethods.Require });
const RequireConfiguration = Configuration.create('require', {
    [ConfigurationType.HANDLER]: {
        [HandlerType.MACRO]: ['require'],
    },
    [ConfigurationType.CONFIG]: RequireConfiguration_config,
    [ConfigurationType.OPTIONS]: RequireConfiguration_options,
});
//# sourceMappingURL=RequireConfiguration.js.map
;// ./mjs/input/tex/autoload/AutoloadConfiguration.js







function Autoload(parser, name, extension, isMacro) {
    if (Package.packages.has(parser.options.require.prefix + extension)) {
        const def = parser.options.autoload[extension];
        const [macros, envs] = def.length === 2 && Array.isArray(def[0]) ? def : [def, []];
        for (const macro of macros) {
            AutoloadMacros.remove(macro);
        }
        for (const env of envs) {
            AutoloadEnvironments.remove(env);
        }
        parser.string =
            (isMacro ? name + ' ' : '\\begin{' + name.slice(1) + '}') +
                parser.string.slice(parser.i);
        parser.i = 0;
    }
    RequireLoad(parser, extension);
}
function initAutoload(config) {
    if (!config.options.require) {
        defaultOptions(config.options, RequireConfiguration.options);
    }
}
function configAutoload(config, jax) {
    const parser = jax.parseOptions;
    const macros = parser.handlers.get(HandlerType.MACRO);
    const environments = parser.handlers.get(HandlerType.ENVIRONMENT);
    const autoload = parser.options.autoload;
    parser.packageData.set('autoload', { Autoload });
    for (const extension of Object.keys(autoload)) {
        const def = autoload[extension];
        const [macs, envs] = def.length === 2 && Array.isArray(def[0]) ? def : [def, []];
        for (const name of macs) {
            if (!macros.lookup(name) || name === 'color') {
                AutoloadMacros.add(name, new Macro(name, Autoload, [extension, true]));
            }
        }
        for (const name of envs) {
            if (!environments.lookup(name)) {
                AutoloadEnvironments.add(name, new Macro(name, Autoload, [extension, false]));
            }
        }
    }
    if (!parser.packageData.get('require')) {
        RequireConfiguration.config(config, jax);
    }
}
const AutoloadMacros = new CommandMap('autoload-macros', {});
const AutoloadEnvironments = new CommandMap('autoload-environments', {});
const AutoloadConfiguration = Configuration.create('autoload', {
    [ConfigurationType.HANDLER]: {
        [HandlerType.MACRO]: ['autoload-macros'],
        [HandlerType.ENVIRONMENT]: ['autoload-environments'],
    },
    [ConfigurationType.OPTIONS]: {
        autoload: expandable({
            action: ['toggle', 'mathtip', 'texttip'],
            amscd: [[], ['CD']],
            bbox: ['bbox'],
            boldsymbol: ['boldsymbol'],
            braket: [
                'bra',
                'ket',
                'braket',
                'set',
                'Bra',
                'Ket',
                'Braket',
                'Set',
                'ketbra',
                'Ketbra',
            ],
            bussproofs: [[], ['prooftree']],
            cancel: ['cancel', 'bcancel', 'xcancel', 'cancelto'],
            color: ['color', 'definecolor', 'textcolor', 'colorbox', 'fcolorbox'],
            enclose: ['enclose'],
            extpfeil: [
                'xtwoheadrightarrow',
                'xtwoheadleftarrow',
                'xmapsto',
                'xlongequal',
                'xtofrom',
                'Newextarrow',
            ],
            html: ['data', 'href', 'class', 'style', 'cssId'],
            mhchem: ['ce', 'pu'],
            newcommand: [
                'newcommand',
                'renewcommand',
                'newenvironment',
                'renewenvironment',
                'def',
                'let',
            ],
            unicode: ['unicode', 'U', 'char'],
            verb: ['verb'],
        }),
    },
    [ConfigurationType.CONFIG]: configAutoload,
    [ConfigurationType.INIT]: initAutoload,
    [ConfigurationType.PRIORITY]: 10,
});
//# sourceMappingURL=AutoloadConfiguration.js.map
;// ./mjs/input/tex/configmacros/ConfigMacrosConfiguration.js








const MACROSMAP = 'configmacros-map';
const ACTIVEMAP = 'configmacros-active-map';
const ENVIRONMENTMAP = 'configmacros-env-map';
function configmacrosInit(config) {
    new MacroMap(ACTIVEMAP, {});
    new CommandMap(MACROSMAP, {});
    new EnvironmentMap(ENVIRONMENTMAP, tex_ParseMethods.environment, {});
    config.append(Configuration.local({
        handler: {
            [HandlerType.CHARACTER]: [ACTIVEMAP],
            [HandlerType.MACRO]: [MACROSMAP],
            [HandlerType.ENVIRONMENT]: [ENVIRONMENTMAP],
        },
        priority: 3,
    }));
}
function configmacrosConfig(_config, jax) {
    configActives(jax);
    configMacros(jax);
    configEnvironments(jax);
}
function setMacros(name, map, jax) {
    const handler = jax.parseOptions.handlers.retrieve(map);
    const macros = jax.parseOptions.options[name];
    for (const cs of Object.keys(macros)) {
        const def = typeof macros[cs] === 'string' ? [macros[cs]] : macros[cs];
        const macro = Array.isArray(def[2])
            ? new Macro(cs, newcommand_NewcommandMethods.MacroWithTemplate, def.slice(0, 2).concat(def[2]))
            : new Macro(cs, newcommand_NewcommandMethods.Macro, def);
        handler.add(cs, macro);
    }
}
function configActives(jax) {
    setMacros('active', ACTIVEMAP, jax);
}
function configMacros(jax) {
    setMacros('macros', MACROSMAP, jax);
}
function configEnvironments(jax) {
    const handler = jax.parseOptions.handlers.retrieve(ENVIRONMENTMAP);
    const environments = jax.parseOptions.options.environments;
    for (const env of Object.keys(environments)) {
        handler.add(env, new Macro(env, newcommand_NewcommandMethods.BeginEnv, [true].concat(environments[env])));
    }
}
const ConfigMacrosConfiguration = Configuration.create('configmacros', {
    [ConfigurationType.INIT]: configmacrosInit,
    [ConfigurationType.CONFIG]: configmacrosConfig,
    [ConfigurationType.ITEMS]: {
        [BeginEnvItem.prototype.kind]: BeginEnvItem,
    },
    [ConfigurationType.OPTIONS]: {
        active: expandable({}),
        macros: expandable({}),
        environments: expandable({}),
    },
});
//# sourceMappingURL=ConfigMacrosConfiguration.js.map
;// ./mjs/input/tex/noundefined/NoUndefinedConfiguration.js


function noUndefined(parser, name) {
    const textNode = parser.create('text', '\\' + name);
    const options = parser.options.noundefined;
    const def = {};
    for (const id of ['color', 'background', 'size']) {
        if (options[id]) {
            def['math' + id] = options[id];
        }
    }
    parser.Push(parser.create('node', 'mtext', [], def, textNode));
}
const NoUndefinedConfiguration = Configuration.create('noundefined', {
    [ConfigurationType.FALLBACK]: { [HandlerType.MACRO]: noUndefined },
    [ConfigurationType.OPTIONS]: {
        noundefined: {
            color: 'red',
            background: '',
            size: '',
        },
    },
    [ConfigurationType.PRIORITY]: 3,
});
//# sourceMappingURL=NoUndefinedConfiguration.js.map
;// ./mjs/input/tex/textmacros/TextParser.js






class TextParser extends TexParser {
    get texParser() {
        return this.configuration.packageData.get('textmacros').texParser;
    }
    get tags() {
        return this.texParser.tags;
    }
    constructor(text, env, configuration, level) {
        super(text, env, configuration);
        this.level = level;
    }
    mml() {
        this.copyLists();
        this.configuration.popParser();
        return this.level != null
            ? this.create('node', 'mstyle', this.nodes, {
                displaystyle: false,
                scriptlevel: this.level,
            })
            : this.nodes.length === 1
                ? this.nodes[0]
                : this.create('node', 'mrow', this.nodes);
    }
    copyLists() {
        const parseOptions = this.texParser.configuration;
        for (const [name, list] of Object.entries(this.configuration.nodeLists)) {
            for (const node of list) {
                parseOptions.addNode(name, node);
            }
        }
        this.configuration.nodeLists = {};
    }
    Parse() {
        this.text = '';
        this.nodes = [];
        this.envStack = [];
        super.Parse();
    }
    saveText() {
        if (this.text) {
            const mathvariant = this.stack.env.mathvariant;
            const text = ParseUtil.internalText(this, this.text, mathvariant ? { mathvariant } : {});
            this.text = '';
            this.Push(text);
        }
    }
    Push(mml) {
        if (this.text) {
            this.saveText();
        }
        if (mml instanceof StopItem) {
            return super.Push(mml);
        }
        if (mml instanceof StyleItem) {
            this.stack.env.mathcolor = this.stack.env.color;
            return;
        }
        if (mml instanceof AbstractMmlNode) {
            this.addAttributes(mml);
            this.nodes.push(mml);
        }
    }
    PushMath(mml) {
        const env = this.stack.env;
        for (const name of ['mathsize', 'mathcolor']) {
            if (env[name] && !mml.attributes.hasExplicit(name)) {
                if (!mml.isToken && !mml.isKind('mstyle')) {
                    mml = this.create('node', 'mstyle', [mml]);
                }
                tex_NodeUtil.setAttribute(mml, name, env[name]);
            }
        }
        if (mml.isInferred) {
            mml = this.create('node', 'mrow', mml.childNodes);
        }
        if (!mml.isKind('TeXAtom')) {
            mml = this.create('node', 'TeXAtom', [mml]);
        }
        this.nodes.push(mml);
    }
    addAttributes(mml) {
        const env = this.stack.env;
        if (!mml.isToken)
            return;
        for (const name of ['mathsize', 'mathcolor', 'mathvariant']) {
            if (env[name] && !mml.attributes.hasExplicit(name)) {
                tex_NodeUtil.setAttribute(mml, name, env[name]);
            }
        }
    }
    ParseTextArg(name, env) {
        const text = this.GetArgument(name);
        env = Object.assign(Object.assign({}, this.stack.env), env);
        return new TextParser(text, env, this.configuration).mml();
    }
    ParseArg(name) {
        return new TextParser(this.GetArgument(name), this.stack.env, this.configuration).mml();
    }
    Error(id, message, ...args) {
        throw new tex_TexError(id, message, ...args);
    }
}
//# sourceMappingURL=TextParser.js.map
;// ./mjs/input/tex/textmacros/TextMacrosMethods.js




const TextMacrosMethods = {
    Comment(parser, _c) {
        while (parser.i < parser.string.length &&
            parser.string.charAt(parser.i) !== '\n') {
            parser.i++;
        }
        parser.i++;
    },
    Math(parser, open) {
        parser.saveText();
        const i = parser.i;
        let j, c;
        let braces = 0;
        while ((c = parser.GetNext())) {
            j = parser.i++;
            switch (c) {
                case '\\': {
                    const cs = parser.GetCS();
                    if (cs === ')')
                        c = '\\(';
                }
                case '$':
                    if (braces === 0 && open === c) {
                        const config = parser.texParser.configuration;
                        const mml = new TexParser(parser.string.substring(i, j), parser.stack.env, config).mml();
                        parser.PushMath(mml);
                        return;
                    }
                    break;
                case '{':
                    braces++;
                    break;
                case '}':
                    if (braces === 0) {
                        parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
                    }
                    braces--;
                    break;
            }
        }
        parser.Error('MathNotTerminated', 'Math mode is not properly terminated');
    },
    MathModeOnly(parser, c) {
        parser.Error('MathModeOnly', "'%1' allowed only in math mode", c);
    },
    Misplaced(parser, c) {
        parser.Error('Misplaced', "Misplaced '%1'", c);
    },
    OpenBrace(parser, _c) {
        const env = parser.stack.env;
        parser.envStack.push(env);
        parser.stack.env = Object.assign({}, env);
    },
    CloseBrace(parser, _c) {
        if (parser.envStack.length) {
            parser.saveText();
            parser.stack.env = parser.envStack.pop();
        }
        else {
            parser.Error('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
        }
    },
    OpenQuote(parser, c) {
        if (parser.string.charAt(parser.i) === c) {
            parser.text += '\u201C';
            parser.i++;
        }
        else {
            parser.text += '\u2018';
        }
    },
    CloseQuote(parser, c) {
        if (parser.string.charAt(parser.i) === c) {
            parser.text += '\u201D';
            parser.i++;
        }
        else {
            parser.text += '\u2019';
        }
    },
    Tilde(parser, _c) {
        parser.text += '\u00A0';
    },
    Space(parser, _c) {
        parser.text += ' ';
        parser.GetNext();
    },
    SelfQuote(parser, name) {
        parser.text += name.substring(1);
    },
    Insert(parser, _name, c) {
        parser.text += c;
    },
    Accent(parser, name, c) {
        const base = parser.ParseArg(name);
        const accent = parser.create('token', 'mo', {}, c);
        parser.addAttributes(accent);
        parser.Push(parser.create('node', 'mover', [base, accent]));
    },
    Emph(parser, name) {
        const variant = parser.stack.env.mathvariant === '-tex-mathit' ? 'normal' : '-tex-mathit';
        parser.Push(parser.ParseTextArg(name, { mathvariant: variant }));
    },
    TextFont(parser, name, variant) {
        parser.saveText();
        parser.Push(parser.ParseTextArg(name, { mathvariant: variant }));
    },
    SetFont(parser, _name, variant) {
        parser.saveText();
        parser.stack.env.mathvariant = variant;
    },
    SetSize(parser, _name, size) {
        parser.saveText();
        parser.stack.env.mathsize = size;
    },
    CheckAutoload(parser, name) {
        const autoload = parser.configuration.packageData.get('autoload');
        const texParser = parser.texParser;
        name = name.slice(1);
        const macro = texParser.lookup(HandlerType.MACRO, name);
        if (!macro || (autoload && macro._func === autoload.Autoload)) {
            texParser.parse(HandlerType.MACRO, [texParser, name]);
            if (!macro)
                return;
            retryAfter(Promise.resolve());
        }
        texParser.parse(HandlerType.MACRO, [parser, name]);
    },
    Macro: base_BaseMethods.Macro,
    Spacer: base_BaseMethods.Spacer,
    Hskip: base_BaseMethods.Hskip,
    rule: base_BaseMethods.rule,
    Rule: base_BaseMethods.Rule,
    HandleRef: base_BaseMethods.HandleRef,
    UnderOver: base_BaseMethods.UnderOver,
    Lap: base_BaseMethods.Lap,
    Phantom: base_BaseMethods.Phantom,
    Smash: base_BaseMethods.Smash,
    MmlToken: base_BaseMethods.MmlToken,
};
//# sourceMappingURL=TextMacrosMethods.js.map
;// ./mjs/input/tex/textmacros/TextMacrosMappings.js




const TextMacrosMappings_VARIANT = TexConstant.Variant;
new MacroMap('text-special', {
    $: TextMacrosMethods.Math,
    '%': TextMacrosMethods.Comment,
    '^': TextMacrosMethods.MathModeOnly,
    _: TextMacrosMethods.MathModeOnly,
    '&': TextMacrosMethods.Misplaced,
    '#': TextMacrosMethods.Misplaced,
    '~': TextMacrosMethods.Tilde,
    ' ': TextMacrosMethods.Space,
    '\t': TextMacrosMethods.Space,
    '\r': TextMacrosMethods.Space,
    '\n': TextMacrosMethods.Space,
    '\u00A0': TextMacrosMethods.Tilde,
    '{': TextMacrosMethods.OpenBrace,
    '}': TextMacrosMethods.CloseBrace,
    '`': TextMacrosMethods.OpenQuote,
    "'": TextMacrosMethods.CloseQuote,
});
new CommandMap('text-macros', {
    '(': TextMacrosMethods.Math,
    $: TextMacrosMethods.SelfQuote,
    _: TextMacrosMethods.SelfQuote,
    '%': TextMacrosMethods.SelfQuote,
    '{': TextMacrosMethods.SelfQuote,
    '}': TextMacrosMethods.SelfQuote,
    ' ': TextMacrosMethods.SelfQuote,
    '&': TextMacrosMethods.SelfQuote,
    '#': TextMacrosMethods.SelfQuote,
    '\\': [TextMacrosMethods.Macro, '$\\\\$'],
    "'": [TextMacrosMethods.Accent, '\u00B4'],
    '\u2019': [TextMacrosMethods.Accent, '\u00B4'],
    '`': [TextMacrosMethods.Accent, '\u0060'],
    '\u2018': [TextMacrosMethods.Accent, '\u0060'],
    '^': [TextMacrosMethods.Accent, '^'],
    '"': [TextMacrosMethods.Accent, '\u00A8'],
    '~': [TextMacrosMethods.Accent, '~'],
    '=': [TextMacrosMethods.Accent, '\u00AF'],
    '.': [TextMacrosMethods.Accent, '\u02D9'],
    u: [TextMacrosMethods.Accent, '\u02D8'],
    v: [TextMacrosMethods.Accent, '\u02C7'],
    emph: TextMacrosMethods.Emph,
    rm: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.NORMAL],
    mit: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.ITALIC],
    oldstyle: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.OLDSTYLE],
    cal: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.CALLIGRAPHIC],
    it: [TextMacrosMethods.SetFont, '-tex-mathit'],
    bf: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.BOLD],
    sf: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.SANSSERIF],
    tt: [TextMacrosMethods.SetFont, TextMacrosMappings_VARIANT.MONOSPACE],
    frak: [TextMacrosMethods.TextFont, TextMacrosMappings_VARIANT.FRAKTUR],
    Bbb: [TextMacrosMethods.TextFont, TextMacrosMappings_VARIANT.DOUBLESTRUCK],
    tiny: [TextMacrosMethods.SetSize, 0.5],
    Tiny: [TextMacrosMethods.SetSize, 0.6],
    scriptsize: [TextMacrosMethods.SetSize, 0.7],
    small: [TextMacrosMethods.SetSize, 0.85],
    normalsize: [TextMacrosMethods.SetSize, 1.0],
    large: [TextMacrosMethods.SetSize, 1.2],
    Large: [TextMacrosMethods.SetSize, 1.44],
    LARGE: [TextMacrosMethods.SetSize, 1.73],
    huge: [TextMacrosMethods.SetSize, 2.07],
    Huge: [TextMacrosMethods.SetSize, 2.49],
    textnormal: [TextMacrosMethods.Macro, '{\\rm #1}', 1],
    textup: [TextMacrosMethods.Macro, '{\\rm #1}', 1],
    textrm: [TextMacrosMethods.Macro, '{\\rm #1}', 1],
    textit: [TextMacrosMethods.Macro, '{\\it #1}', 1],
    textbf: [TextMacrosMethods.Macro, '{\\bf #1}', 1],
    textsf: [TextMacrosMethods.Macro, '{\\sf #1}', 1],
    texttt: [TextMacrosMethods.Macro, '{\\tt #1}', 1],
    dagger: [TextMacrosMethods.Insert, '\u2020'],
    ddagger: [TextMacrosMethods.Insert, '\u2021'],
    S: [TextMacrosMethods.Insert, '\u00A7'],
    AA: [TextMacrosMethods.Insert, '\u212B'],
    ldots: [TextMacrosMethods.Insert, '\u2026'],
    vdots: [TextMacrosMethods.Insert, '\u22EE'],
    ',': [TextMacrosMethods.Spacer, MATHSPACE.thinmathspace],
    ':': [TextMacrosMethods.Spacer, MATHSPACE.mediummathspace],
    '>': [TextMacrosMethods.Spacer, MATHSPACE.mediummathspace],
    ';': [TextMacrosMethods.Spacer, MATHSPACE.thickmathspace],
    '!': [TextMacrosMethods.Spacer, MATHSPACE.negativethinmathspace],
    enspace: [TextMacrosMethods.Spacer, 0.5],
    quad: [TextMacrosMethods.Spacer, 1],
    qquad: [TextMacrosMethods.Spacer, 2],
    thinspace: [TextMacrosMethods.Spacer, MATHSPACE.thinmathspace],
    negthinspace: [TextMacrosMethods.Spacer, MATHSPACE.negativethinmathspace],
    hskip: TextMacrosMethods.Hskip,
    hspace: TextMacrosMethods.Hskip,
    kern: TextMacrosMethods.Hskip,
    mskip: TextMacrosMethods.Hskip,
    mspace: TextMacrosMethods.Hskip,
    mkern: TextMacrosMethods.Hskip,
    rule: TextMacrosMethods.rule,
    Rule: [TextMacrosMethods.Rule],
    Space: [TextMacrosMethods.Rule, 'blank'],
    color: TextMacrosMethods.CheckAutoload,
    textcolor: TextMacrosMethods.CheckAutoload,
    colorbox: TextMacrosMethods.CheckAutoload,
    fcolorbox: TextMacrosMethods.CheckAutoload,
    href: TextMacrosMethods.CheckAutoload,
    style: TextMacrosMethods.CheckAutoload,
    class: TextMacrosMethods.CheckAutoload,
    data: TextMacrosMethods.CheckAutoload,
    cssId: TextMacrosMethods.CheckAutoload,
    unicode: TextMacrosMethods.CheckAutoload,
    U: TextMacrosMethods.CheckAutoload,
    char: TextMacrosMethods.CheckAutoload,
    ref: [TextMacrosMethods.HandleRef, false],
    eqref: [TextMacrosMethods.HandleRef, true],
    underline: [TextMacrosMethods.UnderOver, '2015'],
    llap: TextMacrosMethods.Lap,
    rlap: TextMacrosMethods.Lap,
    phantom: TextMacrosMethods.Phantom,
    vphantom: [TextMacrosMethods.Phantom, 1, 0],
    hphantom: [TextMacrosMethods.Phantom, 0, 1],
    smash: TextMacrosMethods.Smash,
    mmlToken: TextMacrosMethods.MmlToken,
});
//# sourceMappingURL=TextMacrosMappings.js.map
;// ./mjs/input/tex/textmacros/TextMacrosConfiguration.js








const TextBaseConfiguration = Configuration.create('text-base', {
    [ConfigurationType.PARSER]: 'text',
    [ConfigurationType.PRIORITY]: 1,
    [ConfigurationType.HANDLER]: {
        [HandlerType.CHARACTER]: ['command', 'text-special'],
        [HandlerType.MACRO]: ['text-macros'],
    },
    [ConfigurationType.FALLBACK]: {
        [HandlerType.CHARACTER]: (parser, c) => {
            parser.text += c;
        },
        [HandlerType.MACRO]: (parser, name) => {
            const texParser = parser.texParser;
            const macro = texParser.lookup(HandlerType.MACRO, name);
            if (macro && macro._func !== TextMacrosMethods.Macro) {
                parser.Error('MathMacro', '%1 is only supported in math mode', '\\' + name);
            }
            texParser.parse(HandlerType.MACRO, [parser, name]);
        },
    },
    [ConfigurationType.ITEMS]: {
        [StartItem.prototype.kind]: StartItem,
        [StopItem.prototype.kind]: StopItem,
        [MmlItem.prototype.kind]: MmlItem,
        [StyleItem.prototype.kind]: StyleItem,
    },
});
function internalMath(parser, text, level, mathvariant) {
    const config = parser.configuration.packageData.get('textmacros');
    if (!(parser instanceof TextParser)) {
        config.texParser = parser;
    }
    config.parseOptions.clear();
    return [
        new TextParser(text, mathvariant ? { mathvariant } : {}, config.parseOptions, level).mml(),
    ];
}
const TextMacrosConfiguration = Configuration.create('textmacros', {
    [ConfigurationType.PRIORITY]: 1,
    [ConfigurationType.CONFIG]: (_config, jax) => {
        const textConf = new ParserConfiguration(jax.parseOptions.options.textmacros.packages, ['tex', 'text']);
        textConf.init();
        const parseOptions = new tex_ParseOptions(textConf, []);
        parseOptions.options = jax.parseOptions.options;
        textConf.config(jax);
        TagsFactory.addTags(textConf.tags);
        parseOptions.tags = TagsFactory.getDefault();
        parseOptions.tags.configuration = parseOptions;
        parseOptions.packageData = jax.parseOptions.packageData;
        parseOptions.packageData.set('textmacros', {
            textConf,
            parseOptions,
            jax,
            texParser: null,
        });
        parseOptions.options.internalMath = internalMath;
    },
    [ConfigurationType.PREPROCESSORS]: [
        (data) => {
            const config = data.data.packageData.get('textmacros');
            config.parseOptions.nodeFactory.setMmlFactory(config.jax.mmlFactory);
        },
    ],
    [ConfigurationType.OPTIONS]: {
        textmacros: {
            packages: ['text-base'],
        },
    },
});
//# sourceMappingURL=TextMacrosConfiguration.js.map
;// ./components/mjs/input/tex/lib/tex.js











































if (MathJax.loader) {
  MathJax.loader.checkVersion('input/tex', VERSION, 'input');
}

combineWithMathJax({_: {
  input: {
    tex_ts: tex_namespaceObject,
    tex: {
      ColumnParser: ColumnParser_namespaceObject,
      Configuration: Configuration_namespaceObject,
      FilterUtil: FilterUtil_namespaceObject,
      FindTeX: FindTeX_namespaceObject,
      HandlerTypes: HandlerTypes_namespaceObject,
      MapHandler: MapHandler_namespaceObject,
      NodeFactory: tex_NodeFactory_namespaceObject,
      NodeUtil: NodeUtil_namespaceObject,
      ParseMethods: ParseMethods_namespaceObject,
      ParseOptions: ParseOptions_namespaceObject,
      ParseUtil: ParseUtil_namespaceObject,
      Stack: Stack_namespaceObject,
      StackItem: StackItem_namespaceObject,
      StackItemFactory: StackItemFactory_namespaceObject,
      Tags: Tags_namespaceObject,
      TexConstants: TexConstants_namespaceObject,
      TexError: TexError_namespaceObject,
      TexParser: TexParser_namespaceObject,
      Token: Token_namespaceObject,
      TokenMap: TokenMap_namespaceObject,
      UnitUtil: UnitUtil_namespaceObject,
      ams: {
        AmsConfiguration: AmsConfiguration_namespaceObject,
        AmsItems: AmsItems_namespaceObject,
        AmsMethods: AmsMethods_namespaceObject
      },
      autoload: {
        AutoloadConfiguration: AutoloadConfiguration_namespaceObject
      },
      base: {
        BaseConfiguration: BaseConfiguration_namespaceObject,
        BaseItems: BaseItems_namespaceObject,
        BaseMethods: BaseMethods_namespaceObject
      },
      configmacros: {
        ConfigMacrosConfiguration: ConfigMacrosConfiguration_namespaceObject
      },
      newcommand: {
        NewcommandConfiguration: NewcommandConfiguration_namespaceObject,
        NewcommandItems: NewcommandItems_namespaceObject,
        NewcommandMethods: NewcommandMethods_namespaceObject,
        NewcommandUtil: NewcommandUtil_namespaceObject
      },
      noundefined: {
        NoUndefinedConfiguration: NoUndefinedConfiguration_namespaceObject
      },
      require: {
        RequireConfiguration: RequireConfiguration_namespaceObject
      },
      textmacros: {
        TextMacrosConfiguration: TextMacrosConfiguration_namespaceObject,
        TextMacrosMethods: TextMacrosMethods_namespaceObject,
        TextParser: TextParser_namespaceObject
      }
    }
  }
}});

;// ./components/mjs/input/tex/register.js


function registerTeX(packageList = [], tex = true) {
  if (MathJax.startup) {
    if (tex) {
      MathJax.startup.registerConstructor('tex', MathJax._.input.tex_ts.TeX);
      MathJax.startup.useInput('tex');
    }
    if (!MathJax.config.tex) {
      MathJax.config.tex = {};
    }
    let packages = MathJax.config.tex.packages;
    MathJax.config.tex.packages = packageList;
    if (packages) {
      if (Array.isArray(packages)) {
        packages = {'[+]': packages.filter((name) => !packageList.includes(name))};
      }
      insert(MathJax.config.tex, {packages});
    }
  }
}

;// ./components/mjs/input/tex/tex.js





Loader.preLoaded(
  'input/tex-base',
  '[tex]/ams',
  '[tex]/newcommand',
  '[tex]/textmacros',
  '[tex]/noundefined',
  '[tex]/require',
  '[tex]/autoload',
  '[tex]/configmacros'
);

registerTeX([
  'base',
  'ams',
  'newcommand',
  'textmacros',
  'noundefined',
  'require',
  'autoload',
  'configmacros'
]);

;// ./mjs/output/common/Direction.js
const DIRECTION = { None: '', Vertical: 'v', Horizontal: 'h' };
const V = DIRECTION.Vertical;
const H = DIRECTION.Horizontal;
//# sourceMappingURL=Direction.js.map
;// ./mjs/output/common/FontData.js
var FontData_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const NOSTRETCH = { dir: DIRECTION.None };
function mergeOptions(obj, dst, src) {
    return src ? defaultOptions(obj, { [dst]: src })[dst] : obj[dst];
}
class FontData {
    get CLASS() {
        return this.constructor;
    }
    static charOptions(font, n) {
        const char = font[n];
        if (!Array.isArray(char)) {
            throw Error(`Character data hasn't been loaded for 0x${n.toString(16).toUpperCase()}`);
        }
        if (char.length === 3) {
            char[3] = {};
        }
        return char[3];
    }
    static defineDynamicFiles(dynamicFiles, extension = '') {
        const list = {};
        (dynamicFiles || []).forEach(([file, variants, delimiters]) => {
            list[file] = {
                extension,
                file,
                variants,
                delimiters: delimiters || [],
                promise: null,
                failed: false,
                setup: (_font) => {
                    list[file].failed = true;
                },
            };
        });
        return list;
    }
    static dynamicSetup(extension, file, variants, delimiters = {}, fonts = null) {
        const data = extension ? this.dynamicExtensions.get(extension) : null;
        const files = extension ? data.files : this.dynamicFiles;
        files[file].setup = (font) => {
            Object.keys(variants).forEach((name) => font.defineChars(name, variants[name]));
            font.defineDelimiters(delimiters);
            if (extension) {
                this.adjustDelimiters(font.delimiters, Object.keys(delimiters), data.sizeN, data.stretchN);
            }
            if (fonts) {
                font.addDynamicFontCss(fonts);
            }
        };
    }
    static adjustDelimiters(delimiters, keys, sizeN, stretchN) {
        keys.forEach((id) => {
            const delim = delimiters[parseInt(id)];
            if ('dir' in delim) {
                if (delim.variants) {
                    delim.variants = this.adjustArrayIndices(delim.variants, sizeN);
                }
                if (delim.stretchv) {
                    delim.stretchv = this.adjustArrayIndices(delim.stretchv, stretchN);
                }
            }
        });
    }
    static adjustArrayIndices(list, N) {
        return list.map((n) => (n < 0 ? N - 1 - n : n));
    }
    static addExtension(data, prefix = '') {
        const extension = {
            name: data.name,
            prefix: prefix || `[${data.name}-extension]/${this.JAX.toLowerCase()}/dynamic`,
            files: this.defineDynamicFiles(data.ranges, data.name),
            sizeN: this.defaultSizeVariants.length,
            stretchN: this.defaultStretchVariants.length,
        };
        this.dynamicExtensions.set(data.name, extension);
        for (const [src, dst] of [
            ['options', 'OPTIONS'],
            ['variants', 'defaultVariants'],
            ['variantSmp', 'VariantSmp'],
            ['cssFonts', 'defaultCssFonts'],
            ['accentMap', 'defaultAccentMap'],
            ['moMap', 'defaultMoMap'],
            ['mnMap', 'defaultMnMap'],
            ['parameters', 'defaultParams'],
            ['chars', 'defaultChars'],
            ['sizeVariants', 'defaultSizeVariants'],
            ['stretchVariants', 'defaultStretchVariants'],
        ]) {
            mergeOptions(this, dst, data[src]);
        }
        if (data.delimiters) {
            Object.assign(this.defaultDelimiters, data.delimiters);
            this.adjustDelimiters(this.defaultDelimiters, Object.keys(data.delimiters), extension.sizeN, extension.stretchN);
        }
    }
    constructor(options = null) {
        this.variant = {};
        this.delimiters = {};
        this.cssFontMap = {};
        this.cssFontPrefix = '';
        this.remapChars = {};
        this.skewIcFactor = 0.75;
        const CLASS = this.CLASS;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
        this.params = Object.assign({}, CLASS.defaultParams);
        this.sizeVariants = [...CLASS.defaultSizeVariants];
        this.stretchVariants = [...CLASS.defaultStretchVariants];
        this.defineCssFonts(CLASS.defaultCssFonts);
        this.cssFamilyPrefix = CLASS.defaultCssFamilyPrefix;
        this.createVariants(CLASS.defaultVariants);
        this.defineDelimiters(CLASS.defaultDelimiters);
        Object.keys(CLASS.defaultChars).forEach((name) => this.defineChars(name, CLASS.defaultChars[name]));
        this.defineRemap('accent', CLASS.defaultAccentMap);
        this.defineRemap('mo', CLASS.defaultMoMap);
        this.defineRemap('mn', CLASS.defaultMnMap);
        this.defineDynamicCharacters(CLASS.dynamicFiles);
        CLASS.dynamicExtensions.forEach((data) => this.defineDynamicCharacters(data.files));
    }
    setOptions(options) {
        defaultOptions(this.options, options);
    }
    addExtension(data, prefix = '') {
        const jax = this.constructor.JAX.toLowerCase();
        const dynamicFont = {
            name: data.name,
            prefix: prefix || `[${data.name}-extension]/${jax}/dynamic`,
            files: this.CLASS.defineDynamicFiles(data.ranges, prefix),
            sizeN: this.sizeVariants.length,
            stretchN: this.stretchVariants.length,
        };
        this.CLASS.dynamicExtensions.set(data.name, dynamicFont);
        defaultOptions(this.options, data.options || {});
        defaultOptions(this.params, data.parameters || {});
        mergeOptions(this, 'sizeVariants', data.sizeVariants);
        mergeOptions(this, 'stretchVariants', data.stretchVariants);
        mergeOptions(this.constructor, 'VariantSmp', data.variantSmp);
        this.defineCssFonts(mergeOptions({ cssFonts: {} }, 'cssFonts', data.cssFonts));
        this.createVariants(mergeOptions({ variants: [] }, 'variants', data.variants));
        if (data.delimiters) {
            this.defineDelimiters(mergeOptions({ delimiters: {} }, 'delimiters', data.delimiters));
            this.CLASS.adjustDelimiters(this.delimiters, Object.keys(data.delimiters), dynamicFont.sizeN, dynamicFont.stretchN);
        }
        for (const name of Object.keys(data.chars || {})) {
            this.defineChars(name, data.chars[name]);
        }
        this.defineRemap('accent', data.accentMap);
        this.defineRemap('mo', data.moMap);
        this.defineRemap('mn', data.mnMap);
        if (data.ranges) {
            this.defineDynamicCharacters(dynamicFont.files);
        }
        return [];
    }
    get styles() {
        return this._styles;
    }
    set styles(style) {
        this._styles = style;
    }
    createVariant(name, inherit = null, link = null) {
        const variant = {
            linked: [],
            chars: Object.create(inherit ? this.variant[inherit].chars : {}),
        };
        if (this.variant[link]) {
            Object.assign(variant.chars, this.variant[link].chars);
            this.variant[link].linked.push(variant.chars);
            variant.chars = Object.create(variant.chars);
        }
        this.remapSmpChars(variant.chars, name);
        this.variant[name] = variant;
    }
    remapSmpChars(chars, name) {
        const CLASS = this.CLASS;
        let remap = CLASS.VariantSmp[name];
        if (typeof remap === 'string') {
            remap = CLASS.VariantSmp[remap];
        }
        if (!remap)
            return;
        const SmpRemap = CLASS.SmpRemap;
        const SmpGreek = [null, null, CLASS.SmpRemapGreekU, CLASS.SmpRemapGreekL];
        for (const [i, lo, hi] of CLASS.SmpRanges) {
            const base = remap[i];
            if (!base)
                continue;
            for (let n = lo; n <= hi; n++) {
                if (n === 0x3a2)
                    continue;
                const smp = base + n - lo;
                chars[n] = this.smpChar(SmpRemap[smp] || smp);
            }
            if (SmpGreek[i]) {
                for (const n of Object.keys(SmpGreek[i]).map((x) => parseInt(x))) {
                    chars[n] = this.smpChar(base + SmpGreek[i][n]);
                }
            }
        }
        const extra = remap[5] || {};
        for (const n of Object.keys(extra)) {
            chars[n] = this.smpChar(remap[5][n]);
        }
    }
    smpChar(n) {
        return [, , , { smp: n }];
    }
    createVariants(variants) {
        for (const variant of variants) {
            this.createVariant(variant[0], variant[1], variant[2]);
        }
    }
    defineChars(name, chars) {
        const variant = this.variant[name];
        Object.assign(variant.chars, chars);
        for (const link of variant.linked) {
            Object.assign(link, chars);
        }
    }
    defineCssFonts(fonts) {
        Object.assign(this.cssFontMap, fonts);
        for (const name of Object.keys(fonts)) {
            if (this.cssFontMap[name][0] === 'unknown') {
                this.cssFontMap[name][0] = this.options.unknownFamily;
            }
        }
    }
    defineDelimiters(delims) {
        Object.assign(this.delimiters, delims);
    }
    defineRemap(name, remap) {
        if (remap) {
            if (!Object.hasOwn(this.remapChars, name)) {
                this.remapChars[name] = {};
            }
            Object.assign(this.remapChars[name], remap);
        }
    }
    defineDynamicCharacters(dynamicFiles) {
        for (const file of Object.keys(dynamicFiles)) {
            const dynamic = dynamicFiles[file];
            for (const name of Object.keys(dynamic.variants)) {
                this.defineChars(name, this.flattenRanges(dynamic.variants[name], dynamic));
            }
            this.defineDelimiters(this.flattenRanges(dynamic.delimiters, dynamic));
        }
    }
    flattenRanges(ranges, dynamic) {
        const chars = {};
        for (const n of ranges) {
            if (Array.isArray(n)) {
                for (let j = n[0]; j <= n[1]; j++) {
                    chars[j] = dynamic;
                }
            }
            else {
                chars[n] = dynamic;
            }
        }
        return chars;
    }
    dynamicFileName(dynamic) {
        const prefix = !dynamic.extension
            ? this.options.dynamicPrefix
            : this.CLASS.dynamicExtensions.get(dynamic.extension).prefix;
        return dynamic.file.match(/^(?:[/[]|[a-z]+:\/\/|[a-z]:)/i)
            ? dynamic.file
            : prefix + '/' + dynamic.file.replace(/(\.js)?$/, '.js');
    }
    loadDynamicFile(dynamic) {
        return FontData_awaiter(this, void 0, void 0, function* () {
            if (dynamic.failed)
                return Promise.reject(new Error(`dynamic file '${dynamic.file}' failed to load`));
            if (!dynamic.promise) {
                dynamic.promise = asyncLoad(this.dynamicFileName(dynamic)).catch((err) => {
                    dynamic.failed = true;
                    console.warn(err);
                });
            }
            return dynamic.promise.then(() => dynamic.setup(this));
        });
    }
    loadDynamicFiles() {
        const dynamicFiles = this.CLASS.dynamicFiles;
        const promises = Object.keys(dynamicFiles).map((name) => this.loadDynamicFile(dynamicFiles[name]));
        for (const data of this.CLASS.dynamicExtensions.values()) {
            promises.push(...Object.keys(data.files).map((name) => this.loadDynamicFile(data.files[name])));
        }
        return Promise.all(promises);
    }
    loadDynamicFilesSync() {
        if (!mathjax.asyncIsSynchronous) {
            throw Error('MathJax(loadDynamicFilesSync): mathjax.asyncLoad must be specified and synchronous\n' +
                '    Try importing #js/../components/require.mjs and #js/util/asyncLoad/node.js');
        }
        const dynamicFiles = this.CLASS.dynamicFiles;
        Object.keys(dynamicFiles).forEach((name) => this.loadDynamicFileSync(dynamicFiles[name]));
        for (const data of this.CLASS.dynamicExtensions.values()) {
            Object.keys(data.files).forEach((name) => this.loadDynamicFileSync(data.files[name]));
        }
    }
    loadDynamicFileSync(dynamic) {
        if (!dynamic.promise) {
            dynamic.promise = Promise.resolve();
            try {
                mathjax.asyncLoad(this.dynamicFileName(dynamic));
            }
            catch (err) {
                dynamic.failed = true;
                console.warn(err);
            }
            dynamic.setup(this);
        }
    }
    addDynamicFontCss(_fonts, _root) { }
    getDelimiter(n) {
        const delim = this.delimiters[n];
        if (delim && !('dir' in delim)) {
            this.delimiters[n] = null;
            retryAfter(this.loadDynamicFile(delim));
            return null;
        }
        return delim;
    }
    getSizeVariant(n, i) {
        const delim = this.getDelimiter(n);
        if (delim && delim.variants) {
            i = delim.variants[i];
        }
        return this.sizeVariants[i];
    }
    getStretchVariant(n, i) {
        const delim = this.getDelimiter(n);
        return this.stretchVariants[delim.stretchv ? delim.stretchv[i] : 0];
    }
    getStretchVariants(n) {
        return [0, 1, 2, 3].map((i) => this.getStretchVariant(n, i));
    }
    getChar(name, n) {
        const char = this.variant[name].chars[n];
        if (char && !Array.isArray(char)) {
            const variant = this.variant[name];
            delete variant.chars[n];
            variant.linked.forEach((link) => delete link[n]);
            retryAfter(this.loadDynamicFile(char));
            return null;
        }
        return char;
    }
    getVariant(name) {
        return this.variant[name];
    }
    getCssFont(variant) {
        return this.cssFontMap[variant] || ['serif', false, false];
    }
    getFamily(family) {
        return this.cssFamilyPrefix ? this.cssFamilyPrefix + ', ' + family : family;
    }
    getRemappedChar(name, c) {
        const map = this.remapChars[name] || {};
        return map[c];
    }
}
FontData.OPTIONS = {
    unknownFamily: 'serif',
    dynamicPrefix: '.',
};
FontData.JAX = 'common';
FontData.NAME = '';
FontData.defaultVariants = [
    ['normal'],
    ['bold', 'normal'],
    ['italic', 'normal'],
    ['bold-italic', 'italic', 'bold'],
    ['double-struck', 'bold'],
    ['fraktur', 'normal'],
    ['bold-fraktur', 'bold', 'fraktur'],
    ['script', 'italic'],
    ['bold-script', 'bold-italic', 'script'],
    ['sans-serif', 'normal'],
    ['bold-sans-serif', 'bold', 'sans-serif'],
    ['sans-serif-italic', 'italic', 'sans-serif'],
    ['sans-serif-bold-italic', 'bold-italic', 'bold-sans-serif'],
    ['monospace', 'normal'],
    ['-smallop', 'normal'],
    ['-largeop', 'normal'],
    ['-tex-calligraphic', 'italic'],
    ['-tex-bold-calligraphic', 'bold-italic'],
    ['-tex-oldstyle', 'normal'],
    ['-tex-bold-oldstyle', 'bold'],
    ['-tex-mathit', 'italic'],
    ['-tex-variant', 'normal'],
];
FontData.defaultCssFonts = {
    normal: ['unknown', false, false],
    bold: ['unknown', false, true],
    italic: ['unknown', true, false],
    'bold-italic': ['unknown', true, true],
    'double-struck': ['unknown', false, true],
    fraktur: ['unknown', false, false],
    'bold-fraktur': ['unknown', false, true],
    script: ['cursive', false, false],
    'bold-script': ['cursive', false, true],
    'sans-serif': ['sans-serif', false, false],
    'bold-sans-serif': ['sans-serif', false, true],
    'sans-serif-italic': ['sans-serif', true, false],
    'sans-serif-bold-italic': ['sans-serif', true, true],
    monospace: ['monospace', false, false],
    '-smallop': ['unknown', false, false],
    '-largeop': ['unknown', false, false],
    '-tex-calligraphic': ['cursive', true, false],
    '-tex-bold-calligraphic': ['cursive', true, true],
    '-tex-oldstyle': ['unknown', false, false],
    '-tex-bold-oldstyle': ['unknown', false, true],
    '-tex-mathit': ['unknown', true, false],
    '-tex-variant': ['unknown', false, false],
};
FontData.defaultCssFamilyPrefix = '';
FontData.VariantSmp = {
    bold: [
        0x1d400,
        0x1d41a,
        0x1d6a8,
        0x1d6c2,
        0x1d7ce,
        { 0x3dc: 0x1d7ca, 0x3dd: 0x1d7cb },
    ],
    italic: [0x1d434, 0x1d44e, 0x1d6e2, 0x1d6fc],
    'bold-italic': [0x1d468, 0x1d482, 0x1d71c, 0x1d736],
    script: [0x1d49c, 0x1d4b6],
    'bold-script': [0x1d4d0, 0x1d4ea],
    fraktur: [0x1d504, 0x1d51e],
    'double-struck': [0x1d538, 0x1d552, , , 0x1d7d8],
    'bold-fraktur': [0x1d56c, 0x1d586],
    'sans-serif': [0x1d5a0, 0x1d5ba, , , 0x1d7e2],
    'bold-sans-serif': [0x1d5d4, 0x1d5ee, 0x1d756, 0x1d770, 0x1d7ec],
    'sans-serif-italic': [0x1d608, 0x1d622],
    'sans-serif-bold-italic': [0x1d63c, 0x1d656, 0x1d790, 0x1d7aa],
    monospace: [0x1d670, 0x1d68a, , , 0x1d7f6],
};
FontData.SmpRanges = [
    [0, 0x41, 0x5A],
    [1, 0x61, 0x7A],
    [2, 0x391, 0x3A9],
    [3, 0x3B1, 0x3C9],
    [4, 0x30, 0x39]
];
FontData.SmpRemap = {
    0x1D455: 0x210E,
    0x1D49D: 0x212C,
    0x1D4A0: 0x2130,
    0x1D4A1: 0x2131,
    0x1D4A3: 0x210B,
    0x1D4A4: 0x2110,
    0x1D4A7: 0x2112,
    0x1D4A8: 0x2133,
    0x1D4AD: 0x211B,
    0x1D4BA: 0x212F,
    0x1D4BC: 0x210A,
    0x1D4C4: 0x2134,
    0x1D506: 0x212D,
    0x1D50B: 0x210C,
    0x1D50C: 0x2111,
    0x1D515: 0x211C,
    0x1D51D: 0x2128,
    0x1D53A: 0x2102,
    0x1D53F: 0x210D,
    0x1D545: 0x2115,
    0x1D547: 0x2119,
    0x1D548: 0x211A,
    0x1D549: 0x211D,
    0x1D551: 0x2124,
};
FontData.SmpRemapGreekU = {
    0x2207: 0x19,
    0x03F4: 0x11
};
FontData.SmpRemapGreekL = {
    0x3D1: 0x1B,
    0x3D5: 0x1D,
    0x3D6: 0x1F,
    0x3F0: 0x1C,
    0x3F1: 0x1E,
    0x3F5: 0x1A,
    0x2202: 0x19
};
FontData.defaultAccentMap = {
    0x005E: '\u02C6',
    0x007E: '\u02DC',
    0x0300: '\u02CB',
    0x0301: '\u02CA',
    0x0302: '\u02C6',
    0x0303: '\u02DC',
    0x0304: '\u02C9',
    0x0306: '\u02D8',
    0x0307: '\u02D9',
    0x0308: '\u00A8',
    0x030A: '\u02DA',
    0x030C: '\u02C7',
    0x2192: '\u20D7'
};
FontData.defaultMoMap = {
    0x002d: '\u2212',
};
FontData.defaultMnMap = {
    0x002d: '\u2212',
};
FontData.defaultParams = {
    x_height: .442,
    quad: 1,
    num1: .676,
    num2: .394,
    num3: .444,
    denom1: .686,
    denom2: .345,
    sup1: .413,
    sup2: .363,
    sup3: .289,
    sub1: .15,
    sub2: .247,
    sup_drop: .386,
    sub_drop: .05,
    delim1: 2.39,
    delim2: 1.0,
    axis_height: .25,
    rule_thickness: .06,
    big_op_spacing1: .111,
    big_op_spacing2: .167,
    big_op_spacing3: .2,
    big_op_spacing4: .6,
    big_op_spacing5: .1,
    surd_height: .06,
    scriptspace: .05,
    nulldelimiterspace: .12,
    delimiterfactor: 901,
    delimitershortfall: .3,
    rule_factor: 1.25,
    min_rule_thickness: 1.25,
    separation_factor: 1.75,
    extra_ic: .033,
    extender_factor: .333
};
FontData.defaultDelimiters = {};
FontData.defaultChars = {};
FontData.defaultSizeVariants = [];
FontData.defaultStretchVariants = [];
FontData.dynamicFiles = {};
FontData.dynamicExtensions = new Map();
//# sourceMappingURL=FontData.js.map
;// ./mjs/output/common/LineBBox.js

class LineBBox extends BBox {
    static from(bbox, leading, indent = null) {
        const nbox = new this();
        Object.assign(nbox, bbox);
        nbox.lineLeading = leading;
        if (indent) {
            nbox.indentData = indent;
        }
        return nbox;
    }
    constructor(def, start = null) {
        super(def);
        this.indentData = null;
        this.isFirst = false;
        this.originalL = this.L;
        if (start) {
            this.start = start;
        }
    }
    append(cbox) {
        if (this.isFirst) {
            cbox.originalL += cbox.L;
            cbox.L = 0;
        }
        if (cbox.indentData) {
            this.indentData = cbox.indentData;
        }
        this.lineLeading = cbox.lineLeading;
        super.append(cbox);
        this.isFirst = cbox.isFirst;
    }
    copy() {
        const bbox = LineBBox.from(this, this.lineLeading);
        bbox.indentData = this.indentData;
        bbox.lineLeading = this.lineLeading;
        return bbox;
    }
    getIndentData(node) {
        let { indentalign, indentshift, indentalignfirst, indentshiftfirst, indentalignlast, indentshiftlast, } = node.attributes.getAllAttributes();
        if (indentalignfirst === 'indentalign') {
            indentalignfirst = node.attributes.getInherited('indentalign');
        }
        if (indentshiftfirst === 'indentshift') {
            indentshiftfirst = node.attributes.getInherited('indentshift');
        }
        if (indentalignlast === 'indentalign') {
            indentalignlast = indentalign;
        }
        if (indentshiftlast === 'indentshift') {
            indentshiftlast = indentshift;
        }
        this.indentData = [
            [indentalignfirst, indentshiftfirst],
            [indentalign, indentshift],
            [indentalignlast, indentshiftlast],
        ];
    }
    copyIndentData(bbox) {
        return bbox.indentData.map(([align, indent]) => [align, indent]);
    }
}
//# sourceMappingURL=LineBBox.js.map
;// ./mjs/output/common/LinebreakVisitor.js




const NOBREAK = 1000000;
class Linebreaks extends AbstractVisitor {
    breakToWidth(_wrapper, _W) { }
}
class LinebreakVisitor extends Linebreaks {
    constructor() {
        super(...arguments);
        this.PENALTY = {
            newline: (_p) => 0,
            nobreak: (_p) => NOBREAK,
            goodbreak: (p) => p - 200 * this.state.depth,
            badbreak: (p) => p + 200 * this.state.depth,
            auto: (p) => p,
        };
        this.FACTORS = {
            depth: (p) => p + 800 * this.state.depth,
            width: (p) => p +
                Math.floor(((this.state.width - this.state.w) / this.state.width) * 2500),
            tail: (p) => p +
                Math.floor((this.state.width /
                    Math.max(0.0001, this.state.mathLeft - this.state.w)) *
                    500),
            open: (p, mo) => {
                const prevClass = mo.node.prevClass;
                if (prevClass === TEXCLASS.BIN ||
                    prevClass === TEXCLASS.REL ||
                    prevClass === TEXCLASS.OP) {
                    return p + 5000;
                }
                const prev = this.getPrevious(mo);
                if (prev &&
                    (prev.attributes.get('form') !== 'postfix' ||
                        prev.attributes.get('linebreak') === 'nobreak')) {
                    return p + 5000;
                }
                const parent = mo.node.Parent;
                if ((parent === null || parent === void 0 ? void 0 : parent.isKind('mmultiscripts')) &&
                    mo.node === this.getFirstToken(parent)) {
                    const prescripts = !!parent.childNodes.filter((node) => node.isKind('mprescripts')).length;
                    if (prescripts)
                        return NOBREAK;
                }
                return p - 500;
            },
            close: (p, mo) => {
                var _a;
                const parent = mo.node.Parent;
                if ((parent === null || parent === void 0 ? void 0 : parent.isKind('msubsup')) &&
                    !(parent.isKind('mmultiscripts') &&
                        ((_a = parent.childNodes[1]) === null || _a === void 0 ? void 0 : _a.isKind('mprescripts'))) &&
                    mo.node === this.getLastToken(parent.childNodes[0])) {
                    return NOBREAK;
                }
                return p + 500;
            },
            space: (p, node) => {
                const mspace = node;
                if (!mspace.canBreak)
                    return NOBREAK;
                const w = mspace.getBBox().w;
                return w < 0 ? NOBREAK : w < 1 ? p : p - 100 * (w + 4);
            },
            separator: (p) => p + 500,
            fuzz: (p) => p * 0.99,
        };
        this.TEXCLASS = {
            [TEXCLASS.BIN]: (p) => p - 250,
            [TEXCLASS.REL]: (p) => p - 500,
        };
    }
    breakToWidth(wrapper, W) {
        const state = this.state;
        this.state = this.createState(wrapper);
        this.state.width = W;
        const n = wrapper.breakCount;
        for (let i = 0; i <= n; i++) {
            const line = wrapper.lineBBox[i] || wrapper.getLineBBox(i);
            if (line.w > W) {
                this.breakLineToWidth(wrapper, i);
            }
        }
        for (const [ww, ij] of this.state.breaks) {
            if (ij === null) {
                const mo = ww.coreMO();
                mo.setBreakStyle(mo.node.attributes.get('linebreakstyle') || 'before');
            }
            else {
                ww.setBreakAt(ij);
            }
            ww.invalidateBBox();
        }
        this.state = state;
    }
    createState(wrapper) {
        const mathWidth = wrapper.getBBox().w;
        return {
            breaks: new Set(),
            potential: [],
            width: 0,
            w: 0,
            prevWidth: 0,
            prevBreak: null,
            depth: 0,
            mathWidth: mathWidth,
            mathLeft: mathWidth,
        };
    }
    breakLineToWidth(wrapper, i) {
        const state = this.state;
        state.potential = [];
        state.w = 0;
        state.prevWidth = 0;
        state.prevBreak = null;
        state.depth = 0;
        this.visitNode(wrapper, i);
    }
    addWidth(bbox, w = null) {
        if (w === null) {
            w = bbox.L + bbox.w + bbox.R;
        }
        if (!w)
            return;
        w *= bbox.rscale;
        this.state.w += w;
        if (this.state.potential.length) {
            this.state.potential[0][4] += w;
        }
        this.processBreak();
    }
    processBreak() {
        const state = this.state;
        while (state.potential.length && state.w > this.state.width) {
            const br = state.potential.pop();
            const [ww, , pw, dw, w] = br;
            state.breaks.add(ww);
            state.w = state.potential.reduce((w, brk) => w + brk[4], dw + w);
            if (state.prevBreak && state.prevWidth + pw <= state.width) {
                state.breaks.delete(state.prevBreak[0]);
                state.prevWidth += pw;
            }
            else {
                state.prevWidth = pw + dw;
            }
            state.potential.forEach((data) => (data[2] -= pw));
            state.prevBreak = br;
            state.mathLeft -= pw;
        }
    }
    pushBreak(wrapper, penalty, w, ij) {
        var _a;
        const state = this.state;
        if (penalty >= NOBREAK || (state.w === 0 && state.prevWidth === 0))
            return;
        while (state.potential.length &&
            state.potential[0][1] > this.FACTORS.fuzz(penalty)) {
            const data = state.potential.shift();
            if (state.potential.length) {
                state.potential[0][4] += data[4];
            }
        }
        state.potential.unshift([
            [wrapper, ij],
            penalty,
            state.w - (((_a = state.prevBreak) === null || _a === void 0 ? void 0 : _a[3]) || 0),
            w,
            0,
        ]);
    }
    getBorderLR(wrapper) {
        var _a;
        const data = wrapper.styleData;
        if (!data)
            return [0, 0];
        const border = ((_a = data === null || data === void 0 ? void 0 : data.border) === null || _a === void 0 ? void 0 : _a.width) || [0, 0, 0, 0];
        const padding = (data === null || data === void 0 ? void 0 : data.padding) || [0, 0, 0, 0];
        return [border[3] + padding[3], border[1] + padding[1]];
    }
    getFirstToken(node) {
        return node.isToken ? node : this.getFirstToken(node.childNodes[0]);
    }
    getLastToken(node) {
        return node.isToken
            ? node
            : this.getLastToken(node.childNodes[node.childNodes.length - 1]);
    }
    visitNode(wrapper, i) {
        if (!wrapper)
            return;
        this.state.depth++;
        if (wrapper.node.isEmbellished && !wrapper.node.isKind('mo')) {
            this.visitEmbellishedOperator(wrapper, i);
        }
        else {
            super.visitNode(wrapper, i);
        }
        this.state.depth--;
    }
    visitDefault(wrapper, i) {
        var _a;
        const bbox = wrapper.getLineBBox(i);
        if (wrapper.node.isToken ||
            wrapper.node.linebreakContainer ||
            !((_a = wrapper.childNodes) === null || _a === void 0 ? void 0 : _a[0])) {
            this.addWidth(bbox);
        }
        else {
            const [L, R] = this.getBorderLR(wrapper);
            if (i === 0) {
                this.addWidth(bbox, bbox.L + L);
            }
            this.visitNode(wrapper.childNodes[0], i);
            if (i === wrapper.breakCount) {
                this.addWidth(bbox, bbox.R + R);
            }
        }
    }
    visitEmbellishedOperator(wrapper, _i) {
        const mo = wrapper.coreMO();
        const bbox = LineBBox.from(wrapper.getOuterBBox(), wrapper.linebreakOptions.lineleading);
        bbox.getIndentData(mo.node);
        const style = mo.getBreakStyle(mo.node.attributes.get('linebreakstyle'));
        const dw = mo.processIndent('', bbox.indentData[1][1], '', bbox.indentData[0][1], this.state.width)[1];
        const penalty = this.moPenalty(mo);
        if (style === 'before') {
            this.pushBreak(wrapper, penalty, dw - bbox.L, null);
            this.addWidth(bbox);
        }
        else {
            this.addWidth(bbox);
            const w = (style === 'after'
                ? 0
                : mo.multChar
                    ? mo.multChar.getBBox().w
                    : bbox.w) + dw;
            this.pushBreak(wrapper, penalty, w, null);
        }
    }
    visitMoNode(wrapper, _i) {
        const mo = wrapper;
        const bbox = LineBBox.from(mo.getOuterBBox(), mo.linebreakOptions.lineleading);
        bbox.getIndentData(mo.node);
        const style = mo.getBreakStyle(mo.node.attributes.get('linebreakstyle'));
        const dw = mo.processIndent('', bbox.indentData[1][1], '', bbox.indentData[0][1], this.state.width)[1];
        const penalty = this.moPenalty(mo);
        if (style === 'before') {
            this.pushBreak(wrapper, penalty, dw - bbox.L, null);
            this.addWidth(bbox);
        }
        else {
            this.addWidth(bbox);
            const w = (style === 'after'
                ? 0
                : mo.multChar
                    ? mo.multChar.getBBox().w
                    : bbox.w) + dw;
            this.pushBreak(wrapper, penalty, w, null);
        }
    }
    moPenalty(mo) {
        const { linebreak, fence, form } = mo.node.attributes.getList('linebreak', 'fence', 'form');
        const FACTORS = this.FACTORS;
        let penalty = FACTORS.tail(FACTORS.width(0));
        const isOpen = (fence && form === 'prefix') || mo.node.texClass === TEXCLASS.OPEN;
        const isClose = (fence && form === 'postfix') || mo.node.texClass === TEXCLASS.CLOSE;
        if (isOpen) {
            penalty = FACTORS.open(penalty, mo);
            this.state.depth++;
        }
        if (isClose) {
            penalty = FACTORS.close(penalty, mo);
            this.state.depth--;
        }
        penalty = (this.TEXCLASS[mo.node.texClass] || ((p) => p))(penalty);
        return (this.PENALTY[linebreak] || ((p) => p))(FACTORS.depth(penalty));
    }
    getPrevious(mo) {
        let child = mo.node;
        let parent = child.parent;
        let i = parent.childIndex(child);
        while (parent && (parent.notParent || parent.isKind('mrow')) && i === 0) {
            child = parent;
            parent = child.parent;
            i = parent.childIndex(child);
        }
        if (!parent || !i)
            return null;
        const prev = parent.childNodes[i - 1];
        return prev.isEmbellished ? prev.coreMO() : null;
    }
    visitMspaceNode(wrapper, i) {
        const bbox = wrapper.getLineBBox(i);
        const mspace = wrapper;
        if (mspace.canBreak) {
            const penalty = this.mspacePenalty(mspace);
            bbox.getIndentData(wrapper.node);
            const dw = wrapper.processIndent('', bbox.indentData[1][1], '', bbox.indentData[0][1], this.state.width)[1];
            this.pushBreak(wrapper, penalty, dw - bbox.w, null);
        }
        this.addWidth(bbox);
    }
    mspacePenalty(mspace) {
        const linebreak = mspace.node.attributes.get('linebreak');
        const FACTORS = this.FACTORS;
        const penalty = FACTORS.space(FACTORS.tail(FACTORS.width(0)), mspace);
        return (this.PENALTY[linebreak] || ((p) => p))(FACTORS.depth(penalty));
    }
    visitMtextNode(wrapper, i) {
        if (!wrapper.getText().match(/ /)) {
            this.visitDefault(wrapper, i);
            return;
        }
        const mtext = wrapper;
        mtext.clearBreakPoints();
        const space = mtext.textWidth(' ');
        const bbox = wrapper.getBBox();
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(bbox, bbox.L + L);
        const children = mtext.childNodes;
        for (const j of children.keys()) {
            const child = children[j];
            if (child.node.isKind('text')) {
                const words = child.node.getText().split(/ /);
                const last = words.pop();
                for (const k of words.keys()) {
                    this.addWidth(bbox, mtext.textWidth(words[k]));
                    this.pushBreak(wrapper, this.mtextPenalty(), -space, [j, k + 1]);
                    this.addWidth(bbox, space);
                }
                this.addWidth(bbox, mtext.textWidth(last));
            }
            else {
                this.addWidth(child.getBBox());
            }
        }
        this.addWidth(bbox, bbox.R + R);
    }
    mtextPenalty() {
        const FACTORS = this.FACTORS;
        return FACTORS.depth(FACTORS.tail(FACTORS.width(0)));
    }
    visitMrowNode(wrapper, i) {
        const line = wrapper.lineBBox[i] || wrapper.getLineBBox(i);
        const [start, startL] = line.start || [0, 0];
        const [end, endL] = line.end || [wrapper.childNodes.length - 1, 0];
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(line, line.L + L);
        for (let i = start; i <= end; i++) {
            this.visitNode(wrapper.childNodes[i], i === start ? startL : i === end ? endL : 0);
        }
        this.addWidth(line, line.R + R);
    }
    visitInferredMrowNode(wrapper, i) {
        this.state.depth--;
        this.visitMrowNode(wrapper, i);
        this.state.depth++;
    }
    visitMfracNode(wrapper, i) {
        const mfrac = wrapper;
        if (!mfrac.node.attributes.get('bevelled') &&
            mfrac.getOuterBBox().w > this.state.width) {
            this.breakToWidth(mfrac.childNodes[0], this.state.width);
            this.breakToWidth(mfrac.childNodes[1], this.state.width);
        }
        this.visitDefault(wrapper, i);
    }
    visitMsqrtNode(wrapper, i) {
        if (wrapper.getOuterBBox().w > this.state.width) {
            const msqrt = wrapper;
            const base = msqrt.childNodes[msqrt.base];
            this.breakToWidth(base, this.state.width - msqrt.rootWidth());
            msqrt.getStretchedSurd();
        }
        this.visitDefault(wrapper, i);
    }
    visitMrootNode(wrapper, i) {
        this.visitMsqrtNode(wrapper, i);
    }
    visitMsubNode(wrapper, i) {
        this.visitDefault(wrapper, i);
        const msub = wrapper;
        const x = msub.getOffset()[0];
        const sbox = msub.scriptChild.getOuterBBox();
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(msub.getLineBBox(i), x + L + sbox.rscale * sbox.w + msub.font.params.scriptspace + R);
    }
    visitMsupNode(wrapper, i) {
        this.visitDefault(wrapper, i);
        const msup = wrapper;
        const x = msup.getOffset()[0];
        const sbox = msup.scriptChild.getOuterBBox();
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(msup.getLineBBox(i), x + L + sbox.rscale * sbox.w + msup.font.params.scriptspace + R);
    }
    visitMsubsupNode(wrapper, i) {
        this.visitDefault(wrapper, i);
        const msubsup = wrapper;
        const subbox = msubsup.subChild.getOuterBBox();
        const supbox = msubsup.supChild.getOuterBBox();
        const x = msubsup.getAdjustedIc();
        const w = Math.max(subbox.rscale * subbox.w, x + supbox.rscale * supbox.w) +
            msubsup.font.params.scriptspace;
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(wrapper.getLineBBox(i), L + w + R);
    }
    visitMmultiscriptsNode(wrapper, i) {
        const mmultiscripts = wrapper;
        const data = mmultiscripts.scriptData;
        if (data.numPrescripts) {
            const w = Math.max(data.psup.rscale * data.psup.w, data.psub.rscale * data.psub.w);
            this.addWidth(wrapper.getLineBBox(i), w + mmultiscripts.font.params.scriptspace);
        }
        this.visitDefault(wrapper, i);
        if (data.numScripts) {
            const w = Math.max(data.sup.rscale * data.sup.w, data.sub.rscale * data.sub.w);
            this.addWidth(wrapper.getLineBBox(i), w + mmultiscripts.font.params.scriptspace);
        }
    }
    visitMfencedNode(wrapper, i) {
        const mfenced = wrapper;
        const bbox = wrapper.getLineBBox(i);
        const [L, R] = this.getBorderLR(wrapper);
        if (i === 0) {
            this.addWidth(bbox, bbox.L + L);
        }
        this.visitNode(mfenced.mrow, i);
        if (i === wrapper.breakCount) {
            this.addWidth(bbox, bbox.R + R);
        }
    }
    visitMactionNode(wrapper, i) {
        const maction = wrapper;
        const bbox = wrapper.getLineBBox(i);
        const [L, R] = this.getBorderLR(wrapper);
        if (i === 0) {
            this.addWidth(bbox, bbox.L + L);
        }
        this.visitNode(maction.selected, i);
        if (i === wrapper.breakCount) {
            this.addWidth(bbox, bbox.R + R);
        }
    }
}
(function () {
    for (const op of Object.keys(OPTABLE.postfix)) {
        const data = OPTABLE.postfix[op][3];
        if (data && data.fence) {
            data.linebreakstyle = 'after';
        }
    }
    OPTABLE.infix['\u2061'] = [...OPTABLE.infix['\u2061']];
    OPTABLE.infix['\u2061'][3] = { linebreak: 'nobreak' };
})();
//# sourceMappingURL=LinebreakVisitor.js.map
;// ./mjs/output/common.js










const FONTPATH = '@mathjax/%%FONT%%-font';
class CommonOutputJax extends AbstractOutputJax {
    get forceInlineBreaks() {
        return false;
    }
    constructor(options = {}, defaultFactory = null, defaultFont = null) {
        const [fontClass, font] = options.fontData instanceof FontData
            ? [options.fontData.constructor, options.fontData]
            : [options.fontData || defaultFont, null];
        const [jaxOptions, fontOptions] = separateOptions(options, fontClass.OPTIONS);
        super(jaxOptions);
        this.factory =
            this.options.wrapperFactory ||
                new defaultFactory();
        this.factory.jax = this;
        this.styleJson = this.options.styleJson || new StyleJsonSheet();
        this.font = font || new fontClass(fontOptions);
        this.font.setOptions({ mathmlSpacing: this.options.mathmlSpacing });
        this.unknownCache = new Map();
        const linebreaks = (this.options.linebreaks.LinebreakVisitor ||
            LinebreakVisitor);
        this.linebreaks = new linebreaks(this.factory);
    }
    setAdaptor(adaptor) {
        super.setAdaptor(adaptor);
        if (this.options.htmlHDW === 'auto') {
            this.options.htmlHDW = adaptor.canMeasureNodes ? 'ignore' : 'force';
        }
    }
    addExtension(font, prefix = '') {
        return this.font.addExtension(font, prefix);
    }
    typeset(math, html) {
        this.setDocument(html);
        const node = this.createNode();
        this.toDOM(math, node, html);
        return node;
    }
    createNode() {
        const jax = this.constructor.NAME;
        return this.html('mjx-container', { class: 'MathJax', jax: jax });
    }
    setScale(node, wrapper) {
        let scale = this.getInitialScale() * this.options.scale;
        if (wrapper.node.attributes.get('overflow') === 'scale' &&
            this.math.display) {
            const w = wrapper.getOuterBBox().w;
            const W = this.math.metrics.containerWidth / this.pxPerEm;
            if (w > W && w) {
                scale *= W / w;
            }
        }
        if (scale !== 1) {
            this.adaptor.setStyle(node, 'fontSize', percent(scale));
        }
    }
    getInitialScale() {
        return this.math.metrics.scale;
    }
    toDOM(math, node, html = null) {
        var _a;
        this.setDocument(html);
        this.math = math;
        this.container = node;
        this.pxPerEm = math.metrics.ex / this.font.params.x_height;
        this.executeFilters(this.preFilters, math, html, node);
        this.nodeMap = new Map();
        math.root.attributes.getAllInherited().overflow =
            this.options.displayOverflow;
        const overflow = math.root.attributes.get('overflow');
        this.adaptor.setAttribute(node, 'overflow', overflow);
        const linebreak = overflow === 'linebreak';
        if (linebreak) {
            this.getLinebreakWidth();
        }
        const makeBreaks = this.options.linebreaks.inline && !math.display;
        let inlineMarked = !!math.root.getProperty('inlineMarked');
        if (inlineMarked &&
            (!makeBreaks ||
                this.forceInlineBreaks !== math.root.getProperty('inlineForced'))) {
            this.unmarkInlineBreaks(math.root);
            math.root.removeProperty('inlineMarked');
            math.root.removeProperty('inlineForced');
            inlineMarked = false;
        }
        if (makeBreaks && !inlineMarked) {
            this.markInlineBreaks((_a = math.root.childNodes) === null || _a === void 0 ? void 0 : _a[0]);
            math.root.setProperty('inlineMarked', true);
            math.root.setProperty('inlineForced', this.forceInlineBreaks);
        }
        math.root.setTeXclass(null);
        const wrapper = this.factory.wrap(math.root);
        this.setScale(node, wrapper);
        this.processMath(wrapper, node);
        this.nodeMap = null;
        this.executeFilters(this.postFilters, math, html, node);
    }
    getBBox(math, html) {
        this.setDocument(html);
        this.math = math;
        math.root.setTeXclass(null);
        this.nodeMap = new Map();
        const bbox = this.factory.wrap(math.root).getOuterBBox();
        this.nodeMap = null;
        return bbox;
    }
    getLinebreakWidth() {
        const W = this.math.metrics.containerWidth / this.pxPerEm;
        const width = this.math.root.attributes.get('maxwidth') ||
            this.options.linebreaks.width;
        this.containerWidth = length2em(width, W, 1, this.pxPerEm);
    }
    markInlineBreaks(node) {
        if (!node)
            return;
        const forcebreak = this.forceInlineBreaks;
        let postbreak = false;
        let marked = false;
        let markNext = '';
        for (const child of node.childNodes) {
            if (markNext) {
                marked = this.markInlineBreak(marked, forcebreak, markNext, node, child);
                markNext = '';
                postbreak = false;
            }
            else if (child.isEmbellished) {
                if (child === node.childNodes[0]) {
                    continue;
                }
                const mo = child.coreMO();
                const texClass = mo.texClass;
                const linebreak = mo.attributes.get('linebreak');
                const linebreakstyle = mo.attributes.get('linebreakstyle');
                if ((texClass === TEXCLASS.BIN ||
                    texClass === TEXCLASS.REL ||
                    (texClass === TEXCLASS.ORD && mo.hasSpacingAttributes()) ||
                    linebreak !== 'auto') &&
                    linebreak !== 'nobreak') {
                    if (linebreakstyle === 'before') {
                        if (!postbreak || linebreak !== 'auto') {
                            marked = this.markInlineBreak(marked, forcebreak, linebreak, node, child, mo);
                        }
                    }
                    else {
                        markNext = linebreak;
                    }
                }
                postbreak = linebreak === 'newline' && linebreakstyle === 'after';
            }
            else if (child.isKind('mspace')) {
                const linebreak = child.attributes.get('linebreak');
                if (linebreak !== 'nobreak' && child.canBreak) {
                    marked = this.markInlineBreak(marked, forcebreak, linebreak, node, child);
                }
                postbreak = linebreak === 'newline';
            }
            else {
                postbreak = false;
                if ((child.isKind('mstyle') &&
                    !child.attributes.get('style') &&
                    !child.attributes.hasExplicit('mathbackground')) ||
                    child.isKind('semantics')) {
                    this.markInlineBreaks(child.childNodes[0]);
                    if (child.getProperty('process-breaks')) {
                        child.setProperty('inline-breaks', true);
                        child.childNodes[0].setProperty('inline-breaks', true);
                        node.parent.setProperty('process-breaks', 'true');
                    }
                }
                else if (child.isKind('mrow') &&
                    child.attributes.get('data-semantic-added')) {
                    this.markInlineBreaks(child);
                    if (child.getProperty('process-breaks')) {
                        child.setProperty('inline-breaks', true);
                        node.parent.setProperty('process-breaks', 'true');
                    }
                }
            }
        }
    }
    markInlineBreak(marked, forcebreak, linebreak, node, child, mo = null) {
        child.setProperty('breakable', true);
        if (forcebreak && linebreak !== 'newline') {
            child.setProperty('forcebreak', true);
            mo === null || mo === void 0 ? void 0 : mo.setProperty('forcebreak', true);
        }
        else {
            child.removeProperty('forcebreak');
            mo === null || mo === void 0 ? void 0 : mo.removeProperty('forcebreak');
            if (linebreak === 'newline') {
                child.setProperty('newline', true);
            }
        }
        if (!marked) {
            node.setProperty('process-breaks', true);
            node.parent.setProperty('process-breaks', true);
            marked = true;
        }
        return marked;
    }
    unmarkInlineBreaks(node) {
        if (!node)
            return;
        node.removeProperty('forcebreak');
        node.removeProperty('breakable');
        if (node.getProperty('process-breaks')) {
            node.removeProperty('process-breaks');
            for (const child of node.childNodes) {
                this.unmarkInlineBreaks(child);
            }
        }
    }
    getMetrics(html) {
        this.setDocument(html);
        const adaptor = this.adaptor;
        const maps = this.getMetricMaps(html);
        for (const math of html.math) {
            const parent = adaptor.parent(math.start.node);
            if (math.state() < STATE.METRICS && parent) {
                const map = maps[math.display ? 1 : 0];
                const { em, ex, containerWidth, scale, family } = map.get(parent);
                math.setMetrics(em, ex, containerWidth, scale);
                if (this.options.mtextInheritFont) {
                    math.outputData.mtextFamily = family;
                }
                if (this.options.merrorInheritFont) {
                    math.outputData.merrorFamily = family;
                }
                math.state(STATE.METRICS);
            }
        }
    }
    getMetricsFor(node, display) {
        const getFamily = this.options.mtextInheritFont || this.options.merrorInheritFont;
        const test = this.getTestElement(node, display);
        const metrics = Object.assign(Object.assign({}, this.measureMetrics(test, getFamily)), { display });
        this.adaptor.remove(test);
        return metrics;
    }
    getMetricMaps(html) {
        const adaptor = this.adaptor;
        const domMaps = [
            new Map(),
            new Map(),
        ];
        for (const math of html.math) {
            const node = adaptor.parent(math.start.node);
            if (node && math.state() < STATE.METRICS) {
                const map = domMaps[math.display ? 1 : 0];
                if (!map.has(node)) {
                    map.set(node, this.getTestElement(node, math.display));
                }
            }
        }
        const getFamily = this.options.mtextInheritFont || this.options.merrorInheritFont;
        const maps = [new Map(), new Map()];
        for (const i of maps.keys()) {
            for (const node of domMaps[i].keys()) {
                maps[i].set(node, this.measureMetrics(domMaps[i].get(node), getFamily));
            }
        }
        for (const i of maps.keys()) {
            for (const node of domMaps[i].values()) {
                adaptor.remove(node);
            }
        }
        return maps;
    }
    getTestElement(node, display) {
        const adaptor = this.adaptor;
        if (!this.testInline) {
            this.testInline = this.html('mjx-test', {
                style: {
                    display: 'inline-block',
                    width: '100%',
                    'font-style': 'normal',
                    'font-weight': 'normal',
                    'font-size': '100%',
                    'font-size-adjust': 'none',
                    'text-indent': 0,
                    'text-transform': 'none',
                    'letter-spacing': 'normal',
                    'word-spacing': 'normal',
                    overflow: 'hidden',
                    height: '1px',
                    'margin-right': '-1px',
                },
            }, [
                this.html('mjx-left-box', {
                    style: {
                        display: 'inline-block',
                        width: 0,
                        float: 'left',
                    },
                }),
                this.html('mjx-ex-box', {
                    style: {
                        position: 'absolute',
                        overflow: 'hidden',
                        width: '1px',
                        height: '60ex',
                    },
                }),
                this.html('mjx-right-box', {
                    style: {
                        display: 'inline-block',
                        width: 0,
                        float: 'right',
                    },
                }),
            ]);
            this.testDisplay = adaptor.clone(this.testInline);
            adaptor.setStyle(this.testDisplay, 'display', 'table');
            adaptor.setStyle(this.testDisplay, 'margin-right', '');
            adaptor.setStyle(adaptor.firstChild(this.testDisplay), 'display', 'none');
            const right = adaptor.lastChild(this.testDisplay);
            adaptor.setStyle(right, 'display', 'table-cell');
            adaptor.setStyle(right, 'width', '10000em');
            adaptor.setStyle(right, 'float', '');
        }
        return adaptor.append(node, adaptor.clone(display ? this.testDisplay : this.testInline));
    }
    measureMetrics(node, getFamily) {
        const adaptor = this.adaptor;
        const family = getFamily ? adaptor.fontFamily(node) : '';
        const em = adaptor.fontSize(node);
        const [w, h] = adaptor.nodeSize(adaptor.childNode(node, 1));
        const ex = w ? h / 60 : em * this.options.exFactor;
        const containerWidth = !w
            ? 1000000
            : adaptor.getStyle(node, 'display') === 'table'
                ? adaptor.nodeSize(adaptor.lastChild(node))[0] - 1
                : adaptor.nodeBBox(adaptor.lastChild(node)).left -
                    adaptor.nodeBBox(adaptor.firstChild(node)).left -
                    2;
        const scale = Math.max(this.options.minScale, this.options.matchFontHeight ? ex / this.font.params.x_height / em : 1);
        return { em, ex, containerWidth, scale, family };
    }
    styleSheet(html) {
        this.setDocument(html);
        this.styleJson.clear();
        this.styleJson.addStyles(this.constructor.commonStyles);
        if ('getStyles' in html) {
            for (const styles of html.getStyles()) {
                this.styleJson.addStyles(styles);
            }
        }
        this.addWrapperStyles(this.styleJson);
        this.addFontStyles(this.styleJson);
        const sheet = this.html('style', { id: 'MJX-styles' }, [
            this.text('\n' + this.styleJson.cssText + '\n'),
        ]);
        return sheet;
    }
    addFontStyles(styles) {
        styles.addStyles(this.font.styles);
    }
    addWrapperStyles(styles) {
        for (const kind of this.factory.getKinds()) {
            this.addClassStyles(this.factory.getNodeClass(kind), styles);
        }
    }
    addClassStyles(CLASS, styles) {
        CLASS.addStyles(styles, this);
    }
    insertStyles(_styles) { }
    setDocument(html) {
        if (html) {
            this.document = html;
            this.adaptor.document = html.document;
        }
    }
    html(type, def = {}, content = [], ns) {
        return this.adaptor.node(type, def, content, ns);
    }
    text(text) {
        return this.adaptor.text(text);
    }
    fixed(m, n = 3) {
        if (Math.abs(m) < 0.0006) {
            return '0';
        }
        return m.toFixed(n).replace(/\.?0+$/, '');
    }
    measureText(text, variant, font = ['', false, false]) {
        const node = this.unknownText(text, variant);
        if (variant === '-explicitFont') {
            const styles = this.cssFontStyles(font);
            this.adaptor.setAttributes(node, { style: styles });
        }
        return this.measureTextNodeWithCache(node, text, variant, font);
    }
    measureTextNodeWithCache(text, chars, variant, font = ['', false, false]) {
        if (variant === '-explicitFont') {
            variant = [font[0], font[1] ? 'T' : 'F', font[2] ? 'T' : 'F', ''].join('-');
        }
        if (!this.unknownCache.has(variant)) {
            this.unknownCache.set(variant, new Map());
        }
        const map = this.unknownCache.get(variant);
        const cached = map.get(chars);
        if (cached)
            return cached;
        const bbox = this.measureTextNode(text);
        map.set(chars, bbox);
        return bbox;
    }
    cssFontStyles(font, styles = {}) {
        const [family, italic, bold] = font;
        styles['font-family'] = this.font.getFamily(family);
        if (italic)
            styles['font-style'] = 'italic';
        if (bold)
            styles['font-weight'] = 'bold';
        return styles;
    }
    getFontData(styles) {
        if (!styles) {
            styles = new Styles();
        }
        return [
            this.font.getFamily(styles.get('font-family')),
            styles.get('font-style') === 'italic',
            styles.get('font-weight') === 'bold',
        ];
    }
}
CommonOutputJax.NAME = 'Common';
CommonOutputJax.OPTIONS = Object.assign(Object.assign({}, AbstractOutputJax.OPTIONS), { scale: 1, minScale: .5, mtextInheritFont: false, merrorInheritFont: false, mtextFont: '', merrorFont: 'serif', mathmlSpacing: false, skipAttributes: {}, exFactor: .5, displayAlign: 'center', displayIndent: '0', displayOverflow: 'overflow', linebreaks: {
        inline: true,
        width: '100%',
        lineleading: .2,
        LinebreakVisitor: null,
    }, font: '', htmlHDW: 'auto', wrapperFactory: null, fontData: null, fontPath: FONTPATH, styleJson: null });
CommonOutputJax.commonStyles = {
    'mjx-container[overflow="scroll"][display]': {
        overflow: 'auto clip',
        'min-width': 'initial !important',
    },
    'mjx-container[overflow="truncate"][display]': {
        overflow: 'hidden clip',
        'min-width': 'initial !important',
    },
    'mjx-container[display]': {
        display: 'block',
        'text-align': 'center',
        'justify-content': 'center',
        margin: 'calc(1em - 2px) 0',
        padding: '2px 0',
    },
    'mjx-container[display][width="full"]': {
        display: 'flex',
    },
    'mjx-container[justify="left"]': {
        'text-align': 'left',
        'justify-content': 'left',
    },
    'mjx-container[justify="right"]': {
        'text-align': 'right',
        'justify-content': 'right',
    },
};
//# sourceMappingURL=common.js.map
;// ./mjs/output/common/WrapperFactory.js

class CommonWrapperFactory extends AbstractWrapperFactory {
    constructor() {
        super(...arguments);
        this.jax = null;
    }
    get Wrappers() {
        return this.node;
    }
}
CommonWrapperFactory.defaultNodes = {};
//# sourceMappingURL=WrapperFactory.js.map
;// ./mjs/output/common/Wrapper.js









const SMALLSIZE = 2 / 18;
const MOSPACE = 5 / 18;
function MathMLSpace(script, nodict, size) {
    return nodict
        ? script
            ? SMALLSIZE
            : MOSPACE
        : script
            ? size < SMALLSIZE
                ? 0
                : SMALLSIZE
            : size;
}
const SPACE = {
    [em(0)]: '0',
    [em(2 / 18)]: '1',
    [em(3 / 18)]: '2',
    [em(4 / 18)]: '3',
    [em(5 / 18)]: '4',
    [em(6 / 18)]: '5'
};
class CommonWrapper extends AbstractWrapper {
    static addStyles(styles, _jax) {
        styles.addStyles(this.styles);
    }
    get jax() {
        return this.factory.jax;
    }
    get adaptor() {
        return this.factory.jax.adaptor;
    }
    get metrics() {
        return this.factory.jax.math.metrics;
    }
    get containerWidth() {
        return this.jax.containerWidth;
    }
    get linebreaks() {
        return this.jax.linebreaks;
    }
    get linebreakOptions() {
        return this.jax.options.linebreaks;
    }
    get fixesPWidth() {
        return !this.node.notParent && !this.node.isToken;
    }
    get breakCount() {
        if (this._breakCount < 0) {
            const node = this.node;
            this._breakCount = node.isEmbellished
                ? this.coreMO().embellishedBreakCount
                : node.arity < 0 &&
                    !node.linebreakContainer &&
                    this.childNodes[0]
                        .isStack
                    ? this.childNodes[0].breakCount
                    : 0;
        }
        return this._breakCount;
    }
    breakTop(mrow, _child) {
        return this.node.linebreakContainer || !this.parent
            ? mrow
            : this.parent.breakTop(mrow, this);
    }
    constructor(factory, node, parent = null) {
        super(factory, node);
        this.parent = null;
        this.dom = null;
        this.removedStyles = null;
        this.styles = null;
        this.styleData = null;
        this.variant = '';
        this.bboxComputed = false;
        this._breakCount = -1;
        this.lineBBox = [];
        this.stretch = NOSTRETCH;
        this.font = null;
        this.parent = parent;
        this.font = factory.jax.font;
        this.bbox = BBox.zero();
        this.getStyles();
        this.getStyleData();
        this.getVariant();
        this.getScale();
        this.getSpace();
        this.childNodes = node.childNodes.map((child) => {
            const wrapped = this.wrap(child);
            if (wrapped.bbox.pwidth && (node.notParent || node.isKind('math'))) {
                this.bbox.pwidth = BBox.fullWidth;
            }
            return wrapped;
        });
    }
    wrap(node, parent = null) {
        const wrapped = this.factory.wrap(node, parent || this);
        if (parent) {
            parent.childNodes.push(wrapped);
        }
        this.jax.nodeMap.set(node, wrapped);
        return wrapped;
    }
    getBBox(save = true) {
        if (this.bboxComputed) {
            return this.bbox;
        }
        const bbox = save ? this.bbox : BBox.zero();
        this.computeBBox(bbox);
        this.bboxComputed = save;
        return bbox;
    }
    getOuterBBox(save = true) {
        var _a;
        const bbox = this.getBBox(save);
        if (!this.styleData)
            return bbox;
        const padding = this.styleData.padding;
        const border = ((_a = this.styleData.border) === null || _a === void 0 ? void 0 : _a.width) || [0, 0, 0, 0];
        const obox = bbox.copy();
        for (const [, i, side] of BBox.boxSides) {
            obox[side] += padding[i] + border[i];
        }
        return obox;
    }
    getUnbrokenHD() {
        const n = this.breakCount + 1;
        let H = 0;
        let D = 0;
        for (let i = 0; i < n; i++) {
            const { h, d } = this.getLineBBox(i);
            if (h > H) {
                H = h;
            }
            if (d > D) {
                D = d;
            }
        }
        return [H, D];
    }
    computeBBox(bbox, recompute = false) {
        bbox.empty();
        for (const child of this.childNodes) {
            bbox.append(child.getOuterBBox());
        }
        bbox.clean();
        if (this.fixesPWidth && this.setChildPWidths(recompute)) {
            this.computeBBox(bbox, true);
        }
    }
    getLineBBox(i) {
        if (!this.lineBBox[i]) {
            const n = this.breakCount;
            if (n) {
                const line = this.embellishedBBox(i) || this.computeLineBBox(i);
                this.lineBBox[i] = line;
                if (i === 0) {
                    if (!this.node.isKind('mo') && this.node.isEmbellished) {
                        line.originalL = this.getBBox().L;
                    }
                    else {
                        line.L = this.getBBox().L;
                    }
                }
                if (i === n) {
                    line.R = this.getBBox().R;
                }
            }
            else {
                const obox = this.getOuterBBox();
                this.lineBBox[i] = LineBBox.from(obox, this.linebreakOptions.lineleading);
            }
        }
        return this.lineBBox[i];
    }
    embellishedBBox(i) {
        if (!this.node.isEmbellished || this.node.isKind('mo'))
            return null;
        const mo = this.coreMO();
        return mo.moLineBBox(i, mo.embellishedBreakStyle, this.getOuterBBox());
    }
    computeLineBBox(i) {
        return this.getChildLineBBox(this.childNodes[0], i);
    }
    getBreakNode(bbox) {
        var _a, _b;
        if (!bbox.start) {
            return [this, null];
        }
        const [i, j] = bbox.start;
        if (this.node.isEmbellished) {
            return [this, this.coreMO()];
        }
        const childNodes = ((_b = (_a = this.childNodes[0]) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.isInferred)
            ? this.childNodes[0].childNodes
            : this.childNodes;
        if (this.node.isToken || !childNodes[i]) {
            return [this, null];
        }
        return childNodes[i].getBreakNode(childNodes[i].getLineBBox(j));
    }
    getChildLineBBox(child, i) {
        const n = this.breakCount;
        let cbox = child.getLineBBox(i);
        if (this.styleData || this.bbox.L || this.bbox.R) {
            cbox = cbox.copy();
        }
        this.addMiddleBorders(cbox);
        if (i === 0) {
            cbox.L += this.bbox.L;
            this.addLeftBorders(cbox);
        }
        else if (i === n) {
            cbox.R += this.bbox.R;
            this.addRightBorders(cbox);
        }
        return cbox;
    }
    addLeftBorders(bbox) {
        var _a;
        if (!this.styleData)
            return;
        const border = this.styleData.border;
        const padding = this.styleData.padding;
        bbox.w += (((_a = border === null || border === void 0 ? void 0 : border.width) === null || _a === void 0 ? void 0 : _a[3]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[3]) || 0);
    }
    addMiddleBorders(bbox) {
        var _a, _b;
        if (!this.styleData)
            return;
        const border = this.styleData.border;
        const padding = this.styleData.padding;
        bbox.h += (((_a = border === null || border === void 0 ? void 0 : border.width) === null || _a === void 0 ? void 0 : _a[0]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[0]) || 0);
        bbox.d += (((_b = border === null || border === void 0 ? void 0 : border.width) === null || _b === void 0 ? void 0 : _b[2]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[2]) || 0);
    }
    addRightBorders(bbox) {
        var _a;
        if (!this.styleData)
            return;
        const border = this.styleData.border;
        const padding = this.styleData.padding;
        bbox.w += (((_a = border === null || border === void 0 ? void 0 : border.width) === null || _a === void 0 ? void 0 : _a[1]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[1]) || 0);
    }
    setChildPWidths(recompute, w = null, clear = true) {
        if (recompute) {
            return false;
        }
        if (clear) {
            this.bbox.pwidth = '';
        }
        let changed = false;
        for (const child of this.childNodes) {
            const cbox = child.getBBox();
            if (cbox.pwidth &&
                child.setChildPWidths(recompute, w === null ? cbox.w : w, clear)) {
                changed = true;
            }
        }
        return changed;
    }
    breakToWidth(_W) {
    }
    invalidateBBox(bubble = true) {
        if (this.bboxComputed || this._breakCount >= 0) {
            this.bboxComputed = false;
            this.lineBBox = [];
            this._breakCount = -1;
            if (this.parent && bubble) {
                this.parent.invalidateBBox();
            }
        }
    }
    copySkewIC(bbox) {
        var _a, _b, _c;
        const first = this.childNodes[0];
        if ((_a = first === null || first === void 0 ? void 0 : first.bbox) === null || _a === void 0 ? void 0 : _a.sk) {
            bbox.sk = first.bbox.sk;
        }
        if ((_b = first === null || first === void 0 ? void 0 : first.bbox) === null || _b === void 0 ? void 0 : _b.dx) {
            bbox.dx = first.bbox.dx;
        }
        const last = this.childNodes[this.childNodes.length - 1];
        if ((_c = last === null || last === void 0 ? void 0 : last.bbox) === null || _c === void 0 ? void 0 : _c.ic) {
            bbox.ic = last.bbox.ic;
            bbox.w += bbox.ic;
        }
    }
    getStyles() {
        const styleString = this.node.attributes.getExplicit('style');
        if (!styleString)
            return;
        const style = (this.styles = new Styles(styleString));
        for (let i = 0, m = CommonWrapper.removeStyles.length; i < m; i++) {
            const id = CommonWrapper.removeStyles[i];
            if (style.get(id)) {
                if (!this.removedStyles)
                    this.removedStyles = {};
                this.removedStyles[id] = style.get(id);
                style.set(id, '');
            }
        }
    }
    getStyleData() {
        if (!this.styles)
            return;
        const padding = Array(4).fill(0);
        const width = Array(4).fill(0);
        const style = Array(4);
        const color = Array(4);
        let hasPadding = false;
        let hasBorder = false;
        for (const [name, i] of BBox.boxSides) {
            const key = 'border' + name;
            const w = this.styles.get(key + 'Width');
            if (w) {
                hasBorder = true;
                width[i] = Math.max(0, this.length2em(w, 1));
                style[i] = this.styles.get(key + 'Style') || 'solid';
                color[i] = this.styles.get(key + 'Color');
            }
            const p = this.styles.get('padding' + name);
            if (p) {
                hasPadding = true;
                padding[i] = Math.max(0, this.length2em(p, 1));
            }
        }
        this.styleData =
            hasPadding || hasBorder
                ? {
                    padding,
                    border: hasBorder ? { width, style, color } : null,
                }
                : null;
    }
    getVariant() {
        if (!this.node.isToken)
            return;
        const attributes = this.node.attributes;
        let variant = attributes.get('mathvariant');
        if (attributes.hasExplicit('mathvariant')) {
            if (!this.font.getVariant(variant)) {
                console.warn(`Invalid variant: ${variant}`);
                variant = 'normal';
            }
        }
        else {
            const values = attributes.getList('fontfamily', 'fontweight', 'fontstyle');
            if (this.removedStyles) {
                const style = this.removedStyles;
                if (style.fontFamily)
                    values.family = style.fontFamily;
                if (style.fontWeight)
                    values.weight = style.fontWeight;
                if (style.fontStyle)
                    values.style = style.fontStyle;
            }
            if (values.fontfamily)
                values.family = values.fontfamily;
            if (values.fontweight)
                values.weight = values.fontweight;
            if (values.fontstyle)
                values.style = values.fontstyle;
            if (values.weight && values.weight.match(/^\d+$/)) {
                values.weight = parseInt(values.weight) > 600 ? 'bold' : 'normal';
            }
            if (values.family) {
                variant = this.explicitVariant(values.family, values.weight, values.style);
            }
            else {
                if (this.node.getProperty('variantForm'))
                    variant = '-tex-variant';
                variant =
                    (CommonWrapper.BOLDVARIANTS[values.weight] || {})[variant] || variant;
                variant =
                    (CommonWrapper.ITALICVARIANTS[values.style] || {})[variant] ||
                        variant;
            }
        }
        this.variant = variant;
    }
    explicitVariant(fontFamily, fontWeight, fontStyle) {
        let style = this.styles;
        if (!style)
            style = this.styles = new Styles();
        style.set('fontFamily', fontFamily);
        if (fontWeight)
            style.set('fontWeight', fontWeight);
        if (fontStyle)
            style.set('fontStyle', fontStyle);
        return '-explicitFont';
    }
    getScale() {
        let scale = 1;
        const parent = this.parent;
        const pscale = parent ? parent.bbox.scale : 1;
        const attributes = this.node.attributes;
        const scriptlevel = Math.min(attributes.get('scriptlevel'), 2);
        let fontsize = attributes.get('fontsize');
        let mathsize = this.node.isToken || this.node.isKind('mstyle')
            ? attributes.get('mathsize')
            : attributes.getInherited('mathsize');
        if (scriptlevel !== 0) {
            scale = Math.pow(attributes.get('scriptsizemultiplier'), scriptlevel);
        }
        if (this.removedStyles && this.removedStyles.fontSize && !fontsize) {
            fontsize = this.removedStyles.fontSize;
        }
        if (fontsize && !attributes.hasExplicit('mathsize')) {
            mathsize = fontsize;
        }
        if (mathsize !== '1') {
            scale *= this.length2em(mathsize, 1, 1);
        }
        if (scriptlevel !== 0) {
            const scriptminsize = this.length2em(attributes.get('scriptminsize'), 0.4, 1);
            if (scale < scriptminsize)
                scale = scriptminsize;
        }
        this.bbox.scale = scale;
        this.bbox.rscale = scale / pscale;
    }
    getSpace() {
        const isTop = this.isTopEmbellished();
        const hasSpacing = this.node.hasSpacingAttributes();
        if (this.jax.options.mathmlSpacing || hasSpacing) {
            if (isTop) {
                this.getMathMLSpacing();
            }
        }
        else {
            this.getTeXSpacing(isTop, hasSpacing);
        }
    }
    getMathMLSpacing() {
        const node = this.node.coreMO();
        const child = node.coreParent();
        const parent = child.parent;
        if (!parent || !parent.isKind('mrow') || parent.childNodes.length === 1) {
            return;
        }
        const n = parent.childIndex(child);
        if (n === null)
            return;
        const noDictDef = node.getProperty('noDictDef');
        const attributes = node.attributes;
        const isScript = attributes.get('scriptlevel') > 0;
        this.bbox.L = attributes.isSet('lspace')
            ? Math.max(0, this.length2em(attributes.get('lspace')))
            : MathMLSpace(isScript, noDictDef, node.lspace);
        this.bbox.R = attributes.isSet('rspace')
            ? Math.max(0, this.length2em(attributes.get('rspace')))
            : MathMLSpace(isScript, noDictDef, node.rspace);
        if (!n)
            return;
        const prev = parent.childNodes[n - 1];
        if (!prev.isEmbellished)
            return;
        const bbox = this.jax.nodeMap.get(prev).getBBox();
        if (bbox.R) {
            this.bbox.L = Math.max(0, this.bbox.L - bbox.R);
        }
    }
    getTeXSpacing(isTop, hasSpacing) {
        if (!hasSpacing) {
            const space = this.node.texSpacing();
            if (space) {
                this.bbox.L = this.length2em(space);
            }
        }
        if (isTop || hasSpacing) {
            const attributes = this.node.coreMO().attributes;
            if (attributes.isSet('lspace')) {
                this.bbox.L = Math.max(0, this.length2em(attributes.get('lspace')));
            }
            if (attributes.isSet('rspace')) {
                this.bbox.R = Math.max(0, this.length2em(attributes.get('rspace')));
            }
        }
    }
    isTopEmbellished() {
        return (this.node.isEmbellished &&
            !(this.node.parent && this.node.parent.isEmbellished));
    }
    core() {
        return this.jax.nodeMap.get(this.node.core());
    }
    coreMO() {
        return this.jax.nodeMap.get(this.node.coreMO());
    }
    coreRScale() {
        let rscale = this.bbox.rscale;
        let node = this.coreMO();
        while (node !== this && node) {
            rscale *= node.bbox.rscale;
            node = node.parent;
        }
        return rscale;
    }
    getRScale() {
        let rscale = 1;
        let node = this;
        while (node) {
            rscale *= node.bbox.rscale;
            node = node.parent;
        }
        return rscale;
    }
    getText() {
        let text = '';
        if (this.node.isToken) {
            for (const child of this.node.childNodes) {
                if (child instanceof TextNode) {
                    text += child.getText();
                }
            }
        }
        return text;
    }
    canStretch(direction) {
        this.stretch = NOSTRETCH;
        if (this.node.isEmbellished) {
            const core = this.core();
            if (core && core.node !== this.node) {
                if (core.canStretch(direction)) {
                    this.stretch = core.stretch;
                }
            }
        }
        return this.stretch.dir !== DIRECTION.None;
    }
    getAlignShift() {
        let { indentalign, indentshift, indentalignfirst, indentshiftfirst } = this.node.attributes.getAllAttributes();
        if (indentalignfirst !== 'indentalign') {
            indentalign = indentalignfirst;
        }
        if (indentshiftfirst !== 'indentshift') {
            indentshift = indentshiftfirst;
        }
        return this.processIndent(indentalign, indentshift);
    }
    processIndent(indentalign, indentshift, align = '', shift = '', width = this.metrics.containerWidth) {
        if (!this.jax.math.display) {
            return ['left', 0];
        }
        if (!align || align === 'auto') {
            align = this.jax.math.root.getProperty('inlineMarked')
                ? 'left'
                : this.jax.options.displayAlign;
        }
        if (!shift || shift === 'auto') {
            shift = this.jax.math.root.getProperty('inlineMarked')
                ? '0'
                : this.jax.options.displayIndent;
        }
        if (indentalign === 'auto') {
            indentalign = align;
        }
        if (indentshift === 'auto') {
            indentshift = shift;
            if (indentalign === 'right' && !indentshift.match(/^\s*0[a-z]*\s*$/)) {
                indentshift = ('-' + indentshift.trim()).replace(/^--/, '');
            }
        }
        const indent = this.length2em(indentshift, width);
        return [indentalign, indent];
    }
    getAlignX(W, bbox, align) {
        return align === 'right'
            ? W - (bbox.w + bbox.R) * bbox.rscale
            : align === 'left'
                ? bbox.L * bbox.rscale
                : (W - bbox.w * bbox.rscale) / 2;
    }
    getAlignY(H, D, h, d, align) {
        return align === 'top'
            ? H - h
            : align === 'bottom'
                ? d - D
                : align === 'center'
                    ? (H - h - (D - d)) / 2
                    : 0;
    }
    getWrapWidth(i) {
        return this.childNodes[i].getBBox().w;
    }
    getChildAlign(_i) {
        return 'left';
    }
    percent(m) {
        return percent(m);
    }
    em(m) {
        return em(m);
    }
    px(m, M = -BIGDIMEN) {
        return px(m, M, this.metrics.em);
    }
    length2em(length, size = 1, scale = null) {
        if (scale === null) {
            scale = this.bbox.scale;
        }
        const t = this.font.params.rule_thickness;
        const factor = lookup(length, { medium: 1, thin: 2 / 3, thick: 5 / 3 }, 0);
        return factor
            ? factor * t
            : length2em(length, size, scale, this.jax.pxPerEm);
    }
    unicodeChars(text, name = this.variant) {
        let chars = unicodeChars(text);
        const variant = this.font.getVariant(name);
        if (variant && variant.chars) {
            const map = variant.chars;
            chars = chars.map((n) => { var _a, _b; return ((_b = (_a = map[n]) === null || _a === void 0 ? void 0 : _a[3]) === null || _b === void 0 ? void 0 : _b.smp) || n; });
        }
        return chars;
    }
    remapChars(chars) {
        return chars;
    }
    mmlText(text) {
        return this.node.factory.create('text').setText(text);
    }
    mmlNode(kind, properties = {}, children = []) {
        return this.node.factory.create(kind, properties, children);
    }
    createMo(text) {
        const mmlFactory = this.node.factory;
        const textNode = mmlFactory.create('text').setText(text);
        const mml = mmlFactory.create('mo', { stretchy: true }, [textNode]);
        mml.inheritAttributesFrom(this.node);
        mml.parent = this.node.parent;
        const node = this.wrap(mml);
        node.parent = this;
        return node;
    }
    getVariantChar(variant, n) {
        const char = this.font.getChar(variant, n) || [0, 0, 0, { unknown: true }];
        if (char.length === 3) {
            char[3] = {};
        }
        return char;
    }
    html(type, def = {}, content = []) {
        return this.jax.html(type, def, content);
    }
}
CommonWrapper.kind = 'unknown';
CommonWrapper.styles = {};
CommonWrapper.removeStyles = [
    'fontSize',
    'fontFamily',
    'fontWeight',
    'fontStyle',
    'fontVariant',
    'font',
];
CommonWrapper.skipAttributes = {
    fontfamily: true,
    fontsize: true,
    fontweight: true,
    fontstyle: true,
    color: true,
    background: true,
    class: true,
    href: true,
    style: true,
    xmlns: true,
};
CommonWrapper.BOLDVARIANTS = {
    bold: {
        normal: 'bold',
        italic: 'bold-italic',
        fraktur: 'bold-fraktur',
        script: 'bold-script',
        'sans-serif': 'bold-sans-serif',
        'sans-serif-italic': 'sans-serif-bold-italic',
    },
    normal: {
        bold: 'normal',
        'bold-italic': 'italic',
        'bold-fraktur': 'fraktur',
        'bold-script': 'script',
        'bold-sans-serif': 'sans-serif',
        'sans-serif-bold-italic': 'sans-serif-italic',
    },
};
CommonWrapper.ITALICVARIANTS = {
    italic: {
        normal: 'italic',
        bold: 'bold-italic',
        'sans-serif': 'sans-serif-italic',
        'bold-sans-serif': 'sans-serif-bold-italic',
    },
    normal: {
        italic: 'normal',
        'bold-italic': 'bold',
        'sans-serif-italic': 'sans-serif',
        'sans-serif-bold-italic': 'bold-sans-serif',
    },
};
//# sourceMappingURL=Wrapper.js.map
;// ./mjs/output/chtml/Wrapper.js


const FONTSIZE = {
    '70.7%': 's',
    '70%': 's',
    '50%': 'ss',
    '60%': 'Tn',
    '85%': 'sm',
    '120%': 'lg',
    '144%': 'Lg',
    '173%': 'LG',
    '207%': 'hg',
    '249%': 'HG',
};
class ChtmlWrapper extends CommonWrapper {
    toCHTML(parents) {
        if (this.toEmbellishedCHTML(parents))
            return;
        this.addChildren(this.standardChtmlNodes(parents));
    }
    toEmbellishedCHTML(parents) {
        if (parents.length <= 1 || !this.node.isEmbellished)
            return false;
        const adaptor = this.adaptor;
        parents.forEach((dom) => adaptor.append(dom, this.html('mjx-linestrut')));
        const style = this.coreMO().embellishedBreakStyle;
        const dom = [];
        for (const [parent, STYLE] of [
            [parents[0], 'before'],
            [parents[1], 'after'],
        ]) {
            if (style !== STYLE) {
                this.toCHTML([parent]);
                dom.push(this.dom[0]);
                if (STYLE === 'after') {
                    adaptor.removeAttribute(this.dom[0], 'space');
                }
            }
            else {
                dom.push(this.createChtmlNodes([parent])[0]);
            }
        }
        this.dom = dom;
        return true;
    }
    addChildren(parents) {
        for (const child of this.childNodes) {
            child.toCHTML(parents);
        }
    }
    standardChtmlNodes(parents) {
        this.markUsed();
        const chtml = this.createChtmlNodes(parents);
        this.handleStyles();
        this.handleScale();
        this.handleBorders();
        this.handleColor();
        this.handleSpace();
        this.handleAttributes();
        this.handlePWidth();
        return chtml;
    }
    markUsed() {
        this.jax.wrapperUsage.add(this.kind);
    }
    createChtmlNodes(parents) {
        this.dom = parents.map((_parent) => this.html('mjx-' + this.node.kind));
        parents = this.handleHref(parents);
        for (const i of parents.keys()) {
            this.adaptor.append(parents[i], this.dom[i]);
        }
        return this.dom;
    }
    handleHref(parents) {
        const href = this.node.attributes.get('href');
        if (!href)
            return parents;
        return parents.map((parent) => this.adaptor.append(parent, this.html('a', { href: href })));
    }
    handleStyles() {
        if (!this.styles)
            return;
        const styles = this.styles.cssText;
        if (styles) {
            const adaptor = this.adaptor;
            this.dom.forEach((dom) => adaptor.setAttribute(dom, 'style', styles));
            const family = this.styles.get('font-family');
            if (family) {
                this.dom.forEach((dom) => adaptor.setStyle(dom, 'font-family', this.font.cssFamilyPrefix + ', ' + family));
            }
        }
    }
    handleScale() {
        this.dom.forEach((dom) => this.setScale(dom, this.bbox.rscale));
    }
    setScale(chtml, rscale) {
        const scale = Math.abs(rscale - 1) < 0.001 ? 1 : rscale;
        if (chtml && scale !== 1) {
            const size = this.percent(scale);
            if (FONTSIZE[size]) {
                this.adaptor.setAttribute(chtml, 'size', FONTSIZE[size]);
            }
            else {
                this.adaptor.setStyle(chtml, 'fontSize', size);
            }
        }
        return chtml;
    }
    handleSpace() {
        const adaptor = this.adaptor;
        const breakable = !!this.node.getProperty('breakable') && !this.node.getProperty('newline');
        const n = this.dom.length - 1;
        for (const data of [
            [this.getLineBBox(0).L, 'space', 'marginLeft', 0],
            [this.getLineBBox(n).R, 'rspace', 'marginRight', n],
        ]) {
            const [dimen, name, margin, i] = data;
            const space = this.em(dimen);
            if (breakable && name === 'space') {
                const node = adaptor.node('mjx-break', SPACE[space]
                    ? { size: SPACE[space] }
                    : { style: `letter-spacing: ${this.em(dimen - 1)}` }, [adaptor.text(' ')]);
                adaptor.insert(node, this.dom[i]);
            }
            else if (dimen) {
                if (SPACE[space]) {
                    adaptor.setAttribute(this.dom[i], name, SPACE[space]);
                }
                else {
                    adaptor.setStyle(this.dom[i], margin, space);
                }
            }
        }
    }
    handleBorders() {
        var _a, _b;
        const border = (_a = this.styleData) === null || _a === void 0 ? void 0 : _a.border;
        const padding = (_b = this.styleData) === null || _b === void 0 ? void 0 : _b.padding;
        const n = this.dom.length - 1;
        if (!border || !n)
            return;
        const adaptor = this.adaptor;
        for (const k of this.dom.keys()) {
            const dom = this.dom[k];
            if (k) {
                if (border.width[3]) {
                    adaptor.setStyle(dom, 'border-left', ' none');
                }
                if (padding[3]) {
                    adaptor.setStyle(dom, 'padding-left', '0');
                }
            }
            if (k !== n) {
                if (border.width[1]) {
                    adaptor.setStyle(dom, 'border-right', 'none');
                }
                if (padding[1]) {
                    adaptor.setStyle(dom, 'padding-right', '0');
                }
            }
        }
    }
    handleColor() {
        var _a;
        const adaptor = this.adaptor;
        const attributes = this.node.attributes;
        const color = (attributes.getExplicit('mathcolor') ||
            attributes.getExplicit('color'));
        const background = (attributes.getExplicit('mathbackground') ||
            attributes.getExplicit('background') ||
            ((_a = this.styles) === null || _a === void 0 ? void 0 : _a.get('background-color')));
        if (color) {
            this.dom.forEach((dom) => adaptor.setStyle(dom, 'color', color));
        }
        if (background) {
            this.dom.forEach((dom) => adaptor.setStyle(dom, 'backgroundColor', background));
        }
    }
    handleAttributes() {
        const adaptor = this.adaptor;
        const attributes = this.node.attributes;
        const defaults = attributes.getAllDefaults();
        const skip = ChtmlWrapper.skipAttributes;
        for (const name of attributes.getExplicitNames()) {
            if (skip[name] === false ||
                (!(name in defaults) &&
                    !skip[name] &&
                    !adaptor.hasAttribute(this.dom[0], name))) {
                const value = attributes.getExplicit(name);
                this.dom.forEach((dom) => adaptor.setAttribute(dom, name, value));
            }
        }
        if (attributes.get('class')) {
            const names = attributes.get('class').trim().split(/ +/);
            for (const name of names) {
                this.dom.forEach((dom) => adaptor.addClass(dom, name));
            }
        }
        if (this.node.getProperty('inline-breaks')) {
            this.dom.forEach((dom) => adaptor.setAttribute(dom, 'inline-breaks', 'true'));
        }
    }
    handlePWidth() {
        if (this.bbox.pwidth) {
            const adaptor = this.adaptor;
            if (this.bbox.pwidth === BBox.fullWidth) {
                this.dom.forEach((dom) => adaptor.setAttribute(dom, 'width', 'full'));
            }
            else {
                this.dom.forEach((dom) => adaptor.setStyle(dom, 'width', this.bbox.pwidth));
            }
        }
    }
    setIndent(chtml, align, shift) {
        const adaptor = this.adaptor;
        if (align === 'center' || align === 'left') {
            const L = this.getBBox().L;
            adaptor.setStyle(chtml, 'margin-left', this.em(shift + L));
        }
        if (align === 'center' || align === 'right') {
            const R = this.getBBox().R;
            adaptor.setStyle(chtml, 'margin-right', this.em(-shift + R));
        }
    }
    drawBBox() {
        const { w, h, d, R } = this.getOuterBBox();
        const box = this.html('mjx-box', {
            style: {
                opacity: 0.25,
                'margin-left': this.em(-w - R),
            },
        }, [
            this.html('mjx-box', {
                style: {
                    height: this.em(h),
                    width: this.em(w),
                    'background-color': 'red',
                },
            }),
            this.html('mjx-box', {
                style: {
                    height: this.em(d),
                    width: this.em(w),
                    'margin-left': this.em(-w),
                    'vertical-align': this.em(-d),
                    'background-color': 'green',
                },
            }),
        ]);
        const node = this.dom[0] || this.parent.dom[0];
        const size = this.adaptor.getAttribute(node, 'size');
        if (size) {
            this.adaptor.setAttribute(box, 'size', size);
        }
        const fontsize = this.adaptor.getStyle(node, 'fontSize');
        if (fontsize) {
            this.adaptor.setStyle(box, 'fontSize', fontsize);
        }
        this.adaptor.append(this.adaptor.parent(node), box);
        this.adaptor.setStyle(node, 'backgroundColor', '#FFEE00');
    }
    html(type, def = {}, content = []) {
        return this.jax.html(type, def, content);
    }
    text(text) {
        return this.jax.text(text);
    }
    char(n) {
        return this.font.charSelector(n).substring(1);
    }
}
ChtmlWrapper.kind = 'unknown';
ChtmlWrapper.autoStyle = true;
//# sourceMappingURL=Wrapper.js.map
;// ./mjs/output/common/Wrappers/math.js
function CommonMathMixin(Base) {
    return class CommonMathMixin extends Base {
        getWrapWidth(_i) {
            return this.parent
                ? this.getBBox().w
                : this.metrics.containerWidth / this.jax.pxPerEm;
        }
        computeBBox(bbox, recompute = false) {
            super.computeBBox(bbox, recompute);
            const attributes = this.node.attributes;
            if (!this.parent &&
                this.jax.math.display &&
                attributes.get('overflow') === 'linebreak') {
                const W = this.containerWidth;
                if (bbox.w > W) {
                    this.childNodes[0].breakToWidth(W);
                }
                bbox.updateFrom(this.childNodes[0].getBBox());
            }
        }
    };
}
//# sourceMappingURL=math.js.map
;// ./mjs/output/chtml/Wrappers/math.js




const ChtmlMath = (function () {
    var _a;
    const Base = CommonMathMixin(ChtmlWrapper);
    return _a = class ChtmlMath extends Base {
            handleDisplay(parent) {
                const adaptor = this.adaptor;
                const [align, shift] = this.getAlignShift();
                if (align !== 'center') {
                    adaptor.setAttribute(parent, 'justify', align);
                }
                if (this.bbox.pwidth === BBox.fullWidth) {
                    adaptor.setAttribute(parent, 'width', 'full');
                    if (this.jax.table) {
                        let { L, w, R } = this.jax.table.getOuterBBox();
                        if (align === 'right') {
                            R = Math.max(R || -shift, -shift);
                        }
                        else if (align === 'left') {
                            L = Math.max(L || shift, shift);
                        }
                        else if (align === 'center') {
                            w += 2 * Math.abs(shift);
                        }
                        const W = this.em(Math.max(0, L + w + R));
                        adaptor.setStyle(parent, 'min-width', W);
                        adaptor.setStyle(this.jax.table.dom[0], 'min-width', W);
                    }
                }
                else {
                    this.setIndent(this.dom[0], align, shift);
                }
            }
            handleInline(parent) {
                const adaptor = this.adaptor;
                const margin = adaptor.getStyle(this.dom[0], 'margin-right');
                if (margin) {
                    adaptor.setStyle(this.dom[0], 'margin-right', '');
                    adaptor.setStyle(parent, 'margin-right', margin);
                    adaptor.setStyle(parent, 'width', '0');
                }
            }
            toCHTML(parents) {
                super.toCHTML(parents);
                const adaptor = this.adaptor;
                const display = this.node.attributes.get('display') === 'block';
                if (display) {
                    adaptor.setAttribute(this.dom[0], 'display', 'true');
                    adaptor.setAttribute(parents[0], 'display', 'true');
                    this.handleDisplay(parents[0]);
                }
                else {
                    this.handleInline(parents[0]);
                }
                adaptor.addClass(this.dom[0], `${this.font.cssFontPrefix}-N`);
            }
            setChildPWidths(recompute, w = null, clear = true) {
                return this.parent ? super.setChildPWidths(recompute, w, clear) : false;
            }
            handleAttributes() {
                super.handleAttributes();
                const adaptor = this.adaptor;
                if (this.node.getProperty('process-breaks')) {
                    this.dom.forEach((dom) => adaptor.setAttribute(dom, 'breakable', 'true'));
                }
            }
        },
        _a.kind = MmlMath.prototype.kind,
        _a.styles = {
            'mjx-math': {
                'line-height': 0,
                'text-align': 'left',
                'text-indent': 0,
                'font-style': 'normal',
                'font-weight': 'normal',
                'font-size': '100%',
                'font-size-adjust': 'none',
                'letter-spacing': 'normal',
                'word-wrap': 'normal',
                'word-spacing': 'normal',
                direction: 'ltr',
                padding: '1px 0',
            },
            'mjx-container[jax="CHTML"][display="true"] mjx-math': {
                padding: 0,
            },
            'mjx-math[breakable]': {
                display: 'inline',
            },
            'mjx-container[jax="CHTML"] mjx-break': {
                'white-space': 'normal',
                'line-height': '0',
                'clip-path': 'rect(0 0 0 0)',
                'font-family': 'MJX-BRK !important',
            },
            'mjx-break[size="0"]': {
                'letter-spacing': 0.001 - 1 + 'em',
            },
            'mjx-break[size="1"]': {
                'letter-spacing': 0.111 - 1 + 'em',
            },
            'mjx-break[size="2"]': {
                'letter-spacing': 0.167 - 1 + 'em',
            },
            'mjx-break[size="3"]': {
                'letter-spacing': 0.222 - 1 + 'em',
            },
            'mjx-break[size="4"]': {
                'letter-spacing': 0.278 - 1 + 'em',
            },
            'mjx-break[size="5"]': {
                'letter-spacing': 0.333 - 1 + 'em',
            },
        },
        _a;
})();
//# sourceMappingURL=math.js.map
;// ./mjs/output/common/Wrappers/mi.js
function CommonMiMixin(Base) {
    return class CommonMiMixin extends Base {
        computeBBox(bbox, _recompute = false) {
            super.computeBBox(bbox);
            this.copySkewIC(bbox);
        }
    };
}
//# sourceMappingURL=mi.js.map
;// ./mjs/output/chtml/Wrappers/mi.js



const ChtmlMi = (function () {
    var _a;
    const Base = CommonMiMixin(ChtmlWrapper);
    return _a = class ChtmlMi extends Base {
        },
        _a.kind = MmlMi.prototype.kind,
        _a;
})();
//# sourceMappingURL=mi.js.map
;// ./mjs/output/common/Wrappers/mo.js





function CommonMoMixin(Base) {
    return class CommonMoMixin extends Base {
        get breakCount() {
            return this.breakStyle ? 1 : 0;
        }
        get embellishedBreakCount() {
            return this.embellishedBreakStyle ? 1 : 0;
        }
        get embellishedBreakStyle() {
            return this.breakStyle || this.getBreakStyle();
        }
        protoBBox(bbox) {
            const stretchy = this.stretch.dir !== DIRECTION.None;
            if (stretchy && this.size === null) {
                this.getStretchedVariant([0]);
            }
            if (stretchy && this.size < 0)
                return;
            super.computeBBox(bbox);
            if (bbox.w === 0 &&
                this.node.attributes.hasExplicit('fence') &&
                this.node.getText() === '' &&
                (this.node.texClass === TEXCLASS.OPEN ||
                    this.node.texClass === TEXCLASS.CLOSE) &&
                !this.jax.options.mathmlSpacing) {
                bbox.R = this.font.params.nulldelimiterspace;
            }
            this.copySkewIC(bbox);
        }
        getAccentOffset() {
            const bbox = BBox.empty();
            this.protoBBox(bbox);
            return -bbox.w / 2;
        }
        getCenterOffset(bbox = null) {
            if (!bbox) {
                bbox = BBox.empty();
                super.computeBBox(bbox);
            }
            return (bbox.h + bbox.d) / 2 + this.font.params.axis_height - bbox.h;
        }
        getStretchedVariant(WH, exact = false) {
            if (this.stretch.dir !== DIRECTION.None) {
                let D = this.getWH(WH);
                const min = this.getSize('minsize', 0);
                const max = this.getSize('maxsize', Infinity);
                const mathaccent = this.node.getProperty('mathaccent');
                D = Math.max(min, Math.min(max, D));
                const df = this.font.params.delimiterfactor / 1000;
                const ds = this.font.params.delimitershortfall;
                const m = min || exact
                    ? D
                    : mathaccent
                        ? Math.min(D / df, D + ds)
                        : Math.max(D * df, D - ds);
                const delim = this.stretch;
                const c = delim.c || this.getText().codePointAt(0);
                let i = 0;
                if (delim.sizes) {
                    for (const d of delim.sizes) {
                        if (d >= m) {
                            if (mathaccent && i) {
                                i--;
                            }
                            this.setDelimSize(c, i);
                            return;
                        }
                        i++;
                    }
                }
                if (delim.stretch) {
                    this.size = -1;
                    this.invalidateBBox();
                    this.getStretchBBox(WH, this.checkExtendedHeight(D, delim), delim);
                }
                else {
                    this.setDelimSize(c, i - 1);
                }
            }
        }
        setDelimSize(c, i) {
            const delim = this.stretch;
            this.variant = this.font.getSizeVariant(c, i);
            this.size = i;
            const schar = delim.schar
                ? delim.schar[Math.min(i, delim.schar.length - 1)] || c
                : c;
            this.stretch = Object.assign(Object.assign({}, delim), { c: schar });
            this.childNodes[0].invalidateBBox();
        }
        getSize(name, value) {
            const attributes = this.node.attributes;
            if (attributes.isSet(name)) {
                value = this.length2em(attributes.get(name), 1, 1);
            }
            return value;
        }
        getWH(WH) {
            if (WH.length === 0)
                return 0;
            if (WH.length === 1)
                return WH[0];
            const [H, D] = WH;
            const a = this.font.params.axis_height;
            return this.node.attributes.get('symmetric')
                ? 2 * Math.max(H - a, D + a)
                : H + D;
        }
        getStretchBBox(WHD, D, C) {
            if (Object.hasOwn(C, 'min') && C.min > D) {
                D = C.min;
            }
            let [h, d, w] = C.HDW;
            if (this.stretch.dir === DIRECTION.Vertical) {
                [h, d] = this.getBaseline(WHD, D, C);
            }
            else {
                w = D;
                if (this.stretch.hd && !this.jax.options.mathmlSpacing) {
                    const t = this.font.params.extender_factor;
                    h = h * (1 - t) + this.stretch.hd[0] * t;
                    d = d * (1 - t) + this.stretch.hd[1] * t;
                }
            }
            this.bbox.h = h;
            this.bbox.d = d;
            this.bbox.w = w;
        }
        getBaseline(WHD, HD, C) {
            const hasWHD = WHD.length === 2 && WHD[0] + WHD[1] === HD;
            const symmetric = this.node.attributes.get('symmetric');
            const [H, D] = hasWHD ? WHD : [HD, 0];
            let [h, d] = [H + D, 0];
            if (symmetric) {
                const a = this.font.params.axis_height;
                if (hasWHD) {
                    h = 2 * Math.max(H - a, D + a);
                }
                d = h / 2 - a;
            }
            else if (hasWHD) {
                d = D;
            }
            else {
                const [ch, cd] = C.HDW || [0.75, 0.25];
                d = cd * (h / (ch + cd));
            }
            return [h - d, d];
        }
        checkExtendedHeight(D, C) {
            if (C.fullExt) {
                const [extSize, endSize] = C.fullExt;
                const n = Math.ceil(Math.max(0, D - endSize) / extSize);
                D = endSize + n * extSize;
            }
            return D;
        }
        setBreakStyle(linebreak = '') {
            this.breakStyle =
                this.node.parent.isEmbellished && !linebreak
                    ? ''
                    : this.getBreakStyle(linebreak);
            if (!this.breakCount)
                return;
            if (this.multChar) {
                const i = this.parent.node.childIndex(this.node);
                const next = this.parent.node.childNodes[i + 1];
                if (next) {
                    next.setTeXclass(this.multChar.node);
                }
            }
        }
        getBreakStyle(linebreak = '') {
            const attributes = this.node.attributes;
            let style = linebreak ||
                (attributes.get('linebreak') === 'newline' ||
                    this.node.getProperty('forcebreak')
                    ? attributes.get('linebreakstyle')
                    : '');
            if (style === 'infixlinebreakstyle') {
                style = attributes.get(style);
            }
            return style;
        }
        getMultChar() {
            const multChar = this.node.attributes.get('linebreakmultchar');
            if (multChar && this.getText() === '\u2062' && multChar !== '\u2062') {
                this.multChar = this.createMo(multChar);
            }
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.size = null;
            this.isAccent = this.node.isAccent;
            this.getMultChar();
            this.setBreakStyle();
        }
        computeBBox(bbox, _recompute = false) {
            this.protoBBox(bbox);
            if (this.node.attributes.get('symmetric') &&
                this.stretch.dir !== DIRECTION.Horizontal) {
                const d = this.getCenterOffset(bbox);
                bbox.h += d;
                bbox.d -= d;
            }
            if (this.node.getProperty('mathaccent') &&
                (this.stretch.dir === DIRECTION.None || this.size >= 0)) {
                bbox.w = 0;
            }
        }
        computeLineBBox(i) {
            return this.moLineBBox(i, this.breakStyle);
        }
        moLineBBox(i, style, obox = null) {
            const leadingString = this.node.attributes.get('lineleading');
            const leading = this.length2em(leadingString, this.linebreakOptions.lineleading);
            if (i === 0 && style === 'before') {
                const bbox = LineBBox.from(BBox.zero(), leading);
                bbox.originalL = this.bbox.L;
                this.bbox.L = 0;
                return bbox;
            }
            let bbox = LineBBox.from(obox || this.getOuterBBox(), leading);
            if (i === 1) {
                if (style === 'after') {
                    bbox.w = bbox.h = bbox.d = 0;
                    bbox.isFirst = true;
                    this.bbox.R = 0;
                }
                else if (style === 'duplicate') {
                    bbox.L = 0;
                }
                else if (this.multChar) {
                    bbox = LineBBox.from(this.multChar.getOuterBBox(), leading);
                }
                bbox.getIndentData(this.node);
            }
            return bbox;
        }
        canStretch(direction) {
            if (this.stretch.dir !== DIRECTION.None) {
                return this.stretch.dir === direction;
            }
            const attributes = this.node.attributes;
            if (!attributes.get('stretchy'))
                return false;
            const c = this.getText();
            if (Array.from(c).length !== 1)
                return false;
            const delim = this.font.getDelimiter(c.codePointAt(0));
            this.stretch = (delim && delim.dir === direction ? delim : NOSTRETCH);
            return this.stretch.dir !== DIRECTION.None;
        }
        getVariant() {
            if (this.node.attributes.get('largeop')) {
                this.variant = this.node.attributes.get('displaystyle')
                    ? '-largeop'
                    : '-smallop';
                return;
            }
            if (!this.node.attributes.hasExplicit('mathvariant') &&
                this.node.getProperty('pseudoscript') === false) {
                this.variant = '-tex-variant';
                return;
            }
            super.getVariant();
        }
        remapChars(chars) {
            const primes = this.node.getProperty('primes');
            if (primes) {
                return unicodeChars(primes);
            }
            if (chars.length === 1) {
                const parent = this.node.coreParent().parent;
                const isAccent = this.isAccent && !parent.isKind('mrow');
                const map = isAccent ? 'accent' : 'mo';
                const text = this.font.getRemappedChar(map, chars[0]);
                if (text) {
                    chars = this.unicodeChars(text, this.variant);
                }
            }
            return chars;
        }
    };
}
//# sourceMappingURL=mo.js.map
;// ./mjs/output/chtml/Usage.js
class Usage {
    constructor() {
        this.used = new Set();
        this.needsUpdate = [];
    }
    add(item) {
        const name = JSON.stringify(item);
        if (!this.used.has(name)) {
            this.needsUpdate.push(item);
        }
        this.used.add(name);
    }
    has(item) {
        return this.used.has(JSON.stringify(item));
    }
    clear() {
        this.used.clear();
        this.needsUpdate = [];
    }
    update() {
        const update = this.needsUpdate;
        this.needsUpdate = [];
        return update;
    }
}
//# sourceMappingURL=Usage.js.map
;// ./mjs/output/chtml/FontData.js





class ChtmlFontData extends FontData {
    constructor() {
        super(...arguments);
        this.charUsage = new Usage();
        this.delimUsage = new Usage();
        this.fontUsage = {};
        this.newFonts = 0;
    }
    static charOptions(font, n) {
        return super.charOptions(font, n);
    }
    static addFontURLs(styles, fonts, url) {
        for (const name of Object.keys(fonts)) {
            const font = Object.assign({}, fonts[name]);
            font.src = font.src.replace(/%%URL%%/, url);
            styles[name] = font;
        }
    }
    static addDynamicFontCss(styles, fonts, root) {
        const fontStyles = {};
        for (const font of fonts) {
            const name = font.slice(4);
            fontStyles[`@font-face /* ${name} */`] = {
                'font-family': font,
                src: `url("%%URL%%/${font.toLowerCase()}.woff2") format("woff2")`,
            };
            styles[`.${name}`] = {
                'font-family': `${this.defaultCssFamilyPrefix}, ${font}`,
            };
        }
        this.addFontURLs(styles, fontStyles, root);
    }
    static addExtension(data, prefix = '') {
        super.addExtension(data, prefix);
        if (data.fonts) {
            this.addDynamicFontCss(this.defaultStyles, data.fonts, data.fontURL);
        }
    }
    addExtension(data, prefix = '') {
        super.addExtension(data, prefix);
        if (!data.fonts || !this.options.adaptiveCSS) {
            return [];
        }
        const css = {};
        const styles = new StyleJsonSheet();
        this.constructor.addDynamicFontCss(css, data.fonts, data.fontURL);
        styles.addStyles(css);
        return styles.getStyleRules();
    }
    adaptiveCSS(adapt) {
        this.options.adaptiveCSS = adapt;
    }
    clearCache() {
        if (this.options.adaptiveCSS) {
            this.charUsage.clear();
            this.delimUsage.clear();
        }
    }
    createVariant(name, inherit = null, link = null) {
        super.createVariant(name, inherit, link);
        this.variant[name].letter = this.constructor.defaultVariantLetters[name];
    }
    defineChars(name, chars) {
        super.defineChars(name, chars);
        const letter = this.variant[name].letter;
        const CLASS = this.constructor;
        for (const n of Object.keys(chars)) {
            const i = parseInt(n);
            if (!Array.isArray(chars[i]))
                continue;
            const options = CLASS.charOptions(chars, i);
            if (options.f === undefined) {
                options.f = letter;
            }
            for (const [m, M] of CLASS.combiningChars) {
                if (i >= m && i <= M) {
                    options.cmb = true;
                    break;
                }
            }
        }
    }
    addDynamicFontCss(fonts, root = this.options.fontURL) {
        this.constructor.addDynamicFontCss(this.fontUsage, fonts, root);
    }
    updateDynamicStyles() {
        const styles = this.fontUsage;
        this.fontUsage = {};
        if (!this.options.adaptiveCSS) {
            this.updateStyles(styles);
        }
        return styles;
    }
    get styles() {
        const CLASS = this.constructor;
        const styles = Object.assign(Object.assign({}, CLASS.defaultStyles), this.fontUsage);
        this.fontUsage = {};
        CLASS.addFontURLs(styles, CLASS.defaultFonts, this.options.fontURL);
        if (this.options.adaptiveCSS) {
            this.updateStyles(styles);
        }
        else {
            this.allStyles(styles);
        }
        return styles;
    }
    updateStyles(styles) {
        for (const N of this.delimUsage.update()) {
            this.addDelimiterStyles(styles, N, this.getDelimiter(N));
        }
        for (const [name, N] of this.charUsage.update()) {
            const variant = this.variant[name];
            this.addCharStyles(styles, variant.letter, N, variant.chars[N]);
        }
        return styles;
    }
    allStyles(styles) {
        var _a;
        for (const n of Object.keys(this.delimiters)) {
            const N = parseInt(n);
            this.addDelimiterStyles(styles, N, this.delimiters[N]);
        }
        for (const name of Object.keys(this.variant)) {
            const variant = this.variant[name];
            const vletter = variant.letter;
            for (const n of Object.keys(variant.chars)) {
                const N = parseInt(n);
                const char = variant.chars[N];
                if (((_a = char === null || char === void 0 ? void 0 : char[3]) === null || _a === void 0 ? void 0 : _a.smp) || !Array.isArray(char))
                    continue;
                if (char.length < 4) {
                    char[3] = {};
                }
                this.addCharStyles(styles, vletter, N, char);
            }
        }
    }
    addDelimiterStyles(styles, n, data) {
        if (!data.stretch)
            return;
        const c = data.c && data.c !== n ? this.charSelector(data.c) : this.charSelector(n);
        if (data.dir === DIRECTION.Vertical) {
            this.addDelimiterVStyles(styles, n, c, data);
        }
        else {
            this.addDelimiterHStyles(styles, n, c, data);
        }
    }
    addDelimiterVStyles(styles, n, c, data) {
        const HDW = data.HDW;
        const [beg, ext, end, mid] = data.stretch;
        const [begV, extV, endV, midV] = this.getStretchVariants(n);
        const Hb = this.addDelimiterVPart(styles, c, 'beg', beg, begV, HDW);
        this.addDelimiterVPart(styles, c, 'ext', ext, extV, HDW);
        const He = this.addDelimiterVPart(styles, c, 'end', end, endV, HDW);
        if (mid) {
            const Hm = this.addDelimiterVPart(styles, c, 'mid', mid, midV, HDW);
            const m = this.em(Hm / 2 - 0.03);
            styles[`mjx-stretchy-v${c} > mjx-ext:first-of-type`] = {
                height: '50%',
                'border-width': `${this.em1(Hb - 0.03)} 0 ${m}`,
            };
            styles[`mjx-stretchy-v${c} > mjx-ext:last-of-type`] = {
                height: '50%',
                'border-width': `${m} 0 ${this.em1(He - 0.03)}`,
            };
        }
        else if (He || Hb) {
            styles[`mjx-stretchy-v${c} > mjx-ext`]['border-width'] =
                `${this.em1(Hb - 0.03)} 0 ${this.em1(He - 0.03)}`;
        }
    }
    addDelimiterVPart(styles, c, part, n, v, HDW) {
        if (!n)
            return 0;
        const [h, d, w] = this.getChar(v, n);
        const css = { width: this.em0(w) };
        if (part !== 'ext') {
            const dw = w > HDW[2] ? this.em((HDW[2] - w) / 2) : 'auto';
            const y = part === 'beg' ? h : part === 'end' ? -d : (h - d) / 2;
            css.margin = `${this.em(y)} ${dw} ${this.em(-y)}`;
        }
        else {
            css['line-height'] = this.em0(h + d + 0.005);
            styles[`mjx-stretchy-v${c} > mjx-${part} > mjx-spacer`] = {
                'margin-top': this.em(-d),
            };
        }
        styles[`mjx-stretchy-v${c} > mjx-${part}`] = css;
        return h + d;
    }
    addDelimiterHStyles(styles, n, c, data) {
        const HDW = [...data.HDW];
        const [beg, ext, end, mid] = data.stretch;
        const [begV, extV, endV, midV] = this.getStretchVariants(n);
        if (data.hd && !this.options.mathmlSpacing) {
            const t = this.params.extender_factor;
            HDW[0] = HDW[0] * (1 - t) + data.hd[0] * t;
            HDW[1] = HDW[1] * (1 - t) + data.hd[1] * t;
        }
        const Wb = this.addDelimiterHPart(styles, c, 'beg', beg, begV, HDW);
        this.addDelimiterHPart(styles, c, 'ext', ext, extV, HDW);
        const We = this.addDelimiterHPart(styles, c, 'end', end, endV, HDW);
        if (mid) {
            const Wm = this.addDelimiterHPart(styles, c, 'mid', mid, midV, HDW);
            const m = this.em0(Wm / 2 - 0.03);
            styles[`mjx-stretchy-h${c} > mjx-ext:first-of-type`] = {
                width: '50%',
                'border-width': `0 ${m} 0 ${this.em0(Wb - 0.03)}`,
            };
            styles[`mjx-stretchy-h${c} > mjx-ext:last-of-type`] = {
                width: '50%',
                'border-width': `0 ${this.em0(We - 0.03)} 0 ${m}`,
            };
        }
        else if (Wb || We) {
            styles[`mjx-stretchy-h${c} > mjx-ext`]['border-width'] =
                `0 ${this.em0(We - 0.06)} 0 ${this.em0(Wb - 0.06)}`;
        }
        if (data.ext) {
            styles[`mjx-stretchy-h${c} > mjx-ext > mjx-spacer`]['letter-spacing'] =
                this.em(-data.ext);
        }
    }
    addDelimiterHPart(styles, c, part, n, v, HDW) {
        if (!n)
            return 0;
        let [, , w, options] = this.getChar(v, n);
        const css = {
            padding: this.padding(HDW, w - HDW[2]),
        };
        if (part === 'ext') {
            if (!w && options.dx) {
                w = 2 * options.dx - 0.06;
            }
            styles[`mjx-stretchy-h${c} > mjx-${part} > mjx-spacer`] = {
                'margin-left': this.em(-w / 2),
            };
            if (options.cmb) {
                styles[`mjx-stretchy-h${c} > mjx-${part} > mjx-c`] = {
                    width: this.em(w),
                    'text-align': 'right',
                };
            }
        }
        else {
            if (part === 'mid') {
                css['margin'] = `0 ${this.em(-w / 2)}`;
            }
            else {
                css[part == 'end' ? 'margin-left' : 'margin-right'] = this.em(-w);
            }
            this.checkCombiningChar(options, css);
        }
        styles[`mjx-stretchy-h${c} > mjx-${part}`] = css;
        return w;
    }
    addCharStyles(styles, vletter, n, data) {
        const options = data[3];
        const letter = options.f !== undefined ? options.f : vletter;
        const font = options.ff || (letter ? `${this.cssFontPrefix}-${letter}` : '');
        const selector = 'mjx-c' + this.charSelector(n) + (font ? '.' + font : '');
        const padding = options.oc || options.ic || 0;
        styles[selector] = {
            padding: this.padding(data, padding),
        };
        if (options.oc) {
            styles[selector + '[noic]'] = { 'padding-right': this.em(data[2]) };
        }
        this.checkCombiningChar(options, styles[selector]);
    }
    checkCombiningChar(options, css) {
        if (!options.cmb)
            return;
        const pad = css.padding.split(/ /);
        css.width = pad[1];
        pad[1] = '0';
        if (!pad[3]) {
            pad.pop();
        }
        css.padding = pad.join(' ');
    }
    em(n) {
        return em(n);
    }
    em0(n) {
        return em(Math.max(0, n));
    }
    em1(n) {
        const m = em(Math.max(0, n));
        return m === '0' ? '.1px' : m;
    }
    padding([h, d, w], ic = 0) {
        return [h, w + ic, d, 0].map(this.em0).join(' ');
    }
    charSelector(n) {
        return '.mjx-c' + n.toString(16).toUpperCase();
    }
}
ChtmlFontData.OPTIONS = Object.assign(Object.assign({}, FontData.OPTIONS), { dynamicPrefix: './chtml/dynamic', fontURL: './chtml/woff2' });
ChtmlFontData.JAX = 'CHTML';
ChtmlFontData.defaultVariantLetters = {};
ChtmlFontData.defaultStyles = {};
ChtmlFontData.defaultFonts = {};
ChtmlFontData.combiningChars = [
    [0x300, 0x36f],
    [0x20d0, 0x20ff],
];
function AddCSS(font, options) {
    for (const c of Object.keys(options)) {
        const n = parseInt(c);
        const data = options[n];
        if (data.c) {
            data.c = data.c.replace(/\\[0-9A-F]+/gi, (x) => String.fromCodePoint(parseInt(x.substring(1), 16)));
        }
        Object.assign(FontData.charOptions(font, n), data);
    }
    return font;
}
//# sourceMappingURL=FontData.js.map
;// ./mjs/output/chtml/Wrappers/mo.js




const ChtmlMo = (function () {
    var _a;
    const Base = CommonMoMixin(ChtmlWrapper);
    return _a = class ChtmlMo extends Base {
            toCHTML(parents) {
                const adaptor = this.adaptor;
                const attributes = this.node.attributes;
                const symmetric = attributes.get('symmetric') &&
                    this.stretch.dir !== DIRECTION.Horizontal;
                const stretchy = this.stretch.dir !== DIRECTION.None;
                if (stretchy && this.size === null) {
                    this.getStretchedVariant([]);
                }
                if (parents.length > 1) {
                    parents.forEach((dom) => adaptor.append(dom, this.html('mjx-linestrut')));
                }
                const chtml = this.standardChtmlNodes(parents);
                if (chtml.length > 1 && this.breakStyle !== 'duplicate') {
                    const i = this.breakStyle === 'after' ? 1 : 0;
                    adaptor.remove(chtml[i]);
                    chtml[i] = null;
                }
                if (stretchy && this.size < 0) {
                    this.stretchHTML(chtml);
                }
                else {
                    if (symmetric || attributes.get('largeop')) {
                        const u = this.em(this.getCenterOffset());
                        if (u !== '0') {
                            chtml.forEach((dom) => dom && adaptor.setStyle(dom, 'verticalAlign', u));
                        }
                    }
                    if (this.node.getProperty('mathaccent')) {
                        chtml.forEach((dom) => {
                            adaptor.setStyle(dom, 'width', '0');
                            adaptor.setStyle(dom, 'margin-left', this.em(this.getAccentOffset()));
                        });
                    }
                    if (chtml[0]) {
                        this.addChildren([chtml[0]]);
                    }
                    if (chtml[1]) {
                        (this.multChar || this).addChildren([chtml[1]]);
                    }
                }
            }
            stretchHTML(chtml) {
                const c = this.getText().codePointAt(0);
                this.font.delimUsage.add(c);
                this.childNodes[0].markUsed();
                const delim = this.stretch;
                const stretch = delim.stretch;
                const stretchv = this.font.getStretchVariants(c);
                const dom = [];
                const parts = [];
                for (let i = 0; i < stretch.length; i++) {
                    if (stretch[i]) {
                        parts[i] = this.font.getChar(stretchv[i], stretch[i]);
                    }
                }
                const { h, d, w } = this.bbox;
                const styles = {};
                if (delim.dir === DIRECTION.Vertical) {
                    this.createAssembly(parts, stretch, stretchv, dom, h + d, 0.05, '\n');
                    dom.push(this.html('mjx-mark'));
                    styles.height = this.em(h + d);
                    styles.verticalAlign = this.em(-d);
                }
                else {
                    this.createAssembly(parts, stretch, stretchv, dom, w, delim.ext || 0);
                    styles.width = this.em(w);
                }
                const properties = { class: this.char(delim.c || c), style: styles };
                const html = this.html('mjx-stretchy-' + delim.dir, properties, dom);
                const adaptor = this.adaptor;
                if (chtml[0]) {
                    adaptor.append(chtml[0], html);
                }
                if (chtml[1]) {
                    adaptor.append(chtml[1], chtml[0] ? adaptor.clone(html) : html);
                }
            }
            createAssembly(parts, sn, sv, dom, wh, ext, nl = '') {
                parts = [...parts, null, null, null].slice(0, 4);
                let [WHb, WHx, WHe, WHm] = parts.map((part) => part ? (nl ? part[0] + part[1] : part[2]) : 0);
                WHx = Math.max(0, WHx - ext);
                const [WH1, WH2] = parts[3]
                    ? [(wh - WHm) / 2 - WHb, (wh - WHm) / 2 - WHe]
                    : [wh - WHb - WHe, 0];
                this.createPart('mjx-beg', parts[0], sn[0], sv[0], dom);
                this.createPart('mjx-ext', parts[1], sn[1], sv[1], dom, WH1, WHx, nl);
                if (parts[3]) {
                    this.createPart('mjx-mid', parts[3], sn[3], sv[3], dom);
                    this.createPart('mjx-ext', parts[1], sn[1], sv[1], dom, WH2, WHx, nl);
                }
                this.createPart('mjx-end', parts[2], sn[2], sv[2], dom);
            }
            createPart(part, data, n, v, dom, W = 0, Wx = 0, nl = '') {
                if (n) {
                    const options = data[3];
                    const letter = options.f || (v === 'normal' ? '' : this.font.getVariant(v).letter);
                    const font = options.ff || (letter ? `${this.font.cssFontPrefix}-${letter}` : '');
                    const c = options.c || String.fromCodePoint(n);
                    let nodes = [];
                    if (part === 'mjx-ext' && (Wx || options.dx)) {
                        if (!Wx) {
                            Wx = Math.max(0.06, 2 * options.dx - 0.06);
                        }
                        const n = Math.min(Math.ceil(W / Wx) + 1, 500);
                        if (options.cmb) {
                            nodes.push(this.html('mjx-spacer'));
                            for (let i = 0; i < n; i++) {
                                nodes.push(this.html('mjx-c', {}, [this.text(c)]));
                            }
                        }
                        else {
                            nodes = [
                                this.html('mjx-spacer', {}, [
                                    this.text(Array(n).fill(c).join(nl)),
                                ]),
                            ];
                        }
                    }
                    else {
                        nodes = [this.text(c)];
                    }
                    dom.push(this.html(part, font ? { class: font } : {}, nodes));
                }
            }
        },
        _a.kind = MmlMo.prototype.kind,
        _a.styles = {
            'mjx-stretchy-h': {
                display: 'inline-block',
            },
            'mjx-stretchy-h > *': {
                display: 'inline-block',
                width: 0,
                'text-align': 'right',
            },
            'mjx-stretchy-h > mjx-ext': {
                'clip-path': 'padding-box xywh(0 -1em 100% calc(100% + 2em))',
                width: '100%',
                border: '0px solid transparent',
                'box-sizing': 'border-box',
                'text-align': 'left',
            },
            'mjx-stretchy-v': {
                display: 'inline-block',
                'text-align': 'center',
            },
            'mjx-stretchy-v > *': {
                display: 'block',
                height: 0,
                margin: '0 auto',
            },
            'mjx-stretchy-v > mjx-ext > mjx-spacer': {
                display: 'block',
            },
            'mjx-stretchy-v > mjx-ext': {
                'clip-path': 'padding-box xywh(-1em 0 calc(100% + 2em) 100%)',
                height: '100%',
                border: '0.1px solid transparent',
                'box-sizing': 'border-box',
                'white-space': 'wrap',
            },
            'mjx-mark': {
                display: 'inline-block',
                height: 0,
            },
        },
        _a;
})();
//# sourceMappingURL=mo.js.map
;// ./mjs/output/common/Wrappers/mn.js
function CommonMnMixin(Base) {
    return class CommonMnMixin extends Base {
        remapChars(chars) {
            if (chars.length) {
                const text = this.font.getRemappedChar('mn', chars[0]);
                if (text) {
                    const c = this.unicodeChars(text, this.variant);
                    if (c.length === 1) {
                        chars[0] = c[0];
                    }
                    else {
                        chars = c.concat(chars.slice(1));
                    }
                }
            }
            return chars;
        }
    };
}
//# sourceMappingURL=mn.js.map
;// ./mjs/output/chtml/Wrappers/mn.js



const ChtmlMn = (function () {
    var _a;
    const Base = CommonMnMixin(ChtmlWrapper);
    return _a = class ChtmlMn extends Base {
        },
        _a.kind = MmlMn.prototype.kind,
        _a;
})();
//# sourceMappingURL=mn.js.map
;// ./mjs/output/common/Wrappers/ms.js
function CommonMsMixin(Base) {
    return class CommonMsMixin extends Base {
        createText(text) {
            const node = this.wrap(this.mmlText(text));
            node.parent = this;
            return node;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            const attributes = this.node.attributes;
            const quotes = attributes.getList('lquote', 'rquote');
            if (this.variant !== 'monospace') {
                if (!attributes.isSet('lquote') && quotes.lquote === '"') {
                    quotes.lquote = '\u201C';
                }
                if (!attributes.isSet('rquote') && quotes.rquote === '"') {
                    quotes.rquote = '\u201D';
                }
            }
            this.childNodes.unshift(this.createText(quotes.lquote));
            this.childNodes.push(this.createText(quotes.rquote));
        }
    };
}
//# sourceMappingURL=ms.js.map
;// ./mjs/output/chtml/Wrappers/ms.js



const ChtmlMs = (function () {
    var _a;
    const Base = CommonMsMixin(ChtmlWrapper);
    return _a = class ChtmlMs extends Base {
        },
        _a.kind = MmlMs.prototype.kind,
        _a;
})();
//# sourceMappingURL=ms.js.map
;// ./mjs/output/common/Wrappers/mtext.js

function CommonMtextMixin(Base) {
    var _a;
    return _a = class CommonMtextMixin extends Base {
            constructor() {
                super(...arguments);
                this.breakPoints = [];
            }
            textWidth(text) {
                let textNode = this.textNode;
                if (!textNode) {
                    const text = this.node.factory.create('text');
                    text.parent = this.node;
                    textNode = this.textNode = this.factory.wrap(text);
                    textNode.parent = this;
                }
                textNode.node.setText(text);
                textNode.invalidateBBox(false);
                return textNode.getBBox().w;
            }
            get breakCount() {
                return this.breakPoints.length;
            }
            getVariant() {
                const options = this.jax.options;
                const data = this.jax.math.outputData;
                const merror = (!!data.merrorFamily || !!options.merrorFont) &&
                    this.node.Parent.isKind('merror');
                if (!!data.mtextFamily || !!options.mtextFont || merror) {
                    const variant = this.node.attributes.get('mathvariant');
                    const font = this.constructor.INHERITFONTS[variant] ||
                        this.jax.font.getCssFont(variant);
                    const family = font[0] ||
                        (merror
                            ? data.merrorFamily || options.merrorFont
                            : data.mtextFamily || options.mtextFont);
                    this.variant = this.explicitVariant(family, font[2] ? 'bold' : '', font[1] ? 'italic' : '');
                    return;
                }
                super.getVariant();
            }
            setBreakAt(ij) {
                this.breakPoints.push(ij);
            }
            clearBreakPoints() {
                this.breakPoints = [];
            }
            computeLineBBox(i) {
                const bbox = LineBBox.from(this.getOuterBBox(), this.linebreakOptions.lineleading);
                if (!this.breakCount)
                    return bbox;
                bbox.w = this.getBreakWidth(i);
                if (i === 0) {
                    bbox.R = 0;
                    this.addLeftBorders(bbox);
                }
                else {
                    bbox.L = 0;
                    bbox.indentData = [
                        ['left', '0'],
                        ['left', '0'],
                        ['left', '0'],
                    ];
                    if (i === this.breakCount) {
                        this.addRightBorders(bbox);
                    }
                }
                return bbox;
            }
            getBreakWidth(i) {
                const childNodes = this.childNodes;
                let [si, sj] = this.breakPoints[i - 1] || [0, 0];
                const [ei, ej] = this.breakPoints[i] || [childNodes.length, 0];
                let words = childNodes[si].node.getText().split(/ /);
                if (si === ei) {
                    return this.textWidth(words.slice(sj, ej).join(' '));
                }
                let w = this.textWidth(words.slice(sj).join(' '));
                while (++si < ei && si < childNodes.length) {
                    w += childNodes[si].getBBox().w;
                }
                if (si < childNodes.length) {
                    words = childNodes[si].node.getText().split(/ /);
                    w += this.textWidth(words.slice(0, ej).join(' '));
                }
                return w;
            }
        },
        _a.INHERITFONTS = {
            normal: ['', false, false],
            bold: ['', false, true],
            italic: ['', true, false],
            'bold-italic': ['', true, true],
        },
        _a;
}
//# sourceMappingURL=mtext.js.map
;// ./mjs/output/chtml/Wrappers/mtext.js



const ChtmlMtext = (function () {
    var _a;
    const Base = CommonMtextMixin(ChtmlWrapper);
    return _a = class ChtmlMtext extends Base {
            toCHTML(parents) {
                if (!this.breakCount) {
                    super.toCHTML(parents);
                    return;
                }
                const chtml = this.standardChtmlNodes(parents);
                const textNode = this.textNode.node;
                const childNodes = this.childNodes;
                for (const i of chtml.keys()) {
                    const DOM = [chtml[i]];
                    this.adaptor.append(chtml[i], this.html('mjx-linestrut'));
                    let [si, sj] = this.breakPoints[i - 1] || [0, 0];
                    const [ei, ej] = this.breakPoints[i] || [childNodes.length, 0];
                    let words = childNodes[si].node.getText().split(/ /);
                    if (si === ei) {
                        textNode.setText(words.slice(sj, ej).join(' '));
                        this.textNode.toCHTML(DOM);
                        continue;
                    }
                    textNode.setText(words.slice(sj).join(' '));
                    this.textNode.toCHTML(DOM);
                    while (++si < ei && si < childNodes.length) {
                        childNodes[si].toCHTML(DOM);
                    }
                    if (si < childNodes.length) {
                        words = childNodes[si].node.getText().split(/ /);
                        textNode.setText(words.slice(0, ej).join(' '));
                        this.textNode.toCHTML(DOM);
                    }
                }
            }
        },
        _a.kind = MmlMtext.prototype.kind,
        _a;
})();
//# sourceMappingURL=mtext.js.map
;// ./mjs/output/common/Wrappers/mspace.js


function CommonMspaceMixin(Base) {
    return class CommonMspaceMixin extends Base {
        get canBreak() {
            return this.node.canBreak;
        }
        get breakCount() {
            return this.breakStyle ? 1 : 0;
        }
        setBreakStyle(linebreak = '') {
            this.breakStyle =
                linebreak ||
                    (this.node.hasNewline ||
                        this.node.getProperty('forcebreak')
                        ? 'before'
                        : '');
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.setBreakStyle();
        }
        computeBBox(bbox, _recompute = false) {
            const attributes = this.node.attributes;
            bbox.w = this.length2em(attributes.get('width'), 0);
            bbox.h = this.length2em(attributes.get('height'), 0);
            bbox.d = this.length2em(attributes.get('depth'), 0);
        }
        computeLineBBox(i) {
            const leadingString = this.node.attributes.get('data-lineleading');
            const leading = this.length2em(leadingString, this.linebreakOptions.lineleading);
            const bbox = LineBBox.from(BBox.zero(), leading);
            if (i === 1) {
                bbox.getIndentData(this.node);
                bbox.w = this.getBBox().w;
                bbox.isFirst = bbox.w === 0;
            }
            return bbox;
        }
    };
}
//# sourceMappingURL=mspace.js.map
;// ./mjs/output/chtml/Wrappers/mspace.js



const ChtmlMspace = (function () {
    var _a;
    const Base = CommonMspaceMixin(ChtmlWrapper);
    return _a = class ChtmlMspace extends Base {
            toCHTML(parents) {
                if (parents.length > 1) {
                    parents.forEach((dom) => this.adaptor.append(dom, this.html('mjx-linestrut')));
                }
                const chtml = this.standardChtmlNodes(parents);
                let { w, h, d } = this.getBBox();
                if (w < 0) {
                    this.adaptor.setStyle(chtml[0], 'marginRight', this.em(w));
                    w = 0;
                }
                if (w && !this.breakCount) {
                    this.adaptor.setStyle(chtml[0], 'width', this.em(w));
                }
                h = Math.max(0, h + d);
                if (h) {
                    this.adaptor.setStyle(chtml[0], 'height', this.em(Math.max(0, h)));
                }
                if (d) {
                    this.adaptor.setStyle(chtml[0], 'verticalAlign', this.em(-d));
                }
            }
        },
        _a.kind = MmlMspace.prototype.kind,
        _a;
})();
//# sourceMappingURL=mspace.js.map
;// ./mjs/output/common/Wrappers/mpadded.js
function CommonMpaddedMixin(Base) {
    return class CommonMpaddedMixin extends Base {
        getDimens() {
            const values = this.node.attributes.getList('width', 'height', 'depth', 'lspace', 'voffset');
            const bbox = this.childNodes[0].getOuterBBox();
            let { w, h, d } = bbox;
            const W = w;
            const H = h;
            const D = d;
            let x = 0;
            let y = 0;
            let dx = 0;
            if (values.width !== '')
                w = this.dimen(values.width, bbox, 'w', 0);
            if (values.height !== '')
                h = this.dimen(values.height, bbox, 'h', 0);
            if (values.depth !== '')
                d = this.dimen(values.depth, bbox, 'd', 0);
            if (values.voffset !== '')
                y = this.dimen(values.voffset, bbox);
            if (values.lspace !== '')
                x = this.dimen(values.lspace, bbox);
            const align = this.node.attributes.get('data-align');
            if (align) {
                dx = this.getAlignX(w, bbox, align);
            }
            return [H, D, W, h - H, d - D, w - W, x, y, dx];
        }
        dimen(length, bbox, d = '', m = null) {
            length = String(length);
            const match = length.match(/width|height|depth/);
            const size = (match
                ? bbox[match[0].charAt(0)]
                : d
                    ? bbox[d]
                    : 0);
            let dimen = this.length2em(length, size) || 0;
            if (length.match(/^[-+]/) && d) {
                dimen += size;
            }
            if (m != null) {
                dimen = Math.max(m, dimen);
            }
            return dimen;
        }
        setBBoxDimens(bbox) {
            const [H, D, W, dh, dd, dw] = this.getDimens();
            bbox.w = W + dw;
            bbox.h = H + dh;
            bbox.d = D + dd;
        }
        computeBBox(bbox, recompute = false) {
            this.setBBoxDimens(bbox);
            const w = this.childNodes[0].getOuterBBox().w;
            if (w > bbox.w) {
                const overflow = this.node.attributes.get('data-overflow');
                if (overflow === 'linebreak' ||
                    (overflow === 'auto' &&
                        this.jax.math.root.attributes.get('overflow') === 'linebreak')) {
                    this.childNodes[0].breakToWidth(bbox.w);
                    this.setBBoxDimens(bbox);
                }
            }
            this.setChildPWidths(recompute, bbox.w);
        }
        getWrapWidth(_i) {
            return this.getBBox().w;
        }
        getChildAlign(_i) {
            return this.node.attributes.get('data-align') || 'left';
        }
    };
}
//# sourceMappingURL=mpadded.js.map
;// ./mjs/output/chtml/Wrappers/mpadded.js



const ChtmlMpadded = (function () {
    var _a;
    const Base = CommonMpaddedMixin(ChtmlWrapper);
    return _a = class ChtmlMpadded extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                let chtml = this.standardChtmlNodes(parents);
                const content = [];
                const style = {};
                const [, , W, dh, dd, dw, x, y, dx] = this.getDimens();
                if (dw || this.childNodes[0].getBBox().pwidth) {
                    style.width = this.em(W + dw);
                }
                if (dh || dd) {
                    style.margin = this.em(dh) + ' 0 ' + this.em(dd);
                }
                if (x + dx || y) {
                    style.position = 'relative';
                    const rbox = this.html('mjx-rbox', {
                        style: {
                            left: this.em(x + dx),
                            top: this.em(-y),
                            'max-width': style.width,
                        },
                    });
                    if (x + dx && this.childNodes[0].getBBox().pwidth) {
                        this.adaptor.setAttribute(rbox, 'width', 'full');
                        this.adaptor.setStyle(rbox, 'left', this.em(x));
                    }
                    content.push(rbox);
                }
                chtml = [
                    this.adaptor.append(chtml[0], this.html('mjx-block', { style: style }, content)),
                ];
                if (this.childNodes[0].childNodes.length) {
                    this.childNodes[0].toCHTML([content[0] || chtml[0]]);
                }
                else if (dh || dd) {
                    this.adaptor.append(content[0] || chtml[0], this.html('mjx-box'));
                }
            }
        },
        _a.kind = MmlMpadded.prototype.kind,
        _a.styles = {
            'mjx-mpadded': {
                display: 'inline-block',
            },
            'mjx-rbox': {
                display: 'inline-block',
                position: 'relative',
            },
        },
        _a;
})();
//# sourceMappingURL=mpadded.js.map
;// ./mjs/output/common/Notation.js
const ARROWX = 4;
const ARROWDX = 1;
const ARROWY = 2;
const THICKNESS = 0.067;
const PADDING = 0.2;
const SOLID = THICKNESS + 'em solid';
const sideIndex = { top: 0, right: 1, bottom: 2, left: 3 };
const sideNames = Object.keys(sideIndex);
const fullBBox = ((node) => new Array(4).fill(node.thickness + node.padding));
const fullPadding = ((node) => new Array(4).fill(node.padding));
const fullBorder = ((node) => new Array(4).fill(node.thickness));
const arrowHead = (node) => {
    return Math.max(node.padding, node.thickness * (node.arrowhead.x + node.arrowhead.dx + 1));
};
const arrowBBoxHD = (node, TRBL) => {
    if (node.childNodes[0]) {
        const { h, d } = node.childNodes[0].getBBox();
        TRBL[0] = TRBL[2] = Math.max(0, node.thickness * node.arrowhead.y - (h + d) / 2);
    }
    return TRBL;
};
const arrowBBoxW = (node, TRBL) => {
    if (node.childNodes[0]) {
        const { w } = node.childNodes[0].getBBox();
        TRBL[1] = TRBL[3] = Math.max(0, node.thickness * node.arrowhead.y - w / 2);
    }
    return TRBL;
};
const arrowDef = {
    up: [-Math.PI / 2, false, true, 'verticalstrike'],
    down: [Math.PI / 2, false, true, 'verticakstrike'],
    right: [0, false, false, 'horizontalstrike'],
    left: [Math.PI, false, false, 'horizontalstrike'],
    updown: [Math.PI / 2, true, true, 'verticalstrike uparrow downarrow'],
    leftright: [0, true, false, 'horizontalstrike leftarrow rightarrow'],
};
const diagonalArrowDef = {
    updiagonal: [-1, 0, false, 'updiagonalstrike northeastarrow'],
    northeast: [-1, 0, false, 'updiagonalstrike updiagonalarrow'],
    southeast: [1, 0, false, 'downdiagonalstrike'],
    northwest: [1, Math.PI, false, 'downdiagonalstrike'],
    southwest: [-1, Math.PI, false, 'updiagonalstrike'],
    northeastsouthwest: [
        -1,
        0,
        true,
        'updiagonalstrike northeastarrow updiagonalarrow southwestarrow',
    ],
    northwestsoutheast: [
        1,
        0,
        true,
        'downdiagonalstrike northwestarrow southeastarrow',
    ],
};
const arrowBBox = {
    up: (node) => arrowBBoxW(node, [arrowHead(node), 0, node.padding, 0]),
    down: (node) => arrowBBoxW(node, [node.padding, 0, arrowHead(node), 0]),
    right: (node) => arrowBBoxHD(node, [0, arrowHead(node), 0, node.padding]),
    left: (node) => arrowBBoxHD(node, [0, node.padding, 0, arrowHead(node)]),
    updown: (node) => arrowBBoxW(node, [arrowHead(node), 0, arrowHead(node), 0]),
    leftright: (node) => arrowBBoxHD(node, [0, arrowHead(node), 0, arrowHead(node)]),
};
const CommonBorder = function (render) {
    return (side) => {
        const i = sideIndex[side];
        return [
            side,
            {
                renderer: render,
                bbox: (node) => {
                    const bbox = [0, 0, 0, 0];
                    bbox[i] = node.thickness + node.padding;
                    return bbox;
                },
                border: (node) => {
                    const bbox = [0, 0, 0, 0];
                    bbox[i] = node.thickness;
                    return bbox;
                },
            },
        ];
    };
};
const CommonBorder2 = function (render) {
    return (name, side1, side2) => {
        const i1 = sideIndex[side1];
        const i2 = sideIndex[side2];
        return [
            name,
            {
                renderer: render,
                bbox: (node) => {
                    const t = node.thickness + node.padding;
                    const bbox = [0, 0, 0, 0];
                    bbox[i1] = bbox[i2] = t;
                    return bbox;
                },
                border: (node) => {
                    const bbox = [0, 0, 0, 0];
                    bbox[i1] = bbox[i2] = node.thickness;
                    return bbox;
                },
                remove: side1 + ' ' + side2,
            },
        ];
    };
};
const CommonDiagonalStrike = function (render) {
    return (name) => {
        const cname = 'mjx-' + name.charAt(0) + 'strike';
        return [
            name + 'diagonalstrike',
            {
                renderer: render(cname),
                bbox: fullBBox,
            },
        ];
    };
};
const CommonDiagonalArrow = function (render) {
    return (name) => {
        const [c, pi, double, remove] = diagonalArrowDef[name];
        return [
            name + 'arrow',
            {
                renderer: (node, _child) => {
                    const [a, W] = node.arrowAW();
                    const arrow = node.arrow(W, c * (a - pi), double);
                    render(node, arrow);
                },
                bbox: (node) => {
                    const { a, x, y } = node.arrowData();
                    const [ax, ay, adx] = [
                        node.arrowhead.x,
                        node.arrowhead.y,
                        node.arrowhead.dx,
                    ];
                    const [b, ar] = node.getArgMod(ax + adx, ay);
                    const dy = y + (b > a ? node.thickness * ar * Math.sin(b - a) : 0);
                    const dx = x +
                        (b > Math.PI / 2 - a
                            ? node.thickness * ar * Math.sin(b + a - Math.PI / 2)
                            : 0);
                    return [dy, dx, dy, dx];
                },
                remove: remove,
            },
        ];
    };
};
const CommonArrow = function (render) {
    return (name) => {
        const [angle, double, isVertical, remove] = arrowDef[name];
        return [
            name + 'arrow',
            {
                renderer: (node, _child) => {
                    const { w, h, d } = node.getBBox();
                    const [W, offset] = isVertical ? [h + d, 'X'] : [w, 'Y'];
                    const dd = node.getOffset(offset);
                    const arrow = node.arrow(W, angle, double, offset, dd);
                    render(node, arrow);
                },
                bbox: arrowBBox[name],
                remove: remove,
            },
        ];
    };
};
//# sourceMappingURL=Notation.js.map
;// ./mjs/output/common/Wrappers/menclose.js


function CommonMencloseMixin(Base) {
    return class CommonMencloseMixin extends Base {
        getParameters() {
            const attributes = this.node.attributes;
            const padding = attributes.get('data-padding');
            if (padding !== undefined) {
                this.padding = this.length2em(padding, PADDING);
            }
            const thickness = attributes.get('data-thickness');
            if (thickness !== undefined) {
                this.thickness = this.length2em(thickness, THICKNESS);
            }
            const arrowhead = attributes.get('data-arrowhead');
            if (arrowhead !== undefined) {
                const [x, y, dx] = split(arrowhead);
                this.arrowhead = {
                    x: x ? parseFloat(x) : ARROWX,
                    y: y ? parseFloat(y) : ARROWY,
                    dx: dx ? parseFloat(dx) : ARROWDX,
                };
            }
        }
        getNotations() {
            const Notations = this.constructor.notations;
            for (const name of split(this.node.attributes.get('notation'))) {
                const notation = Notations.get(name);
                if (notation) {
                    this.notations[name] = notation;
                    if (notation.renderChild) {
                        this.renderChild = notation.renderer;
                    }
                }
            }
        }
        removeRedundantNotations() {
            for (const name of Object.keys(this.notations)) {
                if (this.notations[name]) {
                    const remove = this.notations[name].remove || '';
                    for (const notation of remove.split(/ /)) {
                        delete this.notations[notation];
                    }
                }
            }
        }
        initializeNotations() {
            for (const name of Object.keys(this.notations)) {
                const init = this.notations[name].init;
                if (init) {
                    init(this);
                }
            }
        }
        getBBoxExtenders() {
            const TRBL = [0, 0, 0, 0];
            for (const name of Object.keys(this.notations)) {
                this.maximizeEntries(TRBL, this.notations[name].bbox(this));
            }
            return TRBL;
        }
        getPadding() {
            const BTRBL = [0, 0, 0, 0];
            for (const name of Object.keys(this.notations)) {
                const border = this.notations[name].border;
                if (border) {
                    this.maximizeEntries(BTRBL, border(this));
                }
            }
            return [0, 1, 2, 3].map((i) => this.TRBL[i] - BTRBL[i]);
        }
        maximizeEntries(X, Y) {
            for (let i = 0; i < X.length; i++) {
                if (X[i] < Y[i]) {
                    X[i] = Y[i];
                }
            }
        }
        getOffset(direction) {
            const [T, R, B, L] = this.TRBL;
            const d = (direction === 'X' ? R - L : B - T) / 2;
            return Math.abs(d) > 0.001 ? d : 0;
        }
        getArgMod(w, h) {
            return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];
        }
        arrow(_w, _a, _double, _offset = '', _dist = 0) {
            return null;
        }
        arrowData() {
            const [p, t] = [this.padding, this.thickness];
            const r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));
            const { h, d, w } = this.childNodes[0].getBBox();
            const H = h + d;
            const R = Math.sqrt(H * H + w * w);
            const x = Math.max(p, (r * w) / R);
            const y = Math.max(p, (r * H) / R);
            const [a, W] = this.getArgMod(w + 2 * x, H + 2 * y);
            return { a, W, x, y };
        }
        arrowAW() {
            const { h, d, w } = this.childNodes[0].getBBox();
            const [T, R, B, L] = this.TRBL;
            return this.getArgMod(L + w + R, T + h + d + B);
        }
        createMsqrt(child) {
            const mmlFactory = this.node.factory;
            const mml = mmlFactory.create('msqrt');
            mml.inheritAttributesFrom(this.node);
            mml.childNodes[0] = child.node;
            const node = this.wrap(mml);
            node.parent = this;
            return node;
        }
        sqrtTRBL() {
            const bbox = this.msqrt.getBBox();
            const cbox = this.msqrt.childNodes[0].getBBox();
            return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.notations = {};
            this.renderChild = null;
            this.msqrt = null;
            this.padding = PADDING;
            this.thickness = THICKNESS;
            this.arrowhead = {
                x: ARROWX,
                y: ARROWY,
                dx: ARROWDX,
            };
            this.TRBL = [0, 0, 0, 0];
            this.getParameters();
            this.getNotations();
            this.removeRedundantNotations();
            this.initializeNotations();
            this.TRBL = this.getBBoxExtenders();
        }
        computeBBox(bbox, recompute = false) {
            const [T, R, B, L] = this.TRBL;
            const child = this.childNodes[0].getBBox();
            bbox.combine(child, L, 0);
            bbox.h += T;
            bbox.d += B;
            bbox.w += R;
            this.setChildPWidths(recompute);
        }
    };
}
//# sourceMappingURL=menclose.js.map
;// ./mjs/output/chtml/Notation.js


const RenderElement = function (name, offset = '') {
    return ((node, _child) => {
        const shape = node.adjustBorder(node.html('mjx-' + name));
        if (offset) {
            const d = node.getOffset(offset);
            if (node.thickness !== THICKNESS || d) {
                const transform = `translate${offset}(${node.Em(node.thickness / 2 - d)})`;
                node.adaptor.setStyle(shape, 'transform', transform);
            }
        }
        node.adaptor.append(node.dom[0], shape);
    });
};
const Border = function (side) {
    return CommonBorder((node, child) => {
        node.adaptor.setStyle(child, 'border-' + side, node.Em(node.thickness) + ' solid');
    })(side);
};
const Border2 = function (name, side1, side2) {
    return CommonBorder2((node, child) => {
        const border = node.Em(node.thickness) + ' solid';
        node.adaptor.setStyle(child, 'border-' + side1, border);
        node.adaptor.setStyle(child, 'border-' + side2, border);
    })(name, side1, side2);
};
const DiagonalStrike = function (name, neg) {
    return CommonDiagonalStrike((cname) => (node, _child) => {
        const { w, h, d } = node.getBBox();
        const [a, W] = node.getArgMod(w, h + d);
        const t = (neg * node.thickness) / 2;
        const strike = node.adjustBorder(node.html(cname, {
            style: {
                width: node.Em(W),
                transform: 'rotate(' + node.fixed(-neg * a) + 'rad) translateY(' + t + 'em)',
            },
        }));
        node.adaptor.append(node.dom[0], strike);
    })(name);
};
const DiagonalArrow = function (name) {
    return CommonDiagonalArrow((node, arrow) => {
        node.adaptor.append(node.dom[0], arrow);
    })(name);
};
const Arrow = function (name) {
    return CommonArrow((node, arrow) => {
        node.adaptor.append(node.dom[0], arrow);
    })(name);
};
//# sourceMappingURL=Notation.js.map
;// ./mjs/output/chtml/Wrappers/menclose.js





function Angle(x, y) {
    return Math.atan2(x, y)
        .toFixed(3)
        .replace(/\.?0+$/, '');
}
const ANGLE = Angle(ARROWDX, ARROWY);
const ChtmlMenclose = (function () {
    var _a;
    const Base = CommonMencloseMixin(ChtmlWrapper);
    return _a = class ChtmlMenclose extends Base {
            adjustArrow(arrow, double) {
                const t = this.thickness;
                const head = this.arrowhead;
                if (head.x === ARROWX &&
                    head.y === ARROWY &&
                    head.dx === ARROWDX &&
                    t === THICKNESS)
                    return;
                const [x, y] = [t * head.x, t * head.y].map((x) => this.em(x));
                const a = Angle(head.dx, head.y);
                const [line, rthead, rbhead, lthead, lbhead] = this.adaptor.childNodes(arrow);
                this.adjustHead(rthead, [y, '0', '1px', x], a);
                this.adjustHead(rbhead, ['1px', '0', y, x], '-' + a);
                this.adjustHead(lthead, [y, x, '1px', '0'], '-' + a);
                this.adjustHead(lbhead, ['1px', x, y, '0'], a);
                this.adjustLine(line, t, head.x, double);
            }
            adjustHead(head, border, a) {
                if (head) {
                    this.adaptor.setStyle(head, 'border-width', border.join(' '));
                    this.adaptor.setStyle(head, 'transform', 'skewX(' + a + 'rad)');
                }
            }
            adjustLine(line, t, x, double) {
                this.adaptor.setStyle(line, 'borderTop', this.em(t) + ' solid');
                this.adaptor.setStyle(line, 'top', this.em(-t / 2));
                this.adaptor.setStyle(line, 'right', this.em(t * (x - 1)));
                if (double) {
                    this.adaptor.setStyle(line, 'left', this.em(t * (x - 1)));
                }
            }
            moveArrow(arrow, offset, d) {
                if (!d)
                    return;
                const transform = this.adaptor.getStyle(arrow, 'transform');
                this.adaptor.setStyle(arrow, 'transform', `translate${offset}(${this.em(-d)})${transform ? ' ' + transform : ''}`);
            }
            adjustBorder(node) {
                if (this.thickness !== THICKNESS) {
                    this.adaptor.setStyle(node, 'borderWidth', this.em(this.thickness));
                }
                return node;
            }
            adjustThickness(shape) {
                if (this.thickness !== THICKNESS) {
                    this.adaptor.setStyle(shape, 'strokeWidth', this.fixed(this.thickness));
                }
                return shape;
            }
            fixed(m, n = 3) {
                if (Math.abs(m) < 0.0006) {
                    return '0';
                }
                return m.toFixed(n).replace(/\.?0+$/, '');
            }
            Em(m) {
                return super.em(m);
            }
            toCHTML(parents) {
                const adaptor = this.adaptor;
                const chtml = this.standardChtmlNodes(parents);
                const block = adaptor.append(chtml[0], this.html('mjx-box'));
                if (this.renderChild) {
                    this.renderChild(this, block);
                }
                else {
                    this.childNodes[0].toCHTML([block]);
                }
                for (const name of Object.keys(this.notations)) {
                    const notation = this.notations[name];
                    if (!notation.renderChild) {
                        notation.renderer(this, block);
                    }
                }
                const pbox = this.getPadding();
                for (const name of sideNames) {
                    const i = sideIndex[name];
                    if (pbox[i] > 0) {
                        adaptor.setStyle(block, 'padding-' + name, this.em(pbox[i]));
                    }
                }
            }
            arrow(w, a, double, offset = '', dist = 0) {
                const W = this.getBBox().w;
                const style = { width: this.em(w) };
                if (W !== w) {
                    style.left = this.em((W - w) / 2);
                }
                if (a) {
                    style.transform = 'rotate(' + this.fixed(a) + 'rad)';
                }
                const arrow = this.html('mjx-arrow', { style: style }, [
                    this.html('mjx-aline'),
                    this.html('mjx-rthead'),
                    this.html('mjx-rbhead'),
                ]);
                if (double) {
                    this.adaptor.append(arrow, this.html('mjx-lthead'));
                    this.adaptor.append(arrow, this.html('mjx-lbhead'));
                    this.adaptor.setAttribute(arrow, 'double', 'true');
                }
                this.adjustArrow(arrow, double);
                this.moveArrow(arrow, offset, dist);
                return arrow;
            }
        },
        _a.kind = MmlMenclose.prototype.kind,
        _a.styles = {
            'mjx-menclose': {
                position: 'relative',
            },
            'mjx-menclose > mjx-dstrike': {
                display: 'inline-block',
                left: 0,
                top: 0,
                position: 'absolute',
                'border-top': SOLID,
                'transform-origin': 'top left',
            },
            'mjx-menclose > mjx-ustrike': {
                display: 'inline-block',
                left: 0,
                bottom: 0,
                position: 'absolute',
                'border-top': SOLID,
                'transform-origin': 'bottom left',
            },
            'mjx-menclose > mjx-hstrike': {
                'border-top': SOLID,
                position: 'absolute',
                left: 0,
                right: 0,
                bottom: '50%',
                transform: 'translateY(' + em(THICKNESS / 2) + ')',
            },
            'mjx-menclose > mjx-vstrike': {
                'border-left': SOLID,
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: '50%',
                transform: 'translateX(' + em(THICKNESS / 2) + ')',
            },
            'mjx-menclose > mjx-rbox': {
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: 0,
                left: 0,
                border: SOLID,
                'border-radius': em(THICKNESS + PADDING),
            },
            'mjx-menclose > mjx-cbox': {
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: 0,
                left: 0,
                border: SOLID,
                'border-radius': '50%',
            },
            'mjx-menclose > mjx-arrow': {
                position: 'absolute',
                left: 0,
                bottom: '50%',
                height: 0,
                width: 0,
            },
            'mjx-menclose > mjx-arrow > *': {
                display: 'block',
                position: 'absolute',
                'transform-origin': 'bottom',
                'border-left': em(THICKNESS * ARROWX) + ' solid',
                'border-right': 0,
                'box-sizing': 'border-box',
            },
            'mjx-menclose > mjx-arrow > mjx-aline': {
                left: 0,
                top: em(-THICKNESS / 2),
                right: em(THICKNESS * (ARROWX - 1)),
                height: 0,
                'border-top': em(THICKNESS) + ' solid',
                'border-left': 0,
            },
            'mjx-menclose > mjx-arrow[double] > mjx-aline': {
                left: em(THICKNESS * (ARROWX - 1)),
                height: 0,
            },
            'mjx-menclose > mjx-arrow > mjx-rthead': {
                transform: 'skewX(' + ANGLE + 'rad)',
                right: 0,
                bottom: '-1px',
                'border-bottom': '1px solid transparent',
                'border-top': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-arrow > mjx-rbhead': {
                transform: 'skewX(-' + ANGLE + 'rad)',
                'transform-origin': 'top',
                right: 0,
                top: '-1px',
                'border-top': '1px solid transparent',
                'border-bottom': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-arrow > mjx-lthead': {
                transform: 'skewX(-' + ANGLE + 'rad)',
                left: 0,
                bottom: '-1px',
                'border-left': 0,
                'border-right': em(THICKNESS * ARROWX) + ' solid',
                'border-bottom': '1px solid transparent',
                'border-top': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-arrow > mjx-lbhead': {
                transform: 'skewX(' + ANGLE + 'rad)',
                'transform-origin': 'top',
                left: 0,
                top: '-1px',
                'border-left': 0,
                'border-right': em(THICKNESS * ARROWX) + ' solid',
                'border-top': '1px solid transparent',
                'border-bottom': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-dbox-top': {
                position: 'absolute',
                top: 0,
                bottom: '50%',
                left: 0,
                width: em(1.5 * PADDING),
                border: em(THICKNESS) + ' solid',
                'border-style': 'solid solid none none',
                'border-radius': '0 100% 0 0',
                'box-sizing': 'border-box',
            },
            'mjx-menclose > mjx-dbox-bot': {
                position: 'absolute',
                top: '50%',
                bottom: 0,
                left: 0,
                width: em(1.5 * PADDING),
                'border-width': em(THICKNESS),
                'border-style': 'none solid solid none',
                'border-radius': '0 0 100% 0',
                'box-sizing': 'border-box',
            },
        },
        _a.notations = new Map([
            Border('top'),
            Border('right'),
            Border('bottom'),
            Border('left'),
            Border2('actuarial', 'top', 'right'),
            Border2('madruwb', 'bottom', 'right'),
            DiagonalStrike('up', 1),
            DiagonalStrike('down', -1),
            [
                'horizontalstrike',
                {
                    renderer: RenderElement('hstrike', 'Y'),
                    bbox: (node) => [0, node.padding, 0, node.padding],
                },
            ],
            [
                'verticalstrike',
                {
                    renderer: RenderElement('vstrike', 'X'),
                    bbox: (node) => [node.padding, 0, node.padding, 0],
                },
            ],
            [
                'box',
                {
                    renderer: (node, child) => {
                        node.adaptor.setStyle(child, 'border', node.Em(node.thickness) + ' solid');
                    },
                    bbox: fullBBox,
                    border: fullBorder,
                    remove: 'left right top bottom',
                },
            ],
            [
                'roundedbox',
                {
                    renderer: RenderElement('rbox'),
                    bbox: fullBBox,
                },
            ],
            [
                'circle',
                {
                    renderer: RenderElement('cbox'),
                    bbox: fullBBox,
                },
            ],
            [
                'phasorangle',
                {
                    renderer: (node, child) => {
                        const { h, d } = node.getBBox();
                        const [a, W] = node.getArgMod(1.75 * node.padding, h + d);
                        const t = node.thickness * Math.sin(a) * 0.9;
                        node.adaptor.setStyle(child, 'border-bottom', node.Em(node.thickness) + ' solid');
                        const strike = node.adjustBorder(node.html('mjx-ustrike', {
                            style: {
                                width: node.Em(W),
                                transform: `translateX(${node.Em(t)}) rotate(${node.fixed(-a)}rad)`,
                            },
                        }));
                        node.adaptor.append(node.dom[0], strike);
                    },
                    bbox: (node) => {
                        const p = node.padding / 2;
                        const t = node.thickness;
                        return [2 * p, p, p + t, 3 * p + t];
                    },
                    border: (node) => [0, 0, node.thickness, 0],
                    remove: 'bottom',
                },
            ],
            Arrow('up'),
            Arrow('down'),
            Arrow('left'),
            Arrow('right'),
            Arrow('updown'),
            Arrow('leftright'),
            DiagonalArrow('updiagonal'),
            DiagonalArrow('northeast'),
            DiagonalArrow('southeast'),
            DiagonalArrow('northwest'),
            DiagonalArrow('southwest'),
            DiagonalArrow('northeastsouthwest'),
            DiagonalArrow('northwestsoutheast'),
            [
                'longdiv',
                {
                    renderer: (node, child) => {
                        const adaptor = node.adaptor;
                        adaptor.setStyle(child, 'border-top', node.Em(node.thickness) + ' solid');
                        const arc1 = adaptor.append(node.dom[0], node.html('mjx-dbox-top'));
                        const arc2 = adaptor.append(node.dom[0], node.html('mjx-dbox-bot'));
                        const t = node.thickness;
                        const p = node.padding;
                        if (t !== THICKNESS) {
                            adaptor.setStyle(arc1, 'border-width', node.Em(t));
                            adaptor.setStyle(arc2, 'border-width', node.Em(t));
                        }
                        if (p !== PADDING) {
                            adaptor.setStyle(arc1, 'width', node.Em(1.5 * p));
                            adaptor.setStyle(arc2, 'width', node.Em(1.5 * p));
                        }
                    },
                    bbox: (node) => {
                        const p = node.padding;
                        const t = node.thickness;
                        return [p + t, p, p, 2 * p + t / 2];
                    },
                },
            ],
            [
                'radical',
                {
                    renderer: (node, child) => {
                        node.msqrt.toCHTML([child]);
                        const TRBL = node.sqrtTRBL();
                        node.adaptor.setStyle(node.msqrt.dom[0], 'margin', TRBL.map((x) => node.Em(-x)).join(' '));
                    },
                    init: (node) => {
                        node.msqrt = node.createMsqrt(node.childNodes[0]);
                    },
                    bbox: (node) => node.sqrtTRBL(),
                    renderChild: true,
                },
            ],
        ]),
        _a;
})();
//# sourceMappingURL=menclose.js.map
;// ./mjs/output/common/Wrappers/mrow.js



function CommonMrowMixin(Base) {
    return class CommonMrowMixin extends Base {
        stretchChildren() {
            const stretchy = [];
            for (const child of this.childNodes) {
                if (child.canStretch(DIRECTION.Vertical)) {
                    stretchy.push(child);
                }
            }
            const count = stretchy.length;
            const nodeCount = this.childNodes.length;
            if (count && nodeCount > 1) {
                let H = 0;
                let D = 0;
                const all = count > 1 && count === nodeCount;
                for (const child of this.childNodes) {
                    const noStretch = child.stretch.dir === DIRECTION.None;
                    if (all || noStretch) {
                        const rscale = child.getBBox().rscale;
                        let [h, d] = child.getUnbrokenHD();
                        h *= rscale;
                        d *= rscale;
                        if (h > H)
                            H = h;
                        if (d > D)
                            D = d;
                    }
                }
                for (const child of stretchy) {
                    const rscale = child.coreRScale();
                    child.coreMO().getStretchedVariant([H / rscale, D / rscale]);
                }
            }
        }
        get fixesPWidth() {
            return false;
        }
        get breakCount() {
            if (this._breakCount < 0) {
                this._breakCount = !this.childNodes.length
                    ? 0
                    : this.childNodes.reduce((n, child) => n + child.breakCount, 0);
            }
            return this._breakCount;
        }
        breakTop(_mrow, _child) {
            const node = this;
            return this.isStack ? this.parent.breakTop(node, node) : node;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.dh = 0;
            const self = this;
            this.isStack =
                !this.parent ||
                    this.parent.node.isInferred ||
                    this.parent.breakTop(self, self) !== self;
            this.stretchChildren();
            for (const child of this.childNodes) {
                if (child.bbox.pwidth) {
                    this.bbox.pwidth = BBox.fullWidth;
                    break;
                }
            }
        }
        computeBBox(bbox, recompute = false) {
            const breaks = this.breakCount;
            this.lineBBox = breaks
                ? [new LineBBox({ h: 0.75, d: 0.25, w: 0 }, [0, 0])]
                : [];
            bbox.empty();
            for (const i of this.childNodes.keys()) {
                const child = this.childNodes[i];
                bbox.append(child.getOuterBBox());
                if (breaks) {
                    this.computeChildLineBBox(child, i);
                }
            }
            bbox.clean();
            if (breaks && !this.coreMO().node.isEmbellished) {
                this.computeLinebreakBBox(bbox);
            }
            if (this.fixesPWidth && this.setChildPWidths(recompute)) {
                this.computeBBox(bbox, true);
            }
            this.vboxAdjust(bbox);
        }
        computeLinebreakBBox(bbox) {
            var _a;
            bbox.empty();
            const isStack = this.isStack;
            const lines = this.lineBBox;
            const n = lines.length - 1;
            if (isStack) {
                for (const k of lines.keys()) {
                    const line = lines[k];
                    this.addMiddleBorders(line);
                    if (k === 0) {
                        this.addLeftBorders(line);
                    }
                    if (k === n) {
                        this.addRightBorders(line);
                    }
                }
            }
            let y = 0;
            for (const k of lines.keys()) {
                const line = lines[k];
                bbox.combine(line, 0, y);
                y -=
                    Math.max(0.25, line.d) +
                        line.lineLeading +
                        Math.max(0.75, ((_a = lines[k + 1]) === null || _a === void 0 ? void 0 : _a.h) || 0);
            }
            if (isStack) {
                lines[0].L = this.bbox.L;
                lines[n].R = this.bbox.R;
            }
            else {
                bbox.w = Math.max(...this.lineBBox.map((bbox) => bbox.w));
                this.shiftLines(bbox.w);
                if (!this.jax.math.display && !this.linebreakOptions.inline) {
                    bbox.pwidth = BBox.fullWidth;
                    if (this.node.isInferred) {
                        this.parent.bbox.pwidth = BBox.fullWidth;
                    }
                }
            }
            bbox.clean();
        }
        vboxAdjust(bbox) {
            if (!this.parent)
                return;
            const n = this.breakCount;
            const valign = this.parent.node.attributes.get('data-vertical-align');
            if (n && valign === 'bottom') {
                this.dh = n ? bbox.d - this.lineBBox[n - 1].d : 0;
            }
            else if (valign === 'center' || (n && valign === 'middle')) {
                const { h, d } = bbox;
                const a = this.font.params.axis_height;
                this.dh = (h + d) / 2 + a - h;
            }
            else {
                this.dh = 0;
                return;
            }
            bbox.h += this.dh;
            bbox.d -= this.dh;
        }
        computeChildLineBBox(child, i) {
            const lbox = this.lineBBox[this.lineBBox.length - 1];
            lbox.end = [i, 0];
            lbox.append(child.getLineBBox(0));
            const parts = child.breakCount + 1;
            if (parts === 1)
                return;
            for (let l = 1; l < parts; l++) {
                const bbox = new LineBBox({ h: 0.75, d: 0.25, w: 0 });
                bbox.start = bbox.end = [i, l];
                bbox.isFirst = true;
                bbox.append(child.getLineBBox(l));
                this.lineBBox.push(bbox);
            }
        }
        getLineBBox(i) {
            this.getBBox();
            return this.isStack
                ? super.getLineBBox(i)
                : LineBBox.from(this.getOuterBBox(), this.linebreakOptions.lineleading);
        }
        shiftLines(W) {
            var _a, _b;
            const lines = this.lineBBox;
            const n = lines.length - 1;
            const [alignfirst, shiftfirst] = ((_a = lines[1].indentData) === null || _a === void 0 ? void 0 : _a[0]) || [
                'left',
                '0',
            ];
            for (const i of lines.keys()) {
                const bbox = lines[i];
                const [indentalign, indentshift] = i === 0
                    ? [alignfirst, shiftfirst]
                    : ((_b = bbox.indentData) === null || _b === void 0 ? void 0 : _b[i === n ? 2 : 1]) || ['left', '0'];
                const [align, shift] = this.processIndent(indentalign, indentshift, alignfirst, shiftfirst, W);
                bbox.L = 0;
                bbox.L = this.getAlignX(W, bbox, align) + shift;
            }
        }
        setChildPWidths(recompute, w = null, clear = true) {
            if (!this.breakCount)
                return super.setChildPWidths(recompute, w, clear);
            if (recompute)
                return false;
            if (w !== null && this.bbox.w !== w) {
                this.bbox.w = w;
                this.shiftLines(w);
            }
            return true;
        }
        breakToWidth(W) {
            this.linebreaks.breakToWidth(this, W);
        }
    };
}
function CommonInferredMrowMixin(Base) {
    return class CommonInferredMrowMixin extends Base {
        getScale() {
            this.bbox.scale = this.parent.bbox.scale;
            this.bbox.rscale = 1;
        }
    };
}
//# sourceMappingURL=mrow.js.map
;// ./mjs/output/chtml/Wrappers/mrow.js




const ChtmlMrow = (function () {
    var _a;
    const Base = CommonMrowMixin(ChtmlWrapper);
    return _a = class ChtmlMrow extends Base {
            constructor() {
                super(...arguments);
                this.linebreakCount = 0;
            }
            toCHTML(parents) {
                const n = (this.linebreakCount = this.isStack ? 0 : this.breakCount);
                if (n || !this.node.isInferred) {
                    parents = this.standardChtmlNodes(parents);
                }
                else {
                    this.dom = parents;
                }
                this.addChildren(parents);
                if (n) {
                    this.placeLines(parents, n);
                }
                else {
                    this.handleVerticalAlign(parents[0]);
                    this.handleNegativeWidth(parents[0]);
                }
            }
            placeLines(parents, n) {
                var _b, _c;
                this.getBBox();
                const lines = this.lineBBox;
                const adaptor = this.adaptor;
                const [alignfirst, shiftfirst] = ((_b = lines[1].indentData) === null || _b === void 0 ? void 0 : _b[0]) || [
                    'left',
                    '0',
                ];
                for (const i of parents.keys()) {
                    const bbox = lines[i];
                    const [indentalign, indentshift] = i === 0
                        ? [alignfirst, shiftfirst]
                        : ((_c = bbox.indentData) === null || _c === void 0 ? void 0 : _c[i === n ? 2 : 1]) || ['left', '0'];
                    const [align, shift] = this.processIndent(indentalign, indentshift, alignfirst, shiftfirst);
                    adaptor.setAttribute(parents[i], 'align', align);
                    if (shift) {
                        adaptor.setStyle(parents[i], 'position', 'relative');
                        adaptor.setStyle(parents[i], 'left', this.em(shift));
                    }
                    if (i < n && this.jax.math.display) {
                        adaptor.setStyle(parents[i], 'margin-bottom', this.em(bbox.lineLeading));
                    }
                }
            }
            handleVerticalAlign(dom) {
                if (this.dh) {
                    this.adaptor.setStyle(this.adaptor.parent(dom), 'vertical-align', this.em(this.dh));
                }
            }
            handleNegativeWidth(dom) {
                const { w } = this.getBBox();
                if (w < 0) {
                    this.adaptor.setStyle(dom, 'width', this.em(Math.max(0, w)));
                    this.adaptor.setStyle(dom, 'marginRight', this.em(w));
                }
            }
            createChtmlNodes(parents) {
                const n = this.linebreakCount;
                if (!n)
                    return super.createChtmlNodes(parents);
                const adaptor = this.adaptor;
                const kind = this.node.isInferred
                    ? 'mjx-linestack'
                    : 'mjx-' + this.node.kind;
                this.dom = [adaptor.append(parents[0], this.html(kind))];
                if (kind === 'mjx-mrow' && !this.isStack) {
                    adaptor.setAttribute(this.dom[0], 'break-top', 'true');
                }
                if (this.node.getProperty('process-breaks')) {
                    adaptor.setAttribute(this.dom[0], 'breakable', 'true');
                }
                if (this.node.isInferred || !this.isStack) {
                    const valign = this.parent.node.attributes.get('data-vertical-align');
                    if (valign === 'middle' || valign === 'center' || valign === 'bottom') {
                        adaptor.setAttribute(this.dom[0], 'break-align', valign);
                    }
                }
                this.dom = [
                    adaptor.append(this.handleHref(parents)[0], this.dom[0]),
                ];
                const chtml = Array(n);
                for (let i = 0; i <= n; i++) {
                    chtml[i] = adaptor.append(this.dom[0], this.html('mjx-linebox', { lineno: i }));
                }
                return chtml;
            }
            addChildren(parents) {
                let i = 0;
                for (const child of this.childNodes) {
                    const n = child.breakCount;
                    child.toCHTML(parents.slice(i, i + n + 1));
                    i += n;
                }
            }
        },
        _a.kind = MmlMrow.prototype.kind,
        _a.styles = {
            'mjx-linestack, mjx-mrow[break-top]': {
                display: 'inline-table',
                width: '100%',
            },
            'mjx-linestack[break-align="bottom"], mjx-mrow[break-top][break-align="bottom"]': {
                display: 'inline-block',
            },
            'mjx-linestack[break-align="middle"], mjx-mrow[break-top][break-align="middle"]': {
                'vertical-align': 'middle',
            },
            'mjx-linestack[break-align="center"], mjx-mrow[break-top][break-align="center"]': {
                'vertical-align': 'middle',
            },
            'mjx-linestack[breakable]': {
                display: 'inline',
            },
            'mjx-linestack[breakable] > mjx-linebox': {
                display: 'inline',
            },
            'mjx-linestack[breakable] > mjx-linebox::before': {
                'white-space': 'pre',
                content: '"\\A"',
            },
            'mjx-linestack[breakable] > mjx-linebox::after': {
                'white-space': 'normal',
                content: '" "',
                'letter-spacing': '-.999em',
                'font-family': 'MJX-BRK',
            },
            'mjx-linestack[breakable] > mjx-linebox:first-of-type::before': {
                display: 'none',
            },
            'mjx-linestack[breakable] > mjx-linebox:last-of-type::after': {
                display: 'none',
            },
            'mjx-linebox': {
                display: 'block',
            },
            'mjx-linebox[align="left"]': {
                'text-align': 'left',
            },
            'mjx-linebox[align="center"]': {
                'text-align': 'center',
            },
            'mjx-linebox[align="right"]': {
                'text-align': 'right',
            },
            'mjx-linestrut': {
                display: 'inline-block',
                height: '1em',
                'vertical-align': '-.25em',
            },
        },
        _a;
})();
const ChtmlInferredMrow = (function () {
    var _a;
    const Base = CommonInferredMrowMixin(ChtmlMrow);
    return _a = class ChtmlInferredMrow extends Base {
        },
        _a.kind = MmlInferredMrow.prototype.kind,
        _a;
})();
//# sourceMappingURL=mrow.js.map
;// ./mjs/output/common/Wrappers/mfenced.js
function CommonMfencedMixin(Base) {
    return class CommonMfencedMixin extends Base {
        createMrow() {
            const mmlFactory = this.node.factory;
            const mrow = mmlFactory.create('inferredMrow');
            mrow.inheritAttributesFrom(this.node);
            this.mrow = this.wrap(mrow);
            this.mrow.parent = this;
        }
        addMrowChildren() {
            const mfenced = this.node;
            const mrow = this.mrow;
            this.addMo(mfenced.open);
            if (this.childNodes.length) {
                mrow.childNodes.push(this.childNodes[0]);
            }
            let i = 0;
            for (const child of this.childNodes.slice(1)) {
                this.addMo(mfenced.separators[i++]);
                mrow.childNodes.push(child);
            }
            this.addMo(mfenced.close);
            mrow.stretchChildren();
        }
        addMo(node) {
            if (!node)
                return;
            const mo = this.wrap(node);
            this.mrow.childNodes.push(mo);
            mo.parent = this.mrow;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.mrow = null;
            this.createMrow();
            this.addMrowChildren();
        }
        computeBBox(bbox, recompute = false) {
            bbox.updateFrom(this.mrow.getOuterBBox());
            this.setChildPWidths(recompute);
        }
        get breakCount() {
            return this.mrow.breakCount;
        }
        computeLineBBox(i) {
            return this.mrow.getLineBBox(i);
        }
    };
}
//# sourceMappingURL=mfenced.js.map
;// ./mjs/output/chtml/Wrappers/mfenced.js



const ChtmlMfenced = (function () {
    var _a;
    const Base = CommonMfencedMixin(ChtmlWrapper);
    return _a = class ChtmlMfenced extends Base {
            toCHTML(parents) {
                const chtml = this.standardChtmlNodes(parents);
                this.mrow.toCHTML(chtml);
            }
        },
        _a.kind = MmlMfenced.prototype.kind,
        _a;
})();
//# sourceMappingURL=mfenced.js.map
;// ./mjs/output/common/Wrappers/mfrac.js

function CommonMfracMixin(Base) {
    return class CommonMfracMixin extends Base {
        getFractionBBox(bbox, display, t) {
            const nbox = this.childNodes[0].getOuterBBox();
            const dbox = this.childNodes[1].getOuterBBox();
            const tex = this.font.params;
            const a = tex.axis_height;
            const { T, u, v } = this.getTUV(display, t);
            bbox.combine(nbox, 0, a + T + Math.max(nbox.d * nbox.rscale, u));
            bbox.combine(dbox, 0, a - T - Math.max(dbox.h * dbox.rscale, v));
            bbox.w += 2 * this.pad + 0.2;
        }
        getTUV(display, t) {
            const tex = this.font.params;
            const a = tex.axis_height;
            const T = (display ? 3.5 : 1.5) * t;
            return {
                T: (display ? 3.5 : 1.5) * t,
                u: (display ? tex.num1 : tex.num2) - a - T,
                v: (display ? tex.denom1 : tex.denom2) + a - T,
            };
        }
        getAtopBBox(bbox, display) {
            const { u, v, nbox, dbox } = this.getUVQ(display);
            bbox.combine(nbox, 0, u);
            bbox.combine(dbox, 0, -v);
            bbox.w += 2 * this.pad;
        }
        getUVQ(display) {
            const nbox = this.childNodes[0].getOuterBBox();
            const dbox = this.childNodes[1].getOuterBBox();
            const tex = this.font.params;
            let [u, v] = display ? [tex.num1, tex.denom1] : [tex.num3, tex.denom2];
            const p = (display ? 7 : 3) * tex.rule_thickness;
            let q = u - nbox.d * nbox.scale - (dbox.h * dbox.scale - v);
            if (q < p) {
                u += (p - q) / 2;
                v += (p - q) / 2;
                q = p;
            }
            return { u, v, q, nbox, dbox };
        }
        getBevelledBBox(bbox, display) {
            const { u, v, delta, nbox, dbox } = this.getBevelData(display);
            const lbox = this.bevel.getOuterBBox();
            bbox.combine(nbox, 0, u);
            bbox.combine(lbox, bbox.w - delta / 2, 0);
            bbox.combine(dbox, bbox.w - delta / 2, v);
        }
        getBevelData(display) {
            const nbox = this.childNodes[0].getOuterBBox();
            const dbox = this.childNodes[1].getOuterBBox();
            const delta = display ? 0.4 : 0.15;
            const H = Math.max(nbox.scale * (nbox.h + nbox.d), dbox.scale * (dbox.h + dbox.d)) +
                2 * delta;
            const a = this.font.params.axis_height;
            const u = (nbox.scale * (nbox.d - nbox.h)) / 2 + a + delta;
            const v = (dbox.scale * (dbox.d - dbox.h)) / 2 + a - delta;
            return { H, delta, u, v, nbox, dbox };
        }
        isDisplay() {
            const { displaystyle, scriptlevel } = this.node.attributes.getList('displaystyle', 'scriptlevel');
            return displaystyle && scriptlevel === 0;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.bevel = null;
            this.pad = this.node.getProperty('withDelims')
                ? 0
                : this.font.params.nulldelimiterspace;
            if (this.node.attributes.get('bevelled')) {
                const { H } = this.getBevelData(this.isDisplay());
                const bevel = (this.bevel = this.createMo('/'));
                bevel.node.attributes.set('symmetric', true);
                bevel.canStretch(DIRECTION.Vertical);
                bevel.getStretchedVariant([H], true);
            }
        }
        computeBBox(bbox, recompute = false) {
            bbox.empty();
            const { linethickness, bevelled } = this.node.attributes.getList('linethickness', 'bevelled');
            const display = this.isDisplay();
            let w = null;
            if (bevelled) {
                this.getBevelledBBox(bbox, display);
            }
            else {
                const thickness = this.length2em(String(linethickness), 0.06);
                w = -2 * this.pad;
                if (thickness === 0) {
                    this.getAtopBBox(bbox, display);
                }
                else {
                    this.getFractionBBox(bbox, display, thickness);
                    w -= 0.2;
                }
                w += bbox.w;
            }
            bbox.clean();
            this.setChildPWidths(recompute, w);
        }
        canStretch(_direction) {
            return false;
        }
        getChildAlign(i) {
            const attributes = this.node.attributes;
            return attributes.get('bevelled')
                ? 'left'
                : attributes.get(['numalign', 'denomalign'][i]);
        }
        getWrapWidth(i) {
            const attributes = this.node.attributes;
            if (attributes.get('bevelled')) {
                return this.childNodes[i].getOuterBBox().w;
            }
            const w = this.getBBox().w;
            const thickness = this.length2em(attributes.get('linethickness'));
            return w - (thickness ? 0.2 : 0) - 2 * this.pad;
        }
    };
}
//# sourceMappingURL=mfrac.js.map
;// ./mjs/output/chtml/Wrappers/mfrac.js



const ChtmlMfrac = (function () {
    var _a;
    const Base = CommonMfracMixin(ChtmlWrapper);
    return _a = class ChtmlMfrac extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                this.standardChtmlNodes(parents);
                const { linethickness, bevelled } = this.node.attributes.getList('linethickness', 'bevelled');
                const display = this.isDisplay();
                if (bevelled) {
                    this.makeBevelled(display);
                }
                else {
                    const thickness = this.length2em(String(linethickness), 0.06);
                    if (thickness === 0) {
                        this.makeAtop(display);
                    }
                    else {
                        this.makeFraction(display, thickness);
                    }
                }
            }
            makeFraction(display, t) {
                const { numalign, denomalign } = this.node.attributes.getList('numalign', 'denomalign');
                const withDelims = this.node.getProperty('withDelims');
                const attr = (display ? { type: 'd' } : {});
                const fattr = (withDelims ? Object.assign(Object.assign({}, attr), { delims: 'true' }) : Object.assign({}, attr));
                const nattr = (numalign !== 'center' ? { align: numalign } : {});
                const dattr = (denomalign !== 'center' ? { align: denomalign } : {});
                const dsattr = Object.assign({}, attr), nsattr = Object.assign({}, attr);
                const tex = this.font.params;
                if (t !== 0.06) {
                    const a = tex.axis_height;
                    const r = this.font.params.rule_factor;
                    const tEm = this.em(t);
                    const { T, u, v } = this.getTUV(display, t);
                    const m = (display ? this.em(3 * t) : tEm) + ' -.1em';
                    attr.style = {
                        height: tEm,
                        'border-top': this.em(t * r) + ' solid',
                        margin: m,
                    };
                    const nh = this.em(Math.max(0, u));
                    nsattr.style = { height: nh, 'vertical-align': '-' + nh };
                    dsattr.style = { height: this.em(Math.max(0, v)) };
                    fattr.style = { 'vertical-align': this.em(a - T) };
                }
                let num, den;
                this.adaptor.append(this.dom[0], this.html('mjx-frac', fattr, [
                    (num = this.html('mjx-num', nattr, [
                        this.html('mjx-nstrut', nsattr),
                    ])),
                    this.html('mjx-dbox', {}, [
                        this.html('mjx-dtable', {}, [
                            this.html('mjx-line', attr),
                            this.html('mjx-row', {}, [
                                (den = this.html('mjx-den', dattr, [
                                    this.html('mjx-dstrut', dsattr),
                                ])),
                            ]),
                        ]),
                    ]),
                ]));
                this.childNodes[0].toCHTML([num]);
                this.childNodes[1].toCHTML([den]);
            }
            makeAtop(display) {
                const { numalign, denomalign } = this.node.attributes.getList('numalign', 'denomalign');
                const withDelims = this.node.getProperty('withDelims');
                const attr = (display ? { type: 'd', atop: true } : { atop: true });
                const fattr = (withDelims ? Object.assign(Object.assign({}, attr), { delims: true }) : Object.assign({}, attr));
                const nattr = (numalign !== 'center' ? { align: numalign } : {});
                const dattr = (denomalign !== 'center' ? { align: denomalign } : {});
                const { v, q } = this.getUVQ(display);
                nattr.style = { 'padding-bottom': this.em(q) };
                fattr.style = { 'vertical-align': this.em(-v) };
                let num, den;
                this.adaptor.append(this.dom[0], this.html('mjx-frac', fattr, [
                    (num = this.html('mjx-num', nattr)),
                    (den = this.html('mjx-den', dattr)),
                ]));
                this.childNodes[0].toCHTML([num]);
                this.childNodes[1].toCHTML([den]);
            }
            makeBevelled(display) {
                const adaptor = this.adaptor;
                adaptor.setAttribute(this.dom[0], 'bevelled', 'ture');
                const num = adaptor.append(this.dom[0], this.html('mjx-num'));
                this.childNodes[0].toCHTML([num]);
                this.bevel.toCHTML(this.dom);
                const den = adaptor.append(this.dom[0], this.html('mjx-den'));
                this.childNodes[1].toCHTML([den]);
                const { u, v, delta, nbox, dbox } = this.getBevelData(display);
                if (u) {
                    adaptor.setStyle(num, 'verticalAlign', this.em(u / nbox.scale));
                }
                if (v) {
                    adaptor.setStyle(den, 'verticalAlign', this.em(v / dbox.scale));
                }
                const dx = this.em(-delta / 2);
                adaptor.setStyle(this.bevel.dom[0], 'marginLeft', dx);
                adaptor.setStyle(this.bevel.dom[0], 'marginRight', dx);
            }
        },
        _a.kind = MmlMfrac.prototype.kind,
        _a.styles = {
            'mjx-frac': {
                display: 'inline-block',
                'vertical-align': '0.17em',
                padding: '0 .22em'
            },
            'mjx-frac[type="d"]': {
                'vertical-align': '.04em'
            },
            'mjx-frac[delims]': {
                padding: '0 .1em'
            },
            'mjx-frac[atop]': {
                padding: '0 .12em'
            },
            'mjx-frac[atop][delims]': {
                padding: '0'
            },
            'mjx-dtable': {
                display: 'inline-table',
                width: '100%'
            },
            'mjx-dtable > *': {
                'font-size': '2000%'
            },
            'mjx-dbox': {
                display: 'block',
                'font-size': '5%'
            },
            'mjx-num': {
                display: 'block',
                'text-align': 'center'
            },
            'mjx-den': {
                display: 'block',
                'text-align': 'center'
            },
            'mjx-mfrac[bevelled] > mjx-num': {
                display: 'inline-block'
            },
            'mjx-mfrac[bevelled] > mjx-den': {
                display: 'inline-block'
            },
            'mjx-den[align="right"], mjx-num[align="right"]': {
                'text-align': 'right'
            },
            'mjx-den[align="left"], mjx-num[align="left"]': {
                'text-align': 'left'
            },
            'mjx-nstrut': {
                display: 'inline-block',
                height: '.054em',
                width: 0,
                'vertical-align': '-.054em'
            },
            'mjx-nstrut[type="d"]': {
                height: '.217em',
                'vertical-align': '-.217em',
            },
            'mjx-dstrut': {
                display: 'inline-block',
                height: '.505em',
                width: 0
            },
            'mjx-dstrut[type="d"]': {
                height: '.726em',
            },
            'mjx-line': {
                display: 'block',
                'box-sizing': 'border-box',
                'min-height': '1px',
                height: '.06em',
                'border-top': '.075em solid',
                margin: '.06em -.1em',
                overflow: 'hidden'
            },
            'mjx-line[type="d"]': {
                margin: '.18em -.1em'
            }
        },
        _a;
})();
//# sourceMappingURL=mfrac.js.map
;// ./mjs/output/common/Wrappers/msqrt.js


function CommonMsqrtMixin(Base) {
    return class CommonMsqrtMixin extends Base {
        get base() {
            return 0;
        }
        get root() {
            return null;
        }
        combineRootBBox(_bbox, _sbox, _H) { }
        getPQ(sbox) {
            const t = this.font.params.rule_thickness;
            const s = this.font.params.surd_height;
            const p = this.node.attributes.get('displaystyle')
                ? this.font.params.x_height
                : t;
            const q = sbox.h + sbox.d > this.surdH
                ? (sbox.h + sbox.d - (this.surdH - t - s - p / 2)) / 2
                : s + p / 4;
            return [p, q];
        }
        getRootDimens(_sbox, _H) {
            return [0, 0, 0, 0];
        }
        rootWidth() {
            return 1.25;
        }
        getStretchedSurd() {
            const t = this.font.params.rule_thickness;
            const s = this.font.params.surd_height;
            const p = this.node.attributes.get('displaystyle')
                ? this.font.params.x_height
                : t;
            const { h, d } = this.childNodes[this.base].getOuterBBox();
            this.surdH = h + d + t + s + p / 4;
            this.surd.getStretchedVariant([this.surdH - d, d], true);
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.surd = this.createMo('\u221A');
            this.surd.canStretch(DIRECTION.Vertical);
            this.getStretchedSurd();
        }
        computeBBox(bbox, recompute = false) {
            bbox.empty();
            const surdbox = this.surd.getBBox();
            const basebox = new BBox(this.childNodes[this.base].getOuterBBox());
            const q = this.getPQ(surdbox)[1];
            const t = this.font.params.rule_thickness;
            const s = this.font.params.surd_height;
            const H = basebox.h + q + t;
            const [x] = this.getRootDimens(surdbox, H);
            bbox.h = H + s;
            this.combineRootBBox(bbox, surdbox, H);
            bbox.combine(surdbox, x, H - surdbox.h);
            bbox.combine(basebox, x + surdbox.w, 0);
            bbox.clean();
            this.setChildPWidths(recompute);
        }
        invalidateBBox() {
            super.invalidateBBox();
            this.surd.childNodes[0].invalidateBBox();
        }
    };
}
//# sourceMappingURL=msqrt.js.map
;// ./mjs/output/chtml/Wrappers/msqrt.js



const ChtmlMsqrt = (function () {
    var _a;
    const Base = CommonMsqrtMixin(ChtmlWrapper);
    return _a = class ChtmlMsqrt extends Base {
            toCHTML(parents) {
                const surd = this.surd;
                const base = this.childNodes[this.base];
                const sbox = surd.getBBox();
                const bbox = base.getOuterBBox();
                const [, q] = this.getPQ(sbox);
                const t = this.font.params.surd_height;
                const H = bbox.h + q + t;
                const adaptor = this.adaptor;
                const CHTML = this.standardChtmlNodes(parents);
                let SURD, BASE, ROOT, root;
                if (this.root != null) {
                    ROOT = adaptor.append(CHTML[0], this.html('mjx-root'));
                    root = this.childNodes[this.root];
                }
                const SQRT = adaptor.append(CHTML[0], this.html('mjx-sqrt', {}, [
                    (SURD = this.html('mjx-surd')),
                    (BASE = this.html('mjx-box', { style: { paddingTop: this.em(q) } })),
                ]));
                if (t !== 0.06) {
                    adaptor.setStyle(BASE, 'border-top-width', this.em(t * this.font.params.rule_factor));
                }
                this.addRoot(ROOT, root, sbox, H);
                surd.toCHTML([SURD]);
                base.toCHTML([BASE]);
                if (surd.size < 0) {
                    adaptor.addClass(SQRT, 'mjx-tall');
                }
            }
            addRoot(_ROOT, _root, _sbox, _H) { }
        },
        _a.kind = MmlMsqrt.prototype.kind,
        _a.styles = {
            'mjx-root': {
                display: 'inline-block',
                'white-space': 'nowrap',
            },
            'mjx-surd': {
                display: 'inline-block',
                'vertical-align': 'top',
            },
            'mjx-sqrt': {
                display: 'inline-block',
                'padding-top': '.075em',
            },
            'mjx-sqrt > mjx-box': {
                'border-top': '.075em solid',
                'padding-left': '.03em',
                'margin-left': '-.03em',
            },
            'mjx-sqrt.mjx-tall > mjx-box': {
                'padding-left': '.3em',
                'margin-left': '-.3em',
            },
        },
        _a;
})();
//# sourceMappingURL=msqrt.js.map
;// ./mjs/output/common/Wrappers/mroot.js
function CommonMrootMixin(Base) {
    return class CommonMrootMixin extends Base {
        get root() {
            return 1;
        }
        combineRootBBox(BBOX, sbox, H) {
            const bbox = this.childNodes[this.root].getOuterBBox();
            const h = this.getRootDimens(sbox, H)[1];
            BBOX.combine(bbox, 0, h);
        }
        getRootDimens(sbox, H) {
            const surd = this.surd;
            const bbox = this.childNodes[this.root].getOuterBBox();
            const offset = (surd.size < 0 ? 0.5 : 0.6) * sbox.w;
            const { w, rscale } = bbox;
            const W = Math.max(w, offset / rscale);
            const dx = Math.max(0, W - w);
            const h = this.rootHeight(bbox, sbox, surd.size, H);
            const x = W * rscale - offset;
            return [x, h, dx];
        }
        rootHeight(rbox, sbox, size, H) {
            const h = sbox.h + sbox.d;
            const b = (size < 0 ? 1.9 : 0.55 * h) - (h - H);
            return b + Math.max(0, rbox.d * rbox.rscale);
        }
        rootWidth() {
            const bbox = this.childNodes[this.root].getOuterBBox();
            return 0.4 + bbox.w * bbox.rscale;
        }
    };
}
//# sourceMappingURL=mroot.js.map
;// ./mjs/output/chtml/Wrappers/mroot.js



const ChtmlMroot = (function () {
    var _a;
    const Base = CommonMrootMixin(ChtmlMsqrt);
    return _a = class ChtmlMroot extends Base {
            addRoot(ROOT, root, sbox, H) {
                root.toCHTML([ROOT]);
                const adaptor = this.adaptor;
                const [x, h, dx] = this.getRootDimens(sbox, H);
                adaptor.setStyle(ROOT, 'verticalAlign', this.em(h));
                adaptor.setStyle(ROOT, 'width', this.em(x));
                if (dx) {
                    adaptor.setStyle(adaptor.firstChild(ROOT), 'paddingLeft', this.em(dx));
                }
            }
        },
        _a.kind = MmlMroot.prototype.kind,
        _a;
})();
//# sourceMappingURL=mroot.js.map
;// ./mjs/output/common/Wrappers/msubsup.js
function CommonMsubMixin(Base) {
    var _a;
    return _a = class CommonMsubMixin extends Base {
            get scriptChild() {
                return this.childNodes[this.node.sub];
            }
            getOffset() {
                const x = this.baseIsChar ? 0 : this.getAdjustedIc();
                return [x, -this.getV()];
            }
        },
        _a.useIC = false,
        _a;
}
function CommonMsupMixin(Base) {
    return class CommonMsupMixin extends Base {
        get scriptChild() {
            return this.childNodes[this.node.sup];
        }
        getOffset() {
            const x = this.getAdjustedIc() - (this.baseRemoveIc ? 0 : this.baseIc);
            return [x, this.getU()];
        }
    };
}
function CommonMsubsupMixin(Base) {
    var _a;
    return _a = class CommonMsubsupMixin extends Base {
            constructor() {
                super(...arguments);
                this.UVQ = null;
            }
            get subChild() {
                return this.childNodes[this.node.sub];
            }
            get supChild() {
                return this.childNodes[this.node.sup];
            }
            get scriptChild() {
                return this.supChild;
            }
            getUVQ(subbox = this.subChild.getOuterBBox(), supbox = this.supChild.getOuterBBox()) {
                const base = this.baseCore;
                const bbox = base.getLineBBox(base.breakCount);
                if (this.UVQ)
                    return this.UVQ;
                const tex = this.font.params;
                const t = 3 * tex.rule_thickness;
                const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub2);
                const drop = this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * subbox.rscale);
                const supd = supbox.d * supbox.rscale;
                const subh = subbox.h * subbox.rscale;
                let [u, v] = [this.getU(), Math.max(drop, subscriptshift)];
                let q = u - supd - (subh - v);
                if (q < t) {
                    v += t - q;
                    const p = (4 / 5) * tex.x_height - (u - supd);
                    if (p > 0) {
                        u += p;
                        v -= p;
                    }
                }
                u = Math.max(this.length2em(this.node.attributes.get('superscriptshift'), u), u);
                v = Math.max(this.length2em(this.node.attributes.get('subscriptshift'), v), v);
                q = u - supd - (subh - v);
                this.UVQ = [u, -v, q];
                return this.UVQ;
            }
            appendScripts(bbox) {
                const [subbox, supbox] = [
                    this.subChild.getOuterBBox(),
                    this.supChild.getOuterBBox(),
                ];
                const w = this.getBaseWidth();
                const x = this.getAdjustedIc();
                const [u, v] = this.getUVQ();
                const y = bbox.d - this.baseChild.getLineBBox(this.baseChild.breakCount).d;
                bbox.combine(subbox, w + (this.baseIsChar ? 0 : x), v - y);
                bbox.combine(supbox, w + x, u - y);
                bbox.w += this.font.params.scriptspace;
                return bbox;
            }
        },
        _a.useIC = false,
        _a;
}
//# sourceMappingURL=msubsup.js.map
;// ./mjs/output/common/Wrappers/scriptbase.js


function CommonScriptbaseMixin(Base) {
    var _a;
    return _a = class CommonScriptbaseMixin extends Base {
            get baseChild() {
                return this.childNodes[this.node.base];
            }
            get scriptChild() {
                return this.childNodes[1];
            }
            getBaseCore() {
                let core = this.getSemanticBase() || this.childNodes[0];
                let node = core === null || core === void 0 ? void 0 : core.node;
                while (core &&
                    ((core.childNodes.length === 1 &&
                        (node.isKind('mrow') ||
                            node.isKind('TeXAtom') ||
                            node.isKind('mstyle') ||
                            (node.isKind('mpadded') && !node.getProperty('vbox')) ||
                            node.isKind('mphantom') ||
                            node.isKind('semantics'))) ||
                        (node.isKind('munderover') &&
                            core.isMathAccent))) {
                    this.setBaseAccentsFor(core);
                    core = core.childNodes[0];
                    node = core === null || core === void 0 ? void 0 : core.node;
                }
                if (!core) {
                    this.baseHasAccentOver = this.baseHasAccentUnder = false;
                }
                return core || this.childNodes[0];
            }
            setBaseAccentsFor(core) {
                if (core.node.isKind('munderover')) {
                    if (this.baseHasAccentOver === null) {
                        this.baseHasAccentOver = !!core.node.attributes.get('accent');
                    }
                    if (this.baseHasAccentUnder === null) {
                        this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');
                    }
                }
            }
            getSemanticBase() {
                const fence = this.node.attributes.getExplicit('data-semantic-fencepointer');
                return this.getBaseFence(this.baseChild, fence);
            }
            getBaseFence(fence, id) {
                if (!fence || !fence.node.attributes || !id) {
                    return null;
                }
                if (fence.node.attributes.getExplicit('data-semantic-id') === id) {
                    return fence;
                }
                for (const child of fence.childNodes) {
                    const result = this.getBaseFence(child, id);
                    if (result) {
                        return result;
                    }
                }
                return null;
            }
            getBaseScale() {
                let child = this.baseCore;
                let scale = 1;
                while (child && child !== this) {
                    const bbox = child.getOuterBBox();
                    scale *= bbox.rscale;
                    child = child.parent;
                }
                return scale;
            }
            getBaseIc() {
                return this.baseCore.getOuterBBox().ic * this.baseScale;
            }
            getAdjustedIc() {
                return this.baseIc ? 1.05 * this.baseIc + 0.05 : 0;
            }
            isCharBase() {
                const base = this.baseCore;
                return (((base.node.isKind('mo') && base.size === null) ||
                    base.node.isKind('mi') ||
                    base.node.isKind('mn')) &&
                    base.bbox.rscale === 1 &&
                    Array.from(base.getText()).length === 1);
            }
            checkLineAccents() {
                if (!this.node.isKind('munderover'))
                    return;
                if (this.node.isKind('mover')) {
                    this.isLineAbove = this.isLineAccent(this.scriptChild);
                }
                else if (this.node.isKind('munder')) {
                    this.isLineBelow = this.isLineAccent(this.scriptChild);
                }
                else {
                    const mml = this;
                    this.isLineAbove = this.isLineAccent(mml.overChild);
                    this.isLineBelow = this.isLineAccent(mml.underChild);
                }
            }
            isLineAccent(script) {
                const node = script.coreMO().node;
                return node.isToken && node.getText() === '\u2015';
            }
            getBaseWidth() {
                const bbox = this.baseChild.getLineBBox(this.baseChild.breakCount);
                return (bbox.w * bbox.rscale -
                    (this.baseRemoveIc ? this.baseIc : 0) +
                    this.font.params.extra_ic);
            }
            getOffset() {
                return [0, 0];
            }
            baseCharZero(n) {
                const largeop = !!this.baseCore.node.attributes.get('largeop');
                const sized = !!(this.baseCore.node.isKind('mo') &&
                    this.baseCore.size);
                const scale = this.baseScale;
                return this.baseIsChar && !largeop && !sized && scale === 1 ? 0 : n;
            }
            getV() {
                const base = this.baseCore;
                const bbox = base.getLineBBox(base.breakCount);
                const sbox = this.scriptChild.getOuterBBox();
                const tex = this.font.params;
                const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);
                return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - (4 / 5) * tex.x_height);
            }
            getU() {
                const base = this.baseCore;
                const bbox = base.getLineBBox(base.breakCount);
                const sbox = this.scriptChild.getOuterBBox();
                const tex = this.font.params;
                const attr = this.node.attributes.getList('displaystyle', 'superscriptshift');
                const prime = this.node.getProperty('texprimestyle');
                const p = prime ? tex.sup3 : attr.displaystyle ? tex.sup1 : tex.sup2;
                const superscriptshift = this.length2em(attr.superscriptshift, p);
                return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + (1 / 4) * tex.x_height);
            }
            hasMovableLimits() {
                const display = this.node.attributes.get('displaystyle');
                const mo = this.baseChild.coreMO().node;
                return !display && !!mo.attributes.get('movablelimits');
            }
            getOverKU(basebox, overbox) {
                const accent = this.node.attributes.get('accent');
                const tex = this.font.params;
                const d = overbox.d * overbox.rscale;
                const t = tex.rule_thickness * tex.separation_factor;
                const delta = this.baseHasAccentOver ? t : 0;
                const T = this.isLineAbove ? 3 * tex.rule_thickness : t;
                const k = (accent
                    ? T
                    : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;
                return [k, basebox.h * basebox.rscale + k + d];
            }
            getUnderKV(basebox, underbox) {
                const accent = this.node.attributes.get('accentunder');
                const tex = this.font.params;
                const h = underbox.h * underbox.rscale;
                const t = tex.rule_thickness * tex.separation_factor;
                const delta = this.baseHasAccentUnder ? t : 0;
                const T = this.isLineBelow ? 3 * tex.rule_thickness : t;
                const k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) -
                    delta;
                return [k, -(basebox.d * basebox.rscale + k + h)];
            }
            getDeltaW(boxes, delta = [0, 0, 0]) {
                const align = this.node.attributes.get('align');
                const widths = boxes.map((box) => box.w * box.rscale);
                widths[0] -=
                    this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop')
                        ? this.baseIc
                        : 0;
                const w = Math.max(...widths);
                const dw = [];
                let m = 0;
                for (const i of widths.keys()) {
                    dw[i] =
                        (align === 'center'
                            ? (w - widths[i]) / 2
                            : align === 'right'
                                ? w - widths[i]
                                : 0) + delta[i];
                    if (dw[i] < m) {
                        m = -dw[i];
                    }
                }
                if (m) {
                    for (const i of dw.keys()) {
                        dw[i] += m;
                    }
                }
                [1, 2].map((i) => (dw[i] += boxes[i] ? boxes[i].dx * boxes[0].rscale : 0));
                return dw;
            }
            getDelta(script, noskew = false) {
                const accent = this.node.attributes.get('accent');
                let { sk, ic } = this.baseCore.getOuterBBox();
                if (accent) {
                    sk -= script.getOuterBBox().sk;
                }
                return (((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) *
                    this.baseScale);
            }
            stretchChildren() {
                const stretchy = [];
                for (const child of this.childNodes) {
                    if (child.canStretch(DIRECTION.Horizontal)) {
                        stretchy.push(child);
                    }
                }
                const count = stretchy.length;
                const nodeCount = this.childNodes.length;
                if (count && nodeCount > 1) {
                    let W = 0;
                    const all = count > 1 && count === nodeCount;
                    for (const child of this.childNodes) {
                        const noStretch = child.stretch.dir === DIRECTION.None;
                        if (all || noStretch) {
                            const { w, rscale } = child.getOuterBBox(noStretch);
                            if (w * rscale > W)
                                W = w * rscale;
                        }
                    }
                    for (const child of stretchy) {
                        const core = child.coreMO();
                        if (core.size === null) {
                            core.getStretchedVariant([W / child.coreRScale()]);
                        }
                    }
                }
            }
            constructor(factory, node, parent = null) {
                super(factory, node, parent);
                this.baseScale = 1;
                this.baseIc = 0;
                this.baseRemoveIc = false;
                this.baseIsChar = false;
                this.baseHasAccentOver = null;
                this.baseHasAccentUnder = null;
                this.isLineAbove = false;
                this.isLineBelow = false;
                this.isMathAccent = false;
                const core = (this.baseCore = this.getBaseCore());
                if (!core)
                    return;
                this.setBaseAccentsFor(core);
                this.baseScale = this.getBaseScale();
                this.baseIc = this.getBaseIc();
                this.baseIsChar = this.isCharBase();
                this.isMathAccent =
                    this.baseIsChar &&
                        this.scriptChild &&
                        this.scriptChild.coreMO().node.getProperty('mathaccent') !== undefined;
                this.checkLineAccents();
                this.baseRemoveIc =
                    !this.isLineAbove &&
                        !this.isLineBelow &&
                        (!(this.constructor
                            .useIC) ||
                            this.isMathAccent);
            }
            computeBBox(bbox, recompute = false) {
                bbox.empty();
                bbox.append(this.baseChild.getOuterBBox());
                this.appendScripts(bbox);
                bbox.clean();
                this.setChildPWidths(recompute);
            }
            appendScripts(bbox) {
                const w = this.getBaseWidth();
                const [x, y] = this.getOffset();
                bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);
                bbox.w += this.font.params.scriptspace;
                return bbox;
            }
            get breakCount() {
                if (this._breakCount < 0) {
                    this._breakCount = this.node.isEmbellished
                        ? this.coreMO().embellishedBreakCount
                        : !this.node.linebreakContainer
                            ? this.childNodes[0].breakCount
                            : 0;
                }
                return this._breakCount;
            }
            breakTop(mrow, child) {
                return this.node.linebreakContainer ||
                    !this.parent ||
                    this.node.childIndex(child.node)
                    ? mrow
                    : this.parent.breakTop(mrow, this);
            }
            computeLineBBox(i) {
                const n = this.breakCount;
                if (!n)
                    return LineBBox.from(this.getOuterBBox(), this.linebreakOptions.lineleading);
                const bbox = this.baseChild.getLineBBox(i).copy();
                if (i < n) {
                    if (i === 0) {
                        this.addLeftBorders(bbox);
                    }
                    this.addMiddleBorders(bbox);
                }
                else {
                    this.appendScripts(bbox);
                    this.addMiddleBorders(bbox);
                    this.addRightBorders(bbox);
                }
                return bbox;
            }
        },
        _a.useIC = true,
        _a;
}
//# sourceMappingURL=scriptbase.js.map
;// ./mjs/output/chtml/Wrappers/scriptbase.js



const ChtmlScriptbase = (function () {
    var _a;
    const Base = CommonScriptbaseMixin(ChtmlWrapper);
    return _a = class ChtmlScriptbase extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                this.dom = this.standardChtmlNodes(parents);
                const [x, v] = this.getOffset();
                const dx = x - (this.baseRemoveIc ? this.baseIc : 0);
                const style = { 'vertical-align': this.em(v) };
                if (dx) {
                    style['margin-left'] = this.em(dx);
                }
                this.baseChild.toCHTML(this.dom);
                const dom = this.dom[this.dom.length - 1];
                this.scriptChild.toCHTML([
                    this.adaptor.append(dom, this.html('mjx-script', { style })),
                ]);
            }
            markUsed() {
                super.markUsed();
                this.jax.wrapperUsage.add(ChtmlMsubsup.kind);
            }
            setDeltaW(nodes, dx) {
                for (let i = 0; i < dx.length; i++) {
                    if (dx[i]) {
                        this.adaptor.setStyle(nodes[i], 'paddingLeft', this.em(dx[i]));
                    }
                }
            }
            adjustOverDepth(over, overbox) {
                if (overbox.d >= 0)
                    return;
                this.adaptor.setStyle(over, 'marginBottom', this.em(overbox.d * overbox.rscale));
            }
            adjustUnderDepth(under, underbox) {
                if (underbox.d >= 0)
                    return;
                const adaptor = this.adaptor;
                const v = this.em(underbox.d);
                const box = this.html('mjx-box', {
                    style: { 'margin-bottom': v, 'vertical-align': v },
                });
                for (const child of adaptor.childNodes(adaptor.firstChild(under))) {
                    adaptor.append(box, child);
                }
                adaptor.append(adaptor.firstChild(under), box);
            }
            adjustBaseHeight(base, basebox) {
                if (this.node.attributes.get('accent')) {
                    const minH = this.font.params.x_height * this.baseScale;
                    if (basebox.h < minH) {
                        this.adaptor.setStyle(base, 'paddingTop', this.em(minH - basebox.h));
                        basebox.h = minH;
                    }
                }
            }
        },
        _a.kind = 'scriptbase',
        _a;
})();
//# sourceMappingURL=scriptbase.js.map
;// ./mjs/output/chtml/Wrappers/msubsup.js



const ChtmlMsub = (function () {
    var _a;
    const Base = CommonMsubMixin(ChtmlScriptbase);
    return _a = class ChtmlMsub extends Base {
        },
        _a.kind = MmlMsub.prototype.kind,
        _a;
})();
const ChtmlMsup = (function () {
    var _a;
    const Base = CommonMsupMixin(ChtmlScriptbase);
    return _a = class ChtmlMsup extends Base {
        },
        _a.kind = MmlMsup.prototype.kind,
        _a;
})();
const ChtmlMsubsup = (function () {
    var _a;
    const Base = CommonMsubsupMixin(ChtmlScriptbase);
    return _a = class ChtmlMsubsup extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const adaptor = this.adaptor;
                const chtml = this.standardChtmlNodes(parents);
                const [base, sup, sub] = [this.baseChild, this.supChild, this.subChild];
                const [, v, q] = this.getUVQ();
                const style = { 'vertical-align': this.em(v) };
                base.toCHTML(chtml);
                const stack = adaptor.append(chtml[chtml.length - 1], this.html('mjx-script', { style }));
                sup.toCHTML([stack]);
                adaptor.append(stack, this.html('mjx-spacer', { style: { 'margin-top': this.em(q) } }));
                sub.toCHTML([stack]);
                const ic = this.getAdjustedIc();
                if (ic) {
                    adaptor.setStyle(sup.dom[0], 'marginLeft', this.em(ic / sup.bbox.rscale));
                    if (!this.baseIsChar) {
                        adaptor.setStyle(sub.dom[0], 'marginLeft', this.em(ic / sup.bbox.rscale));
                    }
                }
                if (this.baseRemoveIc) {
                    adaptor.setStyle(stack, 'marginLeft', this.em(-this.baseIc));
                }
            }
        },
        _a.kind = MmlMsubsup.prototype.kind,
        _a.styles = {
            'mjx-script': {
                display: 'inline-block',
                'padding-right': '.05em',
                'padding-left': '.033em',
            },
            'mjx-script > mjx-spacer': {
                display: 'block',
            },
        },
        _a;
})();
//# sourceMappingURL=msubsup.js.map
;// ./mjs/output/common/Wrappers/munderover.js
function CommonMunderMixin(Base) {
    return class CommonMunderMixin extends Base {
        get scriptChild() {
            return this.childNodes[this.node.under];
        }
        constructor(...args) {
            super(...args);
            this.stretchChildren();
        }
        computeBBox(bbox, recompute = false) {
            if (this.hasMovableLimits()) {
                super.computeBBox(bbox, recompute);
                return;
            }
            bbox.empty();
            const basebox = this.baseChild.getOuterBBox();
            const underbox = this.scriptChild.getOuterBBox();
            const v = this.getUnderKV(basebox, underbox)[1];
            const delta = this.isLineBelow
                ? 0
                : this.getDelta(this.scriptChild, true);
            const [bw, uw] = this.getDeltaW([basebox, underbox], [0, -delta]);
            bbox.combine(basebox, bw, 0);
            bbox.combine(underbox, uw, v);
            bbox.d += this.font.params.big_op_spacing5;
            bbox.clean();
            this.setChildPWidths(recompute);
        }
    };
}
function CommonMoverMixin(Base) {
    return class CommonMoverMixin extends Base {
        get scriptChild() {
            return this.childNodes[this.node.over];
        }
        constructor(...args) {
            super(...args);
            this.stretchChildren();
        }
        computeBBox(bbox) {
            if (this.hasMovableLimits()) {
                super.computeBBox(bbox);
                return;
            }
            bbox.empty();
            const basebox = this.baseChild.getOuterBBox();
            const overbox = this.scriptChild.getOuterBBox();
            if (this.node.attributes.get('accent')) {
                basebox.h = Math.max(basebox.h, this.font.params.x_height * this.baseScale);
            }
            const u = this.getOverKU(basebox, overbox)[1];
            const delta = this.isLineAbove ? 0 : this.getDelta(this.scriptChild);
            const [bw, ow] = this.getDeltaW([basebox, overbox], [0, delta]);
            bbox.combine(basebox, bw, 0);
            bbox.combine(overbox, ow, u);
            bbox.h += this.font.params.big_op_spacing5;
            bbox.clean();
        }
    };
}
function CommonMunderoverMixin(Base) {
    return class CommonMunderoverMixin extends Base {
        get underChild() {
            return this.childNodes[this.node.under];
        }
        get overChild() {
            return this.childNodes[this.node.over];
        }
        get subChild() {
            return this.underChild;
        }
        get supChild() {
            return this.overChild;
        }
        constructor(...args) {
            super(...args);
            this.stretchChildren();
        }
        computeBBox(bbox) {
            if (this.hasMovableLimits()) {
                super.computeBBox(bbox);
                return;
            }
            bbox.empty();
            const overbox = this.overChild.getOuterBBox();
            const basebox = this.baseChild.getOuterBBox();
            const underbox = this.underChild.getOuterBBox();
            if (this.node.attributes.get('accent')) {
                basebox.h = Math.max(basebox.h, this.font.params.x_height * this.baseScale);
            }
            const u = this.getOverKU(basebox, overbox)[1];
            const v = this.getUnderKV(basebox, underbox)[1];
            const odelta = this.getDelta(this.overChild);
            const udelta = this.getDelta(this.underChild, true);
            const [bw, uw, ow] = this.getDeltaW([basebox, underbox, overbox], [0, this.isLineBelow ? 0 : -udelta, this.isLineAbove ? 0 : odelta]);
            bbox.combine(basebox, bw, 0);
            bbox.combine(overbox, ow, u);
            bbox.combine(underbox, uw, v);
            const z = this.font.params.big_op_spacing5;
            bbox.h += z;
            bbox.d += z;
            bbox.clean();
        }
    };
}
//# sourceMappingURL=munderover.js.map
;// ./mjs/output/chtml/Wrappers/munderover.js



const ChtmlMunder = (function () {
    var _a;
    const Base = CommonMunderMixin(ChtmlMsub);
    return _a = class ChtmlMunder extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                if (this.hasMovableLimits()) {
                    super.toCHTML(parents);
                    this.adaptor.setAttribute(this.dom[0], 'limits', 'false');
                    return;
                }
                this.dom = this.standardChtmlNodes(parents);
                const base = this.adaptor.append(this.adaptor.append(this.dom[0], this.html('mjx-row')), this.html('mjx-base'));
                const under = this.adaptor.append(this.adaptor.append(this.dom[0], this.html('mjx-row')), this.html('mjx-under'));
                this.baseChild.toCHTML([base]);
                this.scriptChild.toCHTML([under]);
                const basebox = this.baseChild.getOuterBBox();
                const underbox = this.scriptChild.getOuterBBox();
                const k = this.getUnderKV(basebox, underbox)[0];
                const delta = this.isLineBelow
                    ? 0
                    : this.getDelta(this.scriptChild, true);
                this.adaptor.setStyle(under, 'paddingTop', this.em(k));
                this.setDeltaW([base, under], this.getDeltaW([basebox, underbox], [0, -delta]));
                this.adjustUnderDepth(under, underbox);
            }
        },
        _a.kind = MmlMunder.prototype.kind,
        _a.styles = {
            'mjx-over': {
                'text-align': 'left',
            },
            'mjx-munder:not([limits="false"])': {
                display: 'inline-table',
            },
            'mjx-munder > mjx-row': {
                'text-align': 'left',
            },
            'mjx-under': {
                'padding-bottom': '.1em',
            },
        },
        _a;
})();
const ChtmlMover = (function () {
    var _a;
    const Base = CommonMoverMixin(ChtmlMsup);
    return _a = class ChtmlMover extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                if (this.hasMovableLimits()) {
                    super.toCHTML(parents);
                    this.adaptor.setAttribute(this.dom[0], 'limits', 'false');
                    return;
                }
                this.dom = this.standardChtmlNodes(parents);
                const over = this.adaptor.append(this.dom[0], this.html('mjx-over'));
                const base = this.adaptor.append(this.dom[0], this.html('mjx-base'));
                this.scriptChild.toCHTML([over]);
                this.baseChild.toCHTML([base]);
                const overbox = this.scriptChild.getOuterBBox();
                const basebox = this.baseChild.getOuterBBox();
                this.adjustBaseHeight(base, basebox);
                const k = this.getOverKU(basebox, overbox)[0];
                const delta = this.isLineAbove ? 0 : this.getDelta(this.scriptChild);
                this.adaptor.setStyle(over, 'paddingBottom', this.em(k));
                this.setDeltaW([base, over], this.getDeltaW([basebox, overbox], [0, delta]));
                this.adjustOverDepth(over, overbox);
            }
        },
        _a.kind = MmlMover.prototype.kind,
        _a.styles = {
            'mjx-mover:not([limits="false"])': {
                'padding-top': '.1em',
            },
            'mjx-mover:not([limits="false"]) > *': {
                display: 'block',
                'text-align': 'left',
            },
        },
        _a;
})();
const ChtmlMunderover = (function () {
    var _a;
    const Base = CommonMunderoverMixin(ChtmlMsubsup);
    return _a = class ChtmlMunderover extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                if (this.hasMovableLimits()) {
                    super.toCHTML(parents);
                    this.adaptor.setAttribute(this.dom[0], 'limits', 'false');
                    return;
                }
                this.dom = this.standardChtmlNodes(parents);
                const over = this.adaptor.append(this.dom[0], this.html('mjx-over'));
                const table = this.adaptor.append(this.adaptor.append(this.dom[0], this.html('mjx-box')), this.html('mjx-munder'));
                const base = this.adaptor.append(this.adaptor.append(table, this.html('mjx-row')), this.html('mjx-base'));
                const under = this.adaptor.append(this.adaptor.append(table, this.html('mjx-row')), this.html('mjx-under'));
                this.overChild.toCHTML([over]);
                this.baseChild.toCHTML([base]);
                this.underChild.toCHTML([under]);
                const overbox = this.overChild.getOuterBBox();
                const basebox = this.baseChild.getOuterBBox();
                const underbox = this.underChild.getOuterBBox();
                this.adjustBaseHeight(base, basebox);
                const ok = this.getOverKU(basebox, overbox)[0];
                const uk = this.getUnderKV(basebox, underbox)[0];
                const odelta = this.getDelta(this.overChild);
                const udelta = this.getDelta(this.underChild, true);
                this.adaptor.setStyle(over, 'paddingBottom', this.em(ok));
                this.adaptor.setStyle(under, 'paddingTop', this.em(uk));
                this.setDeltaW([base, under, over], this.getDeltaW([basebox, underbox, overbox], [0, this.isLineBelow ? 0 : -udelta, this.isLineAbove ? 0 : odelta]));
                this.adjustOverDepth(over, overbox);
                this.adjustUnderDepth(under, underbox);
            }
        },
        _a.kind = MmlMunderover.prototype.kind,
        _a.styles = {
            'mjx-munderover:not([limits="false"])': {
                'padding-top': '.1em',
            },
            'mjx-munderover:not([limits="false"]) > *': {
                display: 'block',
            },
        },
        _a;
})();
//# sourceMappingURL=munderover.js.map
;// ./mjs/output/common/Wrappers/mmultiscripts.js


const NextScript = {
    base: 'subList',
    subList: 'supList',
    supList: 'subList',
    psubList: 'psupList',
    psupList: 'psubList',
};
const ScriptNames = ['sup', 'sup', 'psup', 'psub'];
function CommonMmultiscriptsMixin(Base) {
    return class CommonMmultiscriptsMixin extends Base {
        combinePrePost(pre, post) {
            const bbox = new BBox(pre);
            bbox.combine(post, 0, 0);
            return bbox;
        }
        getScriptData() {
            const data = (this.scriptData = {
                base: null,
                sub: BBox.empty(),
                sup: BBox.empty(),
                psub: BBox.empty(),
                psup: BBox.empty(),
                numPrescripts: 0,
                numScripts: 0,
            });
            const lists = this.getScriptBBoxLists();
            this.combineBBoxLists(data.sub, data.sup, lists.subList, lists.supList);
            this.combineBBoxLists(data.psub, data.psup, lists.psubList, lists.psupList);
            data.base = lists.base[0];
            data.numPrescripts = lists.psubList.length;
            data.numScripts = lists.subList.length;
        }
        getScriptBBoxLists() {
            const lists = {
                base: [],
                subList: [],
                supList: [],
                psubList: [],
                psupList: [],
            };
            let script = 'base';
            for (const child of this.childNodes) {
                if (child.node.isKind('mprescripts')) {
                    script = 'psubList';
                }
                else {
                    lists[script].push(child.getOuterBBox());
                    script = NextScript[script];
                }
            }
            this.firstPrescript = lists.subList.length + lists.supList.length + 2;
            this.padLists(lists.subList, lists.supList);
            this.padLists(lists.psubList, lists.psupList);
            return lists;
        }
        padLists(list1, list2) {
            if (list1.length > list2.length) {
                list2.push(BBox.empty());
            }
        }
        combineBBoxLists(bbox1, bbox2, list1, list2) {
            for (let i = 0; i < list1.length; i++) {
                const [w1, h1, d1] = this.getScaledWHD(list1[i]);
                const [w2, h2, d2] = this.getScaledWHD(list2[i]);
                const w = Math.max(w1, w2);
                bbox1.w += w;
                bbox2.w += w;
                if (h1 > bbox1.h)
                    bbox1.h = h1;
                if (d1 > bbox1.d)
                    bbox1.d = d1;
                if (h2 > bbox2.h)
                    bbox2.h = h2;
                if (d2 > bbox2.d)
                    bbox2.d = d2;
            }
        }
        getScaledWHD(bbox) {
            const { w, h, d, rscale } = bbox;
            return [w * rscale, h * rscale, d * rscale];
        }
        getCombinedUV() {
            const data = this.scriptData;
            const sub = this.combinePrePost(data.sub, data.psub);
            const sup = this.combinePrePost(data.sup, data.psup);
            return this.getUVQ(sub, sup);
        }
        addPrescripts(bbox, u, v) {
            const data = this.scriptData;
            if (data.numPrescripts) {
                const scriptspace = this.font.params.scriptspace;
                bbox.combine(data.psup, scriptspace, u);
                bbox.combine(data.psub, scriptspace, v);
            }
            return bbox;
        }
        addPostscripts(bbox, u, v) {
            const data = this.scriptData;
            if (data.numScripts) {
                const x = bbox.w;
                bbox.combine(data.sup, x, u);
                bbox.combine(data.sub, x, v);
                bbox.w += this.font.params.scriptspace;
            }
            return bbox;
        }
        constructor(...args) {
            super(...args);
            this.scriptData = null;
            this.firstPrescript = 0;
            this.getScriptData();
        }
        appendScripts(bbox) {
            bbox.empty();
            const [u, v] = this.getCombinedUV();
            this.addPrescripts(bbox, u, v);
            bbox.append(this.scriptData.base);
            this.addPostscripts(bbox, u, v);
            bbox.clean();
            return bbox;
        }
        computeLineBBox(i) {
            const n = this.baseChild.breakCount;
            const cbox = this.baseChild.getLineBBox(i).copy();
            let bbox = cbox;
            const [u, v] = this.getCombinedUV();
            if (i === 0) {
                bbox = LineBBox.from(this.addPrescripts(BBox.zero(), u, v), this.linebreakOptions.lineleading);
                bbox.append(cbox);
                this.addLeftBorders(bbox);
                bbox.L = this.bbox.L;
            }
            else if (i === n) {
                bbox = this.addPostscripts(bbox, u, v);
                this.addRightBorders(bbox);
                bbox.R = this.bbox.R;
            }
            this.addMiddleBorders(bbox);
            return bbox;
        }
        getUVQ(subbox, supbox) {
            if (!this.UVQ) {
                let [u, v, q] = [0, 0, 0];
                if (subbox.w === 0) {
                    u = this.getU();
                }
                else if (supbox.w === 0) {
                    u = -this.getV();
                }
                else {
                    [u, v, q] = super.getUVQ(subbox, supbox);
                }
                this.UVQ = [u, v, q];
            }
            return this.UVQ;
        }
    };
}
//# sourceMappingURL=mmultiscripts.js.map
;// ./mjs/output/chtml/Wrappers/mmultiscripts.js




const ChtmlMmultiscripts = (function () {
    var _a;
    const Base = CommonMmultiscriptsMixin(ChtmlMsubsup);
    return _a = class ChtmlMmultiscripts extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const chtml = this.standardChtmlNodes(parents);
                const data = this.scriptData;
                const scriptalign = this.node.getProperty('scriptalign') || 'right left';
                const [preAlign, postAlign] = split(scriptalign + ' ' + scriptalign);
                const [u, v] = this.getCombinedUV();
                if (data.numPrescripts) {
                    const scripts = this.addScripts(this.dom[0], u, -v, true, data.psub, data.psup, this.firstPrescript, data.numPrescripts);
                    if (preAlign !== 'right') {
                        this.adaptor.setAttribute(scripts, 'script-align', preAlign);
                    }
                }
                this.childNodes[0].toCHTML(chtml);
                if (data.numScripts) {
                    const scripts = this.addScripts(this.dom[this.dom.length - 1], u, -v, false, data.sub, data.sup, 1, data.numScripts);
                    if (postAlign !== 'left') {
                        this.adaptor.setAttribute(scripts, 'script-align', postAlign);
                    }
                }
            }
            addScripts(dom, u, v, isPre, sub, sup, i, n) {
                const adaptor = this.adaptor;
                const q = u - sup.d + (v - sub.h);
                const U = u < 0 && v === 0 ? sub.h + u : u;
                const rowdef = q > 0 ? { style: { height: this.em(q) } } : {};
                const tabledef = U ? { style: { 'vertical-align': this.em(U) } } : {};
                const supRow = this.html('mjx-row');
                const sepRow = this.html('mjx-row', rowdef);
                const subRow = this.html('mjx-row');
                const name = 'mjx-' + (isPre ? 'pre' : '') + 'scripts';
                const m = i + 2 * n;
                while (i < m) {
                    this.childNodes[i++].toCHTML([
                        adaptor.append(subRow, this.html('mjx-cell')),
                    ]);
                    this.childNodes[i++].toCHTML([
                        adaptor.append(supRow, this.html('mjx-cell')),
                    ]);
                }
                return adaptor.append(dom, this.html(name, tabledef, [supRow, sepRow, subRow]));
            }
        },
        _a.kind = MmlMmultiscripts.prototype.kind,
        _a.styles = {
            'mjx-prescripts': {
                display: 'inline-table',
                'padding-left': '.05em',
            },
            'mjx-scripts': {
                display: 'inline-table',
                'padding-right': '.05em',
            },
            'mjx-prescripts > mjx-row > mjx-cell': {
                'text-align': 'right',
            },
            '[script-align="left"] > mjx-row > mjx-cell': {
                'text-align': 'left',
            },
            '[script-align="center"] > mjx-row > mjx-cell': {
                'text-align': 'center',
            },
            '[script-align="right"] > mjx-row > mjx-cell': {
                'text-align': 'right',
            },
            'mjx-none': {
                display: 'inline-block',
                height: '1px',
            },
        },
        _a;
})();
//# sourceMappingURL=mmultiscripts.js.map
;// ./mjs/output/common/Wrappers/mtable.js





const BREAK_BELOW = 0.333;
function CommonMtableMixin(Base) {
    return class CommonMtableMixin extends Base {
        get tableRows() {
            return this.childNodes;
        }
        findContainer() {
            let node = this;
            let parent = node.parent;
            while (parent && (parent.node.notParent || parent.node.isKind('mrow'))) {
                node = parent;
                parent = parent.parent;
            }
            this.container = parent;
            this.containerI = node.node.childPosition();
        }
        getPercentageWidth() {
            if (this.hasLabels) {
                this.bbox.pwidth = BBox.fullWidth;
            }
            else {
                const width = this.node.attributes.get('width');
                if (isPercent(width)) {
                    this.bbox.pwidth = width;
                }
            }
        }
        stretchRows() {
            const equal = this.node.attributes.get('equalrows');
            const HD = equal ? this.getEqualRowHeight() : 0;
            const { H, D } = equal ? this.getTableData() : { H: [0], D: [0] };
            const rows = this.tableRows;
            for (let i = 0; i < this.numRows; i++) {
                const hd = equal
                    ? [(HD + H[i] - D[i]) / 2, (HD - H[i] + D[i]) / 2]
                    : null;
                rows[i].stretchChildren(hd);
            }
        }
        stretchColumns() {
            const swidths = this.getColumnAttributes('columnwidth', 0);
            for (let i = 0; i < this.numCols; i++) {
                const width = typeof this.cWidths[i] === 'number'
                    ? this.cWidths[i]
                    : null;
                this.stretchColumn(i, width);
                if (width !== null) {
                    this.breakColumn(i, width, swidths[i]);
                }
            }
        }
        stretchColumn(i, W) {
            const stretchy = [];
            for (const row of this.tableRows) {
                const cell = row.getChild(i);
                if (cell) {
                    const child = cell.childNodes[0];
                    if (child.stretch.dir === DIRECTION.None &&
                        child.canStretch(DIRECTION.Horizontal)) {
                        stretchy.push(child);
                    }
                }
            }
            const count = stretchy.length;
            const nodeCount = this.childNodes.length;
            if (count && nodeCount > 1 && W === null) {
                W = 0;
                const all = count > 1 && count === nodeCount;
                for (const row of this.tableRows) {
                    const cell = row.getChild(i);
                    if (cell) {
                        const child = cell.childNodes[0];
                        const noStretch = child.stretch.dir === DIRECTION.None;
                        if (all || noStretch) {
                            const { w } = child.getBBox(noStretch);
                            if (w > W) {
                                W = w;
                            }
                        }
                    }
                }
            }
            if (W !== null) {
                for (const child of stretchy) {
                    child
                        .coreMO()
                        .getStretchedVariant([
                        Math.max(W, child.getBBox().w) / child.coreRScale(),
                    ]);
                }
            }
        }
        breakColumn(i, W, type) {
            if (this.jax.math.root.attributes.get('overflow') !== 'linebreak' ||
                !this.jax.math.display)
                return;
            const { D } = this.getTableData();
            let j = 0;
            let w = 0;
            for (const row of this.tableRows) {
                const cell = row.getChild(i);
                if (cell && cell.getBBox().w > W) {
                    cell.childNodes[0].breakToWidth(W);
                    const bbox = cell.getBBox();
                    D[j] = Math.max(D[j], bbox.d);
                    if (bbox.w > w) {
                        w = bbox.w;
                    }
                }
                j++;
            }
            if (type === 'fit' ||
                type === 'auto' ||
                isPercent(type) ||
                w > this.cWidths[i]) {
                this.cWidths[i] = w;
            }
        }
        getTableData() {
            if (this.data) {
                return this.data;
            }
            const H = new Array(this.numRows).fill(0);
            const D = new Array(this.numRows).fill(0);
            const W = new Array(this.numCols).fill(0);
            const NH = new Array(this.numRows);
            const ND = new Array(this.numRows);
            const LW = [0];
            const rows = this.tableRows;
            for (let j = 0; j < rows.length; j++) {
                let M = 0;
                const row = rows[j];
                const align = row.node.attributes.get('rowalign');
                for (let i = 0; i < row.numCells; i++) {
                    const cell = row.getChild(i);
                    M = this.updateHDW(cell, i, j, align, H, D, W, M);
                    this.recordPWidthCell(cell, i);
                }
                NH[j] = H[j];
                ND[j] = D[j];
                if (row.labeled) {
                    M = this.updateHDW(row.childNodes[0], 0, j, align, H, D, LW, M);
                }
                this.extendHD(j, H, D, M);
                this.extendHD(j, NH, ND, M);
            }
            const L = LW[0];
            this.data = { H, D, W, NH, ND, L };
            return this.data;
        }
        updateHDW(cell, i, j, align, H, D, W, M) {
            let { h, d, w } = cell.getBBox();
            const scale = cell.parent.bbox.rscale;
            if (cell.parent.bbox.rscale !== 1) {
                h *= scale;
                d *= scale;
                w *= scale;
            }
            if (this.node.getProperty('useHeight')) {
                if (h < 0.75)
                    h = 0.75;
                if (d < 0.25)
                    d = 0.25;
            }
            let m = 0;
            align = cell.node.attributes.get('rowalign') || align;
            if (align !== 'baseline' && align !== 'axis') {
                m = h + d;
                h = d = 0;
            }
            if (h > H[j])
                H[j] = h;
            if (d > D[j])
                D[j] = d;
            if (m > M)
                M = m;
            if (W && w > W[i])
                W[i] = w;
            return M;
        }
        extendHD(i, H, D, M) {
            const d = (M - (H[i] + D[i])) / 2;
            if (d < 0.00001)
                return;
            H[i] += d;
            D[i] += d;
        }
        recordPWidthCell(cell, i) {
            if (cell.childNodes[0] && cell.childNodes[0].getBBox().pwidth) {
                this.pwidthCells.push([cell, i]);
            }
        }
        setColumnPWidths() {
            const W = this.cWidths;
            for (const [cell, i] of this.pwidthCells) {
                if (cell.setChildPWidths(false, W[i])) {
                    cell.invalidateBBox();
                    cell.getBBox();
                }
            }
        }
        getBBoxHD(height) {
            const [align, row] = this.getAlignmentRow();
            if (row === null) {
                const a = this.font.params.axis_height;
                const h2 = height / 2;
                const HD = {
                    top: [0, height],
                    center: [h2, h2],
                    bottom: [height, 0],
                    baseline: [h2, h2],
                    axis: [h2 + a, h2 - a],
                };
                return HD[align] || [h2, h2];
            }
            else {
                const y = this.getVerticalPosition(row, align);
                return [y, height - y];
            }
        }
        getBBoxLR() {
            var _a;
            if (this.hasLabels) {
                const attributes = this.node.attributes;
                const side = attributes.get('side');
                let [pad, align] = this.getPadAlignShift(side);
                const labels = this.hasLabels && !!attributes.get('data-width-includes-label');
                if (labels && this.frame && this.fSpace[0]) {
                    pad -= this.fSpace[0];
                }
                return align === 'center' && !labels
                    ? [pad, pad]
                    : side === 'left'
                        ? [pad, 0]
                        : [0, pad];
            }
            return [((_a = this.bbox) === null || _a === void 0 ? void 0 : _a.L) || 0, 0];
        }
        getPadAlignShift(side) {
            const { L } = this.getTableData();
            const sep = this.length2em(this.node.attributes.get('minlabelspacing'));
            let pad = L + sep;
            const [lpad, rpad] = this.styles == null
                ? ['', '']
                : [this.styles.get('padding-left'), this.styles.get('padding-right')];
            if (lpad || rpad) {
                pad = Math.max(pad, this.length2em(lpad || '0'), this.length2em(rpad || '0'));
            }
            let [align, shift] = this.getAlignShift();
            if (align === side) {
                shift =
                    side === 'left'
                        ? Math.max(pad, shift) - pad
                        : Math.min(-pad, shift) + pad;
            }
            return [pad, align, shift];
        }
        getWidth() {
            return this.pWidth || this.getBBox().w;
        }
        adjustWideTable() {
            const attributes = this.node.attributes;
            if (attributes.get('width') !== 'auto')
                return;
            const [pad, align] = this.getPadAlignShift(attributes.get('side'));
            const W = Math.max(this.containerWidth / 10, this.containerWidth - pad - (align === 'center' ? pad : 0));
            if (this.naturalWidth() > W) {
                this.adjustColumnWidths(W);
            }
        }
        naturalWidth() {
            const CW = this.getComputedWidths();
            return (sum(CW.concat(this.cLines, this.cSpace)) +
                2 * this.fLine +
                this.fSpace[0] +
                this.fSpace[2]);
        }
        getEqualRowHeight() {
            const { H, D } = this.getTableData();
            const HD = Array.from(H.keys()).map((i) => H[i] + D[i]);
            return Math.max(...HD);
        }
        getComputedWidths() {
            const W = this.getTableData().W;
            let CW = Array.from(W.keys()).map((i) => {
                return typeof this.cWidths[i] === 'number'
                    ? this.cWidths[i]
                    : W[i];
            });
            if (this.node.attributes.get('equalcolumns')) {
                CW = Array(CW.length).fill(max(CW));
            }
            return CW;
        }
        getColumnWidths() {
            const width = this.node.attributes.get('width');
            if (this.node.attributes.get('equalcolumns')) {
                return this.getEqualColumns(width);
            }
            const swidths = this.getColumnAttributes('columnwidth', 0);
            if (width === 'auto') {
                return this.getColumnWidthsAuto(swidths);
            }
            if (isPercent(width)) {
                return this.getColumnWidthsPercent(swidths);
            }
            return this.getColumnWidthsFixed(swidths, this.length2em(width));
        }
        getEqualColumns(width) {
            const n = Math.max(1, this.numCols);
            let cwidth;
            if (width === 'auto') {
                const { W } = this.getTableData();
                cwidth = max(W);
            }
            else if (isPercent(width)) {
                cwidth = this.percent(1 / n);
            }
            else {
                const w = sum([].concat(this.cLines, this.cSpace)) +
                    this.fSpace[0] +
                    this.fSpace[2];
                cwidth = Math.max(0, this.length2em(width) - w) / n;
            }
            return Array(this.numCols).fill(cwidth);
        }
        getColumnWidthsAuto(swidths) {
            return swidths.map((x) => {
                if (x === 'auto' || x === 'fit')
                    return null;
                if (isPercent(x))
                    return x;
                return this.length2em(x);
            });
        }
        getColumnWidthsPercent(swidths) {
            const hasFit = swidths.includes('fit');
            const { W } = hasFit ? this.getTableData() : { W: null };
            return Array.from(swidths.keys()).map((i) => {
                const x = swidths[i];
                if (x === 'fit')
                    return null;
                if (x === 'auto')
                    return hasFit ? W[i] : null;
                if (isPercent(x))
                    return x;
                return this.length2em(x);
            });
        }
        getColumnWidthsFixed(swidths, width) {
            const indices = Array.from(swidths.keys());
            const fit = indices.filter((i) => swidths[i] === 'fit');
            const auto = indices.filter((i) => swidths[i] === 'auto');
            const n = fit.length || auto.length;
            const { W } = n ? this.getTableData() : { W: null };
            const cwidth = width -
                sum([].concat(this.cLines, this.cSpace)) -
                this.fSpace[0] -
                this.fSpace[2];
            let dw = cwidth;
            indices.forEach((i) => {
                const x = swidths[i];
                dw -= x === 'fit' || x === 'auto' ? W[i] : this.length2em(x, cwidth);
            });
            const fw = n && dw > 0 ? dw / n : 0;
            return indices.map((i) => {
                const x = swidths[i];
                if (x === 'fit')
                    return W[i] + fw;
                if (x === 'auto')
                    return W[i] + (fit.length === 0 ? fw : 0);
                return this.length2em(x, cwidth);
            });
        }
        adjustColumnWidths(width) {
            const { W } = this.getTableData();
            const swidths = this.getColumnAttributes('columnwidth', 0);
            const indices = Array.from(swidths.keys());
            const fit = indices
                .filter((i) => swidths[i] === 'fit')
                .sort((a, b) => W[b] - W[a]);
            const auto = indices
                .filter((i) => swidths[i] === 'auto')
                .sort((a, b) => W[b] - W[a]);
            const percent = indices
                .filter((i) => isPercent(swidths[i]))
                .sort((a, b) => W[b] - W[a]);
            const fixed = indices
                .filter((i) => swidths[i] !== 'fit' &&
                swidths[i] !== 'auto' &&
                !isPercent(swidths[i]))
                .sort((a, b) => W[b] - W[a]);
            const columns = [...fit, ...auto, ...percent, ...fixed];
            if (!columns.length)
                return;
            this.cWidths = indices.map((i) => typeof this.cWidths[i] === 'number' ? this.cWidths[i] : W[i]);
            const cwidth = width -
                sum([].concat(this.cLines, this.cSpace)) -
                this.fSpace[0] -
                this.fSpace[2];
            let dw = sum(this.cWidths) - cwidth;
            let w = 0;
            let n = 0;
            while (n < columns.length) {
                w += W[columns[n++]];
                if (w && dw / w < BREAK_BELOW)
                    break;
            }
            dw = 1 - dw / w;
            columns.slice(0, n).forEach((i) => (this.cWidths[i] *= dw));
        }
        getVerticalPosition(i, align) {
            const equal = this.node.attributes.get('equalrows');
            const { H, D } = this.getTableData();
            const HD = equal ? this.getEqualRowHeight() : 0;
            const space = this.getRowHalfSpacing();
            let y = this.fLine;
            for (let j = 0; j < i; j++) {
                y +=
                    space[j] + (equal ? HD : H[j] + D[j]) + space[j + 1] + this.rLines[j];
            }
            const [h, d] = equal
                ? [(HD + H[i] - D[i]) / 2, (HD - H[i] + D[i]) / 2]
                : [H[i], D[i]];
            const offset = {
                top: 0,
                center: space[i] + (h + d) / 2,
                bottom: space[i] + h + d + space[i + 1],
                baseline: space[i] + h,
                axis: space[i] + h - 0.25,
            };
            y += offset[align] || 0;
            return y;
        }
        getFrameSpacing() {
            const fspace = this.fframe
                ? this.convertLengths(this.getAttributeArray('framespacing'))
                : [0, 0];
            fspace[2] = fspace[0];
            const padding = this.node.attributes.get('data-array-padding');
            if (padding) {
                const [L, R] = this.convertLengths(split(padding));
                fspace[0] = L;
                fspace[2] = R;
            }
            return fspace;
        }
        getEmHalfSpacing(fspace, space, scale = 1) {
            const spaceEm = this.addEm(space, 2 / scale);
            spaceEm.unshift(this.em(fspace[0] * scale));
            spaceEm.push(this.em(fspace[1] * scale));
            return spaceEm;
        }
        getRowHalfSpacing() {
            const space = this.rSpace.map((x) => x / 2);
            space.unshift(this.fSpace[1]);
            space.push(this.fSpace[1]);
            return space;
        }
        getColumnHalfSpacing() {
            const space = this.cSpace.map((x) => x / 2);
            space.unshift(this.fSpace[0]);
            space.push(this.fSpace[2]);
            return space;
        }
        getAlignmentRow() {
            const [align, row] = split(this.node.attributes.get('align'));
            if (row == null)
                return [align, null];
            let i = parseInt(row);
            if (i < 0)
                i += this.numRows + 1;
            return [align, i < 1 || i > this.numRows ? null : i - 1];
        }
        getColumnAttributes(name, i = 1) {
            const n = this.numCols - i;
            const columns = this.getAttributeArray(name);
            if (columns.length === 0)
                return null;
            while (columns.length < n) {
                columns.push(columns[columns.length - 1]);
            }
            if (columns.length > n) {
                columns.splice(n);
            }
            return columns;
        }
        getRowAttributes(name, i = 1) {
            const n = this.numRows - i;
            const rows = this.getAttributeArray(name);
            if (rows.length === 0)
                return null;
            while (rows.length < n) {
                rows.push(rows[rows.length - 1]);
            }
            if (rows.length > n) {
                rows.splice(n);
            }
            return rows;
        }
        getAttributeArray(name) {
            const value = this.node.attributes.get(name);
            if (!value)
                return [this.node.attributes.getDefault(name)];
            return split(value);
        }
        addEm(list, n = 1) {
            if (!list)
                return null;
            return list.map((x) => this.em(x / n));
        }
        convertLengths(list) {
            if (!list)
                return null;
            return list.map((x) => this.length2em(x));
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.numCols = 0;
            this.numRows = 0;
            this.data = null;
            this.pwidthCells = [];
            this.pWidth = 0;
            this.numCols = max(this.tableRows.map((row) => row.numCells));
            this.numRows = this.childNodes.length;
            this.hasLabels = this.childNodes.reduce((value, row) => value || row.node.isKind('mlabeledtr'), false);
            this.findContainer();
            this.isTop =
                !this.container ||
                    (this.container.node.isKind('math') && !this.container.parent);
            if (this.isTop) {
                this.jax.table = this;
            }
            this.getPercentageWidth();
            const attributes = this.node.attributes;
            const frame = attributes.get('frame');
            this.frame = frame !== 'none';
            this.fframe =
                this.frame || attributes.get('data-frame-styles') !== undefined;
            this.fLine = this.frame ? 0.07 : 0;
            this.fSpace = this.getFrameSpacing();
            this.cSpace = this.convertLengths(this.getColumnAttributes('columnspacing'));
            this.rSpace = this.convertLengths(this.getRowAttributes('rowspacing'));
            this.cLines = this.getColumnAttributes('columnlines').map((x) => x === 'none' ? 0 : 0.07);
            this.rLines = this.getRowAttributes('rowlines').map((x) => x === 'none' ? 0 : 0.07);
            this.cWidths = this.getColumnWidths();
            this.adjustWideTable();
            this.stretchColumns();
            this.stretchRows();
        }
        getStyles() {
            super.getStyles();
            const frame = this.node.attributes.get('data-frame-styles');
            if (!frame)
                return;
            if (!this.styles) {
                this.styles = new Styles('');
            }
            const fstyles = frame.split(/ /);
            for (const i of TRBL.keys()) {
                const style = fstyles[i];
                if (style === 'none')
                    continue;
                this.styles.set(`border-${TRBL[i]}`, `.07em ${style}`);
            }
        }
        computeBBox(bbox, _recompute = false) {
            const { H, D } = this.getTableData();
            let height, width;
            if (this.node.attributes.get('equalrows')) {
                const HD = this.getEqualRowHeight();
                height = sum([].concat(this.rLines, this.rSpace)) + HD * this.numRows;
            }
            else {
                height = sum(H.concat(D, this.rLines, this.rSpace));
            }
            height += 2 * (this.fLine + this.fSpace[1]);
            width = this.naturalWidth();
            const w = this.node.attributes.get('width');
            if (w !== 'auto') {
                width = Math.max(this.length2em(w, 0) + 2 * this.fLine, width);
            }
            const [h, d] = this.getBBoxHD(height);
            bbox.h = h;
            bbox.d = d;
            bbox.w = width;
            const [L, R] = this.getBBoxLR();
            bbox.L = L;
            bbox.R = R;
            if (!isPercent(w)) {
                this.setColumnPWidths();
            }
        }
        setChildPWidths(_recompute, cwidth, _clear) {
            const width = this.node.attributes.get('width');
            if (!isPercent(width))
                return false;
            if (!this.hasLabels) {
                this.bbox.pwidth = '';
                this.container.bbox.pwidth = '';
            }
            const { w, L, R } = this.bbox;
            const labelInWidth = this.node.attributes.get('data-width-includes-label');
            const W = Math.max(w, this.length2em(width, Math.max(cwidth, L + w + R))) -
                (labelInWidth ? L + R : 0);
            const cols = this.node.attributes.get('equalcolumns')
                ? Array(this.numCols).fill(this.percent(1 / Math.max(1, this.numCols)))
                : this.getColumnAttributes('columnwidth', 0);
            this.cWidths = this.getColumnWidthsFixed(cols, W);
            this.pWidth = this.naturalWidth();
            if (this.isTop) {
                this.bbox.w = this.pWidth;
            }
            this.setColumnPWidths();
            if (this.pWidth !== w) {
                this.parent.invalidateBBox();
            }
            return this.pWidth !== w;
        }
        getAlignShift() {
            return this.isTop
                ? super.getAlignShift()
                : [this.container.getChildAlign(this.containerI), 0];
        }
    };
}
//# sourceMappingURL=mtable.js.map
;// ./mjs/output/chtml/Wrappers/mtable.js




const ChtmlMtable = (function () {
    var _a;
    const Base = CommonMtableMixin(ChtmlWrapper);
    return _a = class ChtmlMtable extends Base {
            constructor(factory, node, parent = null) {
                super(factory, node, parent);
                this.itable = this.html('mjx-itable');
                this.labels = this.html('mjx-itable');
            }
            getAlignShift() {
                const data = super.getAlignShift();
                if (!this.isTop) {
                    data[1] = 0;
                }
                return data;
            }
            toCHTML(parents) {
                const chtml = this.standardChtmlNodes(parents);
                this.adaptor.append(chtml[0], this.html('mjx-table', {}, [this.itable]));
                for (const child of this.childNodes) {
                    child.toCHTML([this.itable]);
                }
                this.padRows();
                this.handleColumnSpacing();
                this.handleColumnLines();
                this.handleColumnWidths();
                this.handleRowSpacing();
                this.handleRowLines();
                this.handleRowHeights();
                this.handleFrame();
                this.handleWidth();
                this.handleLabels();
                this.handleAlign();
                this.handleJustify();
                this.shiftColor();
            }
            shiftColor() {
                const adaptor = this.adaptor;
                const color = adaptor.getStyle(this.dom[0], 'backgroundColor');
                if (color) {
                    adaptor.setStyle(this.dom[0], 'backgroundColor', '');
                    adaptor.setStyle(this.itable, 'backgroundColor', color);
                }
            }
            padRows() {
                const adaptor = this.adaptor;
                for (const row of adaptor.childNodes(this.itable)) {
                    while (adaptor.childNodes(row).length < this.numCols) {
                        adaptor.append(row, this.html('mjx-mtd', { extra: true }));
                    }
                }
            }
            handleColumnSpacing() {
                const scale = this.childNodes[0]
                    ? 1 / this.childNodes[0].getBBox().rscale
                    : 1;
                const spacing = this.getEmHalfSpacing([this.fSpace[0], this.fSpace[2]], this.cSpace, scale);
                for (const row of this.tableRows) {
                    let i = 0;
                    for (const cell of row.tableCells) {
                        const lspace = spacing[i++];
                        const rspace = spacing[i];
                        const styleNode = cell
                            ? cell.dom[0]
                            : this.adaptor.childNodes(row.dom[0])[i];
                        if ((i > 1 && lspace !== '0.4em') || (lspace !== '0' && i === 1)) {
                            this.adaptor.setStyle(styleNode, 'paddingLeft', lspace);
                        }
                        if ((i < this.numCols && rspace !== '0.4em') ||
                            (rspace !== '0' && i === this.numCols)) {
                            this.adaptor.setStyle(styleNode, 'paddingRight', rspace);
                        }
                    }
                }
            }
            handleColumnLines() {
                if (this.node.attributes.get('columnlines') === 'none')
                    return;
                const lines = this.getColumnAttributes('columnlines');
                for (const row of this.childNodes) {
                    let i = 0;
                    const cells = this.adaptor.childNodes(row.dom[0]).slice(1);
                    for (const cell of cells) {
                        const line = lines[i++];
                        if (line === 'none')
                            continue;
                        this.adaptor.setStyle(cell, 'borderLeft', '.07em ' + line);
                    }
                }
            }
            handleColumnWidths() {
                for (const row of this.childNodes) {
                    let i = 0;
                    for (const cell of this.adaptor.childNodes(row.dom[0])) {
                        const w = this.cWidths[i++];
                        if (w !== null) {
                            const width = typeof w === 'number' ? this.em(w) : w;
                            this.adaptor.setStyle(cell, 'width', width);
                            this.adaptor.setStyle(cell, 'maxWidth', width);
                            this.adaptor.setStyle(cell, 'minWidth', width);
                        }
                    }
                }
            }
            handleRowSpacing() {
                const scale = this.childNodes[0]
                    ? 1 / this.childNodes[0].getBBox().rscale
                    : 1;
                const spacing = this.getEmHalfSpacing([this.fSpace[1], this.fSpace[1]], this.rSpace, scale);
                const frame = this.fframe;
                let i = 0;
                for (const row of this.childNodes) {
                    const tspace = spacing[i++];
                    const bspace = spacing[i];
                    for (const cell of row.childNodes) {
                        if ((i > 1 && tspace !== '0.215em') || (frame && i === 1)) {
                            this.adaptor.setStyle(cell.dom[0], 'paddingTop', tspace);
                        }
                        if ((i < this.numRows && bspace !== '0.215em') ||
                            (frame && i === this.numRows)) {
                            this.adaptor.setStyle(cell.dom[0], 'paddingBottom', bspace);
                        }
                    }
                }
            }
            handleRowLines() {
                if (this.node.attributes.get('rowlines') === 'none')
                    return;
                const lines = this.getRowAttributes('rowlines');
                let i = 0;
                for (const row of this.childNodes.slice(1)) {
                    const line = lines[i++];
                    if (line === 'none')
                        continue;
                    for (const cell of this.adaptor.childNodes(row.dom[0])) {
                        this.adaptor.setStyle(cell, 'borderTop', '.07em ' + line);
                    }
                }
            }
            handleRowHeights() {
                if (this.node.attributes.get('equalrows')) {
                    this.handleEqualRows();
                }
            }
            handleEqualRows() {
                const space = this.getRowHalfSpacing();
                const { H, D, NH, ND } = this.getTableData();
                const HD = this.getEqualRowHeight();
                for (let i = 0; i < this.numRows; i++) {
                    const row = this.childNodes[i];
                    this.setRowHeight(row, HD + space[i] + space[i + 1] + this.rLines[i]);
                    if (HD !== NH[i] + ND[i]) {
                        this.setRowBaseline(row, HD, (HD - H[i] + D[i]) / 2);
                    }
                }
            }
            setRowHeight(row, HD) {
                this.adaptor.setStyle(row.dom[0], 'height', this.em(HD));
            }
            setRowBaseline(row, HD, D) {
                const ralign = row.node.attributes.get('rowalign');
                for (const cell of row.childNodes) {
                    if (this.setCellBaseline(cell, ralign, HD, D))
                        break;
                }
            }
            setCellBaseline(cell, ralign, HD, D) {
                const calign = cell.node.attributes.get('rowalign');
                if (calign === 'baseline' || calign === 'axis') {
                    const adaptor = this.adaptor;
                    const child = adaptor.lastChild(cell.dom[0]);
                    adaptor.setStyle(child, 'height', this.em(HD));
                    adaptor.setStyle(child, 'verticalAlign', this.em(-D));
                    const row = cell.parent;
                    if ((!row.node.isKind('mlabeledtr') || cell !== row.childNodes[0]) &&
                        (ralign === 'baseline' || ralign === 'axis')) {
                        return true;
                    }
                }
                return false;
            }
            handleFrame() {
                if (this.frame && this.fLine) {
                    const frame = this.node.attributes.get('frame');
                    this.adaptor.setStyle(this.itable, 'border', `${this.em(this.fLine)} ${frame}`);
                }
            }
            handleWidth() {
                const adaptor = this.adaptor;
                const dom = this.dom[0];
                const { w, L, R } = this.getBBox();
                adaptor.setStyle(dom, 'minWidth', this.em(L + w + R));
                let W = this.node.attributes.get('width');
                if (isPercent(W)) {
                    adaptor.setStyle(dom, 'width', '');
                    adaptor.setAttribute(dom, 'width', 'full');
                }
                else if (!this.hasLabels) {
                    if (W === 'auto')
                        return;
                    W = this.em(this.length2em(W) + 2 * this.fLine);
                }
                const table = adaptor.firstChild(dom);
                adaptor.setStyle(table, 'width', W);
                adaptor.setStyle(table, 'minWidth', this.em(w));
                if (L || R) {
                    adaptor.setStyle(dom, 'margin', '');
                    const style = this.node.attributes.get('data-width-includes-label')
                        ? 'padding'
                        : 'margin';
                    if (L === R) {
                        adaptor.setStyle(table, style, '0 ' + this.em(R));
                    }
                    else {
                        adaptor.setStyle(table, style, '0 ' + this.em(R) + ' 0 ' + this.em(L));
                    }
                }
                adaptor.setAttribute(this.itable, 'width', 'full');
            }
            handleAlign() {
                const [align, row] = this.getAlignmentRow();
                const dom = this.dom[0];
                if (row === null) {
                    if (align !== 'axis') {
                        this.adaptor.setAttribute(dom, 'align', align);
                    }
                }
                else {
                    const y = this.getVerticalPosition(row, align);
                    this.adaptor.setAttribute(dom, 'align', 'top');
                    this.adaptor.setStyle(dom, 'verticalAlign', this.em(y));
                }
            }
            handleJustify() {
                const align = this.getAlignShift()[0];
                if (align !== 'center') {
                    this.adaptor.setAttribute(this.dom[0], 'justify', align);
                }
            }
            handleLabels() {
                if (!this.hasLabels)
                    return;
                const labels = this.labels;
                const attributes = this.node.attributes;
                const adaptor = this.adaptor;
                const side = attributes.get('side');
                adaptor.setAttribute(this.dom[0], 'side', side);
                adaptor.setAttribute(labels, 'align', side);
                adaptor.setStyle(labels, side, '0');
                const [align, shift] = this.addLabelPadding(side);
                if (shift) {
                    const table = adaptor.firstChild(this.dom[0]);
                    this.setIndent(table, align, shift);
                }
                this.updateRowHeights();
                this.addLabelSpacing();
            }
            addLabelPadding(side) {
                const [, align, shift] = this.getPadAlignShift(side);
                const styles = {};
                if (side === 'right' &&
                    !this.node.attributes.get('data-width-includes-label')) {
                    const W = this.node.attributes.get('width');
                    const { w, L, R } = this.getBBox();
                    styles.style = {
                        width: isPercent(W)
                            ? 'calc(' + W + ' + ' + this.em(L + R) + ')'
                            : this.em(L + w + R),
                    };
                }
                this.adaptor.append(this.dom[0], this.html('mjx-labels', styles, [this.labels]));
                return [align, shift];
            }
            updateRowHeights() {
                const { H, D, NH, ND } = this.getTableData();
                const space = this.getRowHalfSpacing();
                for (let i = 0; i < this.numRows; i++) {
                    const row = this.childNodes[i];
                    this.setRowHeight(row, H[i] + D[i] + space[i] + space[i + 1] + this.rLines[i]);
                    if (H[i] !== NH[i] || D[i] !== ND[i]) {
                        this.setRowBaseline(row, H[i] + D[i], D[i]);
                    }
                    else if (row.node.isKind('mlabeledtr')) {
                        this.setCellBaseline(row.childNodes[0], '', H[i] + D[i], D[i]);
                    }
                }
            }
            addLabelSpacing() {
                const adaptor = this.adaptor;
                const equal = this.node.attributes.get('equalrows');
                const { H, D } = this.getTableData();
                const HD = equal ? this.getEqualRowHeight() : 0;
                const space = this.getRowHalfSpacing();
                let h = this.fLine;
                let current = adaptor.firstChild(this.labels);
                for (let i = 0; i < this.numRows; i++) {
                    const row = this.childNodes[i];
                    if (row.node.isKind('mlabeledtr')) {
                        if (h) {
                            adaptor.insert(this.html('mjx-mtr', { style: { height: this.em(h) } }), current);
                        }
                        adaptor.setStyle(current, 'height', this.em((equal ? HD : H[i] + D[i]) + space[i] + space[i + 1]));
                        current = adaptor.next(current);
                        h = this.rLines[i];
                    }
                    else {
                        h +=
                            space[i] +
                                (equal ? HD : H[i] + D[i]) +
                                space[i + 1] +
                                this.rLines[i];
                    }
                }
            }
        },
        _a.kind = MmlMtable.prototype.kind,
        _a.styles = {
            'mjx-mtable': {
                'vertical-align': '.25em',
                'text-align': 'center',
                position: 'relative',
                'box-sizing': 'border-box',
                'border-spacing': 0,
                'border-collapse': 'collapse',
            },
            'mjx-mstyle[size="s"] mjx-mtable': {
                'vertical-align': '.354em',
            },
            'mjx-labels': {
                position: 'absolute',
                left: 0,
                top: 0,
            },
            'mjx-table': {
                display: 'inline-block',
                'vertical-align': '-.5ex',
                'box-sizing': 'border-box',
            },
            'mjx-table > mjx-itable': {
                'vertical-align': 'middle',
                'text-align': 'left',
                'box-sizing': 'border-box',
            },
            'mjx-labels > mjx-itable': {
                position: 'absolute',
                top: 0,
            },
            'mjx-mtable[justify="left"]': {
                'text-align': 'left',
            },
            'mjx-mtable[justify="right"]': {
                'text-align': 'right',
            },
            'mjx-mtable[justify="left"][side="left"]': {
                'padding-right': '0 ! important',
            },
            'mjx-mtable[justify="left"][side="right"]': {
                'padding-left': '0 ! important',
            },
            'mjx-mtable[justify="right"][side="left"]': {
                'padding-right': '0 ! important',
            },
            'mjx-mtable[justify="right"][side="right"]': {
                'padding-left': '0 ! important',
            },
            'mjx-mtable[align]': {
                'vertical-align': 'baseline',
            },
            'mjx-mtable[align="top"] > mjx-table': {
                'vertical-align': 'top',
            },
            'mjx-mtable[align="bottom"] > mjx-table': {
                'vertical-align': 'bottom',
            },
            'mjx-mtable[side="right"] mjx-labels': {
                'min-width': '100%',
            },
        },
        _a;
})();
//# sourceMappingURL=mtable.js.map
;// ./mjs/output/common/Wrappers/mtr.js

function CommonMtrMixin(Base) {
    return class CommonMtrMixin extends Base {
        get numCells() {
            return this.childNodes.length;
        }
        get labeled() {
            return false;
        }
        get tableCells() {
            return this.childNodes;
        }
        getChild(i) {
            return this.childNodes[i];
        }
        getChildBBoxes() {
            return this.childNodes.map((cell) => cell.getBBox());
        }
        stretchChildren(HD = null) {
            const stretchy = [];
            const children = this.labeled
                ? this.childNodes.slice(1)
                : this.childNodes;
            for (const mtd of children) {
                const child = mtd.childNodes[0];
                if (child.canStretch(DIRECTION.Vertical)) {
                    stretchy.push(child);
                }
            }
            const count = stretchy.length;
            const nodeCount = this.childNodes.length;
            if (count && nodeCount > 1 && !HD) {
                let H = 0;
                let D = 0;
                const all = count > 1 && count === nodeCount;
                for (const mtd of children) {
                    const child = mtd.childNodes[0];
                    const noStretch = child.stretch.dir === DIRECTION.None;
                    if (all || noStretch) {
                        const { h, d } = child.getBBox(noStretch);
                        if (h > H) {
                            H = h;
                        }
                        if (d > D) {
                            D = d;
                        }
                    }
                }
                HD = [H, D];
            }
            if (HD) {
                for (const child of stretchy) {
                    const rscale = child.coreRScale();
                    child.coreMO().getStretchedVariant(HD.map((x) => x * rscale));
                }
            }
        }
        get fixesPWidth() {
            return false;
        }
    };
}
function CommonMlabeledtrMixin(Base) {
    return class CommonMlabeledtrMixin extends Base {
        get numCells() {
            return Math.max(0, this.childNodes.length - 1);
        }
        get labeled() {
            return true;
        }
        get tableCells() {
            return this.childNodes.slice(1);
        }
        getChild(i) {
            return this.childNodes[i + 1];
        }
        getChildBBoxes() {
            return this.childNodes.slice(1).map((cell) => cell.getBBox());
        }
    };
}
//# sourceMappingURL=mtr.js.map
;// ./mjs/output/chtml/Wrappers/mtr.js



const ChtmlMtr = (function () {
    var _a;
    const Base = CommonMtrMixin(ChtmlWrapper);
    return _a = class ChtmlMtr extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                const align = this.node.attributes.get('rowalign');
                if (align !== 'baseline') {
                    this.adaptor.setAttribute(this.dom[0], 'rowalign', align);
                }
            }
        },
        _a.kind = MmlMtr.prototype.kind,
        _a.styles = {
            'mjx-mtr': {
                display: 'table-row',
            },
            'mjx-mtr[rowalign="top"] > mjx-mtd': {
                'vertical-align': 'top',
            },
            'mjx-mtr[rowalign="center"] > mjx-mtd': {
                'vertical-align': 'middle',
            },
            'mjx-mtr[rowalign="bottom"] > mjx-mtd': {
                'vertical-align': 'bottom',
            },
            'mjx-mtr[rowalign="baseline"] > mjx-mtd': {
                'vertical-align': 'baseline',
            },
            'mjx-mtr[rowalign="axis"] > mjx-mtd': {
                'vertical-align': '.25em',
            },
        },
        _a;
})();
const ChtmlMlabeledtr = (function () {
    var _a;
    const Base = CommonMlabeledtrMixin(ChtmlMtr);
    return _a = class ChtmlMlabeledtr extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                const child = this.adaptor.firstChild(this.dom[0]);
                if (child) {
                    this.adaptor.remove(child);
                    const align = this.node.attributes.get('rowalign');
                    const attr = align !== 'baseline' && align !== 'axis' ? { rowalign: align } : {};
                    const row = this.html('mjx-mtr', attr, [child]);
                    this.adaptor.append(this.parent.labels, row);
                }
            }
            markUsed() {
                super.markUsed();
                this.jax.wrapperUsage.add(ChtmlMtr.kind);
            }
        },
        _a.kind = MmlMlabeledtr.prototype.kind,
        _a.styles = {
            'mjx-mlabeledtr': {
                display: 'table-row',
            },
            'mjx-mlabeledtr[rowalign="top"] > mjx-mtd': {
                'vertical-align': 'top',
            },
            'mjx-mlabeledtr[rowalign="center"] > mjx-mtd': {
                'vertical-align': 'middle',
            },
            'mjx-mlabeledtr[rowalign="bottom"] > mjx-mtd': {
                'vertical-align': 'bottom',
            },
            'mjx-mlabeledtr[rowalign="baseline"] > mjx-mtd': {
                'vertical-align': 'baseline',
            },
            'mjx-mlabeledtr[rowalign="axis"] > mjx-mtd': {
                'vertical-align': '.25em',
            },
        },
        _a;
})();
//# sourceMappingURL=mtr.js.map
;// ./mjs/output/common/Wrappers/mtd.js
function CommonMtdMixin(Base) {
    return class CommonMtdMixin extends Base {
        get fixesPWidth() {
            return false;
        }
        invalidateBBox() {
            this.bboxComputed = false;
            this.lineBBox = [];
        }
        getWrapWidth(_j) {
            const table = this.parent.parent;
            const row = this.parent;
            const i = this.node.childPosition() - (row.labeled ? 1 : 0);
            return (typeof table.cWidths[i] === 'number'
                ? table.cWidths[i]
                : table.getTableData().W[i]);
        }
        getChildAlign(_i) {
            return this.node.attributes.get('columnalign');
        }
    };
}
//# sourceMappingURL=mtd.js.map
;// ./mjs/output/chtml/Wrappers/mtd.js



const ChtmlMtd = (function () {
    var _a;
    const Base = CommonMtdMixin(ChtmlWrapper);
    return _a = class ChtmlMtd extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                const ralign = this.node.attributes.get('rowalign');
                const calign = this.node.attributes.get('columnalign');
                const palign = this.parent.node.attributes.get('rowalign');
                if (ralign !== palign) {
                    this.adaptor.setAttribute(this.dom[0], 'rowalign', ralign);
                }
                if (calign !== 'center' &&
                    (this.parent.kind !== 'mlabeledtr' ||
                        this !== this.parent.childNodes[0] ||
                        calign !== this.parent.parent.node.attributes.get('side'))) {
                    this.adaptor.setStyle(this.dom[0], 'textAlign', calign);
                }
                if (this.parent.parent.node.getProperty('useHeight')) {
                    this.adaptor.append(this.dom[0], this.html('mjx-tstrut'));
                }
            }
        },
        _a.kind = MmlMtd.prototype.kind,
        _a.styles = {
            'mjx-mtd': {
                display: 'table-cell',
                'text-align': 'center',
                padding: '.215em .4em',
            },
            'mjx-mtd:first-child': {
                'padding-left': 0,
            },
            'mjx-mtd:last-child': {
                'padding-right': 0,
            },
            'mjx-mtable > * > mjx-itable > *:first-child > mjx-mtd': {
                'padding-top': 0,
            },
            'mjx-mtable > * > mjx-itable > *:last-child > mjx-mtd': {
                'padding-bottom': 0,
            },
            'mjx-tstrut': {
                display: 'inline-block',
                height: '1em',
                'vertical-align': '-.25em',
            },
            'mjx-labels[align="left"] > mjx-mtr > mjx-mtd': {
                'text-align': 'left',
            },
            'mjx-labels[align="right"] > mjx-mtr > mjx-mtd': {
                'text-align': 'right',
            },
            'mjx-mtd[extra]': {
                padding: 0,
            },
            'mjx-mtd[rowalign="top"]': {
                'vertical-align': 'top',
            },
            'mjx-mtd[rowalign="center"]': {
                'vertical-align': 'middle',
            },
            'mjx-mtd[rowalign="bottom"]': {
                'vertical-align': 'bottom',
            },
            'mjx-mtd[rowalign="baseline"]': {
                'vertical-align': 'baseline',
            },
            'mjx-mtd[rowalign="axis"]': {
                'vertical-align': '.25em',
            },
        },
        _a;
})();
//# sourceMappingURL=mtd.js.map
;// ./mjs/output/common/Wrappers/maction.js

const TooltipData = {
    dx: '.2em',
    dy: '.1em',
    postDelay: 600,
    clearDelay: 100,
    hoverTimer: new Map(),
    clearTimer: new Map(),
    stopTimers: (node, data) => {
        if (data.clearTimer.has(node)) {
            clearTimeout(data.clearTimer.get(node));
            data.clearTimer.delete(node);
        }
        if (data.hoverTimer.has(node)) {
            clearTimeout(data.hoverTimer.get(node));
            data.hoverTimer.delete(node);
        }
    }
};
function CommonMactionMixin(Base) {
    return class CommonMactionMixin extends Base {
        get selected() {
            const selection = this.node.attributes.get('selection');
            const i = Math.max(1, Math.min(this.childNodes.length, selection)) - 1;
            return (this.childNodes[i] || this.wrap(this.node.selected));
        }
        getParameters() {
            const offsets = this.node.attributes.get('data-offsets');
            const [dx, dy] = split(offsets || '');
            this.tipDx = this.length2em(dx || TooltipData.dx);
            this.tipDy = this.length2em(dy || TooltipData.dy);
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            const actions = this.constructor
                .actions;
            const action = this.node.attributes.get('actiontype');
            const [handler, data] = actions.get(action) || [
                ((_node, _data) => { }),
                {},
            ];
            this.action = handler;
            this.data = data;
            this.getParameters();
        }
        computeBBox(bbox, recompute = false) {
            bbox.updateFrom(this.selected.getOuterBBox());
            this.selected.setChildPWidths(recompute);
        }
        get breakCount() {
            return this.node.isEmbellished
                ? this.selected.coreMO().embellishedBreakCount
                : this.selected.breakCount;
        }
        computeLineBBox(i) {
            return this.getChildLineBBox(this.selected, i);
        }
    };
}
//# sourceMappingURL=maction.js.map
;// ./mjs/output/chtml/Wrappers/maction.js





const ChtmlMaction = (function () {
    var _a;
    const Base = CommonMactionMixin(ChtmlWrapper);
    return _a = class ChtmlMaction extends Base {
            setEventHandler(type, handler, dom = null) {
                (dom ? [dom] : this.dom).forEach((node) => node.addEventListener(type, handler));
            }
            Em(m) {
                return this.em(m);
            }
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const chtml = this.standardChtmlNodes(parents);
                const child = this.selected;
                child.toCHTML(chtml);
                this.action(this, this.data);
            }
        },
        _a.kind = MmlMaction.prototype.kind,
        _a.styles = {
            'mjx-maction': {
                position: 'relative',
            },
            'mjx-maction > mjx-tool': {
                display: 'none',
                position: 'absolute',
                bottom: 0,
                right: 0,
                width: 0,
                height: 0,
                'z-index': 500,
            },
            'mjx-tool > mjx-tip': {
                display: 'inline-block',
                'line-height': 0,
                padding: '.2em',
                border: '1px solid #888',
                'background-color': '#F8F8F8',
                color: 'black',
                'box-shadow': '2px 2px 5px #AAAAAA',
            },
            'mjx-maction[toggle]': {
                cursor: 'pointer',
            },
            'mjx-status': {
                display: 'block',
                position: 'fixed',
                left: '1em',
                bottom: '1em',
                'min-width': '25%',
                padding: '.2em .4em',
                border: '1px solid #888',
                'font-size': '90%',
                'background-color': '#F8F8F8',
                color: 'black',
            },
        },
        _a.actions = new Map([
            [
                'toggle',
                [
                    (node, _data) => {
                        node.dom.forEach((dom) => {
                            node.adaptor.setAttribute(dom, 'toggle', node.node.attributes.get('selection'));
                        });
                        const math = node.factory.jax.math;
                        const document = node.factory.jax.document;
                        const mml = node.node;
                        node.setEventHandler('click', (event) => {
                            if (!math.end.node) {
                                math.start.node = math.end.node = math.typesetRoot;
                                math.start.n = math.end.n = 0;
                            }
                            mml.nextToggleSelection();
                            math.rerender(document, mml.attributes.get('data-maction-id')
                                ? STATE.ENRICHED
                                : STATE.RERENDER);
                            event.stopPropagation();
                        });
                    },
                    {},
                ],
            ],
            [
                'tooltip',
                [
                    (node, data) => {
                        const tip = node.childNodes[1];
                        if (!tip)
                            return;
                        if (tip.node.isKind('mtext')) {
                            const text = tip.node.getText();
                            node.dom.forEach((dom) => node.adaptor.setAttribute(dom, 'title', text));
                        }
                        else {
                            const adaptor = node.adaptor;
                            for (const dom of node.dom) {
                                const tool = adaptor.append(dom, node.html('mjx-tool', {
                                    style: {
                                        bottom: node.Em(-node.tipDy),
                                        right: node.Em(-node.tipDx),
                                    },
                                }, [node.html('mjx-tip')]));
                                tip.toCHTML([adaptor.firstChild(tool)]);
                                node.setEventHandler('mouseover', (event) => {
                                    data.stopTimers(dom, data);
                                    const timeout = setTimeout(() => adaptor.setStyle(tool, 'display', 'block'), data.postDelay);
                                    data.hoverTimer.set(dom, timeout);
                                    event.stopPropagation();
                                }, dom);
                                node.setEventHandler('mouseout', (event) => {
                                    data.stopTimers(dom, data);
                                    const timeout = setTimeout(() => adaptor.setStyle(tool, 'display', ''), data.clearDelay);
                                    data.clearTimer.set(dom, timeout);
                                    event.stopPropagation();
                                }, dom);
                            }
                        }
                    },
                    TooltipData,
                ],
            ],
            [
                'statusline',
                [
                    (node, data) => {
                        const tip = node.childNodes[1];
                        if (!tip)
                            return;
                        if (tip.node.isKind('mtext')) {
                            const adaptor = node.adaptor;
                            const text = tip.node.getText();
                            node.dom.forEach((dom) => adaptor.setAttribute(dom, 'statusline', text));
                            node.setEventHandler('mouseover', (event) => {
                                if (data.status === null) {
                                    const body = adaptor.body(adaptor.document);
                                    data.status = adaptor.append(body, node.html('mjx-status', {}, [node.text(text)]));
                                }
                                event.stopPropagation();
                            });
                            node.setEventHandler('mouseout', (event) => {
                                if (data.status) {
                                    adaptor.remove(data.status);
                                    data.status = null;
                                }
                                event.stopPropagation();
                            });
                        }
                    },
                    {
                        status: null,
                    },
                ],
            ],
        ]),
        _a;
})();
//# sourceMappingURL=maction.js.map
;// ./mjs/output/common/Wrappers/mglyph.js
function CommonMglyphMixin(Base) {
    return class CommonMglyphMixin extends Base {
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.getParameters();
        }
        getParameters() {
            const { width, height, valign, src, index } = this.node.attributes.getList('width', 'height', 'valign', 'src', 'index');
            if (src) {
                this.width = width === 'auto' ? 1 : this.length2em(width);
                this.height = height === 'auto' ? 1 : this.length2em(height);
                this.valign = this.length2em(valign || '0');
            }
            else {
                const text = String.fromCodePoint(parseInt(index));
                const mmlFactory = this.node.factory;
                this.charWrapper = this.wrap(mmlFactory.create('text').setText(text));
                this.charWrapper.parent = this;
            }
        }
        computeBBox(bbox, _recompute = false) {
            if (this.charWrapper) {
                bbox.updateFrom(this.charWrapper.getBBox());
            }
            else {
                bbox.w = this.width;
                bbox.h = this.height + this.valign;
                bbox.d = -this.valign;
            }
        }
    };
}
//# sourceMappingURL=mglyph.js.map
;// ./mjs/output/chtml/Wrappers/mglyph.js



const ChtmlMglyph = (function () {
    var _a;
    const Base = CommonMglyphMixin(ChtmlWrapper);
    return _a = class ChtmlMglyph extends Base {
            toCHTML(parents) {
                const chtml = this.standardChtmlNodes(parents);
                if (this.charWrapper) {
                    this.charWrapper.toCHTML(chtml);
                    return;
                }
                const { src, alt } = this.node.attributes.getList('src', 'alt');
                const styles = {
                    width: this.em(this.width),
                    height: this.em(this.height),
                };
                if (this.valign) {
                    styles.verticalAlign = this.em(this.valign);
                }
                const img = this.html('img', {
                    src: src,
                    style: styles,
                    alt: alt,
                    title: alt,
                });
                this.adaptor.append(chtml[0], img);
            }
        },
        _a.kind = MmlMglyph.prototype.kind,
        _a.styles = {
            'mjx-mglyph > img': {
                display: 'inline-block',
                border: 0,
                padding: 0,
            },
        },
        _a;
})();
//# sourceMappingURL=mglyph.js.map
;// ./mjs/output/common/Wrappers/semantics.js
function CommonSemanticsMixin(Base) {
    return class CommonSemanticsMixin extends Base {
        computeBBox(bbox, _recompute = false) {
            if (this.childNodes.length) {
                const { w, h, d } = this.childNodes[0].getBBox();
                bbox.w = w;
                bbox.h = h;
                bbox.d = d;
            }
        }
        get breakCount() {
            return this.node.isEmbellished
                ? this.coreMO().embellishedBreakCount
                : this.childNodes[0].breakCount;
        }
    };
}
//# sourceMappingURL=semantics.js.map
;// ./mjs/output/common/Wrappers/XmlNode.js

function CommonXmlNodeMixin(Base) {
    class CommonXmlNodeMixin extends Base {
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.rscale = this.getRScale();
        }
        computeBBox(bbox, _recompute = false) {
            const xml = this.node.getXML();
            const hdw = this.getHDW(xml, 'use', 'force');
            const { h, d, w } = hdw ? this.splitHDW(hdw) : this.measureXmlNode(xml);
            bbox.w = w;
            bbox.h = h;
            bbox.d = d;
        }
        getHTML() {
            const adaptor = this.adaptor;
            let html = adaptor.clone(this.node.getXML());
            const styles = this.getFontStyles();
            const hdw = this.getHDW(html, 'force');
            if (hdw || this.jax.options.scale !== 1) {
                html = this.addHDW(html, styles);
            }
            return this.html('mjx-html', { variant: this.parent.variant, style: styles }, [html]);
        }
        getHDW(xml, use, force = use) {
            const option = this.jax.options.htmlHDW;
            const hdw = this.adaptor.getAttribute(xml, 'data-mjx-hdw');
            return hdw && (option === use || option === force) ? hdw : null;
        }
        splitHDW(hdw) {
            const scale = 1 / this.metrics.scale;
            const [h, d, w] = split(hdw).map((x) => this.length2em(x || '0') * scale);
            return { h, d, w };
        }
        getFontStyles() {
            var _a;
            const adaptor = this.adaptor;
            const metrics = this.metrics;
            return {
                'font-family': ((_a = this.parent.styles) === null || _a === void 0 ? void 0 : _a.get('font-family')) ||
                    metrics.family ||
                    adaptor.fontFamily(adaptor.parent(this.jax.math.start.node)) ||
                    'initial',
                'font-size': this.jax.fixed(metrics.em * this.rscale) + 'px',
            };
        }
        measureXmlNode(xml) {
            const adaptor = this.adaptor;
            const content = this.html('mjx-xml-block', { style: { display: 'inline-block' } }, [adaptor.clone(xml)]);
            const base = this.html('mjx-baseline', {
                style: { display: 'inline-block', width: 0, height: 0 },
            });
            const style = this.getFontStyles();
            const node = this.html('mjx-measure-xml', { style }, [base, content]);
            const container = this.jax.container;
            adaptor.append(adaptor.parent(this.jax.math.start.node), container);
            adaptor.append(container, node);
            const metrics = this.metrics;
            const em = metrics.em * metrics.scale * this.rscale;
            const { left, right, bottom, top } = adaptor.nodeBBox(content);
            const w = (right - left) / em;
            const h = (adaptor.nodeBBox(base).top - top) / em;
            const d = (bottom - top) / em - h;
            adaptor.remove(container);
            adaptor.remove(node);
            return { w, h, d };
        }
        getStyles() { }
        getScale() { }
        getVariant() { }
    }
    CommonXmlNodeMixin.autoStyle = false;
    CommonXmlNodeMixin.styles = {
        'mjx-measure-xml': {
            position: 'absolute',
            left: 0,
            top: 0,
            display: 'inline-block',
            'line-height': 'normal',
            'white-space': 'normal',
        },
        'mjx-html': {
            display: 'inline-block',
            'line-height': 'normal',
            'text-align': 'initial',
            'white-space': 'initial',
        },
        'mjx-html-holder': {
            display: 'block',
            position: 'absolute',
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
        },
    };
    return CommonXmlNodeMixin;
}
//# sourceMappingURL=XmlNode.js.map
;// ./mjs/output/chtml/Wrappers/semantics.js





const ChtmlSemantics = (function () {
    var _a;
    const Base = CommonSemanticsMixin(ChtmlWrapper);
    return _a = class ChtmlSemantics extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const chtml = this.standardChtmlNodes(parents);
                if (this.childNodes.length) {
                    this.childNodes[0].toCHTML(chtml);
                }
            }
        },
        _a.kind = MmlSemantics.prototype.kind,
        _a;
})();
const ChtmlAnnotation = (function () {
    var _a;
    return _a = class ChtmlAnnotation extends ChtmlWrapper {
            toCHTML(parents) {
                super.toCHTML(parents);
            }
            computeBBox() {
                return this.bbox;
            }
        },
        _a.kind = MmlAnnotation.prototype.kind,
        _a;
})();
const ChtmlAnnotationXML = (function () {
    var _a;
    return _a = class ChtmlAnnotationXML extends ChtmlWrapper {
        },
        _a.kind = MmlAnnotationXML.prototype.kind,
        _a.styles = {
            'mjx-annotation-xml': {
                'font-family': 'initial',
                'line-height': 'normal',
            },
        },
        _a;
})();
const ChtmlXmlNode = (function () {
    var _a;
    const Base = CommonXmlNodeMixin(ChtmlWrapper);
    return _a = class ChtmlXmlNode extends Base {
            toCHTML(parents) {
                this.markUsed();
                this.dom = [this.adaptor.append(parents[0], this.getHTML())];
            }
            addHDW(html, styles) {
                const scale = this.jax.options.scale;
                const { h, d, w } = this.bbox;
                const rscale = scale * this.metrics.scale;
                styles.width = this.em(w * rscale);
                styles.height = this.em((h + d) * rscale);
                styles['vertical-align'] = this.em(-d * rscale);
                styles.position = 'relative';
                return this.html('mjx-html-holder', {
                    style: {
                        transform: `scale(${this.jax.fixed(scale)})`,
                        'transform-origin': 'top left',
                    },
                }, [html]);
            }
        },
        _a.kind = XMLNode.prototype.kind,
        _a;
})();
//# sourceMappingURL=semantics.js.map
;// ./mjs/output/common/Wrappers/TeXAtom.js
function CommonTeXAtomMixin(Base) {
    return class CommonTeXAtomMixin extends Base {
        computeBBox(bbox, recompute = false) {
            super.computeBBox(bbox, recompute);
            if (this.childNodes[0] && this.childNodes[0].bbox.ic) {
                bbox.ic = this.childNodes[0].bbox.ic;
            }
        }
    };
}
//# sourceMappingURL=TeXAtom.js.map
;// ./mjs/output/chtml/Wrappers/TeXAtom.js




const ChtmlTeXAtom = (function () {
    var _a;
    const Base = CommonTeXAtomMixin(ChtmlWrapper);
    return _a = class ChtmlTeXAtom extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                this.dom.forEach((dom) => this.adaptor.setAttribute(dom, 'texclass', TEXCLASSNAMES[this.node.texClass]));
            }
        },
        _a.kind = TeXAtom.prototype.kind,
        _a;
})();
//# sourceMappingURL=TeXAtom.js.map
;// ./mjs/output/common/Wrappers/TextNode.js
function CommonTextNodeMixin(Base) {
    return class CommonTextNodeMixin extends Base {
        remappedText(text, variant) {
            const c = this.parent.stretch.c;
            return c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant));
        }
        computeBBox(bbox, _recompute = false) {
            const variant = this.parent.variant;
            const text = this.node.getText();
            if (variant === '-explicitFont') {
                const font = this.jax.getFontData(this.parent.styles);
                const { w, h, d } = this.jax.measureText(text, variant, font);
                bbox.h = h;
                bbox.d = d;
                bbox.w = w;
            }
            else {
                const chars = this.remappedText(text, variant);
                let utext = '';
                bbox.empty();
                for (let i = 0; i < chars.length; i++) {
                    const [h, d, w, data] = this.getVariantChar(variant, chars[i]);
                    if (data.unknown) {
                        utext += String.fromCodePoint(chars[i]);
                    }
                    else {
                        utext = this.addUtextBBox(bbox, utext, variant);
                        this.updateBBox(bbox, h, d, w);
                        bbox.ic = data.ic || 0;
                        bbox.sk = data.sk || 0;
                        bbox.dx = data.dx || 0;
                        if (!data.oc || i < chars.length - 1)
                            continue;
                        const children = this.parent.childNodes;
                        if (this.node !== children[children.length - 1].node)
                            continue;
                        const parent = this.parent.parent.node;
                        let next = parent.isKind('mrow') || parent.isInferred
                            ? parent.childNodes[parent.childIndex(this.parent.node) + 1]
                            : null;
                        if ((next === null || next === void 0 ? void 0 : next.isKind('mo')) && next.getText() === '\u2062') {
                            next = parent.childNodes[parent.childIndex(next) + 1];
                        }
                        if (!next || next.attributes.get('mathvariant') !== variant) {
                            bbox.ic = data.oc;
                        }
                        else {
                            bbox.oc = data.oc;
                        }
                    }
                }
                this.addUtextBBox(bbox, utext, variant);
                if (chars.length > 1) {
                    bbox.sk = 0;
                }
                bbox.clean();
            }
        }
        addUtextBBox(bbox, utext, variant) {
            if (utext) {
                const { h, d, w } = this.jax.measureText(utext, variant);
                this.updateBBox(bbox, h, d, w);
            }
            return '';
        }
        updateBBox(bbox, h, d, w) {
            bbox.w += w;
            if (h > bbox.h) {
                bbox.h = h;
            }
            if (d > bbox.d) {
                bbox.d = d;
            }
        }
        getStyles() { }
        getVariant() { }
        getScale() { }
        getSpace() { }
    };
}
//# sourceMappingURL=TextNode.js.map
;// ./mjs/output/chtml/Wrappers/TextNode.js



const ChtmlTextNode = (function () {
    var _a;
    const Base = CommonTextNodeMixin(ChtmlWrapper);
    return _a = class ChtmlTextNode extends Base {
            toCHTML(parents) {
                this.markUsed();
                const parent = parents[0];
                const adaptor = this.adaptor;
                const variant = this.parent.variant;
                const text = this.node.getText();
                if (text.length === 0)
                    return;
                const bbox = this.getBBox();
                if (variant === '-explicitFont') {
                    adaptor.append(parent, this.jax.unknownText(text, variant, bbox.w));
                }
                else {
                    let utext = '';
                    const chars = this.remappedText(text, variant);
                    const H = chars.length > 1 ? this.em(this.parent.getBBox().h) : '';
                    const m = chars.length;
                    for (let i = 0; i < m; i++) {
                        const n = chars[i];
                        const data = this.getVariantChar(variant, n)[3];
                        if (data.unknown) {
                            utext += String.fromCodePoint(n);
                        }
                        else {
                            utext = this.addUtext(utext, variant, parent);
                            const font = data.ff || (data.f ? `${this.font.cssFontPrefix}-${data.f}` : '');
                            const node = adaptor.append(parent, this.html('mjx-c', { class: this.char(n) + (font ? ' ' + font : '') }, [this.text(data.c || String.fromCodePoint(n))]));
                            if (i < m - 1 || bbox.oc) {
                                adaptor.setAttribute(node, 'noic', 'true');
                            }
                            if (H) {
                                adaptor.setStyle(node, 'padding-top', H);
                            }
                            this.font.charUsage.add([variant, n]);
                        }
                    }
                    this.addUtext(utext, variant, parent);
                }
            }
            addUtext(utext, variant, parent) {
                if (utext) {
                    this.adaptor.append(parent, this.jax.unknownText(utext, variant));
                }
                return '';
            }
        },
        _a.kind = TextNode.prototype.kind,
        _a.autoStyle = false,
        _a.styles = {
            'mjx-c': {
                display: 'inline-block',
                width: 0,
                'text-align': 'right',
            },
            'mjx-utext': {
                display: 'inline-block',
                padding: '.75em 0 .2em 0',
            },
        },
        _a;
})();
//# sourceMappingURL=TextNode.js.map
;// ./mjs/output/chtml/Wrappers/HtmlNode.js


const ChtmlHtmlNode = (function () {
    var _a;
    return _a = class ChtmlHtmlNode extends ChtmlXmlNode {
        },
        _a.kind = HtmlNode.prototype.kind,
        _a;
})();
//# sourceMappingURL=HtmlNode.js.map
;// ./mjs/output/chtml/Wrappers.js



























const ChtmlWrappers = {
    [ChtmlMath.kind]: ChtmlMath,
    [ChtmlMrow.kind]: ChtmlMrow,
    [ChtmlInferredMrow.kind]: ChtmlInferredMrow,
    [ChtmlMi.kind]: ChtmlMi,
    [ChtmlMo.kind]: ChtmlMo,
    [ChtmlMn.kind]: ChtmlMn,
    [ChtmlMs.kind]: ChtmlMs,
    [ChtmlMtext.kind]: ChtmlMtext,
    [ChtmlMspace.kind]: ChtmlMspace,
    [ChtmlMpadded.kind]: ChtmlMpadded,
    [ChtmlMenclose.kind]: ChtmlMenclose,
    [ChtmlMfrac.kind]: ChtmlMfrac,
    [ChtmlMsqrt.kind]: ChtmlMsqrt,
    [ChtmlMroot.kind]: ChtmlMroot,
    [ChtmlMsub.kind]: ChtmlMsub,
    [ChtmlMsup.kind]: ChtmlMsup,
    [ChtmlMsubsup.kind]: ChtmlMsubsup,
    [ChtmlMunder.kind]: ChtmlMunder,
    [ChtmlMover.kind]: ChtmlMover,
    [ChtmlMunderover.kind]: ChtmlMunderover,
    [ChtmlMmultiscripts.kind]: ChtmlMmultiscripts,
    [ChtmlMfenced.kind]: ChtmlMfenced,
    [ChtmlMtable.kind]: ChtmlMtable,
    [ChtmlMtr.kind]: ChtmlMtr,
    [ChtmlMlabeledtr.kind]: ChtmlMlabeledtr,
    [ChtmlMtd.kind]: ChtmlMtd,
    [ChtmlMaction.kind]: ChtmlMaction,
    [ChtmlMglyph.kind]: ChtmlMglyph,
    [ChtmlSemantics.kind]: ChtmlSemantics,
    [ChtmlAnnotation.kind]: ChtmlAnnotation,
    [ChtmlAnnotationXML.kind]: ChtmlAnnotationXML,
    [ChtmlXmlNode.kind]: ChtmlXmlNode,
    [ChtmlTeXAtom.kind]: ChtmlTeXAtom,
    [ChtmlTextNode.kind]: ChtmlTextNode,
    [ChtmlHtmlNode.kind]: ChtmlHtmlNode,
    [ChtmlWrapper.kind]: ChtmlWrapper,
};
//# sourceMappingURL=Wrappers.js.map
;// ./mjs/output/chtml/WrapperFactory.js


class ChtmlWrapperFactory extends CommonWrapperFactory {
}
ChtmlWrapperFactory.defaultNodes = ChtmlWrappers;
//# sourceMappingURL=WrapperFactory.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/common.js

function CommonMathJaxNewcmFontMixin(Base) {
    var _a;
    return _a = class extends Base {
        },
        _a.defaultVariants = [
            ...FontData.defaultVariants,
            ['-size3', 'normal'],
            ['-size4', 'normal'],
            ['-size5', 'normal'],
            ['-size6', 'normal'],
            ['-size7', 'normal'],
            ['-lf-tp', 'normal'],
            ['-rt-bt', 'normal'],
            ['-ex-md', 'normal'],
            ['-bbold', 'normal'],
            ['-upsmall', 'normal'],
            ['-uplarge', 'normal']
        ],
        _a.VariantSmp = Object.assign(Object.assign({}, FontData.VariantSmp), { '-bbold': [120120, 120146, , , 120792] }),
        _a.defaultCssFonts = Object.assign(Object.assign({}, FontData.defaultCssFonts), { '-size3': ['serif', false, false], '-size4': ['serif', false, false], '-size5': ['serif', false, false], '-size6': ['serif', false, false], '-size7': ['serif', false, false], '-lf-tp': ['serif', false, false], '-rt-bt': ['serif', false, false], '-ex-md': ['serif', false, false], '-bbold': ['serif', false, false], '-upsmall': ['serif', false, false], '-uplarge': ['serif', false, false] }),
        _a.defaultAccentMap = {
            0x005E: '\u02C6',
            0x007E: '\u02DC',
            0x0300: '\u02CB',
            0x0301: '\u02CA',
            0x0302: '\u02C6',
            0x0303: '\u02DC',
            0x0304: '\u02C9',
            0x0306: '\u02D8',
            0x0307: '\u02D9',
            0x0308: '\u00A8',
            0x030A: '\u02DA',
            0x030C: '\u02C7',
            0x2192: '\u20D7'
        },
        _a.defaultParams = Object.assign(Object.assign({}, FontData.defaultParams), { x_height: .442 }),
        _a.defaultSizeVariants = [
            'normal', '-smallop', '-largeop', '-size3', '-size4', '-size5', '-size6', '-size7'
        ],
        _a.defaultStretchVariants = [
            'normal', '-ex-md', '-size3', '-lf-tp', '-rt-bt'
        ],
        _a;
}
//# sourceMappingURL=common.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/normal.js
const normal = {
    0x20: [0, 0, .332],
    0x21: [.716, 0, .278],
    0x22: [.705, -.423, .374],
    0x23: [.694, .194, .833],
    0x24: [.75, .056, .5],
    0x25: [.75, .056, .833],
    0x26: [.716, .022, .778],
    0x27: [.705, -.423, .278],
    0x28: [.748, .248, .389],
    0x29: [.748, .248, .389],
    0x2A: [.75, -.32, .5],
    0x2B: [.583, .083, .778],
    0x2C: [.106, .193, .278],
    0x2D: [.245, -.187, .333],
    0x2E: [.106, 0, .278],
    0x2F: [.75, .25, .5],
    0x30: [.666, .022, .5],
    0x31: [.666, 0, .5],
    0x32: [.666, 0, .5, { sk: -.01 }],
    0x33: [.666, .022, .5],
    0x34: [.677, 0, .5, { sk: .103 }],
    0x35: [.666, .022, .5],
    0x36: [.666, .022, .5, { sk: .068 }],
    0x37: [.676, .022, .5, { sk: -.147 }],
    0x38: [.666, .022, .5, { sk: .011 }],
    0x39: [.666, .022, .5],
    0x3A: [.431, 0, .278],
    0x3B: [.431, .193, .278],
    0x3C: [.547, .052, .778],
    0x3D: [.367, -.133, .778],
    0x3E: [.547, .047, .778],
    0x3F: [.705, 0, .472],
    0x40: [.705, .011, .778],
    0x41: [.716, 0, .75],
    0x42: [.683, 0, .708, { sk: -.014 }],
    0x43: [.705, .022, .722, { sk: .044 }],
    0x44: [.683, 0, .764],
    0x45: [.68, 0, .681, { sk: .013 }],
    0x46: [.68, 0, .653],
    0x47: [.705, .022, .785, { sk: .013 }],
    0x48: [.683, 0, .75],
    0x49: [.683, 0, .361],
    0x4A: [.683, .022, .514, { sk: .06 }],
    0x4B: [.683, 0, .778, { sk: -.011 }],
    0x4C: [.683, 0, .625, { sk: -.119 }],
    0x4D: [.683, 0, .917],
    0x4E: [.683, 0, .75],
    0x4F: [.705, .022, .778],
    0x50: [.683, 0, .681],
    0x51: [.705, .194, .778],
    0x52: [.683, .022, .736, { sk: -.026 }],
    0x53: [.705, .022, .556],
    0x54: [.677, 0, .722],
    0x55: [.683, .022, .75, { sk: .02 }],
    0x56: [.683, .022, .75],
    0x57: [.683, .022, 1.028],
    0x58: [.683, 0, .75],
    0x59: [.683, 0, .75],
    0x5A: [.683, 0, .611, { sk: .011 }],
    0x5B: [.75, .25, .278],
    0x5C: [.75, .25, .5],
    0x5D: [.75, .25, .278],
    0x5E: [.745, -.561, .556, { ic: .006 }],
    0x5F: [-.1, .14, .333],
    0x60: [.698, -.509, .5, { sk: -.031 }],
    0x61: [.448, .011, .5, { sk: -.036 }],
    0x62: [.694, .011, .556, { sk: -.142 }],
    0x63: [.448, .011, .444, { sk: .027 }],
    0x64: [.694, .011, .556, { sk: .109 }],
    0x65: [.448, .011, .444, { sk: .014 }],
    0x66: [.705, 0, .306, { ic: .051, sk: .043 }],
    0x67: [.453, .206, .5, { sk: -.024 }],
    0x68: [.694, 0, .556, { sk: -.132 }],
    0x69: [.657, 0, .278],
    0x6A: [.657, .205, .306],
    0x6B: [.694, 0, .528, { sk: -.128 }],
    0x6C: [.694, 0, .278],
    0x6D: [.442, 0, .833],
    0x6E: [.442, 0, .556, { sk: .013 }],
    0x6F: [.448, .011, .5],
    0x70: [.442, .194, .556, { sk: .032 }],
    0x71: [.442, .194, .528],
    0x72: [.442, 0, .392, { sk: -.015 }],
    0x73: [.448, .011, .394],
    0x74: [.615, .011, .389, { sk: -.034 }],
    0x75: [.442, .011, .556, { sk: -.017 }],
    0x76: [.431, .011, .528, { sk: .014 }],
    0x77: [.431, .011, .722],
    0x78: [.431, 0, .528],
    0x79: [.431, .205, .528],
    0x7A: [.431, 0, .444],
    0x7B: [.75, .25, .5],
    0x7C: [.75, .25, .278],
    0x7D: [.75, .25, .5],
    0x7E: [.309, -.191, .556, { ic: .001 }],
    0xA0: [0, 0, .332],
    0xA3: [.683, .035, .75],
    0xA5: [.683, 0, .75],
    0xA7: [.705, .205, .444],
    0xA8: [.652, -.557, .5],
    0xAC: [.367, -.133, .667],
    0xAF: [.62, -.589, .5],
    0xB0: [.683, -.406, .375],
    0xB1: [.583, .084, .778],
    0xB4: [.698, -.509, .5, { sk: .031 }],
    0xB5: [.441, .194, .556],
    0xB6: [.694, .194, .611],
    0xB7: [.303, -.197, .278],
    0xD7: [.491, -.009, .778],
    0xF0: [.696, .011, .5],
    0xF7: [.504, .004, .778],
    0x131: [.442, 0, .278],
    0x237: [.442, .205, .306],
    0x2C6: [.694, -.515, .5],
    0x2C7: [.693, -.514, .5],
    0x2C9: [.62, -.589, .5],
    0x2CA: [.698, -.509, .5, { sk: .031 }],
    0x2CB: [.698, -.509, .5, { sk: -.031 }],
    0x2CD: [-.193, .233, .333, { ic: .018 }],
    0x2D8: [.69, -.518, .5],
    0x2D9: [.657, -.551, .278],
    0x2DA: [.705, -.529, .75],
    0x2DC: [.653, -.556, .5],
    0x2FF: [-.025, .275, 0, { dx: .274 }],
    0x300: [.733, -.544, 0, { dx: .294 }],
    0x301: [.733, -.544, 0, { dx: .234 }],
    0x302: [.694, -.515, .5],
    0x303: [.653, -.556, .5, { sk: .016 }],
    0x304: [.64, -.609, 0, { dx: .264 }],
    0x305: [.67, -.63, 0, { dx: .264 }],
    0x306: [.73, -.592, 0, { dx: .264 }],
    0x307: [.677, -.571, 0, { dx: .265 }],
    0x308: [.672, -.577, 0, { dx: .264 }],
    0x30A: [.725, -.549, 0, { dx: .264 }],
    0x30C: [.726, -.577, 0, { dx: .264 }],
    0x338: [.75, .25, 0, { sk: -.263 }],
    0x391: [.716, 0, .75],
    0x392: [.683, 0, .708, { sk: -.068 }],
    0x393: [.68, 0, .625, { sk: -.015 }],
    0x394: [.716, 0, .833],
    0x395: [.68, 0, .681, { sk: -.022 }],
    0x396: [.683, 0, .611, { sk: .011 }],
    0x397: [.683, 0, .75],
    0x398: [.705, .022, .778],
    0x399: [.683, 0, .361],
    0x39A: [.683, 0, .778, { sk: -.011 }],
    0x39B: [.716, 0, .694],
    0x39C: [.683, 0, .917],
    0x39D: [.683, 0, .75],
    0x39E: [.677, 0, .667],
    0x39F: [.705, .022, .778],
    0x3A0: [.68, 0, .75],
    0x3A1: [.683, 0, .681, { sk: -.058 }],
    0x3A3: [.683, 0, .722, { sk: -.011 }],
    0x3A4: [.677, 0, .722],
    0x3A5: [.705, 0, .778],
    0x3A6: [.683, 0, .722],
    0x3A7: [.683, 0, .75, { sk: -.014 }],
    0x3A8: [.683, 0, .778],
    0x3A9: [.705, 0, .722],
    0x3B1: [.442, .011, .641, { ic: .006, sk: .031 }],
    0x3B2: [.706, .194, .558],
    0x3B3: [.442, .215, .586],
    0x3B4: [.712, .011, .474],
    0x3B5: [.453, .022, .535, { sk: -.024 }],
    0x3B6: [.697, .205, .53, { sk: -.041 }],
    0x3B7: [.442, .216, .53, { sk: -.047 }],
    0x3B8: [.705, .011, .488],
    0x3B9: [.442, .011, .308, { sk: -.056 }],
    0x3BA: [.442, .011, .53, { sk: -.018 }],
    0x3BB: [.694, .013, .537, { ic: .029, sk: -.204 }],
    0x3BC: [.442, .216, .53, { sk: -.028 }],
    0x3BD: [.442, 0, .502, { sk: -.042 }],
    0x3BE: [.697, .205, .53, { sk: -.069 }],
    0x3BF: [.448, .011, .5],
    0x3C0: [.431, .011, .586, { sk: -.014 }],
    0x3C1: [.442, .216, .488],
    0x3C2: [.442, .108, .474],
    0x3C3: [.431, .011, .599],
    0x3C4: [.431, .012, .53, { sk: -.033 }],
    0x3C5: [.442, .011, .53, { sk: -.014 }],
    0x3C6: [.442, .218, .641, { sk: -.018 }],
    0x3C7: [.442, .205, .641, { ic: .004, sk: -.057 }],
    0x3C8: [.694, .205, .641, { sk: .028 }],
    0x3C9: [.442, .011, .641],
    0x3D1: [.705, .011, .53, { sk: .026 }],
    0x3D2: [.715, 0, .778],
    0x3D5: [.694, .205, .641],
    0x3D6: [.431, .011, .836, { sk: -.014 }],
    0x3F0: [.442, .012, .624, { sk: -.015 }],
    0x3F1: [.442, .194, .488],
    0x3F4: [.705, .022, .778],
    0x3F5: [.431, .011, .414, { ic: .015, sk: .024 }],
    0x3F6: [.431, .011, .414, { ic: .058 }],
    0x2000: [0, 0, .5],
    0x2001: [0, 0, 1],
    0x2002: [0, 0, .5],
    0x2003: [0, 0, 1],
    0x2004: [0, 0, .333],
    0x2005: [0, 0, .25],
    0x2006: [0, 0, .167],
    0x2007: [0, 0, .5],
    0x2008: [0, 0, .25],
    0x2009: [0, 0, .2],
    0x200A: [0, 0, .1],
    0x200B: [0, 0, 0],
    0x2010: [.245, -.187, .333],
    0x2011: [.245, -.187, .333],
    0x2012: [.342, -.302, .68],
    0x2013: [.277, -.255, .5],
    0x2014: [.277, -.255, 1],
    0x2015: [.27, -.23, 1.152],
    0x2016: [.75, .25, .398],
    0x2018: [.693, -.394, .278],
    0x2019: [.694, -.395, .278],
    0x201C: [.693, -.394, .472],
    0x201D: [.694, -.395, .472],
    0x2020: [.705, .216, .444],
    0x2021: [.705, .205, .444],
    0x2026: [.106, 0, .837],
    0x2027: [.266, -.16, .276],
    0x202F: [0, 0, .2],
    0x2032: [.748, -.43, .311],
    0x2033: [.748, -.43, .511],
    0x2034: [.748, -.43, .711],
    0x2035: [.748, -.43, .311],
    0x2036: [.748, -.43, .511],
    0x2037: [.748, -.43, .711],
    0x2044: [.75, .25, .5],
    0x2057: [.748, -.43, .911],
    0x205F: [0, 0, .222],
    0x2060: [0, 0, 0],
    0x2061: [0, 0, 0],
    0x2062: [0, 0, 0],
    0x2063: [0, 0, 0],
    0x2064: [0, 0, 0],
    0x20A4: [.683, .035, .75],
    0x20AC: [.705, .022, .627],
    0x20D0: [.711, -.601, 0, { dx: .264 }],
    0x20D1: [.711, -.601, 0, { dx: .264 }],
    0x20D2: [.75, .25, 0, { sk: -.264 }],
    0x20D6: [.711, -.521, 0, { dx: .264 }],
    0x20D7: [.711, -.521, 0, { dx: .264 }],
    0x20DB: [.696, -.604, 0, { dx: .264 }],
    0x20DC: [.696, -.604, 0, { dx: .264 }],
    0x20E1: [.711, -.521, 0, { dx: .264 }],
    0x20EC: [-.171, .281, 0, { dx: .264 }],
    0x20ED: [-.171, .281, 0, { dx: .264 }],
    0x20EE: [-.091, .281, 0, { dx: .264 }],
    0x20EF: [-.091, .281, 0, { dx: .264 }],
    0x2107: [.705, .022, .53],
    0x210E: [.694, .011, .576, { sk: -.033 }],
    0x210F: [.694, .011, .576],
    0x2126: [.705, 0, .722],
    0x2127: [.684, .021, .722],
    0x212A: [.683, 0, .778, { sk: -.011 }],
    0x212B: [.892, 0, .75],
    0x2132: [.68, 0, .653],
    0x2135: [.693, 0, .611],
    0x2136: [.723, .04, .604],
    0x2137: [.721, .03, .528],
    0x2138: [.71, .035, .574],
    0x2190: [.51, .01, 1],
    0x2191: [.679, .203, .5],
    0x2192: [.51, .01, 1],
    0x2193: [.703, .179, .5],
    0x2194: [.51, .01, 1],
    0x2195: [.757, .257, .5],
    0x2196: [.714, .203, 1],
    0x2197: [.714, .203, 1],
    0x2198: [.703, .214, 1],
    0x2199: [.703, .214, 1],
    0x219A: [.51, .01, .997],
    0x219B: [.51, .01, .997],
    0x219E: [.51, .01, 1.017],
    0x21A0: [.51, .01, 1.017],
    0x21A2: [.51, .01, 1.192],
    0x21A3: [.51, .01, 1.192],
    0x21A4: [.51, .011, .977],
    0x21A6: [.51, .011, .977],
    0x21A9: [.55, .01, .997],
    0x21AA: [.55, .01, .997],
    0x21AB: [.55, .05, .997],
    0x21AC: [.55, .05, .997],
    0x21AE: [.51, .01, .996],
    0x21B6: [.562, -.229, .98],
    0x21B7: [.562, -.229, .98],
    0x21BA: [.68, .06, .771],
    0x21BB: [.68, .06, .771],
    0x21BC: [.503, -.23, 1],
    0x21BD: [.27, .003, 1.012],
    0x21BE: [.697, .203, .441],
    0x21BF: [.697, .203, .441],
    0x21C0: [.503, -.23, 1],
    0x21C1: [.27, .003, 1.012],
    0x21C2: [.703, .197, .441],
    0x21C3: [.703, .197, .441],
    0x21C4: [.672, .172, 1.018],
    0x21C5: [.703, .203, .896],
    0x21C6: [.672, .172, 1.018],
    0x21C7: [.75, .25, .997],
    0x21C8: [.679, .203, .992],
    0x21C9: [.75, .25, .997],
    0x21CA: [.703, .179, .992],
    0x21CB: [.6, .1, 1.018],
    0x21CC: [.6, .1, 1.018],
    0x21CD: [.52, .02, .991],
    0x21CE: [.52, .02, 1.068],
    0x21CF: [.52, .02, .991],
    0x21D0: [.52, .02, 1],
    0x21D1: [.676, .203, .611],
    0x21D2: [.52, .02, 1],
    0x21D3: [.703, .176, .611],
    0x21D4: [.52, .02, 1],
    0x21D5: [.728, .228, .611],
    0x21DA: [.617, .117, 1.015],
    0x21DB: [.617, .117, 1.015],
    0x21E0: [.51, .01, 1],
    0x21E1: [.692, .192, .684],
    0x21E2: [.51, .01, 1],
    0x21E3: [.692, .192, .684],
    0x21E4: [.51, .01, 1.018],
    0x21E5: [.51, .01, 1.018],
    0x21F5: [.703, .203, .896],
    0x21F6: [.99, .49, .997],
    0x2200: [.688, -.002, .666],
    0x2201: [.684, 0, .556],
    0x2202: [.716, .022, .586],
    0x2203: [.684, 0, .556],
    0x2204: [.789, .105, .556],
    0x2205: [.772, .078, .5],
    0x2206: [.716, 0, .833],
    0x2207: [.683, .033, .833],
    0x2208: [.543, .043, .667],
    0x2209: [.73, .23, .667],
    0x220B: [.543, .043, .667],
    0x220C: [.73, .23, .667],
    0x220E: [.554, 0, .666],
    0x220F: [.75, .25, .944],
    0x2210: [.75, .25, .944],
    0x2211: [.75, .25, 1.056],
    0x2212: [.583, .083, .778],
    0x2213: [.584, .083, .778],
    0x2214: [.785, .083, .778],
    0x2215: [.603, .103, .568],
    0x2216: [.603, .103, .568],
    0x2217: [.462, -.039, .5],
    0x2218: [.4, -.1, .412],
    0x2219: [.445, -.055, .5],
    0x221A: [.04, .96, .833, { ic: .02 }],
    0x221D: [.442, .011, .778],
    0x221E: [.442, .011, 1],
    0x221F: [.679, -.013, .778],
    0x2220: [.724, -.013, .778],
    0x2221: [.724, .109, .778],
    0x2222: [.562, .062, .778],
    0x2223: [.75, .25, .278],
    0x2224: [.75, .25, .388],
    0x2225: [.75, .25, .5],
    0x2226: [.75, .25, .556],
    0x2227: [.602, .02, .667],
    0x2228: [.601, .02, .667],
    0x2229: [.604, .02, .667],
    0x222A: [.604, .02, .667],
    0x222B: [.805, .306, .545, { ic: 0.12 }],
    0x222C: [.805, .306, .915, { ic: 0.12 }],
    0x222D: [.805, .306, 1.285, { ic: 0.12 }],
    0x222E: [.805, .306, .615, { ic: 0.05 }],
    0x222F: [.805, .306, .985, { ic: 0.05 }],
    0x2230: [.805, .306, 1.355, { ic: 0.05 }],
    0x2231: [.805, .306, .675, { ic: 0.02 }],
    0x2232: [.805, .306, .662, { ic: 0.02 }],
    0x2233: [.805, .306, .662, { ic: 0.02 }],
    0x2234: [.416, -.084, .516],
    0x2235: [.416, -.084, .516],
    0x2236: [.422, -.078, .278],
    0x2237: [.422, -.078, .516],
    0x2238: [.504, -.23, .778],
    0x2239: [.422, -.078, .906],
    0x223C: [.366, -.134, .773],
    0x223D: [.366, -.134, .773],
    0x223E: [.466, -.034, .901],
    0x223F: [.492, -.008, .778],
    0x2240: [.583, .083, .28],
    0x2241: [.482, -.018, .773],
    0x2242: [.38, -.032, .778],
    0x2243: [.468, -.12, .778],
    0x2244: [.603, .103, .778],
    0x2245: [.552, -.036, .778],
    0x2246: [.614, .048, .778],
    0x2247: [.603, .103, .778],
    0x2248: [.457, -.043, .773],
    0x2249: [.603, .103, .773],
    0x224A: [.541, -.036, .778],
    0x224B: [.541, .041, .773],
    0x224C: [.541, -.036, .778],
    0x224D: [.498, -.002, .778],
    0x2250: [.601, -.133, .778],
    0x2254: [.422, -.078, .906],
    0x2255: [.422, -.078, .906],
    0x225D: [.793, -.133, .778],
    0x225F: [.803, -.133, .778],
    0x2260: [.73, .23, .778],
    0x2261: [.464, -.036, .778],
    0x2262: [.73, .23, .778],
    0x2263: [.561, .061, .778],
    0x2264: [.631, .119, .778],
    0x2265: [.631, .119, .778],
    0x2266: [.715, .203, .778],
    0x2267: [.715, .203, .778],
    0x2268: [.715, .287, .778],
    0x2269: [.715, .287, .778],
    0x226A: [.554, .047, 1],
    0x226B: [.546, .054, 1],
    0x226C: [.77, .27, .434],
    0x226D: [.73, .23, .778],
    0x226E: [.73, .23, .778],
    0x226F: [.73, .23, .778],
    0x2270: [.73, .23, .778],
    0x2271: [.73, .23, .778],
    0x2272: [.636, .125, .776],
    0x2273: [.636, .125, .776],
    0x2274: [.691, .191, .776],
    0x2275: [.691, .191, .776],
    0x2276: [.741, .241, .778],
    0x2277: [.741, .241, .778],
    0x2278: [.776, .276, .778],
    0x2279: [.776, .276, .778],
    0x227A: [.547, .047, .778],
    0x227B: [.547, .047, .778],
    0x227C: [.639, .139, .738],
    0x227D: [.639, .139, .738],
    0x227E: [.682, .17, .773],
    0x227F: [.682, .17, .773],
    0x2280: [.73, .23, .778],
    0x2281: [.73, .23, .778],
    0x2282: [.543, .043, .778],
    0x2283: [.543, .043, .778],
    0x2284: [.73, .23, .778],
    0x2285: [.73, .23, .778],
    0x2286: [.627, .127, .778],
    0x2287: [.627, .127, .778],
    0x2288: [.73, .23, .778],
    0x2289: [.73, .23, .778],
    0x228A: [.627, .211, .778],
    0x228B: [.627, .211, .778],
    0x228D: [.604, .02, .667],
    0x228E: [.604, .02, .667],
    0x228F: [.543, .043, .778],
    0x2290: [.543, .043, .778],
    0x2291: [.627, .127, .778],
    0x2292: [.627, .127, .778],
    0x2293: [.604, .02, .667],
    0x2294: [.604, .02, .667],
    0x2295: [.591, .093, .782],
    0x2296: [.591, .093, .782],
    0x2297: [.591, .093, .782],
    0x2298: [.591, .093, .782],
    0x2299: [.591, .093, .782],
    0x229A: [.591, .093, .782],
    0x229B: [.591, .093, .782],
    0x229C: [.591, .093, .782],
    0x229D: [.591, .093, .782],
    0x229E: [.583, .083, .778],
    0x229F: [.583, .083, .778],
    0x22A0: [.583, .083, .778],
    0x22A1: [.583, .083, .778],
    0x22A2: [.684, 0, .611],
    0x22A3: [.684, 0, .611],
    0x22A4: [.664, .02, .778],
    0x22A5: [.684, 0, .778],
    0x22A6: [.684, 0, .445],
    0x22A7: [.684, 0, .445],
    0x22A8: [.684, 0, .612],
    0x22A9: [.684, 0, .673],
    0x22AA: [.684, 0, .841],
    0x22AB: [.684, 0, .653],
    0x22AC: [.684, 0, .565],
    0x22AD: [.684, 0, .732],
    0x22AE: [.684, 0, .793],
    0x22AF: [.684, 0, .773],
    0x22B0: [.563, .063, .778],
    0x22B1: [.563, .063, .778],
    0x22B2: [.547, .047, .738],
    0x22B3: [.547, .047, .738],
    0x22B4: [.605, .105, .738],
    0x22B5: [.605, .105, .738],
    0x22BA: [.664, .02, .778],
    0x22C0: [.78, .282, .833],
    0x22C1: [.783, .28, .833],
    0x22C2: [.772, .25, .833],
    0x22C3: [.75, .272, .833],
    0x22C4: [.48, -.02, .5],
    0x22C5: [.303, -.197, .278],
    0x22C6: [.486, -.008, .5],
    0x22C8: [.505, .005, .623],
    0x22C9: [.505, .005, .623],
    0x22CA: [.505, .005, .623],
    0x22CB: [.505, .005, .623],
    0x22CC: [.505, .005, .623],
    0x22CD: [.468, -.12, .778],
    0x22CE: [.584, .02, .733],
    0x22CF: [.584, .02, .733],
    0x22E2: [.73, .23, .778],
    0x22E3: [.73, .23, .778],
    0x22EA: [.73, .23, .738],
    0x22EB: [.73, .23, .738],
    0x22EC: [.73, .23, .738],
    0x22ED: [.73, .23, .738],
    0x22EE: [.582, .082, .218],
    0x22EF: [.303, -.197, .776],
    0x22F0: [.5, 0, .613],
    0x22F1: [.5, 0, .613],
    0x2307: [.783, .313, .28],
    0x2308: [.75, .25, .444],
    0x2309: [.75, .25, .444],
    0x230A: [.75, .25, .444],
    0x230B: [.75, .25, .444],
    0x230C: [.274, .103, .818],
    0x230D: [.274, .103, .818],
    0x230E: [.603, -.226, .818],
    0x230F: [.603, -.226, .818],
    0x2310: [.367, -.133, .667],
    0x2319: [.367, -.133, .667],
    0x231C: [.77, -.49, .392],
    0x231D: [.77, -.49, .392],
    0x231E: [.01, .27, .392],
    0x231F: [.01, .27, .392],
    0x2320: [1.344, 0, 1.185],
    0x2321: [.806, .538, 1.185],
    0x2322: [.381, -.13, 1],
    0x2323: [.371, -.133, 1],
    0x2329: [.75, .25, .389],
    0x232A: [.75, .25, .389],
    0x239B: [1.495, 0, .875],
    0x239C: [.498, 0, .875],
    0x239D: [1.495, 0, .875],
    0x239E: [1.495, 0, .875],
    0x239F: [.498, 0, .875],
    0x23A0: [1.495, 0, .875],
    0x23A1: [1.5, 0, .667],
    0x23A2: [1, 0, .667],
    0x23A3: [1.5, 0, .667],
    0x23A4: [1.5, 0, .667],
    0x23A5: [1, 0, .667],
    0x23A6: [1.5, 0, .667],
    0x23A7: [.75, 0, .902],
    0x23A8: [1.5, 0, .902],
    0x23A9: [.75, 0, .902],
    0x23AA: [.748, 0, .902],
    0x23AB: [.75, 0, .902],
    0x23AC: [1.5, 0, .902],
    0x23AD: [.75, 0, .902],
    0x23AE: [.806, 0, 1.185],
    0x23AF: [.27, -.23, .396],
    0x23B0: [.75, .375, .752],
    0x23B1: [.75, .375, .752],
    0x23B2: [.846, 0, 1.576],
    0x23B3: [.847, 0, 1.576],
    0x23B4: [.726, -.552, .36],
    0x23B5: [-.122, .296, .36],
    0x23B7: [1.82, 0, 1.056],
    0x23B8: [1.765, .235, .659],
    0x23B9: [1.765, .235, .659],
    0x23D0: [.642, 0, .333],
    0x23DC: [.727, -.572, .504],
    0x23DD: [-.142, .297, .504],
    0x23DE: [.783, -.539, .492],
    0x23DF: [-.109, .353, .492],
    0x23E0: [.829, -.657, .546, { ic: .006 }],
    0x23E1: [-.227, .399, .546, { ic: .006 }],
    0x23F4: [.422, -.082, .356],
    0x23F5: [.422, -.078, .356],
    0x23F6: [.38, -.12, .356],
    0x23F7: [.38, -.12, .356],
    0x25A0: [.583, .083, .778],
    0x25A1: [.583, .083, .778],
    0x25AA: [.358, -.142, .328],
    0x25AB: [.358, -.142, .328],
    0x25B2: [.741, .005, .968],
    0x25B3: [.741, .005, .968],
    0x25B4: [.592, -.144, .626],
    0x25B5: [.592, -.144, .626],
    0x25B6: [.678, .178, .858],
    0x25B7: [.678, .178, .858],
    0x25B8: [.625, -.111, .626],
    0x25B9: [.625, -.111, .626],
    0x25BA: [.625, -.111, .866],
    0x25BB: [.625, -.111, .866],
    0x25BC: [.505, .241, .968],
    0x25BD: [.505, .241, .968],
    0x25BE: [.592, -.144, .626],
    0x25BF: [.592, -.144, .626],
    0x25C0: [.678, .178, .858],
    0x25C1: [.678, .178, .858],
    0x25C2: [.625, -.111, .626],
    0x25C3: [.625, -.111, .626],
    0x25C4: [.625, -.111, .866],
    0x25C5: [.625, -.111, .866],
    0x25C6: [.713, .213, 1.025],
    0x25C7: [.713, .213, 1.025],
    0x25CA: [.61, .11, .572],
    0x25CB: [.592, .092, .796],
    0x25CF: [.592, .092, .796],
    0x25E6: [.445, -.055, .5],
    0x25EF: [.701, .201, 1.013],
    0x25F8: [.679, -.013, .778],
    0x25F9: [.679, -.013, .778],
    0x25FA: [.679, -.013, .778],
    0x25FB: [.533, .033, .706],
    0x25FC: [.533, .033, .706],
    0x25FD: [.483, -.017, .566],
    0x25FE: [.483, -.017, .566],
    0x25FF: [.679, -.013, .778],
    0x2758: [.694, .083, .525],
    0x27D8: [.684, .184, .946],
    0x27D9: [.684, .184, .986],
    0x27DD: [.684, .184, .946],
    0x27DE: [.684, .184, .946],
    0x27E6: [.75, .25, .41],
    0x27E7: [.75, .25, .41],
    0x27E8: [.75, .25, .389],
    0x27E9: [.75, .25, .389],
    0x27EA: [.75, .25, .57],
    0x27EB: [.75, .25, .57],
    0x27EC: [.748, .248, .389],
    0x27ED: [.748, .248, .389],
    0x27EE: [.762, .262, .287],
    0x27EF: [.762, .262, .287],
    0x27F5: [.51, .01, 1.463],
    0x27F6: [.51, .01, 1.463],
    0x27F7: [.51, .01, 1.442],
    0x27F8: [.52, .02, 1.457],
    0x27F9: [.52, .02, 1.457],
    0x27FA: [.52, .02, 1.534],
    0x27FB: [.51, .011, 1.443],
    0x27FC: [.51, .011, 1.443],
    0x27FD: [.52, .021, 1.437],
    0x27FE: [.52, .021, 1.437],
    0x290A: [.702, .202, .846],
    0x290B: [.702, .202, .846],
    0x294A: [.503, .003, 1.012],
    0x294B: [.503, .003, 1.012],
    0x294E: [.503, -.23, 1],
    0x2950: [.27, .003, 1],
    0x2952: [.503, .019, 1.088],
    0x2953: [.503, .019, 1.088],
    0x2956: [.502, .019, 1.088],
    0x2957: [.502, .019, 1.088],
    0x295A: [.51, .011, 1],
    0x295B: [.51, .011, 1],
    0x295E: [.51, .011, 1],
    0x295F: [.51, .011, 1],
    0x296A: [.6, -.133, 1.018],
    0x296B: [.368, .099, 1.018],
    0x296C: [.6, -.133, 1.018],
    0x296D: [.368, .099, 1.018],
    0x296E: [.703, .203, .8],
    0x296F: [.703, .203, .8],
    0x297C: [.563, .063, .778],
    0x297D: [.563, .063, .778],
    0x297E: [.546, .046, .726],
    0x297F: [.546, .046, .726],
    0x2980: [.75, .25, .694],
    0x2997: [.748, .248, .278],
    0x2998: [.748, .248, .278],
    0x29F5: [.603, .103, .556],
    0x29F7: [.603, .103, .556],
    0x29F8: [.75, .325, .5],
    0x29F9: [.75, .325, .5],
    0x2A00: [.743, .243, 1.111],
    0x2A01: [.743, .243, 1.111],
    0x2A02: [.743, .243, 1.111],
    0x2A03: [.75, .272, .833],
    0x2A04: [.75, .272, .833],
    0x2A05: [.764, .264, .833],
    0x2A06: [.764, .264, .833],
    0x2A07: [.78, .282, 1.082],
    0x2A08: [.799, .264, 1.082],
    0x2A09: [.74, .24, 1.092],
    0x2A0C: [.805, .306, 1.655, { ic: 0.12 }],
    0x2A0D: [.805, .306, .615, { ic: 0.05 }],
    0x2A0E: [.805, .306, .615, { ic: 0.05 }],
    0x2A0F: [.805, .306, .615, { ic: 0.05 }],
    0x2A10: [.805, .306, .615, { ic: 0.05 }],
    0x2A11: [.805, .306, .675, { ic: 0.02 }],
    0x2A12: [.805, .306, .615, { ic: 0.05 }],
    0x2A13: [.805, .306, .615, { ic: 0.05 }],
    0x2A14: [.805, .306, .615, { ic: 0.05 }],
    0x2A15: [.805, .306, .545, { ic: 0.12 }],
    0x2A16: [.805, .306, .545, { ic: 0.12 }],
    0x2A17: [.805, .306, .794],
    0x2A18: [.805, .306, .665],
    0x2A19: [.805, .306, .665],
    0x2A1A: [.805, .306, .645, { ic: 0.02 }],
    0x2A1B: [.967, .306, .545, { ic: 0.12 }],
    0x2A1C: [.805, .468, .645, { ic: 0.02 }],
    0x2A2F: [.496, -.004, .778],
    0x2A3F: [.683, 0, .75],
    0x2A7D: [.634, .134, .778],
    0x2A7E: [.634, .134, .778],
    0x2A85: [.721, .205, .776],
    0x2A86: [.721, .205, .776],
    0x2A87: [.667, .167, .778],
    0x2A88: [.667, .167, .778],
    0x2A89: [.753, .321, .776],
    0x2A8A: [.721, .289, .776],
    0x2A8B: [.977, .477, .778],
    0x2A8C: [.977, .477, .778],
    0x2A95: [.629, .134, .778],
    0x2A96: [.629, .129, .778],
    0x2AAF: [.631, .119, .778],
    0x2AB0: [.631, .119, .778],
    0x2AB1: [.631, .203, .778],
    0x2AB2: [.631, .203, .778],
    0x2AB3: [.716, .203, .778],
    0x2AB4: [.716, .203, .778],
    0x2AB5: [.716, .287, .778],
    0x2AB6: [.716, .287, .778],
    0x2AB7: [.816, .205, .776],
    0x2AB8: [.816, .205, .776],
    0x2AB9: [.816, .321, .776],
    0x2ABA: [.816, .321, .776],
    0x2AC5: [.543, .203, .698],
    0x2AC6: [.543, .203, .698],
    0x2ACB: [.543, .287, .698],
    0x2ACC: [.543, .287, .698],
    0x2ADE: [.684, 0, .381],
    0x2ADF: [.342, .02, .778],
    0x2AE0: [.342, .02, .778],
    0x2AE1: [.684, 0, .778],
    0x2AE2: [.684, 0, .612],
    0x2AE3: [.684, 0, .673],
    0x2AE4: [.684, 0, .612],
    0x2AE5: [.684, 0, .653],
    0x2AE6: [.684, 0, .673],
    0x2AE7: [.622, -.062, .784],
    0x2AE8: [.622, -.062, .784],
    0x2AE9: [.812, .02, .778],
    0x2AEA: [.592, -.092, .784],
    0x2AEB: [.592, -.092, .784],
    0x2AF2: [.75, .25, .62],
    0x2AF3: [.75, .25, .773],
    0x2AF4: [.75, .25, .694],
    0x2AF5: [.75, .25, .694],
    0x2AFC: [.75, .25, .694],
    0x1D400: [.698, 0, .869],
    0x1D401: [.686, 0, .818, { sk: -.026 }],
    0x1D402: [.697, .011, .831, { sk: .051 }],
    0x1D403: [.686, 0, .882, { sk: -.04 }],
    0x1D404: [.68, 0, .756],
    0x1D405: [.68, 0, .724, { sk: -.02 }],
    0x1D406: [.697, .011, .904, { sk: .015 }],
    0x1D407: [.686, 0, .9],
    0x1D408: [.686, 0, .436],
    0x1D409: [.686, .011, .594, { sk: .051 }],
    0x1D40A: [.686, 0, .901, { sk: -.013 }],
    0x1D40B: [.686, 0, .692, { sk: -.114 }],
    0x1D40C: [.686, 0, 1.092],
    0x1D40D: [.686, 0, .9],
    0x1D40E: [.697, .011, .864],
    0x1D40F: [.686, 0, .786, { sk: -.021 }],
    0x1D410: [.697, .194, .864],
    0x1D411: [.686, .011, .863, { sk: -.044 }],
    0x1D412: [.697, .011, .639, { sk: -.025 }],
    0x1D413: [.675, 0, .8],
    0x1D414: [.686, .011, .885],
    0x1D415: [.686, .008, .869],
    0x1D416: [.686, .008, 1.189],
    0x1D417: [.686, 0, .869, { sk: -.017 }],
    0x1D418: [.686, 0, .869],
    0x1D419: [.686, 0, .703, { sk: .013 }],
    0x1D41A: [.453, .006, .559, { sk: -.049 }],
    0x1D41B: [.694, .006, .639, { sk: -.194 }],
    0x1D41C: [.453, .006, .511, { sk: .043 }],
    0x1D41D: [.694, .006, .639, { sk: .124 }],
    0x1D41E: [.453, .006, .527, { sk: .018 }],
    0x1D41F: [.7, 0, .351, { ic: .086, sk: .033 }],
    0x1D420: [.455, .201, .575, { sk: -.032 }],
    0x1D421: [.694, 0, .639, { sk: -.172 }],
    0x1D422: [.685, 0, .319],
    0x1D423: [.685, .2, .351, { sk: .013 }],
    0x1D424: [.694, 0, .607, { sk: -.177 }],
    0x1D425: [.694, 0, .319, { sk: -.024 }],
    0x1D426: [.45, 0, .958, { sk: .012 }],
    0x1D427: [.45, 0, .639],
    0x1D428: [.453, .006, .575],
    0x1D429: [.45, .194, .639, { sk: .043 }],
    0x1D42A: [.45, .194, .607, { sk: -.013 }],
    0x1D42B: [.45, 0, .474, { sk: -.021 }],
    0x1D42C: [.453, .006, .454],
    0x1D42D: [.635, .006, .447, { sk: -.029 }],
    0x1D42E: [.45, .006, .639, { sk: -.024 }],
    0x1D42F: [.444, .004, .607],
    0x1D430: [.444, .004, .831],
    0x1D431: [.444, 0, .607],
    0x1D432: [.444, .2, .607],
    0x1D433: [.444, 0, .511],
    0x1D434: [.716, 0, .75, { sk: .175 }],
    0x1D435: [.683, 0, .759, { sk: .115 }],
    0x1D436: [.705, .022, .715, { ic: .045, sk: .105 }],
    0x1D437: [.683, 0, .828, { sk: .088 }],
    0x1D438: [.68, 0, .738, { ic: .028, sk: .115 }],
    0x1D439: [.68, 0, .643, { ic: .108, sk: .102 }],
    0x1D43A: [.705, .022, .786, { sk: .093 }],
    0x1D43B: [.683, 0, .831, { ic: .05, sk: .089 }],
    0x1D43C: [.684, .001, .44, { ic: .057, sk: .084 }],
    0x1D43D: [.683, .022, .555, { ic: .078, sk: .151 }],
    0x1D43E: [.684, 0, .849, { ic: .04, sk: .09 }],
    0x1D43F: [.684, 0, .681, { sk: .019 }],
    0x1D440: [.683, 0, .97, { ic: .074, sk: .085 }],
    0x1D441: [.683, 0, .803, { ic: .078, sk: .082 }],
    0x1D442: [.705, .022, .763, { sk: .114 }],
    0x1D443: [.683, 0, .642, { ic: .112, sk: .072 }],
    0x1D444: [.705, .194, .791, { sk: .1 }],
    0x1D445: [.683, .022, .759, { sk: .084 }],
    0x1D446: [.705, .022, .613, { ic: .032, sk: .093 }],
    0x1D447: [.677, 0, .584, { ic: .12, sk: .016 }],
    0x1D448: [.683, .022, .683, { ic: .077, sk: .022 }],
    0x1D449: [.683, .022, .583, { ic: .187, sk: -.019 }],
    0x1D44A: [.683, .022, .944, { ic: .104 }],
    0x1D44B: [.683, 0, .828, { ic: .023, sk: .097 }],
    0x1D44C: [.683, .001, .581, { ic: .181, sk: -.027 }],
    0x1D44D: [.683, 0, .683, { ic: .04, sk: .114 }],
    0x1D44E: [.442, .011, .529, { sk: .022 }],
    0x1D44F: [.694, .011, .429, { sk: -.011 }],
    0x1D450: [.442, .011, .433, { sk: .101 }],
    0x1D451: [.694, .011, .52, { sk: .182 }],
    0x1D452: [.442, .011, .466, { sk: .067 }],
    0x1D453: [.705, .205, .49, { ic: .062, sk: .172 }],
    0x1D454: [.442, .205, .477, { sk: .077 }],
    0x1D456: [.661, .011, .345, { sk: .074 }],
    0x1D457: [.661, .205, .412, { sk: .153 }],
    0x1D458: [.694, .011, .521, { sk: -.011 }],
    0x1D459: [.694, .011, .298, { sk: .055 }],
    0x1D45A: [.442, .011, .878, { sk: .017 }],
    0x1D45B: [.442, .011, .6, { sk: .025 }],
    0x1D45C: [.442, .011, .485, { sk: .072 }],
    0x1D45D: [.442, .194, .503, { sk: .092 }],
    0x1D45E: [.442, .194, .446, { ic: .006, sk: .053 }],
    0x1D45F: [.442, .011, .451, { sk: .021 }],
    0x1D460: [.442, .011, .469, { sk: .061 }],
    0x1D461: [.626, .011, .361, { sk: .044 }],
    0x1D462: [.442, .011, .572, { sk: .019 }],
    0x1D463: [.442, .011, .485, { sk: .051 }],
    0x1D464: [.442, .011, .716, { sk: .047 }],
    0x1D465: [.442, .011, .572, { sk: .043 }],
    0x1D466: [.442, .205, .49, { sk: .059 }],
    0x1D467: [.442, .011, .465, { ic: .002, sk: .102 }],
    0x1D468: [.711, 0, .869, { sk: .173 }],
    0x1D469: [.686, 0, .866, { sk: .11 }],
    0x1D46A: [.703, .017, .817, { ic: .038, sk: .113 }],
    0x1D46B: [.686, 0, .938, { sk: .063 }],
    0x1D46C: [.68, 0, .81, { ic: .015, sk: .124 }],
    0x1D46D: [.68, 0, .689, { ic: .12, sk: .104 }],
    0x1D46E: [.703, .017, .887, { sk: .102 }],
    0x1D46F: [.686, 0, .982, { ic: .045, sk: .091 }],
    0x1D470: [.686, 0, .511, { ic: .055, sk: .086 }],
    0x1D471: [.686, .017, .631, { ic: .063, sk: .176 }],
    0x1D472: [.686, 0, .971, { ic: .032, sk: .137 }],
    0x1D473: [.686, 0, .756, { sk: .018 }],
    0x1D474: [.686, 0, 1.142, { ic: .074, sk: .086 }],
    0x1D475: [.686, 0, .95, { ic: .077, sk: .083 }],
    0x1D476: [.703, .017, .837, { sk: .11 }],
    0x1D477: [.686, 0, .723, { ic: .126, sk: .07 }],
    0x1D478: [.703, .194, .869, { sk: .093 }],
    0x1D479: [.686, .017, .872, { ic: .009, sk: .1 }],
    0x1D47A: [.703, .017, .693, { ic: .021, sk: .097 }],
    0x1D47B: [.675, 0, .637, { ic: .135, sk: .014 }],
    0x1D47C: [.686, .017, .8, { ic: .077, sk: .06 }],
    0x1D47D: [.686, .017, .678, { ic: .207, sk: .016 }],
    0x1D47E: [.686, .017, 1.093, { ic: .114 }],
    0x1D47F: [.686, 0, .947, { ic: .006, sk: .132 }],
    0x1D480: [.686, 0, .675, { ic: .2, sk: .022 }],
    0x1D481: [.686, 0, .773, { ic: .032, sk: .122 }],
    0x1D482: [.452, .008, .633, { sk: .019 }],
    0x1D483: [.694, .008, .521, { sk: -.035 }],
    0x1D484: [.452, .008, .513, { sk: .101 }],
    0x1D485: [.694, .008, .61, { sk: .219 }],
    0x1D486: [.452, .008, .554, { sk: .063 }],
    0x1D487: [.702, .202, .568, { ic: .058, sk: .169 }],
    0x1D488: [.452, .202, .545, { sk: .067 }],
    0x1D489: [.694, .008, .668, { sk: -.078 }],
    0x1D48A: [.694, .008, .405, { sk: .08 }],
    0x1D48B: [.694, .202, .471, { sk: .163 }],
    0x1D48C: [.694, .008, .604, { sk: -.026 }],
    0x1D48D: [.694, .008, .348, { sk: .074 }],
    0x1D48E: [.452, .008, 1.032, { sk: .06 }],
    0x1D48F: [.452, .008, .713, { sk: .032 }],
    0x1D490: [.452, .008, .585, { sk: .074 }],
    0x1D491: [.452, .194, .601, { sk: .112 }],
    0x1D492: [.452, .194, .542, { ic: .001, sk: .059 }],
    0x1D493: [.452, .008, .529, { sk: .018 }],
    0x1D494: [.452, .008, .531, { sk: .059 }],
    0x1D495: [.643, .008, .415, { sk: .063 }],
    0x1D496: [.452, .008, .681, { sk: .038 }],
    0x1D497: [.453, .008, .567, { sk: .069 }],
    0x1D498: [.453, .008, .831, { sk: .101 }],
    0x1D499: [.452, .008, .659, { sk: .029 }],
    0x1D49A: [.452, .202, .59, { sk: .078 }],
    0x1D49B: [.452, .008, .555, { sk: .076 }],
    0x1D6A4: [.442, .011, .322],
    0x1D6A5: [.442, .205, .384, { sk: .083 }],
    0x1D6A8: [.698, 0, .869],
    0x1D6A9: [.686, 0, .818, { sk: -.075 }],
    0x1D6AA: [.68, 0, .692, { sk: -.019 }],
    0x1D6AB: [.698, 0, .958],
    0x1D6AC: [.68, 0, .756, { sk: -.027 }],
    0x1D6AD: [.686, 0, .703, { sk: .013 }],
    0x1D6AE: [.686, 0, .9],
    0x1D6AF: [.697, .011, .894],
    0x1D6B0: [.686, 0, .436],
    0x1D6B1: [.686, 0, .901, { sk: -.013 }],
    0x1D6B2: [.698, 0, .806],
    0x1D6B3: [.686, 0, 1.092],
    0x1D6B4: [.686, 0, .9],
    0x1D6B5: [.675, 0, .767],
    0x1D6B6: [.697, .011, .864],
    0x1D6B7: [.68, 0, .9],
    0x1D6B8: [.686, 0, .786, { sk: -.063 }],
    0x1D6B9: [.697, .011, .894],
    0x1D6BA: [.686, 0, .831, { sk: -.015 }],
    0x1D6BB: [.675, 0, .8],
    0x1D6BC: [.697, 0, .894],
    0x1D6BD: [.686, 0, .831],
    0x1D6BE: [.686, 0, .869, { sk: -.017 }],
    0x1D6BF: [.686, 0, .894],
    0x1D6C0: [.697, 0, .831],
    0x1D6C1: [.686, .025, .958],
    0x1D6C2: [.452, .008, .743, { ic: .007, sk: .015 }],
    0x1D6C3: [.703, .194, .647],
    0x1D6C4: [.452, .211, .679],
    0x1D6C5: [.718, .008, .551, { sk: -.011 }],
    0x1D6C6: [.461, .017, .597, { sk: -.025 }],
    0x1D6C7: [.703, .202, .615, { sk: -.041 }],
    0x1D6C8: [.452, .211, .615, { sk: -.051 }],
    0x1D6C9: [.702, .008, .567],
    0x1D6CA: [.452, .008, .359, { ic: .004, sk: -.068 }],
    0x1D6CB: [.452, .008, .615, { ic: .004, sk: -.034 }],
    0x1D6CC: [.694, .012, .618, { ic: .048, sk: -.227 }],
    0x1D6CD: [.452, .211, .615, { ic: .004, sk: -.036 }],
    0x1D6CE: [.453, 0, .583, { sk: -.04 }],
    0x1D6CF: [.703, .202, .615, { sk: -.072 }],
    0x1D6D0: [.453, .006, .575],
    0x1D6D1: [.444, .009, .679, { sk: -.011 }],
    0x1D6D2: [.452, .211, .567],
    0x1D6D3: [.452, .105, .551],
    0x1D6D4: [.444, .008, .695],
    0x1D6D5: [.444, .012, .615, { sk: -.035 }],
    0x1D6D6: [.453, .008, .615, { sk: -.019 }],
    0x1D6D7: [.452, .216, .743, { sk: -.015 }],
    0x1D6D8: [.452, .202, .743, { ic: .003, sk: -.063 }],
    0x1D6D9: [.694, .202, .743, { sk: .032 }],
    0x1D6DA: [.453, .008, .743],
    0x1D6DB: [.711, .017, .679],
    0x1D6DC: [.444, .008, .506, { ic: .003, sk: .04 }],
    0x1D6DD: [.702, .008, .615, { sk: .033 }],
    0x1D6DE: [.452, .01, .724, { sk: -.018 }],
    0x1D6DF: [.694, .202, .743],
    0x1D6E0: [.452, .194, .567],
    0x1D6E1: [.444, .008, .966, { sk: -.01 }],
    0x1D6E2: [.716, 0, .75, { sk: .177 }],
    0x1D6E3: [.683, 0, .759, { sk: .077 }],
    0x1D6E4: [.68, 0, .615, { ic: .108, sk: .072 }],
    0x1D6E5: [.716, 0, .833, { sk: .17 }],
    0x1D6E6: [.68, 0, .738, { ic: .028, sk: .092 }],
    0x1D6E7: [.683, 0, .683, { ic: .04, sk: .11 }],
    0x1D6E8: [.683, 0, .831, { ic: .05, sk: .089 }],
    0x1D6E9: [.705, .022, .763, { sk: .117 }],
    0x1D6EA: [.684, .001, .44, { ic: .057, sk: .084 }],
    0x1D6EB: [.684, 0, .849, { ic: .04, sk: .09 }],
    0x1D6EC: [.716, 0, .694, { sk: .17 }],
    0x1D6ED: [.683, 0, .97, { ic: .074, sk: .085 }],
    0x1D6EE: [.683, 0, .803, { ic: .078, sk: .082 }],
    0x1D6EF: [.677, 0, .742, { ic: .035, sk: .097 }],
    0x1D6F0: [.705, .022, .763, { sk: .117 }],
    0x1D6F1: [.68, 0, .831, { ic: .049, sk: .089 }],
    0x1D6F2: [.683, 0, .642, { ic: .112, sk: .049 }],
    0x1D6F3: [.705, .022, .763, { sk: .117 }],
    0x1D6F4: [.683, 0, .78, { ic: .026, sk: .104 }],
    0x1D6F5: [.677, 0, .584, { ic: .12, sk: .012 }],
    0x1D6F6: [.705, 0, .583, { ic: .118 }],
    0x1D6F7: [.683, 0, .667, { sk: .082 }],
    0x1D6F8: [.683, 0, .828, { ic: .023, sk: .097 }],
    0x1D6F9: [.683, 0, .612, { ic: .081, sk: .025 }],
    0x1D6FA: [.705, 0, .772, { ic: .014, sk: .137 }],
    0x1D6FB: [.683, .033, .833],
    0x1D6FC: [.442, .011, .64, { sk: .072 }],
    0x1D6FD: [.706, .194, .566, { ic: .008, sk: .148 }],
    0x1D6FE: [.442, .215, .518, { ic: .025, sk: .111 }],
    0x1D6FF: [.712, .011, .444, { ic: .008, sk: .107 }],
    0x1D700: [.453, .022, .466, { sk: .051 }],
    0x1D701: [.697, .205, .438, { ic: .036, sk: .067 }],
    0x1D702: [.442, .216, .497, { sk: .1 }],
    0x1D703: [.705, .011, .469, { sk: .075 }],
    0x1D704: [.442, .011, .354],
    0x1D705: [.442, .011, .576, { sk: .043 }],
    0x1D706: [.694, .013, .583, { sk: -.053 }],
    0x1D707: [.442, .216, .603, { sk: .048 }],
    0x1D708: [.442, 0, .494, { ic: .03, sk: .028 }],
    0x1D709: [.697, .205, .438, { ic: .008, sk: .06 }],
    0x1D70A: [.442, .011, .485],
    0x1D70B: [.431, .011, .57, { sk: .043 }],
    0x1D70C: [.442, .216, .517, { sk: .096 }],
    0x1D70D: [.442, .108, .363, { ic: .046, sk: .044 }],
    0x1D70E: [.431, .011, .571],
    0x1D70F: [.431, .012, .437, { ic: .074 }],
    0x1D710: [.442, .011, .54, { sk: .036 }],
    0x1D711: [.442, .218, .654, { sk: .028 }],
    0x1D712: [.442, .205, .626, { sk: .018 }],
    0x1D713: [.694, .205, .651, { sk: .143 }],
    0x1D714: [.442, .011, .622, { sk: .034 }],
    0x1D715: [.716, .022, .531, { ic: .035, sk: .069 }],
    0x1D716: [.431, .011, .406, { sk: .066 }],
    0x1D717: [.705, .011, .591, { sk: .116 }],
    0x1D718: [.442, .012, .624, { sk: .053 }],
    0x1D719: [.694, .205, .596, { sk: .125 }],
    0x1D71A: [.442, .194, .517, { sk: .102 }],
    0x1D71B: [.431, .011, .828, { sk: .039 }],
    0x1D71C: [.711, 0, .869, { sk: .174 }],
    0x1D71D: [.686, 0, .866, { sk: .069 }],
    0x1D71E: [.68, 0, .657, { ic: .12, sk: .071 }],
    0x1D71F: [.711, 0, .958, { sk: .168 }],
    0x1D720: [.68, 0, .81, { ic: .015, sk: .098 }],
    0x1D721: [.686, 0, .773, { ic: .032, sk: .117 }],
    0x1D722: [.686, 0, .982, { ic: .045, sk: .09 }],
    0x1D723: [.703, .017, .867, { sk: .108 }],
    0x1D724: [.686, 0, .511, { ic: .055, sk: .085 }],
    0x1D725: [.686, 0, .971, { ic: .032, sk: .093 }],
    0x1D726: [.711, 0, .806, { sk: .167 }],
    0x1D727: [.686, 0, 1.142, { ic: .074, sk: .085 }],
    0x1D728: [.686, 0, .95, { ic: .077, sk: .082 }],
    0x1D729: [.675, 0, .841, { ic: .026, sk: .104 }],
    0x1D72A: [.703, .017, .837, { sk: .111 }],
    0x1D72B: [.68, 0, .982, { ic: .044, sk: .09 }],
    0x1D72C: [.686, 0, .723, { ic: .126, sk: .039 }],
    0x1D72D: [.703, .017, .867, { sk: .108 }],
    0x1D72E: [.686, 0, .885, { ic: .019, sk: .108 }],
    0x1D72F: [.675, 0, .637, { ic: .135, sk: .01 }],
    0x1D730: [.703, 0, .671, { ic: .131 }],
    0x1D731: [.686, 0, .767, { sk: .08 }],
    0x1D732: [.686, 0, .947, { ic: .006, sk: .106 }],
    0x1D733: [.686, 0, .714, { ic: .078, sk: .029 }],
    0x1D734: [.703, 0, .879, { ic: .007, sk: .135 }],
    0x1D735: [.686, .025, .958],
    0x1D736: [.452, .008, .761, { sk: .059 }],
    0x1D737: [.703, .194, .66, { sk: .153 }],
    0x1D738: [.452, .211, .59, { ic: .027, sk: -.02 }],
    0x1D739: [.718, .008, .522, { sk: .115 }],
    0x1D73A: [.461, .017, .529, { sk: .058 }],
    0x1D73B: [.703, .202, .508, { ic: .014, sk: .083 }],
    0x1D73C: [.452, .211, .6, { sk: .019 }],
    0x1D73D: [.702, .008, .562, { sk: .062 }],
    0x1D73E: [.452, .008, .412],
    0x1D73F: [.452, .008, .668, { sk: .025 }],
    0x1D740: [.694, .012, .671, { sk: -.072 }],
    0x1D741: [.452, .211, .708, { sk: .042 }],
    0x1D742: [.453, 0, .577, { ic: .026, sk: .028 }],
    0x1D743: [.703, .202, .508, { sk: .061 }],
    0x1D744: [.452, .008, .585],
    0x1D745: [.444, .009, .682, { sk: .046 }],
    0x1D746: [.452, .211, .612, { sk: .1 }],
    0x1D747: [.452, .105, .424, { ic: .038, sk: -.029 }],
    0x1D748: [.444, .008, .686],
    0x1D749: [.444, .012, .521, { ic: .083 }],
    0x1D74A: [.453, .008, .631, { sk: .037 }],
    0x1D74B: [.452, .216, .747, { sk: .033 }],
    0x1D74C: [.452, .202, .718, { sk: .011 }],
    0x1D74D: [.694, .202, .758, { sk: .151 }],
    0x1D74E: [.453, .008, .718, { sk: .039 }],
    0x1D74F: [.711, .017, .628, { ic: .029, sk: .079 }],
    0x1D750: [.444, .008, .483, { sk: .074 }],
    0x1D751: [.702, .008, .692, { sk: .119 }],
    0x1D752: [.452, .01, .724, { sk: .053 }],
    0x1D753: [.694, .202, .713, { sk: .126 }],
    0x1D754: [.452, .194, .612, { sk: .094 }],
    0x1D755: [.444, .008, .975, { sk: .043 }],
    0x1D7CA: [.68, 0, .783],
    0x1D7CB: [.445, .267, .628],
    0x1D7CE: [.655, .011, .575],
    0x1D7CF: [.655, 0, .575],
    0x1D7D0: [.655, 0, .575, { sk: -.011 }],
    0x1D7D1: [.655, .011, .575],
    0x1D7D2: [.656, 0, .575, { sk: .127 }],
    0x1D7D3: [.655, .011, .575],
    0x1D7D4: [.655, .011, .575, { sk: .048 }],
    0x1D7D5: [.676, .011, .575, { sk: -.164 }],
    0x1D7D6: [.655, .011, .575, { sk: .011 }],
    0x1D7D7: [.655, .011, .575]
};
//# sourceMappingURL=normal.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/bold.js
const bold = {
    0x20: [0, 0, .383],
    0x21: [.705, 0, .35],
    0x22: [.697, -.418, .481],
    0x23: [.694, .194, .958],
    0x24: [.75, .056, .575],
    0x25: [.75, .056, .958],
    0x26: [.705, .011, .894],
    0x27: [.697, -.418, .319],
    0x28: [.75, .249, .447],
    0x29: [.75, .249, .447],
    0x2A: [.75, -.306, .575],
    0x2B: [.633, .132, .894],
    0x2C: [.156, .194, .319],
    0x2D: [.271, -.174, .383],
    0x2E: [.156, 0, .319],
    0x2F: [.75, .25, .575],
    0x3A: [.444, 0, .319],
    0x3B: [.444, .194, .319],
    0x3C: [.587, .086, .894],
    0x3D: [.393, -.108, .894],
    0x3E: [.587, .086, .894],
    0x3F: [.7, 0, .543],
    0x40: [.7, .006, .894],
    0x5B: [.75, .25, .319],
    0x5C: [.75, .25, .575],
    0x5D: [.75, .25, .319],
    0x5E: [.744, -.562, .556, { ic: .005 }],
    0x5F: [-.101, .189, .869],
    0x60: [.704, -.509, .575],
    0x7B: [.75, .25, .575],
    0x7C: [.76, .26, .319],
    0x7D: [.75, .25, .575],
    0x7E: [.311, -.189, .556, { ic: .001 }],
    0xA0: [0, 0, .575],
    0xA3: [.686, .031, .869],
    0xA5: [.686, 0, .869],
    0xA7: [.712, .212, .695],
    0xA8: [.677, -.537, .575],
    0xAC: [.403, -.098, .894],
    0xAF: [.633, -.581, .575],
    0xB0: [.686, -.367, .431],
    0xB1: [.693, 0, .894],
    0xB4: [.704, -.509, .575],
    0xB5: [.45, .194, .639],
    0xB6: [.694, .194, .703],
    0xB7: [.396, -.24, .278],
    0xD7: [.543, .042, .894],
    0xF0: [.702, .006, .575],
    0xF7: [.582, .08, .894],
    0x131: [.45, 0, .319],
    0x237: [.45, .2, .351],
    0x2C6: [.71, -.503, .575],
    0x2C7: [.71, -.503, .575],
    0x2C9: [.633, -.581, .575],
    0x2CA: [.704, -.509, .575],
    0x2CB: [.704, -.509, .575],
    0x2CD: [-.247, .307, .383, { ic: .029 }],
    0x2D8: [.7, -.513, .575],
    0x2D9: [.685, -.529, .319],
    0x2DA: [.714, -.492, .338],
    0x2DC: [.661, -.553, .575],
    0x2FF: [-.035, .286, 0, { dx: .287 }],
    0x300: [.704, -.509, 0, { dx: .317 }],
    0x301: [.704, -.509, 0, { dx: .242 }],
    0x302: [.71, -.503, 0, { dx: .279 }],
    0x303: [.661, -.553, 0, { dx: .279 }],
    0x304: [.633, -.581, 0, { dx: .279 }],
    0x305: [.697, -.636, .894],
    0x306: [.7, -.513, 0, { dx: .279 }],
    0x307: [.685, -.529, 0, { dx: .279 }],
    0x308: [.677, -.537, 0, { dx: .28 }],
    0x30A: [.764, -.542, 0, { dx: .28 }],
    0x30C: [.71, -.503, 0, { dx: .279 }],
    0x338: [.748, .249, 0],
    0x3D2: [.697, 0, .87],
    0x3F6: [.442, .011, .43],
    0x2000: [0, 0, .575],
    0x2001: [0, 0, 1.15],
    0x2002: [0, 0, .575],
    0x2003: [0, 0, 1.15],
    0x2004: [0, 0, .383],
    0x2005: [0, 0, .288],
    0x2006: [0, 0, .192],
    0x2007: [0, 0, .575],
    0x2008: [0, 0, .319],
    0x2009: [0, 0, .23],
    0x200A: [0, 0, .032],
    0x200B: [0, 0, 0],
    0x2010: [.271, -.174, .383],
    0x2011: [.271, -.174, .383],
    0x2012: [.312, -.236, .575],
    0x2013: [.312, -.236, .575],
    0x2014: [.312, -.236, 1.15],
    0x2016: [.75, .25, .499],
    0x2018: [.694, -.344, .319],
    0x2019: [.694, -.344, .319],
    0x201C: [.694, -.344, .571],
    0x201D: [.694, -.344, .571],
    0x2020: [.702, .211, .511],
    0x2021: [.702, .202, .511],
    0x2026: [.156, 0, .838],
    0x2044: [.696, .01, .648],
    0x20A4: [.686, .031, .869],
    0x20AC: [.697, .011, .72],
    0x2126: [.697, 0, .831],
    0x2127: [.686, .011, .831],
    0x2190: [.5, 0, 1.15],
    0x2191: [.694, .204, .575],
    0x2192: [.5, 0, 1.15],
    0x2193: [.704, .194, .575],
    0x2197: [.725, 0, .894],
    0x2198: [.694, .031, .894],
    0x2206: [.698, 0, 1.028],
    0x2212: [.281, -.22, .894],
    0x221A: [.757, .094, .543, { ic: .064 }],
    0x221E: [.47, .026, 1.15],
    0x2222: [.634, .132, .894],
    0x22C6: [.501, -.001, .575],
    0x2322: [.365, -.15, .894],
    0x2329: [.751, .25, .447],
    0x232A: [.751, .25, .447],
    0x25CB: [.761, .261, 1.277],
    0x25E6: [.381, -.077, .894],
    0x27E6: [.751, .249, .463],
    0x27E7: [.751, .249, .463]
};
//# sourceMappingURL=bold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/italic.js
const italic = {
    0x20: [0, 0, .358],
    0x21: [.716, 0, .307, { ic: .068 }],
    0x22: [.705, -.423, .401, { ic: .048 }],
    0x23: [.694, .194, .818, { ic: .01 }],
    0x24: [.75, .056, .5, { ic: .091 }],
    0x25: [.75, .056, .818, { ic: .028 }],
    0x26: [.716, .022, .767, { ic: .037 }],
    0x27: [.705, -.423, .307, { ic: .048 }],
    0x28: [.75, .25, .409, { ic: .107 }],
    0x29: [.75, .25, .409],
    0x2A: [.75, -.319, .511, { ic: .072 }],
    0x2B: [.557, .057, .767],
    0x2C: [.106, .193, .307],
    0x2D: [.243, -.187, .358],
    0x2E: [.106, 0, .307],
    0x2F: [.75, .25, .511, { ic: .105 }],
    0x30: [.666, .022, .511, { ic: .044 }],
    0x31: [.666, 0, .511],
    0x32: [.666, .022, .511, { ic: .04 }],
    0x33: [.666, .022, .511, { ic: .051 }],
    0x34: [.666, .194, .511],
    0x35: [.665, .022, .511, { ic: .056 }],
    0x36: [.666, .022, .511, { ic: .057 }],
    0x37: [.666, .022, .511, { ic: .114 }],
    0x38: [.666, .022, .511, { ic: .043 }],
    0x39: [.666, .022, .511, { ic: .042 }],
    0x3A: [.431, 0, .307],
    0x3B: [.431, .193, .307],
    0x3C: [.54, .04, .778, { ic: .049 }],
    0x3D: [.367, -.133, .767, { ic: .01 }],
    0x3E: [.54, .04, .778],
    0x3F: [.716, 0, .511, { ic: .04 }],
    0x40: [.705, .011, .767, { ic: .022 }],
    0x5B: [.75, .25, .307, { ic: .139 }],
    0x5C: [.75, .25, .5],
    0x5D: [.75, .25, .307, { ic: .052 }],
    0x5E: [.745, -.561, .556, { ic: .153 }],
    0x5F: [-.11, .14, .743],
    0x60: [.696, -.505, .511],
    0x7B: [.75, .25, .5, { ic: .113 }],
    0x7C: [.75, .25, .278, { ic: .066 }],
    0x7D: [.75, .25, .5],
    0x7E: [.309, -.191, .556, { ic: .072 }],
    0xA0: [0, 0, .511],
    0xA8: [.649, -.553, .511, { ic: .032 }],
    0xAF: [.616, -.586, .511, { ic: .061 }],
    0xB0: [.683, -.428, .383, { ic: .079 }],
    0xB4: [.696, -.505, .511, { ic: .028 }],
    0x131: [.442, .011, .322],
    0x237: [.442, .205, .384, { sk: .083 }],
    0x2C6: [.686, -.509, .511, { ic: .024 }],
    0x2C7: [.692, -.515, .511, { ic: .061 }],
    0x2C9: [.616, -.586, .511, { ic: .061 }],
    0x2CA: [.696, -.505, .511, { ic: .028 }],
    0x2CB: [.696, -.505, .511],
    0x2D8: [.686, -.516, .511, { ic: .052 }],
    0x2D9: [.654, -.548, .307, { ic: .051 }],
    0x2DA: [.705, -.529, .831],
    0x2DC: [.651, -.55, .511, { ic: .057 }],
    0x2FF: [-.025, .275, 0, { dx: .275 }],
    0x300: [.696, -.505, 0, { dx: .136 }],
    0x301: [.696, -.505, 0, { dx: .077 }],
    0x302: [.686, -.509, 0, { dx: .123 }],
    0x303: [.651, -.55, 0, { dx: .105 }],
    0x304: [.616, -.586, 0, { dx: .105 }],
    0x305: [.681, -.641, .766, { ic: .062 }],
    0x306: [.686, -.516, 0, { dx: .089 }],
    0x307: [.654, -.548, 0, { dx: .105 }],
    0x308: [.649, -.553, 0, { dx: .096 }],
    0x30A: [.705, -.529, 0, { dx: .101 }],
    0x30C: [.692, -.515, 0, { dx: .086 }],
    0x338: [.748, .248, 0],
    0x3D2: [.722, 0, .778, { ic: .007 }],
    0x3F6: [.442, .011, .43],
    0x2000: [0, 0, .511],
    0x2001: [0, 0, 1.022],
    0x2002: [0, 0, .511],
    0x2003: [0, 0, 1.022],
    0x2004: [0, 0, .341],
    0x2005: [0, 0, .256],
    0x2006: [0, 0, .17],
    0x2007: [0, 0, .511],
    0x2008: [0, 0, .307],
    0x2009: [0, 0, .204],
    0x200A: [0, 0, .026],
    0x200B: [0, 0, 0],
    0x2010: [.243, -.187, .358, { ic: .001 }],
    0x2011: [.243, -.187, .358, { ic: .001 }],
    0x2012: [.277, -.255, .511, { ic: .04 }],
    0x2013: [.277, -.255, .511, { ic: .04 }],
    0x2014: [.277, -.255, 1.022, { ic: .014 }],
    0x2016: [.75, .25, .398, { ic: .066 }],
    0x2018: [.693, -.394, .307, { ic: .053 }],
    0x2019: [.694, -.395, .307, { ic: .066 }],
    0x201C: [.693, -.394, .49, { ic: .053 }],
    0x201D: [.694, -.395, .49, { ic: .064 }],
    0x2026: [.106, 0, .684],
    0x2044: [.683, 0, .603, { ic: .093 }],
    0x20A4: [.683, .032, .743, { ic: .003 }],
    0x20AC: [.705, .022, .576, { ic: .126 }],
    0x2126: [.705, 0, .716, { ic: .043 }],
    0x2127: [.684, .021, .716, { ic: .071 }],
    0x2190: [.512, .011, .971],
    0x2191: [.694, .195, .512, { ic: .07 }],
    0x2192: [.513, .01, .971],
    0x2193: [.695, .194, .512],
    0x2206: [.716, 0, .833],
    0x2212: [.27, -.23, .767],
    0x221A: [.735, .104, .46, { ic: .226 }],
    0x221E: [.456, .025, .92, { ic: .022 }],
    0x2222: [.557, .057, .767, { ic: .047 }],
    0x22C6: [.483, -.019, .511, { ic: .063 }],
    0x2329: [.751, .249, .409, { ic: .105 }],
    0x232A: [.751, .249, .409],
    0x25CB: [.772, .272, 1.073, { ic: .003 }],
    0x25E6: [.379, -.081, .767],
    0x27E6: [.751, .249, .422, { ic: .138 }],
    0x27E7: [.751, .249, .422, { ic: .052 }]
};
//# sourceMappingURL=italic.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/bold-italic.js
const boldItalic = {
    0x20: [0, 0, .414],
    0x21: [.711, 0, .386, { ic: .044 }],
    0x22: [.703, -.422, .518, { ic: .048 }],
    0x23: [.694, .194, .944],
    0x24: [.75, .056, .575, { ic: .079 }],
    0x25: [.75, .056, .944, { ic: .002 }],
    0x26: [.711, .017, .886, { ic: .011 }],
    0x27: [.703, -.422, .356, { ic: .048 }],
    0x28: [.75, .249, .473, { ic: .094 }],
    0x29: [.75, .249, .473],
    0x2A: [.75, -.306, .591, { ic: .057 }],
    0x2B: [.603, .102, .886],
    0x2C: [.147, .194, .356],
    0x2D: [.269, -.175, .414],
    0x2E: [.147, 0, .356],
    0x2F: [.75, .25, .591, { ic: .09 }],
    0x30: [.661, .017, .591, { ic: .045 }],
    0x31: [.661, 0, .591],
    0x32: [.661, .017, .591, { ic: .027 }],
    0x33: [.661, .017, .591, { ic: .037 }],
    0x34: [.661, .194, .591],
    0x35: [.661, .017, .591, { ic: .037 }],
    0x36: [.661, .017, .591, { ic: .037 }],
    0x37: [.661, .017, .591, { ic: .115 }],
    0x38: [.661, .017, .591, { ic: .027 }],
    0x39: [.661, .017, .591, { ic: .03 }],
    0x3A: [.444, 0, .356],
    0x3B: [.444, .194, .356],
    0x3C: [.587, .086, .894, { ic: .046 }],
    0x3D: [.393, -.108, .886],
    0x3E: [.587, .086, .894],
    0x3F: [.711, 0, .591, { ic: .023 }],
    0x40: [.702, .008, .886, { ic: .01 }],
    0x5B: [.75, .25, .356, { ic: .129 }],
    0x5C: [.75, .25, .575],
    0x5D: [.75, .25, .356, { ic: .036 }],
    0x5E: [.744, -.562, .556, { ic: .151 }],
    0x5F: [-.097, .153, .866],
    0x60: [.699, -.502, .591],
    0x7B: [.75, .25, .575, { ic: .109 }],
    0x7C: [.75, .25, .319, { ic: .059 }],
    0x7D: [.75, .25, .575],
    0x7E: [.307, -.193, .556, { ic: .071 }],
    0xA0: [0, 0, .591],
    0xA8: [.667, -.535, .591, { ic: .045 }],
    0xAF: [.626, -.576, .591, { ic: .047 }],
    0xB0: [.686, -.392, .443, { ic: .081 }],
    0xB4: [.699, -.502, .591, { ic: .005 }],
    0x131: [.452, .008, .394, { sk: -.012 }],
    0x237: [.452, .202, .439, { sk: .063 }],
    0x2C6: [.704, -.497, .591, { ic: .012 }],
    0x2C7: [.704, -.497, .591, { ic: .052 }],
    0x2C9: [.626, -.576, .591, { ic: .047 }],
    0x2CA: [.699, -.502, .591, { ic: .005 }],
    0x2CB: [.699, -.502, .591],
    0x2CD: [-.247, .307, .383, { ic: .032 }],
    0x2D8: [.69, -.511, .591, { ic: .037 }],
    0x2D9: [.674, -.527, .356, { ic: .048 }],
    0x2DA: [.702, -.534, .949],
    0x2DC: [.66, -.541, .591, { ic: .042 }],
    0x2FF: [-.035, .286, 0, { dx: .272 }],
    0x300: [.699, -.502, 0, { dx: .188 }],
    0x301: [.699, -.502, 0, { dx: .113 }],
    0x302: [.704, -.497, 0, { dx: .165 }],
    0x303: [.66, -.541, 0, { dx: .145 }],
    0x304: [.626, -.576, 0, { dx: .145 }],
    0x305: [.708, -.647, .885, { ic: .049 }],
    0x306: [.69, -.511, 0, { dx: .13 }],
    0x307: [.674, -.527, 0, { dx: .144 }],
    0x308: [.667, -.535, 0, { dx: .145 }],
    0x30A: [.702, -.534, 0, { dx: .141 }],
    0x30C: [.704, -.497, 0, { dx: .124 }],
    0x338: [.749, .249, 0],
    0x3D2: [.697, 0, .87, { ic: .103 }],
    0x3F6: [.442, .011, .43, { ic: .04 }],
    0x2000: [0, 0, .591],
    0x2001: [0, 0, 1.182],
    0x2002: [0, 0, .591],
    0x2003: [0, 0, 1.182],
    0x2004: [0, 0, .394],
    0x2005: [0, 0, .296],
    0x2006: [0, 0, .197],
    0x2007: [0, 0, .591],
    0x2008: [0, 0, .355],
    0x2009: [0, 0, .236],
    0x200A: [0, 0, .029],
    0x200B: [0, 0, 0],
    0x2010: [.269, -.175, .414],
    0x2011: [.269, -.175, .414],
    0x2012: [.293, -.257, .591, { ic: .036 }],
    0x2013: [.292, -.256, .591, { ic: .037 }],
    0x2014: [.292, -.256, 1.182, { ic: .006 }],
    0x2016: [.75, .25, .499, { ic: .059 }],
    0x2018: [.694, -.353, .356, { ic: .037 }],
    0x2019: [.694, -.353, .356, { ic: .059 }],
    0x201C: [.694, -.353, .59, { ic: .038 }],
    0x201D: [.694, -.353, .59, { ic: .059 }],
    0x2026: [.147, 0, .842],
    0x2044: [.696, .01, .713, { ic: .08 }],
    0x20A4: [.686, .031, .866, { ic: .008 }],
    0x20AC: [.703, .017, .664, { ic: .115 }],
    0x2126: [.703, 0, .827, { ic: .031 }],
    0x2127: [.686, .017, .827, { ic: .056 }],
    0x2190: [.518, .017, 1.121],
    0x2191: [.694, .204, .592, { ic: .069 }],
    0x2192: [.518, .017, 1.121],
    0x2193: [.704, .194, .592],
    0x2206: [.699, 0, 1.028],
    0x2212: [.281, -.22, .886],
    0x221A: [.757, .094, .531, { ic: .243 }],
    0x221E: [.473, .029, 1.06, { ic: .044 }],
    0x2222: [.604, .102, .886, { ic: .035 }],
    0x22C6: [.501, -.001, .591, { ic: .048 }],
    0x2329: [.75, .25, .473, { ic: .09 }],
    0x232A: [.751, .25, .473],
    0x25CB: [.772, .272, 1.239],
    0x25E6: [.386, -.072, .886],
    0x27E6: [.751, .249, .488, { ic: .129 }],
    0x27E7: [.751, .249, .488, { ic: .037 }]
};
//# sourceMappingURL=bold-italic.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/double-struck.js
const doubleStruck = {};
//# sourceMappingURL=double-struck.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/fraktur.js
const fraktur = {};
//# sourceMappingURL=fraktur.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/fraktur-bold.js
const frakturBold = {};
//# sourceMappingURL=fraktur-bold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/sans-serif.js
const sansSerif = {
    0x2CD: [-.208, .286, .333, { ic: .038 }],
    0x2FF: [-.023, .277, 0, { dx: .274 }],
    0x338: [.749, .25, 0],
    0x2000: [0, 0, .5],
    0x2001: [0, 0, 1],
    0x2002: [0, 0, .5],
    0x2003: [0, 0, 1],
    0x2004: [0, 0, .333],
    0x2005: [0, 0, .25],
    0x2006: [0, 0, .167],
    0x2007: [0, 0, .5],
    0x2008: [0, 0, .278],
    0x2009: [0, 0, .2],
    0x200A: [0, 0, .028],
    0x200B: [0, 0, 0],
    0x20A4: [.694, .022, .667],
    0x2197: [.718, -.001, .778],
    0x2198: [.694, .024, .778],
    0x2206: [.694, 0, .833],
    0x22C6: [.491, .006, .5, { ic: .023 }],
    0x2322: [.363, -.133, .778],
    0x25CB: [.772, .272, 1.111]
};
//# sourceMappingURL=sans-serif.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/sans-serif-bold.js
const sansSerifBold = {
    0x2CD: [-.253, .389, .367, { ic: .067 }],
    0x2FF: [-.025, .319, 0, { dx: .294 }],
    0x338: [.759, .257, 0],
    0x2000: [0, 0, .55],
    0x2001: [0, 0, 1.1],
    0x2002: [0, 0, .55],
    0x2003: [0, 0, 1.1],
    0x2004: [0, 0, .367],
    0x2005: [0, 0, .275],
    0x2006: [0, 0, .183],
    0x2007: [0, 0, .55],
    0x2008: [0, 0, .305],
    0x2009: [0, 0, .22],
    0x200A: [0, 0, .031],
    0x200B: [0, 0, 0],
    0x20A4: [.694, .047, .733],
    0x2197: [.734, .023, .856],
    0x2198: [.72, .037, .856],
    0x2206: [.694, 0, .916],
    0x22C6: [.519, .031, .55, { ic: .015 }],
    0x2322: [.381, -.095, .856],
    0x25CB: [.772, .272, 1.222]
};
//# sourceMappingURL=sans-serif-bold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/sans-serif-italic.js
const sansSerifItalic = {
    0x2CD: [-.208, .286, .333],
    0x2FF: [-.023, .277, 0, { dx: .272 }],
    0x338: [.749, .25, 0],
    0x2000: [0, 0, .5],
    0x2001: [0, 0, .5],
    0x2002: [0, 0, .333],
    0x2003: [0, 0, .25],
    0x2004: [0, 0, .167],
    0x2005: [0, 0, .5],
    0x2006: [0, 0, .278],
    0x2007: [0, 0, .2],
    0x2008: [0, 0, .028],
    0x2009: [0, 0, 0],
    0x200A: [0, 0, 0],
    0x200B: [0, 0, 0],
    0x20A4: [.694, .022, .667],
    0x2197: [.718, -.001, .778, { ic: .095 }],
    0x2198: [.694, .025, .778, { ic: .029 }],
    0x2206: [.694, 0, .833],
    0x22C6: [.515, .008, .5, { ic: .09 }],
    0x2322: [.364, -.133, .778],
    0x25CB: [.772, .272, 1.111, { ic: .008 }]
};
//# sourceMappingURL=sans-serif-italic.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/sans-serif-bold-italic.js
const sansSerifBoldItalic = {
    0x2CD: [-.253, .389, .367, { ic: .003 }],
    0x2FF: [-.025, .319, 0, { dx: .327 }],
    0x338: [.759, .257, 0],
    0x2000: [0, 0, .55],
    0x2001: [0, 0, 1.1],
    0x2002: [0, 0, .55],
    0x2003: [0, 0, 1.1],
    0x2004: [0, 0, .367],
    0x2005: [0, 0, .275],
    0x2006: [0, 0, .183],
    0x2007: [0, 0, .55],
    0x2008: [0, 0, .305],
    0x2009: [0, 0, .22],
    0x200A: [0, 0, .031],
    0x200B: [0, 0, 0],
    0x20A4: [.694, .047, .733],
    0x2197: [.734, .023, .856, { ic: .086 }],
    0x2198: [.72, .037, .856, { ic: .049 }],
    0x2206: [.694, 0, .916],
    0x22C6: [.519, .031, .55, { ic: .076 }],
    0x2322: [.381, -.095, .856],
    0x25CB: [.772, .272, 1.222, { ic: .046 }]
};
//# sourceMappingURL=sans-serif-bold-italic.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/monospace.js
const monospace = {
    0x2CD: [-.025, .095, .525, { ic: .035 }],
    0x2FF: [-.008, .359, .525],
    0x338: [.694, .083, .525],
    0x2001: [0, 0, .525],
    0x2003: [0, 0, .525],
    0x2007: [0, 0, .525],
    0x2008: [0, 0, .525],
    0x20A4: [.611, .011, .525],
    0x2197: [.619, 0, .525, { ic: .035 }],
    0x2198: [.611, .008, .525, { ic: .035 }],
    0x2206: [.651, 0, .525],
    0x22C6: [.555, -.057, .525],
    0x2322: [.414, -.195, .525],
    0x25CB: [.705, .233, .525, { ic: .075 }],
    0xFB07: [0, 0, .525]
};
//# sourceMappingURL=monospace.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/smallop.js
const smallop = {
    0x28: [.797, .297, .422],
    0x29: [.797, .297, .422],
    0x2F: [.905, .405, .617],
    0x5B: [.8, .3, .34],
    0x5C: [.905, .405, .617],
    0x5D: [.8, .3, .34],
    0x7B: [.801, .301, .54],
    0x7D: [.801, .301, .54],
    0x302: [.746, -.571, .644, { ic: .001 }],
    0x303: [.751, -.55, .652],
    0x305: [.67, -.63, .568],
    0x306: [.743, -.578, .658, { ic: .001 }],
    0x30C: [.741, -.566, .644, { ic: .001 }],
    0x2044: [.905, .405, .617],
    0x20D0: [.711, -.601, .667],
    0x20D1: [.711, -.601, .667],
    0x20D6: [.711, -.521, .659],
    0x20D7: [.711, -.521, .659],
    0x20E1: [.711, -.521, .715],
    0x20EC: [-.171, .281, .667],
    0x20ED: [-.171, .281, .667],
    0x20EE: [-.091, .281, .659],
    0x20EF: [-.091, .281, .659],
    0x2215: [.605, .105, .572],
    0x2216: [.605, .105, .572],
    0x221A: [.85, .35, 1, { ic: .02 }],
    0x2223: [.851, .351, .333],
    0x2225: [.851, .351, .555],
    0x2308: [.8, .3, .458],
    0x2309: [.8, .3, .458],
    0x230A: [.8, .3, .458],
    0x230B: [.8, .3, .458],
    0x23B4: [.73, -.546, .735],
    0x23B5: [-.116, .3, .735],
    0x23DC: [.745, -.54, 1.006],
    0x23DD: [-.11, .315, 1.006],
    0x23DE: [.815, -.509, .993, { ic: .001 }],
    0x23DF: [-.079, .385, .993],
    0x23E0: [.853, -.613, 1.048, { ic: .006 }],
    0x23E1: [-.183, .423, 1.048, { ic: .006 }],
    0x27E6: [.8, .3, .444],
    0x27E7: [.8, .3, .444],
    0x27E8: [.8, .3, .428],
    0x27E9: [.8, .3, .428],
    0x27EA: [.8, .3, .623],
    0x27EB: [.8, .3, .623],
    0x27EE: [.813, .313, .305],
    0x27EF: [.813, .313, .305],
    0x2983: [.801, .301, .54],
    0x2984: [.801, .301, .54],
    0x2985: [.797, .297, .422],
    0x2986: [.797, .297, .422],
    0x29FC: [.791, .291, .422],
    0x29FD: [.791, .291, .422],
    0x1EEF0: [.72, .017, 1.953, { sk: -.102 }],
    0x1EEF1: [.708, .035, 2.524]
};
//# sourceMappingURL=smallop.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/largeop.js
const largeop = {
    0x28: [.847, .347, .458],
    0x29: [.847, .347, .458],
    0x2F: [1.108, .608, .768],
    0x5B: [.85, .35, .417],
    0x5C: [1.108, .608, .768],
    0x5D: [.85, .35, .417],
    0x7B: [.85, .35, .583],
    0x7D: [.85, .35, .583],
    0x302: [.746, -.571, .768, { ic: .001 }],
    0x303: [.753, -.548, .778],
    0x306: [.743, -.578, .784, { ic: .001 }],
    0x30C: [.741, -.566, .768, { ic: .001 }],
    0x2044: [1.108, .608, .768],
    0x2140: [.95, .45, 1.353, { sk: .067 }],
    0x220F: [.95, .45, 1.278],
    0x2210: [.95, .45, 1.278],
    0x2211: [.95, .45, 1.444],
    0x2215: [.608, .107, .577],
    0x2216: [.608, .107, .577],
    0x221A: [1.15, .651, 1, { ic: .02 }],
    0x2223: [.971, .471, .333],
    0x2225: [.971, .471, .555],
    0x222B: [1.361, .861, .669, { ic: 0.33 }],
    0x222C: [1.361, .861, 1.089, { ic: 0.33 }],
    0x222D: [1.361, .861, 1.509, { ic: 0.33 }],
    0x222E: [1.361, .861, .669, { ic: 0.33 }],
    0x222F: [1.361, .861, 1.089, { ic: 0.33 }],
    0x2230: [1.361, .861, 1.509, { ic: 0.33 }],
    0x2231: [1.361, .861, .669, { ic: 0.33 }],
    0x2232: [1.361, .861, .669, { ic: 0.33 }],
    0x2233: [1.361, .861, .669, { ic: 0.33 }],
    0x22C0: [.958, .456, 1.111],
    0x22C1: [.956, .458, 1.111],
    0x22C2: [.939, .417, 1.111],
    0x22C3: [.917, .439, 1.111],
    0x2308: [.85, .35, .472],
    0x2309: [.85, .35, .472],
    0x230A: [.85, .35, .472],
    0x230B: [.85, .35, .472],
    0x23B4: [.735, -.541, 1.11],
    0x23B5: [-.111, .305, 1.11],
    0x23DC: [.761, -.511, 1.508],
    0x23DD: [-.081, .331, 1.508],
    0x23DE: [.818, -.509, 1.494],
    0x23DF: [-.078, .387, 1.494],
    0x23E0: [.854, -.612, 1.55, { ic: .006 }],
    0x23E1: [-.182, .424, 1.55, { ic: .006 }],
    0x27A1: [.469, -.031, 1.423],
    0x27D5: [.621, .006, .888, { sk: .09 }],
    0x27D6: [.621, .006, .888, { sk: -.07 }],
    0x27D7: [.621, .006, 1.03],
    0x27E6: [.85, .35, .48],
    0x27E7: [.85, .35, .48],
    0x27E8: [.85, .35, .472],
    0x27E9: [.85, .35, .472],
    0x27EA: [.85, .35, .682],
    0x27EB: [.85, .35, .682],
    0x27EE: [.864, .364, .323],
    0x27EF: [.864, .364, .323],
    0x2983: [.85, .35, .583],
    0x2984: [.85, .35, .583],
    0x2985: [.847, .347, .458],
    0x2986: [.847, .347, .458],
    0x29F8: [1.239, .677, .597, { ic: .053 }],
    0x29F9: [1.239, .677, .5, { ic: .15 }],
    0x29FC: [.842, .342, .422],
    0x29FD: [.842, .342, .422],
    0x2A00: [.902, .402, 1.511],
    0x2A01: [.902, .402, 1.511],
    0x2A02: [.902, .402, 1.511],
    0x2A03: [.917, .439, 1.111],
    0x2A04: [.917, .439, 1.111],
    0x2A05: [.936, .436, 1.111],
    0x2A06: [.936, .436, 1.111],
    0x2A07: [1.225, .693, 1.945, { sk: .015 }],
    0x2A08: [1.23, .681, 1.945],
    0x2A09: [.88, .38, 1.371],
    0x2A0A: [.95, .45, 1.474, { sk: -.011 }],
    0x2A0B: [1.361, .861, 1.056],
    0x2A0C: [1.361, .861, 1.929, { ic: 0.33 }],
    0x2A0D: [1.361, .861, .669, { ic: 0.33 }],
    0x2A0E: [1.361, .861, .669, { ic: 0.33 }],
    0x2A0F: [1.361, .861, .669, { ic: 0.33 }],
    0x2A10: [1.361, .861, .669, { ic: 0.33 }],
    0x2A11: [1.361, .861, .669, { ic: 0.33 }],
    0x2A12: [1.361, .861, .669, { ic: 0.33 }],
    0x2A13: [1.361, .861, .669, { ic: 0.33 }],
    0x2A14: [1.361, .861, .669, { ic: 0.33 }],
    0x2A15: [1.361, .861, .669, { ic: 0.33 }],
    0x2A16: [1.361, .861, .669, { ic: 0.33 }],
    0x2A17: [1.361, .861, .669, { ic: 0.33 }],
    0x2A18: [1.361, .861, .669, { ic: 0.33 }],
    0x2A19: [1.361, .861, .849, { ic: 0.15 }],
    0x2A1A: [1.361, .861, .849, { ic: 0.15 }],
    0x2A1B: [1.602, .861, .763, { ic: 0.44 }],
    0x2A1C: [1.361, 1.124, .789, { ic: 0.33 }],
    0x2A1D: [.921, .151, 1.291],
    0x2A1E: [.885, .188, 1.046, { sk: .083 }],
    0x2A20: [.774, .081, 1.52],
    0x2A21: [.976, .284, .784],
    0x2AFC: [1.237, .677, .694],
    0x2AFF: [1.237, .677, .478]
};
//# sourceMappingURL=largeop.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/size3.js
const size3 = {
    0x28: [.972, .472, .523],
    0x29: [.972, .472, .523],
    0x2F: [1.374, .874, .964],
    0x5B: [.975, .475, .444],
    0x5C: [1.374, .874, .964],
    0x5D: [.975, .475, .444],
    0x7B: [.975, .475, .624],
    0x7D: [.975, .475, .624],
    0x302: [.747, -.571, .919, { ic: .001 }],
    0x303: [.757, -.543, .931],
    0x306: [.743, -.577, .937, { ic: .001 }],
    0x30C: [.741, -.565, .919, { ic: .001 }],
    0x2044: [1.374, .874, .964],
    0x2215: [.61, .109, .581],
    0x2216: [.61, .109, .581],
    0x221A: [1.45, .951, 1, { ic: .02 }],
    0x2223: [1.117, .617, .333],
    0x2225: [1.117, .617, .555],
    0x2308: [.975, .475, .499],
    0x2309: [.975, .475, .499],
    0x230A: [.975, .475, .499],
    0x230B: [.975, .475, .499],
    0x23B4: [.742, -.535, 1.485],
    0x23B5: [-.105, .312, 1.485],
    0x23DC: [.767, -.509, 2.012],
    0x23DD: [-.079, .337, 2.012],
    0x23DE: [.825, -.506, 1.996],
    0x23DF: [-.075, .394, 1.996],
    0x23E0: [.858, -.61, 2.056, { ic: .006 }],
    0x23E1: [-.18, .428, 2.056, { ic: .006 }],
    0x27E6: [.975, .475, .555],
    0x27E7: [.975, .475, .555],
    0x27E8: [.975, .475, .537],
    0x27E9: [.975, .475, .537],
    0x27EA: [.975, .475, .781],
    0x27EB: [.975, .475, .781],
    0x27EE: [.991, .491, .37],
    0x27EF: [.991, .491, .37],
    0x2983: [.975, .475, .624],
    0x2984: [.975, .475, .624],
    0x2985: [.972, .472, .523],
    0x2986: [.972, .472, .523],
    0x29FC: [.966, .466, .467],
    0x29FD: [.966, .466, .467]
};
//# sourceMappingURL=size3.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/size4.js
const size4 = {
    0x28: [1.146, .646, .597],
    0x29: [1.146, .646, .597],
    0x2F: [1.722, 1.222, 1.222],
    0x5B: [1.15, .65, .472],
    0x5C: [1.722, 1.222, 1.222],
    0x5D: [1.15, .65, .472],
    0x7B: [1.15, .65, .667],
    0x7D: [1.15, .65, .667],
    0x302: [.747, -.57, 1.1, { ic: .001 }],
    0x303: [.762, -.539, 1.115],
    0x306: [.743, -.576, 1.12, { ic: .001 }],
    0x30C: [.742, -.565, 1.1, { ic: .001 }],
    0x2044: [1.722, 1.222, 1.222],
    0x2215: [.613, .113, .588],
    0x2216: [.613, .113, .588],
    0x221A: [1.75, 1.25, 1, { ic: .02 }],
    0x2223: [1.292, .792, .333],
    0x2225: [1.292, .792, .555],
    0x2308: [1.15, .65, .528],
    0x2309: [1.15, .65, .528],
    0x230A: [1.15, .65, .528],
    0x230B: [1.15, .65, .528],
    0x23B4: [.75, -.527, 1.86],
    0x23B5: [-.097, .32, 1.86],
    0x23DC: [.774, -.506, 2.516],
    0x23DD: [-.076, .344, 2.516],
    0x23DE: [.833, -.502, 2.498],
    0x23DF: [-.071, .402, 2.498],
    0x23E0: [.863, -.607, 2.564, { ic: .006 }],
    0x23E1: [-.177, .433, 2.564, { ic: .006 }],
    0x27E6: [1.15, .65, .66],
    0x27E7: [1.15, .65, .66],
    0x27E8: [1.15, .65, .611],
    0x27E9: [1.15, .65, .611],
    0x27EA: [1.15, .65, .905],
    0x27EB: [1.15, .65, .905],
    0x27EE: [1.168, .668, .432],
    0x27EF: [1.168, .668, .432],
    0x2983: [1.15, .65, .667],
    0x2984: [1.15, .65, .667],
    0x2985: [1.146, .646, .597],
    0x2986: [1.146, .646, .597],
    0x29FC: [1.146, .646, .467, { ic: .023 }],
    0x29FD: [1.146, .646, .467, { ic: .023 }]
};
//# sourceMappingURL=size4.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/size5.js
const size5 = {
    0x28: [1.296, .796, .663],
    0x29: [1.296, .796, .663],
    0x2F: [2.179, 1.679, 1.557],
    0x5B: [1.3, .8, .499],
    0x5C: [2.179, 1.679, 1.557],
    0x5D: [1.3, .8, .499],
    0x7B: [1.3, .8, .707],
    0x7D: [1.3, .8, .707],
    0x302: [.748, -.569, 1.32, { ic: .001 }],
    0x303: [.766, -.534, 1.335],
    0x306: [.743, -.575, 1.341, { ic: .001 }],
    0x30C: [.743, -.564, 1.32, { ic: .001 }],
    0x2044: [2.179, 1.679, 1.557],
    0x2215: [.616, .115, .593],
    0x2216: [.616, .115, .593],
    0x2223: [1.502, 1.002, .333],
    0x2225: [1.501, 1.001, .555],
    0x2308: [1.3, .8, .555],
    0x2309: [1.3, .8, .555],
    0x230A: [1.3, .8, .555],
    0x230B: [1.3, .8, .555],
    0x23B4: [.757, -.521, 2.235],
    0x23B5: [-.091, .327, 2.235],
    0x23DC: [.78, -.506, 3.02],
    0x23DD: [-.076, .35, 3.02],
    0x23DE: [.838, -.5, 3],
    0x23DF: [-.07, .408, 3],
    0x23E0: [.866, -.607, 3.068, { ic: .006 }],
    0x23E1: [-.177, .436, 3.068, { ic: .006 }],
    0x27E6: [1.3, .8, .75],
    0x27E7: [1.3, .8, .75],
    0x27E8: [1.3, .8, .677],
    0x27E9: [1.3, .8, .677],
    0x27EA: [1.3, .8, 1.011],
    0x27EB: [1.3, .8, 1.011],
    0x27EE: [1.32, .82, .485],
    0x27EF: [1.32, .82, .485],
    0x2983: [1.3, .8, .707],
    0x2984: [1.3, .8, .707],
    0x2985: [1.296, .796, .663],
    0x2986: [1.296, .796, .663],
    0x29FC: [1.296, .796, .467, { ic: .077 }],
    0x29FD: [1.296, .796, .467, { ic: .077 }]
};
//# sourceMappingURL=size5.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/size6.js
const size6 = {
    0x28: [1.446, .946, .736],
    0x29: [1.446, .946, .736],
    0x2F: [2.777, 2.277, 1.997],
    0x5B: [1.45, .95, .528],
    0x5C: [2.777, 2.277, 1.997],
    0x5D: [1.45, .95, .528],
    0x7B: [1.45, .95, .75],
    0x7D: [1.45, .95, .75],
    0x302: [.748, -.57, 1.581, { ic: .001 }],
    0x303: [.769, -.532, 1.599],
    0x306: [.744, -.574, 1.604, { ic: .001 }],
    0x30C: [.742, -.564, 1.581, { ic: .001 }],
    0x2044: [2.777, 2.277, 1.997],
    0x2215: [.619, .119, .6],
    0x2216: [.619, .119, .6],
    0x2223: [1.752, 1.252, .333],
    0x2225: [1.751, 1.252, .555],
    0x2308: [1.45, .95, .583],
    0x2309: [1.45, .95, .583],
    0x230A: [1.45, .95, .583],
    0x230B: [1.45, .95, .583],
    0x23B4: [.764, -.513, 2.61],
    0x23B5: [-.083, .334, 2.61],
    0x23DC: [.787, -.505, 3.524],
    0x23DD: [-.075, .357, 3.524],
    0x23DE: [.845, -.498, 3.502],
    0x23DF: [-.067, .414, 3.502],
    0x23E0: [.869, -.606, 3.574, { ic: .006 }],
    0x23E1: [-.176, .439, 3.574, { ic: .006 }],
    0x27E6: [1.45, .95, .838],
    0x27E7: [1.45, .95, .838],
    0x27E8: [1.45, .95, .75],
    0x27E9: [1.45, .95, .75],
    0x27EA: [1.45, .95, 1.124],
    0x27EB: [1.45, .95, 1.124],
    0x27EE: [1.472, .972, .541],
    0x27EF: [1.472, .972, .541],
    0x2983: [1.45, .95, .75],
    0x2984: [1.45, .95, .75],
    0x2985: [1.446, .946, .736],
    0x2986: [1.446, .946, .736],
    0x29FC: [1.447, .936, .467, { ic: .131 }],
    0x29FD: [1.447, .936, .467, { ic: .131 }]
};
//# sourceMappingURL=size6.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/size7.js
const size7 = {
    0x28: [1.745, 1.245, .875],
    0x29: [1.745, 1.245, .875],
    0x2F: [3.56, 3.06, 2.572],
    0x5B: [1.75, 1.25, .667],
    0x5C: [3.56, 3.06, 2.572],
    0x5D: [1.75, 1.25, .667],
    0x7B: [1.75, 1.25, .902],
    0x7D: [1.75, 1.25, .902],
    0x302: [.749, -.569, 1.896],
    0x303: [.773, -.527, 1.915],
    0x306: [.744, -.573, 1.92, { ic: .001 }],
    0x30C: [.743, -.563, 1.896],
    0x2044: [3.56, 3.06, 2.572],
    0x2215: [.623, .122, .607],
    0x2216: [.623, .122, .607],
    0x2223: [2.052, 1.552, .333],
    0x2225: [2.053, 1.553, .555],
    0x2308: [1.75, 1.25, .623],
    0x2309: [1.75, 1.25, .623],
    0x230A: [1.75, 1.25, .623],
    0x230B: [1.75, 1.25, .623],
    0x23B4: [.772, -.504, 2.985],
    0x23B5: [-.074, .342, 2.985],
    0x23DC: [.796, -.502, 4.032],
    0x23DD: [-.072, .366, 4.032],
    0x23DE: [.854, -.493, 4.006],
    0x23DF: [-.062, .423, 4.006],
    0x23E0: [.873, -.605, 4.082, { ic: .006 }],
    0x23E1: [-.175, .443, 4.082, { ic: .006 }],
    0x27E6: [1.75, 1.25, 1.007],
    0x27E7: [1.75, 1.25, 1.007],
    0x27E8: [1.75, 1.25, .908],
    0x27E9: [1.75, 1.25, .908],
    0x27EA: [1.75, 1.25, 1.362],
    0x27EB: [1.75, 1.25, 1.362],
    0x27EE: [1.776, 1.276, .647],
    0x27EF: [1.776, 1.276, .647],
    0x2983: [1.75, 1.25, .902],
    0x2984: [1.75, 1.25, .902],
    0x2985: [1.745, 1.245, .875],
    0x2986: [1.745, 1.245, .875],
    0x29FC: [1.751, 1.251, .467, { ic: .257 }],
    0x29FD: [1.751, 1.251, .467, { ic: .592 }]
};
//# sourceMappingURL=size7.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/tex-mathit.js
const texMathit = {
    0x41: [.716, 0, .743],
    0x42: [.683, 0, .704, { oc: .03 }],
    0x43: [.705, .022, .716, { oc: .096 }],
    0x44: [.683, 0, .755, { oc: .02 }],
    0x45: [.68, 0, .678, { oc: .069 }],
    0x46: [.68, 0, .653, { oc: .082 }],
    0x47: [.705, .022, .774, { oc: .038 }],
    0x48: [.683, 0, .743, { oc: .109 }],
    0x49: [.683, 0, .386, { oc: .115 }],
    0x4A: [.683, .022, .525, { oc: .097 }],
    0x4B: [.683, 0, .769, { oc: .09 }],
    0x4C: [.683, 0, .627],
    0x4D: [.683, 0, .897, { oc: .105 }],
    0x4E: [.683, 0, .743, { oc: .109 }],
    0x4F: [.705, .022, .767, { oc: .021 }],
    0x50: [.683, 0, .678, { oc: .052 }],
    0x51: [.705, .194, .767, { oc: .021 }],
    0x52: [.683, .022, .729],
    0x53: [.705, .022, .562, { oc: .07 }],
    0x54: [.677, 0, .716, { oc: .09 }],
    0x55: [.683, .022, .743, { oc: .109 }],
    0x56: [.683, .022, .743, { oc: .125 }],
    0x57: [.683, .022, .999, { oc: .125 }],
    0x58: [.683, 0, .743, { oc: .082 }],
    0x59: [.683, 0, .743, { oc: .131 }],
    0x5A: [.683, 0, .613, { oc: .091 }],
    0x61: [.442, .011, .511, { oc: .014 }],
    0x62: [.694, .011, .46],
    0x63: [.442, .011, .46, { oc: .01 }],
    0x64: [.694, .011, .511, { oc: .049 }],
    0x65: [.442, .011, .46, { oc: .008 }],
    0x66: [.705, .205, .307, { oc: .145 }],
    0x67: [.442, .205, .46, { oc: .027 }],
    0x68: [.694, .011, .511, { oc: .024 }],
    0x69: [.654, .011, .307, { oc: .051 }],
    0x6A: [.654, .205, .307, { oc: .051 }],
    0x6B: [.694, .011, .46, { oc: .042 }],
    0x6C: [.694, .011, .256, { oc: .05 }],
    0x6D: [.442, .011, .818, { oc: .024 }],
    0x6E: [.442, .011, .562, { oc: .024 }],
    0x6F: [.442, .011, .511],
    0x70: [.442, .194, .511],
    0x71: [.442, .194, .46, { oc: .037 }],
    0x72: [.442, .011, .422, { oc: .067 }],
    0x73: [.442, .011, .409, { oc: .01 }],
    0x74: [.626, .011, .332, { oc: .041 }],
    0x75: [.442, .011, .537, { oc: .024 }],
    0x76: [.442, .011, .46, { oc: .033 }],
    0x77: [.442, .011, .664, { oc: .033 }],
    0x78: [.442, .011, .464, { oc: .054 }],
    0x79: [.442, .205, .486, { oc: .03 }],
    0x7A: [.442, .011, .409, { oc: .055 }]
};
//# sourceMappingURL=tex-mathit.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/tex-calligraphic.js
const texCalligraphic = {};
//# sourceMappingURL=tex-calligraphic.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/tex-calligraphic-bold.js
const texCalligraphicBold = {};
//# sourceMappingURL=tex-calligraphic-bold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/tex-oldstyle.js
const texOldstyle = {
    0x30: [.472, .022, .57],
    0x31: [.472, 0, .404],
    0x32: [.472, 0, .554],
    0x33: [.472, .216, .563],
    0x34: [.485, .194, .517],
    0x35: [.472, .216, .547],
    0x36: [.666, .022, .563],
    0x37: [.485, .213, .503],
    0x38: [.666, .022, .563],
    0x39: [.472, .216, .563]
};
//# sourceMappingURL=tex-oldstyle.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/tex-oldstyle-bold.js
const texOldstyleBold = {
    0x30: [.461, .011, .654],
    0x31: [.461, 0, .494],
    0x32: [.461, 0, .636],
    0x33: [.461, .205, .648],
    0x34: [.488, .194, .595],
    0x35: [.461, .205, .63],
    0x36: [.655, .011, .648],
    0x37: [.488, .199, .579],
    0x38: [.655, .011, .648],
    0x39: [.461, .205, .648]
};
//# sourceMappingURL=tex-oldstyle-bold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/tex-variant.js
const texVariant = {
    0x2018: [.549, -.096, .407],
    0x2019: [.549, -.096, .407],
    0x201A: [.549, -.096, .407],
    0x201B: [.549, -.096, .407],
    0x201C: [.549, -.096, .647],
    0x201D: [.549, -.096, .647],
    0x201E: [.549, -.096, .647],
    0x201F: [.549, -.096, .647],
    0x2032: [.549, -.096, .407],
    0x2033: [.549, -.096, .647],
    0x2034: [.549, -.096, .887],
    0x2035: [.549, -.096, .407],
    0x2036: [.549, -.096, .647],
    0x2037: [.549, -.096, .887],
    0x2057: [.549, -.096, 1.127],
    0x210F: [.694, .011, .511, { ic: .024 }],
    0x2190: [.437, -.063, .5],
    0x2192: [.437, -.063, .5],
    0x2205: [.597, .097, .778],
    0x2212: [.27, -.23, .5],
    0x2216: [.431, .022, .777],
    0x221A: [.75, .25, .833, { ic: .02 }],
    0x221D: [.472, -.028, .777],
    0x2223: [.431, .022, .222],
    0x2224: [.431, .022, .222, { ic: .019 }],
    0x2225: [.431, .022, .388],
    0x2226: [.431, .022, .388, { ic: .02 }],
    0x223C: [.367, -.133, .777],
    0x2248: [.483, -.056, .777],
    0x2268: [.753, .276, .777],
    0x2269: [.753, .276, .777],
    0x2270: [.92, .42, .777],
    0x2271: [.92, .42, .777],
    0x2288: [.828, .328, .777],
    0x2289: [.828, .328, .777],
    0x228A: [.636, .248, .777],
    0x228B: [.636, .248, .777],
    0x22C6: [.485, -.019, .5],
    0x2322: [.378, -.122, .777],
    0x2323: [.378, -.142, .777],
    0x2A87: [.803, .303, .777],
    0x2A88: [.803, .303, .777],
    0x2ACB: [.753, .325, .777],
    0x2ACC: [.753, .325, .777]
};
//# sourceMappingURL=tex-variant.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/lf-tp.js
const lfTp = {
    0x20D0: [.711, -.601, .208],
    0x20D6: [.711, -.521, .205],
    0x20ED: [-.171, .281, .208],
    0x20EE: [-.091, .281, .205],
    0x2190: [.51, .01, .507],
    0x2191: [.505, 0, .5],
    0x219A: [.51, .01, .386],
    0x219E: [.51, .01, .507],
    0x219F: [.505, 0, .572],
    0x21A3: [.51, .01, .58],
    0x21A6: [.51, .011, .499],
    0x21A7: [.498, 0, .632],
    0x21AA: [.546, -.226, .507],
    0x21AC: [.55, .05, .507],
    0x21BC: [.499, -.226, .513],
    0x21BD: [.273, 0, .512],
    0x21BE: [.513, 0, .441],
    0x21BF: [.513, 0, .441],
    0x21C4: [.432, .172, .515],
    0x21C5: [.514, 0, .896],
    0x21C6: [.669, -.065, .514],
    0x21C7: [.75, .25, .507],
    0x21C8: [.505, 0, .992],
    0x21CB: [.598, -.131, .515],
    0x21CC: [.369, .098, .514],
    0x21CD: [.52, .02, .384],
    0x21D0: [.52, .02, .504],
    0x21D1: [.504, 0, .652],
    0x21DA: [.617, .117, .506],
    0x21F5: [.515, 0, .896],
    0x221A: [.62, 0, 1.056, { ic: .013 }],
    0x23B4: [.772, -.504, 1.493],
    0x23B5: [-.074, .342, 1.493],
    0x23DC: [.796, -.502, 2.016],
    0x23DD: [-.072, .366, 2.016],
    0x23DE: [.724, -.493, 1.002],
    0x23DF: [-.062, .294, 1.002],
    0x23E0: [.873, -.605, 2.041],
    0x23E1: [-.175, .443, 2.041],
    0x27E6: [1, 0, 1.007],
    0x27E7: [1, 0, 1.007],
    0x27EE: [1.526, 0, .647],
    0x27EF: [1.526, 0, .647],
    0x294C: [.513, 0, .616],
    0x294D: [.513, 0, .616],
    0x2B31: [.99, .49, .507]
};
//# sourceMappingURL=lf-tp.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/rt-bt.js
const rtBt = {
    0x20D1: [.711, -.601, .208],
    0x20D7: [.711, -.521, .205],
    0x20EC: [-.171, .281, .208],
    0x20EF: [-.091, .281, .205],
    0x2192: [.51, .01, .507],
    0x2193: [.505, 0, .5],
    0x219B: [.51, .01, .386],
    0x21A0: [.51, .01, .507],
    0x21A1: [.505, 0, .572],
    0x21A2: [.51, .01, .58],
    0x21A4: [.51, .011, .499],
    0x21A5: [.498, 0, .632],
    0x21A9: [.546, -.226, .507],
    0x21AB: [.55, .05, .507],
    0x21C0: [.499, -.226, .513],
    0x21C1: [.273, 0, .513],
    0x21C2: [.513, 0, .441],
    0x21C3: [.513, 0, .441],
    0x21C4: [.669, -.065, .514],
    0x21C5: [.515, 0, .896],
    0x21C6: [.432, .172, .515],
    0x21C9: [.75, .25, .507],
    0x21CA: [.505, 0, .992],
    0x21CB: [.369, .098, .514],
    0x21CC: [.598, -.131, .515],
    0x21CE: [.52, .02, .406],
    0x21D2: [.52, .02, .504],
    0x21D3: [.504, 0, .652],
    0x21DB: [.617, .117, .506],
    0x21F5: [.514, 0, .896],
    0x21F6: [.99, .49, .507],
    0x23B4: [.772, -.504, 1.492],
    0x23B5: [-.074, .342, 1.492],
    0x23DC: [.796, -.502, 2.016],
    0x23DD: [-.072, .366, 2.016],
    0x23DE: [.724, -.493, 1.001],
    0x23DF: [-.062, .294, 1.001],
    0x23E0: [.873, -.605, 2.041, { ic: .006 }],
    0x23E1: [-.175, .443, 2.041, { ic: .006 }],
    0x27E6: [1, 0, 1.007],
    0x27E7: [1, 0, 1.007],
    0x27EE: [1.526, 0, .647],
    0x27EF: [1.526, 0, .647],
    0x294C: [.513, 0, .616],
    0x294D: [.513, 0, .616]
};
//# sourceMappingURL=rt-bt.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/ex-md.js
const exMd = {
    0x5F: [-.188, .294, .994],
    0x7B: [.748, 0, .902],
    0xAF: [.724, -.618, .994],
    0x305: [.67, -.63, .19],
    0x20D0: [.631, -.601, .139],
    0x2190: [.274, -.226, .337],
    0x2191: [.337, 0, .5],
    0x219A: [.51, .01, .386],
    0x21A9: [.274, -.226, .337],
    0x21BC: [.273, -.226, .341],
    0x21BE: [.341, 0, .441],
    0x21BF: [.341, 0, .441],
    0x21C4: [.432, -.065, .343],
    0x21C5: [.343, 0, .896],
    0x21C7: [.512, .012, .337],
    0x21C8: [.337, 0, .992],
    0x21CB: [.369, -.131, .343],
    0x21CD: [.52, .02, .384],
    0x21CE: [.369, -.131, .102],
    0x21D0: [.369, -.131, .336],
    0x21D1: [.336, 0, .652],
    0x21DA: [.466, -.034, .337],
    0x21F6: [.751, .251, .337],
    0x221A: [.64, 0, 1.056],
    0x23B4: [.772, -.706, .995],
    0x23B5: [-.276, .342, .995],
    0x23DC: [.796, -.689, .994],
    0x23DD: [-.259, .366, .994],
    0x23DE: [.85, -.618, 2.003],
    0x23DF: [-.188, .419, 2.003],
    0x23E0: [.873, -.766, 1.36],
    0x23E1: [-.336, .443, 1.36],
    0x27E6: [1, 0, 1.007],
    0x27E7: [1, 0, 1.007],
    0x27EE: [.998, 0, .647],
    0x27EF: [.998, 0, .647],
    0x294C: [.337, 0, .616]
};
//# sourceMappingURL=ex-md.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/bbold.js
const bbold = {
    0x2102: [.705, .022, .722, { sk: .042 }],
    0x210D: [.683, 0, .833, { sk: .052 }],
    0x2115: [.683, 0, .833],
    0x2119: [.683, 0, .736],
    0x211A: [.705, .194, .778],
    0x211D: [.683, .022, .792],
    0x2124: [.683, 0, .75, { sk: .021 }],
    0x213C: [.431, .011, .687, { sk: .085 }],
    0x213D: [.442, .215, .518, { ic: .025, sk: .098 }],
    0x213E: [.68, 0, .737, { sk: .026 }],
    0x213F: [.68, 0, .862, { sk: .056 }],
    0x2140: [.683, 0, .839, { sk: .048 }],
    0x2145: [.683, 0, .794, { ic: .023, sk: .115 }],
    0x2146: [.694, .011, .673, { ic: .042, sk: .245 }],
    0x2147: [.448, .011, .444, { ic: .03, sk: .082 }],
    0x2148: [.691, 0, .395, { ic: .028, sk: .119 }],
    0x2149: [.691, .205, .423, { ic: .038, sk: .12 }],
    0x1D538: [.683, 0, .863, { sk: -.025 }],
    0x1D539: [.683, 0, .764],
    0x1D53B: [.683, 0, .794, { sk: -.043 }],
    0x1D53C: [.68, 0, .736, { sk: .03 }],
    0x1D53D: [.68, 0, .709, { sk: .013 }],
    0x1D53E: [.705, .022, .785],
    0x1D540: [.683, 0, .467, { sk: .015 }],
    0x1D541: [.683, .022, .597, { sk: .065 }],
    0x1D542: [.683, 0, .833, { sk: .022 }],
    0x1D543: [.683, 0, .68, { sk: -.08 }],
    0x1D544: [.684, 0, 1, { sk: .051 }],
    0x1D546: [.705, .022, .778],
    0x1D54A: [.705, .022, .556, { sk: -.018 }],
    0x1D54B: [.677, 0, .754, { sk: .023 }],
    0x1D54C: [.683, .022, .806, { sk: .045 }],
    0x1D54D: [.683, .008, .804, { sk: .059 }],
    0x1D54E: [.683, .022, 1.058, { sk: .015 }],
    0x1D54F: [.683, 0, .866, { sk: .043 }],
    0x1D550: [.683, 0, .868, { sk: .057 }],
    0x1D552: [.448, .011, .614, { sk: -.013 }],
    0x1D553: [.694, .011, .673, { sk: -.126 }],
    0x1D554: [.448, .011, .444, { sk: .026 }],
    0x1D555: [.694, .011, .673, { sk: .152 }],
    0x1D556: [.448, .011, .444, { sk: .014 }],
    0x1D557: [.705, 0, .423, { ic: .051, sk: -.028 }],
    0x1D558: [.453, .206, .5, { sk: -.026 }],
    0x1D559: [.694, 0, .676, { sk: -.117 }],
    0x1D55A: [.691, 0, .395],
    0x1D55B: [.691, .205, .423, { sk: .015 }],
    0x1D55C: [.694, 0, .648, { sk: -.109 }],
    0x1D55D: [.694, 0, .394, { sk: .018 }],
    0x1D55E: [.442, 0, .95, { sk: -.037 }],
    0x1D55F: [.442, 0, .673],
    0x1D560: [.448, .011, .5],
    0x1D561: [.442, .194, .673],
    0x1D562: [.442, .194, .645, { sk: .019 }],
    0x1D563: [.442, 0, .509, { sk: -.051 }],
    0x1D564: [.448, .011, .394],
    0x1D565: [.615, .011, .506, { sk: -.037 }],
    0x1D566: [.442, .011, .673, { sk: .024 }],
    0x1D567: [.431, .011, .635, { sk: .053 }],
    0x1D568: [.431, .011, .635, { ic: .155, sk: .012 }],
    0x1D569: [.431, 0, .645, { sk: .049 }],
    0x1D56A: [.431, .205, .635, { sk: .05 }],
    0x1D56B: [.431, 0, .561, { sk: .046 }],
    0x1D7D8: [.666, .022, .5],
    0x1D7D9: [.666, 0, .624, { sk: .025 }],
    0x1D7DA: [.666, 0, .5],
    0x1D7DB: [.666, .022, .5],
    0x1D7DC: [.677, 0, .627, { sk: .11 }],
    0x1D7DD: [.666, .022, .5, { sk: .011 }],
    0x1D7DE: [.666, .022, .5, { sk: .013 }],
    0x1D7DF: [.676, .022, .55, { sk: .038 }],
    0x1D7E0: [.666, .022, .5],
    0x1D7E1: [.666, .022, .5]
};
//# sourceMappingURL=bbold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/upsmall.js
const upsmall = {
    0x222B: [.805, .306, .665],
    0x222C: [.805, .306, 1.035],
    0x222D: [.805, .306, 1.405],
    0x222E: [.81, .312, .665],
    0x222F: [.805, .306, 1.035],
    0x2230: [.805, .306, 1.405],
    0x2231: [.805, .306, .695],
    0x2232: [.805, .306, .665],
    0x2233: [.805, .306, .665],
    0x2A0C: [.805, .306, 1.775],
    0x2A0D: [.805, .306, .665],
    0x2A0E: [.805, .306, .665],
    0x2A18: [.805, .306, .665],
    0x2A19: [.805, .306, .665],
    0x2A1A: [.805, .306, .665],
    0x2A1B: [.967, .306, .665, { ic: .002 }],
    0x2A1C: [.805, .468, .665],
    0xE376: [.805, .306, .665],
    0xE377: [.805, .306, .665],
    0xE395: [.805, .306, .665],
    0xE397: [.805, .306, .665],
    0xE398: [.805, .306, .665],
    0xE399: [.805, .306, .665],
    0xE39A: [.805, .306, .665, { ic: .085 }],
    0xE39B: [.798, .299, .695],
    0xE3D3: [.805, .306, .665],
    0xEA57: [.805, .306, .707]
};
//# sourceMappingURL=upsmall.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/uplarge.js
const uplarge = {
    0x222B: [1.361, .861, .763],
    0x222C: [1.361, .861, 1.175],
    0x222D: [1.361, .861, 1.623],
    0x222E: [1.363, .861, .899],
    0x222F: [1.361, .861, 1.295],
    0x2230: [1.361, .861, 1.699],
    0x2231: [1.361, .861, .999],
    0x2232: [1.361, .861, .999],
    0x2233: [1.361, .861, .999],
    0x2A0B: [1.361, .861, 1.056],
    0x2A0C: [1.361, .861, 2.019],
    0x2A0D: [1.361, .861, .999],
    0x2A0E: [1.361, .861, .999],
    0x2A0F: [1.361, .861, .999],
    0x2A10: [1.361, .861, .999],
    0x2A11: [1.361, .861, .999],
    0x2A12: [1.361, .861, .895],
    0x2A13: [1.361, .861, .871],
    0x2A14: [1.361, .861, .831, { ic: .077 }],
    0x2A15: [1.361, .861, .903],
    0x2A16: [1.361, .861, .883],
    0x2A17: [1.361, .861, .967],
    0x2A18: [1.361, .861, .875],
    0x2A19: [1.361, .861, .955],
    0x2A1A: [1.361, .861, .967],
    0x2A1B: [1.602, .861, .999],
    0x2A1C: [1.361, 1.124, .807]
};
//# sourceMappingURL=uplarge.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/script.js
const script = {};
//# sourceMappingURL=script.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/script-bold.js
const scriptBold = {};
//# sourceMappingURL=script-bold.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/delimiters.js

const delimiters = {
    0x28: {
        dir: V,
        sizes: [.997, 1.095, 1.195, 1.445, 1.793, 2.093, 2.393, 2.991],
        stretch: [0x239B, 0x239C, 0x239D],
        HDW: [.748, .248, .875]
    },
    0x29: {
        dir: V,
        sizes: [.997, 1.095, 1.195, 1.445, 1.793, 2.093, 2.393, 2.991],
        stretch: [0x239E, 0x239F, 0x23A0],
        HDW: [.748, .248, .875]
    },
    0x2D: {
        c: 0x2212,
        dir: H,
        stretch: [0, 0x2212],
        HDW: [0.583, 0.083, .778],
        ext: 0.112,
        hd: [.583, .083]
    },
    0x2F: {
        dir: V,
        sizes: [1.001, 1.311, 1.717, 2.249, 2.945, 3.859, 5.055, 6.621]
    },
    0x3D: {
        dir: H,
        stretch: [0, 0x3D],
        HDW: [0.367, -0.133, .778],
        ext: 0.112,
        hd: [.367, -.133]
    },
    0x5B: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x23A1, 0x23A2, 0x23A3],
        HDW: [.75, .25, .667]
    },
    0x5C: {
        dir: V,
        sizes: [1.001, 1.311, 1.717, 2.249, 2.945, 3.859, 5.055, 6.621]
    },
    0x5D: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x23A4, 0x23A5, 0x23A6],
        HDW: [.75, .25, .667]
    },
    0x5E: {
        c: 0x302,
        dir: H,
        sizes: [.5, .644, .768, .919, 1.1, 1.32, 1.581, 1.896]
    },
    0x5F: {
        c: 0x2013,
        dir: H,
        stretch: [0, 0x2013],
        HDW: [0.277, -0.255, .5],
        ext: 0.001,
        hd: [.277, -.255]
    },
    0x7B: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x23A7, 0x7B, 0x23A9, 0x23A8],
        stretchv: [0, 1, 0, 0],
        HDW: [.75, .25, .902]
    },
    0x7C: {
        dir: V,
        sizes: [1.001, 1.203, 1.443, 1.735, 2.085, 2.505, 3.005, 3.605],
        schar: [0x7C, 0x2223],
        stretch: [0, 0x2223],
        stretchv: [0, 2],
        HDW: [.75, .25, .333]
    },
    0x7D: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x23AB, 0x7B, 0x23AD, 0x23AC],
        stretchv: [0, 1, 0, 0],
        HDW: [.75, .25, .902]
    },
    0x7E: {
        c: 0x303,
        dir: H,
        sizes: [.5, .652, .778, .931, 1.115, 1.335, 1.599, 1.915]
    },
    0xAF: {
        c: 0x305,
        dir: H,
        sizes: [.392, .568],
        stretch: [0, 0x305],
        stretchv: [0, 1],
        HDW: [0.67, -0.63, 0],
        hd: [.67, -.63]
    },
    0x2C6: {
        c: 0x302,
        dir: H,
        sizes: [.5, .644, .768, .919, 1.1, 1.32, 1.581, 1.896]
    },
    0x2C7: {
        c: 0x30C,
        dir: H,
        sizes: [.366, .644, .768, .919, 1.1, 1.32, 1.581, 1.896]
    },
    0x2C9: {
        c: 0x305,
        dir: H,
        sizes: [.392, .568],
        stretch: [0, 0x305],
        stretchv: [0, 1],
        HDW: [0.67, -0.63, 0],
        hd: [.67, -.63]
    },
    0x2D8: {
        c: 0x306,
        dir: H,
        sizes: [.376, .658, .784, .937, 1.12, 1.341, 1.604, 1.92]
    },
    0x2DC: {
        c: 0x303,
        dir: H,
        sizes: [.5, .652, .778, .931, 1.115, 1.335, 1.599, 1.915]
    },
    0x302: {
        dir: H,
        sizes: [.5, .644, .768, .919, 1.1, 1.32, 1.581, 1.896]
    },
    0x303: {
        dir: H,
        sizes: [.5, .652, .778, .931, 1.115, 1.335, 1.599, 1.915]
    },
    0x305: {
        dir: H,
        sizes: [.392, .568],
        stretch: [0, 0x305],
        stretchv: [0, 1],
        HDW: [0.67, -0.63, 0],
        hd: [.67, -.63]
    },
    0x306: {
        dir: H,
        sizes: [.376, .658, .784, .937, 1.12, 1.341, 1.604, 1.92]
    },
    0x30C: {
        dir: H,
        sizes: [.366, .644, .768, .919, 1.1, 1.32, 1.581, 1.896]
    },
    0x2013: {
        dir: H,
        stretch: [0, 0x2013],
        HDW: [0.277, -0.255, .5],
        ext: 0.001,
        hd: [.277, -.255]
    },
    0x2014: {
        dir: H,
        stretch: [0, 0x2014],
        HDW: [0.277, -0.255, 1],
        ext: 0.001,
        hd: [.277, -.255]
    },
    0x2015: {
        dir: H,
        stretch: [0, 0x2015],
        HDW: [0.27, -0.23, 1.152],
        ext: 0.112,
        hd: [.27, -.23]
    },
    0x2016: {
        dir: V,
        sizes: [1.001, 1.203, 1.443, 1.735, 2.085, 2.503, 3.004, 3.607],
        schar: [0x2016, 0x2225],
        stretch: [0, 0x2225],
        stretchv: [0, 2],
        HDW: [.75, .25, .555]
    },
    0x203E: {
        c: 0xAF,
        dir: H,
        sizes: [.392, .568],
        stretch: [0, 0x305],
        stretchv: [0, 1],
        HDW: [0.67, -0.63, 0],
        hd: [.67, -.63]
    },
    0x2044: {
        dir: V,
        sizes: [1.001, 1.311, 1.717, 2.249, 2.945, 3.859, 5.055, 6.621]
    },
    0x20D0: {
        dir: H,
        sizes: [.422, .667],
        stretch: [0x20D0, 0x20D0],
        stretchv: [3, 1],
        HDW: [0.711, -0.601, 0],
        hd: [.631, -.601]
    },
    0x20D1: {
        dir: H,
        sizes: [.422, .667],
        stretch: [0, 0x20D0, 0x20D1],
        stretchv: [0, 1, 4],
        HDW: [0.711, -0.601, 0],
        hd: [.631, -.601]
    },
    0x20D6: {
        dir: H,
        sizes: [.416, .659],
        stretch: [0x20D6, 0x20D0],
        stretchv: [3, 1],
        HDW: [0.711, -0.521, 0],
        hd: [.631, -.601]
    },
    0x20D7: {
        dir: H,
        sizes: [.416, .659],
        stretch: [0, 0x20D0, 0x20D7],
        stretchv: [0, 1, 4],
        HDW: [0.711, -0.521, 0],
        hd: [.631, -.601]
    },
    0x20E1: {
        dir: H,
        sizes: [.47, .715],
        stretch: [0x20D6, 0x20D0, 0x20D7],
        stretchv: [3, 1, 4],
        HDW: [0.711, -0.521, 0],
        hd: [.631, -.601]
    },
    0x20EC: {
        dir: H,
        sizes: [.422, .667],
        stretch: [0, 0x34D, 0x20EC],
        stretchv: [0, 1, 4],
        HDW: [-0.171, 0.281, 0],
        hd: [-.171, .201]
    },
    0x20ED: {
        dir: H,
        sizes: [.422, .667],
        stretch: [0x20ED, 0x34D],
        stretchv: [3, 1],
        HDW: [-0.171, 0.281, 0],
        hd: [-.171, .201]
    },
    0x20EE: {
        dir: H,
        sizes: [.416, .659],
        stretch: [0x20EE, 0x34D],
        stretchv: [3, 1],
        HDW: [-0.091, 0.281, 0],
        hd: [-.171, .201]
    },
    0x20EF: {
        dir: H,
        sizes: [.416, .659],
        stretch: [0, 0x34D, 0x20EF],
        stretchv: [0, 1, 4],
        HDW: [-0.091, 0.281, 0],
        hd: [-.171, .201]
    },
    0x2140: {
        dir: V,
        sizes: [.684, 1.401],
        variants: [0, 2]
    },
    0x2190: {
        dir: H,
        sizes: [1, 1.463],
        variants: [0, 0],
        schar: [0x2190, 0x27F5],
        stretch: [0x2190, 0x2190],
        stretchv: [3, 1],
        HDW: [0.51, 0.01, 1],
        hd: [.274, -.226]
    },
    0x2191: {
        dir: V,
        sizes: [.883, 1.349],
        variants: [0, 2],
        stretch: [0x2191, 0x2191],
        stretchv: [3, 1],
        HDW: [.679, .203, .5]
    },
    0x2192: {
        dir: H,
        sizes: [1, 1.463],
        variants: [0, 0],
        schar: [0x2192, 0x27F6],
        stretch: [0, 0x2190, 0x2192],
        stretchv: [0, 1, 4],
        HDW: [0.51, 0.01, 1],
        hd: [.274, -.226]
    },
    0x2193: {
        dir: V,
        sizes: [.883, 1.349],
        variants: [0, 2],
        stretch: [0, 0x2191, 0x2193],
        stretchv: [0, 1, 4],
        HDW: [.703, .179, .5]
    },
    0x2194: {
        dir: H,
        sizes: [1, 1.442],
        variants: [0, 0],
        schar: [0x2194, 0x27F7],
        stretch: [0x2190, 0x2190, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.01, 1],
        hd: [.274, -.226]
    },
    0x2195: {
        dir: V,
        sizes: [1.015, 1.015],
        variants: [0, 2],
        stretch: [0x2191, 0x2191, 0x2193],
        stretchv: [3, 1, 4],
        HDW: [.757, .257, .5]
    },
    0x2196: {
        dir: V,
        sizes: [.918, 1.384],
        variants: [0, 2]
    },
    0x2197: {
        dir: V,
        sizes: [.918, 1.384],
        variants: [0, 2]
    },
    0x2198: {
        dir: V,
        sizes: [.918, 1.384],
        variants: [0, 2]
    },
    0x2199: {
        dir: V,
        sizes: [.918, 1.384],
        variants: [0, 2]
    },
    0x219A: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0x219A, 0x2190, 0, 0x219A],
        stretchv: [3, 1, 0, 1],
        HDW: [0.51, 0.01, .997],
        hd: [.274, -.226]
    },
    0x219B: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0, 0x2190, 0x219B, 0x219A],
        stretchv: [0, 1, 4, 1],
        HDW: [0.51, 0.01, .997],
        hd: [.274, -.226]
    },
    0x219E: {
        dir: H,
        sizes: [1.017, 1.463],
        variants: [0, 2],
        stretch: [0x219E, 0x2190],
        stretchv: [3, 1],
        HDW: [0.51, 0.01, 1.017],
        hd: [.274, -.226]
    },
    0x21A0: {
        dir: H,
        sizes: [1.017, 1.463],
        variants: [0, 2],
        stretch: [0, 0x2190, 0x21A0],
        stretchv: [0, 1, 4],
        HDW: [0.51, 0.01, 1.017],
        hd: [.274, -.226]
    },
    0x21A2: {
        dir: H,
        sizes: [1.192, 1.658],
        variants: [0, 2],
        stretch: [0x2190, 0x2190, 0x21A2],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.01, 1.192],
        hd: [.274, -.226]
    },
    0x21A3: {
        dir: H,
        sizes: [1.192, 1.658],
        variants: [0, 2],
        stretch: [0x21A3, 0x2190, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.01, 1.192],
        hd: [.274, -.226]
    },
    0x21A4: {
        dir: H,
        sizes: [.977, 1.443],
        variants: [0, 0],
        schar: [0x21A4, 0x27FB],
        stretch: [0x2190, 0x2190, 0x21A4],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, .977],
        hd: [.274, -.226]
    },
    0x21A6: {
        dir: H,
        sizes: [.977, 1.443],
        variants: [0, 0],
        schar: [0x21A6, 0x27FC],
        stretch: [0x21A6, 0x2190, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, .977],
        hd: [.274, -.226]
    },
    0x21A9: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0x2190, 0x21A9, 0x21A9],
        stretchv: [3, 1, 4],
        HDW: [0.546, 0.01, .997],
        hd: [.274, -.226]
    },
    0x21AA: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0x21AA, 0x21A9, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.546, 0.01, .997],
        hd: [.274, -.226]
    },
    0x21AB: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0x2190, 0x21A9, 0x21AB],
        stretchv: [3, 1, 4],
        HDW: [0.55, 0.05, .997],
        hd: [.274, -.226]
    },
    0x21AC: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0x21AC, 0x21A9, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.55, 0.05, .997],
        hd: [.274, -.226]
    },
    0x21B6: {
        dir: H,
        sizes: [.98, 1.33],
        variants: [0, 2]
    },
    0x21B7: {
        dir: H,
        sizes: [.98, 1.33],
        variants: [0, 2]
    },
    0x21BC: {
        dir: H,
        sizes: [1, 1.478],
        variants: [0, 2],
        stretch: [0x21BC, 0x21BC],
        stretchv: [3, 1],
        HDW: [0.499, -0.226, 1],
        hd: [.273, -.226]
    },
    0x21BD: {
        dir: H,
        sizes: [1.012, 1.478],
        variants: [0, 2],
        stretch: [0x21BD, 0x21BC],
        stretchv: [3, 1],
        HDW: [0.273, 0, 1.012],
        hd: [.273, -.226]
    },
    0x21BE: {
        dir: V,
        sizes: [.901, 1.367],
        variants: [0, 2],
        stretch: [0x21BE, 0x21BE],
        stretchv: [3, 1],
        HDW: [.697, .203, .441]
    },
    0x21BF: {
        dir: V,
        sizes: [.901, 1.367],
        variants: [0, 2],
        stretch: [0x21BF, 0x21BF],
        stretchv: [3, 1],
        HDW: [.697, .203, .441]
    },
    0x21C0: {
        dir: H,
        sizes: [1, 1.478],
        variants: [0, 2],
        stretch: [0, 0x21BC, 0x21C0],
        stretchv: [0, 1, 4],
        HDW: [0.499, -0.226, 1],
        hd: [.273, -.226]
    },
    0x21C1: {
        dir: H,
        sizes: [1.012, 1.478],
        variants: [0, 2],
        stretch: [0, 0x21BC, 0x21C1],
        stretchv: [0, 1, 4],
        HDW: [0.273, 0, 1.012],
        hd: [.273, -.226]
    },
    0x21C2: {
        dir: V,
        sizes: [.901, 1.367],
        variants: [0, 2],
        stretch: [0, 0x21BE, 0x21C2],
        stretchv: [0, 1, 4],
        HDW: [.703, .197, .441]
    },
    0x21C3: {
        dir: V,
        sizes: [.901, 1.367],
        variants: [0, 2],
        stretch: [0, 0x21BF, 0x21C3],
        stretchv: [0, 1, 4],
        HDW: [.703, .197, .441]
    },
    0x21C4: {
        dir: H,
        sizes: [1.018, 1.484],
        variants: [0, 2],
        stretch: [0x21C4, 0x21C4, 0x21C4],
        stretchv: [3, 1, 4],
        HDW: [0.669, 0.172, 1.018],
        hd: [.432, -.065]
    },
    0x21C5: {
        dir: V,
        sizes: [.907, 1.373],
        variants: [0, 2],
        stretch: [0x21C5, 0x21C5, 0x21C5],
        stretchv: [3, 1, 4],
        HDW: [.703, .203, .896]
    },
    0x21C6: {
        dir: H,
        sizes: [1.018, 1.484],
        variants: [0, 2],
        stretch: [0x21C6, 0x21C4, 0x21C6],
        stretchv: [3, 1, 4],
        HDW: [0.669, 0.172, 1.018],
        hd: [.432, -.065]
    },
    0x21C7: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0x21C7, 0x21C7],
        stretchv: [3, 1],
        HDW: [0.75, 0.25, .997],
        hd: [.512, .012]
    },
    0x21C8: {
        dir: V,
        sizes: [.883, 1.349],
        variants: [0, 2],
        stretch: [0x21C8, 0x21C8],
        stretchv: [3, 1],
        HDW: [.679, .203, .992]
    },
    0x21C9: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0, 0x21C7, 0x21C9],
        stretchv: [0, 1, 4],
        HDW: [0.75, 0.25, .997],
        hd: [.512, .012]
    },
    0x21CA: {
        dir: V,
        sizes: [.883, 1.349],
        variants: [0, 2],
        stretch: [0, 0x21C8, 0x21CA],
        stretchv: [0, 1, 4],
        HDW: [.703, .179, .992]
    },
    0x21CB: {
        dir: H,
        sizes: [1.018, 1.484],
        variants: [0, 2],
        stretch: [0x21CB, 0x21CB, 0x21CB],
        stretchv: [3, 1, 4],
        HDW: [0.598, 0.098, 1.018],
        hd: [.369, -.131]
    },
    0x21CC: {
        dir: H,
        sizes: [1.018, 1.484],
        variants: [0, 2],
        stretch: [0x21CC, 0x21CB, 0x21CC],
        stretchv: [3, 1, 4],
        HDW: [0.598, 0.098, 1.018],
        hd: [.369, -.131]
    },
    0x21CD: {
        dir: H,
        sizes: [.991, 1.457],
        variants: [0, 2],
        stretch: [0x21CD, 0x21CE, 0, 0x21CD],
        stretchv: [3, 1, 0, 1],
        HDW: [0.52, 0.02, .991],
        hd: [.369, -.131]
    },
    0x21CE: {
        dir: H,
        sizes: [1.068, 1.534],
        variants: [0, 2],
        stretch: [0x21D0, 0x21CE, 0x21D2, 0x21CD],
        stretchv: [3, 1, 4, 1],
        HDW: [0.52, 0.02, 1.068],
        hd: [.369, -.131]
    },
    0x21CF: {
        dir: H,
        sizes: [.991, 1.457],
        variants: [0, 2],
        stretch: [0, 0x21CE, 0x21D2, 0x21CD],
        stretchv: [0, 1, 4, 1],
        HDW: [0.52, 0.02, .991],
        hd: [.369, -.131]
    },
    0x21D0: {
        dir: H,
        sizes: [1, 1.457],
        variants: [0, 0],
        schar: [0x21D0, 0x27F8],
        stretch: [0x21D0, 0x21D0],
        stretchv: [3, 1],
        HDW: [0.52, 0.02, 1],
        hd: [.369, -.131]
    },
    0x21D1: {
        dir: V,
        sizes: [.88, 1.346],
        variants: [0, 2],
        stretch: [0x21D1, 0x21D1],
        stretchv: [3, 1],
        HDW: [.676, .203, .652]
    },
    0x21D2: {
        dir: H,
        sizes: [1, 1.457],
        variants: [0, 0],
        schar: [0x21D2, 0x27F9],
        stretch: [0, 0x21D0, 0x21D2],
        stretchv: [0, 1, 4],
        HDW: [0.52, 0.02, 1],
        hd: [.369, -.131]
    },
    0x21D3: {
        dir: V,
        sizes: [.88, 1.346],
        variants: [0, 2],
        stretch: [0, 0x21D1, 0x21D3],
        stretchv: [0, 1, 4],
        HDW: [.703, .176, .652]
    },
    0x21D4: {
        dir: H,
        sizes: [1, 1.534],
        variants: [0, 0],
        schar: [0x21D4, 0x27FA],
        stretch: [0x21D0, 0x21D0, 0x21D2],
        stretchv: [3, 1, 4],
        HDW: [0.52, 0.02, 1],
        hd: [.369, -.131]
    },
    0x21D5: {
        dir: V,
        sizes: [.957, 1.423],
        variants: [0, 2],
        stretch: [0x21D1, 0x21D1, 0x21D3],
        stretchv: [3, 1, 4],
        HDW: [.728, .228, .652]
    },
    0x21DA: {
        dir: H,
        sizes: [1.015, 1.461],
        variants: [0, 2],
        stretch: [0x21DA, 0x21DA],
        stretchv: [3, 1],
        HDW: [0.617, 0.117, 1.015],
        hd: [.466, -.034]
    },
    0x21DB: {
        dir: H,
        sizes: [1.015, 1.461],
        variants: [0, 2],
        stretch: [0, 0x21DA, 0x21DB],
        stretchv: [0, 1, 4],
        HDW: [0.617, 0.117, 1.015],
        hd: [.466, -.034]
    },
    0x21F5: {
        dir: V,
        sizes: [.907, 1.373],
        variants: [0, 2],
        stretch: [0x21F5, 0x21C5, 0x21F5],
        stretchv: [3, 1, 4],
        HDW: [.703, .203, .896]
    },
    0x21F6: {
        dir: H,
        sizes: [.997, 1.463],
        variants: [0, 2],
        stretch: [0, 0x21F6, 0x21F6],
        stretchv: [0, 1, 4],
        HDW: [0.99, 0.49, .997],
        hd: [.751, .251]
    },
    0x220F: {
        dir: V,
        sizes: [1.001, 1.401],
        variants: [0, 2]
    },
    0x2210: {
        dir: V,
        sizes: [1.001, 1.401],
        variants: [0, 2]
    },
    0x2211: {
        dir: V,
        sizes: [1.001, 1.401],
        variants: [0, 2]
    },
    0x2212: {
        dir: H,
        stretch: [0, 0x2212],
        HDW: [0.583, 0.083, .778],
        ext: 0.112,
        hd: [.583, .083]
    },
    0x2215: {
        c: 0x2F,
        dir: V,
        sizes: [1.001, 1.311, 1.717, 2.249, 2.945, 3.859, 5.055, 6.621]
    },
    0x221A: {
        dir: V,
        sizes: [1.001, 1.201, 1.801, 2.401, 3.001],
        stretch: [0x221A, 0x221A, 0x23B7],
        stretchv: [3, 1, 0],
        HDW: [.04, .96, 1.056],
        fullExt: [0.64, 2.44]
    },
    0x2223: {
        dir: V,
        sizes: [1.001, 1.203, 1.443, 1.735, 2.085, 2.505, 3.005, 3.605],
        stretch: [0, 0x2223],
        stretchv: [0, 2],
        HDW: [.75, .25, .333]
    },
    0x2225: {
        dir: V,
        sizes: [1.001, 1.203, 1.443, 1.735, 2.085, 2.503, 3.004, 3.607],
        stretch: [0, 0x2225],
        stretchv: [0, 2],
        HDW: [.75, .25, .555]
    },
    0x222B: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2],
        stretch: [0x2320, 0x23AE, 0x2321],
        HDW: [.805, .306, 1.185]
    },
    0x222C: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x222D: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x222E: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x222F: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2230: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2231: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2232: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2233: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2261: {
        dir: H,
        stretch: [0, 0x2261],
        HDW: [0.464, -0.036, .778],
        ext: 0.112,
        hd: [.464, -.036]
    },
    0x2263: {
        dir: H,
        stretch: [0, 0x2263],
        HDW: [0.561, 0.061, .778],
        ext: 0.112,
        hd: [.561, .061]
    },
    0x22A2: {
        dir: V,
        sizes: [.685, .869],
        variants: [0, 0],
        schar: [0x22A2, 0x27DD]
    },
    0x22A3: {
        dir: V,
        sizes: [.685, .869],
        variants: [0, 0],
        schar: [0x22A3, 0x27DE]
    },
    0x22A4: {
        dir: V,
        sizes: [.685, .869],
        variants: [0, 0],
        schar: [0x22A4, 0x27D9]
    },
    0x22A5: {
        dir: V,
        sizes: [.685, .869],
        variants: [0, 0],
        schar: [0x22A5, 0x27D8]
    },
    0x22C0: {
        dir: V,
        sizes: [1.045, 1.394],
        variants: [0, 2]
    },
    0x22C1: {
        dir: V,
        sizes: [1.045, 1.394],
        variants: [0, 2]
    },
    0x22C2: {
        dir: V,
        sizes: [1.023, 1.357],
        variants: [0, 2]
    },
    0x22C3: {
        dir: V,
        sizes: [1.023, 1.357],
        variants: [0, 2]
    },
    0x2308: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x23A1, 0x23A2],
        HDW: [.75, .25, .667]
    },
    0x2309: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x23A4, 0x23A5],
        HDW: [.75, .25, .667]
    },
    0x230A: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0, 0x23A2, 0x23A3],
        HDW: [.75, .25, .667]
    },
    0x230B: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0, 0x23A5, 0x23A6],
        HDW: [.75, .25, .667]
    },
    0x2312: {
        c: 0x23DC,
        dir: H,
        sizes: [.504, 1.006, 1.508, 2.012, 2.516, 3.02, 3.524, 4.032],
        stretch: [0x23DC, 0x23DC, 0x23DC],
        stretchv: [3, 1, 4],
        HDW: [0.796, -0.502, .504],
        hd: [.796, -.689]
    },
    0x2322: {
        c: 0x23DC,
        dir: H,
        sizes: [.504, 1.006, 1.508, 2.012, 2.516, 3.02, 3.524, 4.032],
        stretch: [0x23DC, 0x23DC, 0x23DC],
        stretchv: [3, 1, 4],
        HDW: [0.796, -0.502, .504],
        hd: [.796, -.689]
    },
    0x2323: {
        c: 0x23DD,
        dir: H,
        sizes: [.504, 1.006, 1.508, 2.012, 2.516, 3.02, 3.524, 4.032],
        stretch: [0x23DD, 0x23DD, 0x23DD],
        stretchv: [3, 1, 4],
        HDW: [-0.072, 0.366, .504],
        hd: [-.259, .366]
    },
    0x2329: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        schar: [0x2329, 0x27E8]
    },
    0x232A: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        schar: [0x232A, 0x27E9]
    },
    0x23AA: {
        dir: V,
        sizes: [.748],
        stretch: [0, 0x23AA],
        HDW: [.748, 0, .902]
    },
    0x23AF: {
        c: 0x2013,
        dir: H,
        stretch: [0, 0x2013],
        HDW: [0.277, -0.255, .5],
        ext: 0.001,
        hd: [.277, -.255]
    },
    0x23B0: {
        dir: V,
        sizes: [1.125],
        stretch: [0x23A7, 0x23AA, 0x23AD],
        HDW: [.75, .375, .902]
    },
    0x23B1: {
        dir: V,
        sizes: [1.125],
        stretch: [0x23AB, 0x23AA, 0x23A9],
        HDW: [.75, .375, .902]
    },
    0x23B4: {
        dir: H,
        sizes: [.36, .735, 1.11, 1.485, 1.86, 2.235, 2.61, 2.985],
        stretch: [0x23B4, 0x23B4, 0x23B4],
        stretchv: [3, 1, 4],
        HDW: [0.772, -0.504, .36],
        hd: [.772, -.706]
    },
    0x23B5: {
        dir: H,
        sizes: [.36, .735, 1.11, 1.485, 1.86, 2.235, 2.61, 2.985],
        stretch: [0x23B5, 0x23B5, 0x23B5],
        stretchv: [3, 1, 4],
        HDW: [-0.074, 0.342, .36],
        hd: [-.276, .342]
    },
    0x23D0: {
        dir: V,
        sizes: [.642],
        stretch: [0, 0x23D0],
        HDW: [.642, 0, .333]
    },
    0x23DC: {
        dir: H,
        sizes: [.504, 1.006, 1.508, 2.012, 2.516, 3.02, 3.524, 4.032],
        stretch: [0x23DC, 0x23DC, 0x23DC],
        stretchv: [3, 1, 4],
        HDW: [0.796, -0.502, .504],
        hd: [.796, -.689]
    },
    0x23DD: {
        dir: H,
        sizes: [.504, 1.006, 1.508, 2.012, 2.516, 3.02, 3.524, 4.032],
        stretch: [0x23DD, 0x23DD, 0x23DD],
        stretchv: [3, 1, 4],
        HDW: [-0.072, 0.366, .504],
        hd: [-.259, .366]
    },
    0x23DE: {
        dir: H,
        sizes: [.492, .993, 1.494, 1.996, 2.498, 3, 3.502, 4.006],
        stretch: [0x23DE, 0xAF, 0x23DE, 0x23DE],
        stretchv: [3, 1, 4, 1],
        HDW: [0.85, -0.493, .492],
        hd: [.724, -.618]
    },
    0x23DF: {
        dir: H,
        sizes: [.492, .993, 1.494, 1.996, 2.498, 3, 3.502, 4.006],
        stretch: [0x23DF, 0x5F, 0x23DF, 0x23DF],
        stretchv: [3, 1, 4, 1],
        HDW: [-0.062, 0.419, .492],
        hd: [-.188, .294]
    },
    0x23E0: {
        dir: H,
        sizes: [.546, 1.048, 1.55, 2.056, 2.564, 3.068, 3.574, 4.082],
        stretch: [0x23E0, 0x23E0, 0x23E0],
        stretchv: [3, 1, 4],
        HDW: [0.873, -0.605, .546],
        hd: [.873, -.766]
    },
    0x23E1: {
        dir: H,
        sizes: [.546, 1.048, 1.55, 2.056, 2.564, 3.068, 3.574, 4.082],
        stretch: [0x23E1, 0x23E1, 0x23E1],
        stretchv: [3, 1, 4],
        HDW: [-0.175, 0.443, .546],
        hd: [-.336, .443]
    },
    0x2500: {
        c: 0x2013,
        dir: H,
        stretch: [0, 0x2013],
        HDW: [0.277, -0.255, .5],
        ext: 0.001,
        hd: [.277, -.255]
    },
    0x2758: {
        c: 0x2223,
        dir: V,
        sizes: [1.001, 1.203, 1.443, 1.735, 2.085, 2.505, 3.005, 3.605],
        stretch: [0, 0x2223],
        stretchv: [0, 2],
        HDW: [.75, .25, .333]
    },
    0x27D5: {
        dir: V,
        sizes: [.511, .628],
        variants: [0, 2]
    },
    0x27D6: {
        dir: V,
        sizes: [.511, .628],
        variants: [0, 2]
    },
    0x27D7: {
        dir: V,
        sizes: [.511, .628],
        variants: [0, 2]
    },
    0x27E6: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x27E6, 0x27E6, 0x27E6],
        stretchv: [3, 1, 4],
        HDW: [.75, .25, 1.007]
    },
    0x27E7: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001],
        stretch: [0x27E7, 0x27E7, 0x27E7],
        stretchv: [3, 1, 4],
        HDW: [.75, .25, 1.007]
    },
    0x27E8: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x27E9: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x27EA: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x27EB: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x27EE: {
        dir: V,
        sizes: [1.025, 1.127, 1.229, 1.483, 1.837, 2.141, 2.445, 3.053],
        stretch: [0x27EE, 0x27EE, 0x27EE],
        stretchv: [3, 1, 4],
        HDW: [.762, .262, .647]
    },
    0x27EF: {
        dir: V,
        sizes: [1.025, 1.127, 1.229, 1.483, 1.837, 2.141, 2.445, 3.053],
        stretch: [0x27EF, 0x27EF, 0x27EF],
        stretchv: [3, 1, 4],
        HDW: [.762, .262, .647]
    },
    0x27F5: {
        c: 0x2190,
        dir: H,
        sizes: [1, 1.463],
        variants: [0, 0],
        schar: [0x2190, 0x27F5],
        stretch: [0x2190, 0x2190],
        stretchv: [3, 1],
        HDW: [0.51, 0.01, 1],
        hd: [.274, -.226]
    },
    0x27F6: {
        c: 0x2192,
        dir: H,
        sizes: [1, 1.463],
        variants: [0, 0],
        schar: [0x2192, 0x27F6],
        stretch: [0, 0x2190, 0x2192],
        stretchv: [0, 1, 4],
        HDW: [0.51, 0.01, 1],
        hd: [.274, -.226]
    },
    0x27F7: {
        c: 0x2194,
        dir: H,
        sizes: [1, 1.442],
        variants: [0, 0],
        schar: [0x2194, 0x27F7],
        stretch: [0x2190, 0x2190, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.01, 1],
        hd: [.274, -.226]
    },
    0x27F8: {
        c: 0x21D0,
        dir: H,
        sizes: [1, 1.457],
        variants: [0, 0],
        schar: [0x21D0, 0x27F8],
        stretch: [0x21D0, 0x21D0],
        stretchv: [3, 1],
        HDW: [0.52, 0.02, 1],
        hd: [.369, -.131]
    },
    0x27F9: {
        c: 0x21D2,
        dir: H,
        sizes: [1, 1.457],
        variants: [0, 0],
        schar: [0x21D2, 0x27F9],
        stretch: [0, 0x21D0, 0x21D2],
        stretchv: [0, 1, 4],
        HDW: [0.52, 0.02, 1],
        hd: [.369, -.131]
    },
    0x27FA: {
        c: 0x21D4,
        dir: H,
        sizes: [1, 1.534],
        variants: [0, 0],
        schar: [0x21D4, 0x27FA],
        stretch: [0x21D0, 0x21D0, 0x21D2],
        stretchv: [3, 1, 4],
        HDW: [0.52, 0.02, 1],
        hd: [.369, -.131]
    },
    0x27FB: {
        c: 0x21A4,
        dir: H,
        sizes: [.977, 1.443],
        variants: [0, 0],
        schar: [0x21A4, 0x27FB],
        stretch: [0x2190, 0x2190, 0x21A4],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, .977],
        hd: [.274, -.226]
    },
    0x27FC: {
        c: 0x21A6,
        dir: H,
        sizes: [.977, 1.443],
        variants: [0, 0],
        schar: [0x21A6, 0x27FC],
        stretch: [0x21A6, 0x2190, 0x2192],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, .977],
        hd: [.274, -.226]
    },
    0x294A: {
        dir: H,
        sizes: [1.012],
        stretch: [0x21BC, 0x21BC, 0x21C1],
        stretchv: [3, 1, 4],
        HDW: [0.499, 0, 1.012],
        hd: [.273, -.226]
    },
    0x294B: {
        dir: H,
        sizes: [1.012],
        stretch: [0x21BD, 0x21BC, 0x21C0],
        stretchv: [3, 1, 4],
        HDW: [0.499, 0, 1.012],
        hd: [.273, -.226]
    },
    0x294E: {
        dir: H,
        sizes: [1],
        stretch: [0x21BC, 0x21BC, 0x21C0],
        stretchv: [3, 1, 4],
        HDW: [0.499, -0.226, 1],
        hd: [.273, -.226]
    },
    0x2950: {
        dir: H,
        sizes: [1],
        stretch: [0x21BD, 0x21BC, 0x21C1],
        stretchv: [3, 1, 4],
        HDW: [0.273, 0, 1],
        hd: [.273, -.226]
    },
    0x295A: {
        dir: H,
        sizes: [1],
        stretch: [0x21BC, 0x21BC, 0x21A4],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, 1],
        hd: [.273, -.226]
    },
    0x295B: {
        dir: H,
        sizes: [1],
        stretch: [0x21A6, 0x21BC, 0x21C0],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, 1],
        hd: [.273, -.226]
    },
    0x295E: {
        dir: H,
        sizes: [1],
        stretch: [0x21BD, 0x21BC, 0x21A4],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, 1],
        hd: [.273, -.226]
    },
    0x295F: {
        dir: H,
        sizes: [1],
        stretch: [0x21A6, 0x21BC, 0x21C1],
        stretchv: [3, 1, 4],
        HDW: [0.51, 0.011, 1],
        hd: [.273, -.226]
    },
    0x2983: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x2984: {
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x2985: {
        dir: V,
        sizes: [.997, 1.095, 1.195, 1.445, 1.793, 2.093, 2.393, 2.991]
    },
    0x2986: {
        dir: V,
        sizes: [.997, 1.095, 1.195, 1.445, 1.793, 2.093, 2.393, 2.991]
    },
    0x29F8: {
        dir: V,
        sizes: [1.076, 1.917],
        variants: [0, 2]
    },
    0x29F9: {
        dir: V,
        sizes: [1.076, 1.917],
        variants: [0, 2]
    },
    0x29FC: {
        dir: V,
        sizes: [1.001, 1.083, 1.185, 1.433, 1.793, 2.093, 2.383, 2.997]
    },
    0x29FD: {
        dir: V,
        sizes: [1.001, 1.083, 1.185, 1.433, 1.793, 2.093, 2.383, 2.997]
    },
    0x2A00: {
        dir: V,
        sizes: [.987, 1.305],
        variants: [0, 2]
    },
    0x2A01: {
        dir: V,
        sizes: [.987, 1.305],
        variants: [0, 2]
    },
    0x2A02: {
        dir: V,
        sizes: [.987, 1.305],
        variants: [0, 2]
    },
    0x2A03: {
        dir: V,
        sizes: [1.023, 1.357],
        variants: [0, 2]
    },
    0x2A04: {
        dir: V,
        sizes: [1.023, 1.357],
        variants: [0, 2]
    },
    0x2A05: {
        dir: V,
        sizes: [1.029, 1.373],
        variants: [0, 2]
    },
    0x2A06: {
        dir: V,
        sizes: [1.029, 1.373],
        variants: [0, 2]
    },
    0x2A07: {
        dir: V,
        sizes: [1.045, 1.907],
        variants: [0, 2]
    },
    0x2A08: {
        dir: V,
        sizes: [1.045, 1.907],
        variants: [0, 2]
    },
    0x2A09: {
        dir: V,
        sizes: [.981, 1.261],
        variants: [0, 2]
    },
    0x2A0A: {
        dir: V,
        sizes: [1.001, 1.401],
        variants: [0, 2]
    },
    0x2A0B: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A0C: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A0D: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A0E: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A0F: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A10: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A11: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A12: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A13: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A14: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A15: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A16: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A17: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A18: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A19: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A1A: {
        dir: V,
        sizes: [1.112, 2.223],
        variants: [0, 2]
    },
    0x2A1B: {
        dir: V,
        sizes: [1.274, 2.464],
        variants: [0, 2]
    },
    0x2A1C: {
        dir: V,
        sizes: [1.274, 2.486],
        variants: [0, 2]
    },
    0x2A1D: {
        dir: V,
        sizes: [.767, 1.073],
        variants: [0, 2]
    },
    0x2A1E: {
        dir: V,
        sizes: [.767, 1.074],
        variants: [0, 2]
    },
    0x2A20: {
        dir: V,
        sizes: [.595, .835],
        variants: [0, 2]
    },
    0x2A21: {
        dir: V,
        sizes: [.901, 1.261],
        variants: [0, 2]
    },
    0x2AFC: {
        dir: V,
        sizes: [1.001, 1.915],
        variants: [0, 2]
    },
    0x2AFF: {
        dir: V,
        sizes: [1.241, 1.915],
        variants: [0, 2]
    },
    0x3008: {
        c: 0x27E8,
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0x3009: {
        c: 0x27E9,
        dir: V,
        sizes: [1.001, 1.101, 1.201, 1.451, 1.801, 2.101, 2.401, 3.001]
    },
    0xFE37: {
        c: 0x23DE,
        dir: H,
        sizes: [.492, .993, 1.494, 1.996, 2.498, 3, 3.502, 4.006],
        stretch: [0x23DE, 0xAF, 0x23DE, 0x23DE],
        stretchv: [3, 1, 4, 1],
        HDW: [0.85, -0.493, .492],
        hd: [.724, -.618]
    },
    0xFE38: {
        c: 0x23DF,
        dir: H,
        sizes: [.492, .993, 1.494, 1.996, 2.498, 3, 3.502, 4.006],
        stretch: [0x23DF, 0x5F, 0x23DF, 0x23DF],
        stretchv: [3, 1, 4, 1],
        HDW: [-0.062, 0.419, .492],
        hd: [-.188, .294]
    },
    0x1EEF0: {
        dir: V,
        sizes: [.527, .738]
    },
    0x1EEF1: {
        dir: V,
        sizes: [.531, .744]
    }
};
//# sourceMappingURL=delimiters.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml.js




































const Base = CommonMathJaxNewcmFontMixin(ChtmlFontData);
class MathJaxNewcmFont extends Base {
    constructor() {
        super(...arguments);
        this.cssFontPrefix = 'NCM';
    }
}
MathJaxNewcmFont.NAME = 'MathJaxNewcm';
MathJaxNewcmFont.OPTIONS = Object.assign(Object.assign({}, Base.OPTIONS), { fontURL: '@mathjax/mathjax-newcm-font/js/chtml/woff2', dynamicPrefix: '@mathjax/mathjax-newcm-font/js/chtml/dynamic' });
MathJaxNewcmFont.defaultCssFamilyPrefix = 'MJX-NCM-ZERO';
MathJaxNewcmFont.defaultVariantLetters = {
    'normal': '',
    'bold': 'B',
    'italic': 'I',
    'bold-italic': 'BI',
    'double-struck': 'DS',
    'fraktur': 'F',
    'bold-fraktur': 'FB',
    'sans-serif': 'SS',
    'bold-sans-serif': 'SSB',
    'sans-serif-italic': 'SSI',
    'sans-serif-bold-italic': 'SSBI',
    'monospace': 'M',
    '-smallop': 'SO',
    '-largeop': 'LO',
    '-size3': 'S3',
    '-size4': 'S4',
    '-size5': 'S5',
    '-size6': 'S6',
    '-size7': 'S7',
    '-tex-mathit': 'MI',
    '-tex-calligraphic': 'C',
    '-tex-bold-calligraphic': 'CB',
    '-tex-oldstyle': 'OS',
    '-tex-bold-oldstyle': 'OB',
    '-tex-variant': 'V',
    '-lf-tp': 'LT',
    '-rt-bt': 'RB',
    '-ex-md': 'EM',
    '-bbold': 'Be',
    '-upsmall': 'U',
    '-uplarge': 'Ue',
    'script': 'S',
    'bold-script': 'SB'
};
MathJaxNewcmFont.defaultDelimiters = delimiters;
MathJaxNewcmFont.defaultChars = {
    'normal': normal,
    'bold': bold,
    'italic': italic,
    'bold-italic': boldItalic,
    'double-struck': doubleStruck,
    'fraktur': fraktur,
    'bold-fraktur': frakturBold,
    'sans-serif': sansSerif,
    'bold-sans-serif': sansSerifBold,
    'sans-serif-italic': sansSerifItalic,
    'sans-serif-bold-italic': sansSerifBoldItalic,
    'monospace': monospace,
    '-smallop': smallop,
    '-largeop': largeop,
    '-size3': size3,
    '-size4': size4,
    '-size5': size5,
    '-size6': size6,
    '-size7': size7,
    '-tex-mathit': texMathit,
    '-tex-calligraphic': texCalligraphic,
    '-tex-bold-calligraphic': texCalligraphicBold,
    '-tex-oldstyle': texOldstyle,
    '-tex-bold-oldstyle': texOldstyleBold,
    '-tex-variant': texVariant,
    '-lf-tp': lfTp,
    '-rt-bt': rtBt,
    '-ex-md': exMd,
    '-bbold': bbold,
    '-upsmall': upsmall,
    '-uplarge': uplarge,
    'script': script,
    'bold-script': scriptBold
};
MathJaxNewcmFont.defaultStyles = Object.assign(Object.assign({}, ChtmlFontData.defaultStyles), { 'mjx-container[jax="CHTML"] > mjx-math.NCM-N[breakable] > *': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-N'
    }, '.NCM-N': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-N'
    }, '.NCM-B': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-B'
    }, '.NCM-I': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-I'
    }, '.NCM-BI': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-BI'
    }, '.NCM-DS': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-DS'
    }, '.NCM-F': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-F'
    }, '.NCM-FB': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-FB'
    }, '.NCM-SS': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-SS'
    }, '.NCM-SSB': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-SSB'
    }, '.NCM-SSI': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-SSI'
    }, '.NCM-SSBI': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-SSBI'
    }, '.NCM-M': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-M'
    }, '.NCM-SO': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-SO'
    }, '.NCM-LO': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-LO'
    }, '.NCM-S3': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-S3'
    }, '.NCM-S4': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-S4'
    }, '.NCM-S5': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-S5'
    }, '.NCM-S6': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-S6'
    }, '.NCM-S7': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-S7'
    }, '.NCM-MI': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-MI'
    }, '.NCM-C': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-C'
    }, '.NCM-CB': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-CB'
    }, '.NCM-OS': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-OS'
    }, '.NCM-OB': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-OB'
    }, '.NCM-V': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-V'
    }, '.NCM-LT': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-LT'
    }, '.NCM-RB': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-RB'
    }, '.NCM-EM': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-EM'
    }, '.NCM-Be': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-Be'
    }, '.NCM-U': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-U'
    }, '.NCM-Ue': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-Ue'
    }, '.NCM-S': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-S'
    }, '.NCM-SB': {
        'font-family': 'MJX-NCM-ZERO, MJX-NCM-SB'
    } });
MathJaxNewcmFont.defaultFonts = Object.assign(Object.assign({}, ChtmlFontData.defaultFonts), { '@font-face /* MJX-NCM-ZERO */': {
        'font-family': 'MJX-NCM-ZERO',
        src: 'url("%%URL%%/mjx-ncm-zero.woff2") format("woff2")'
    }, '@font-face /* MJX-BRK */': {
        'font-family': 'MJX-BRK',
        src: 'url("%%URL%%/mjx-ncm-brk.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-N */': {
        'font-family': 'MJX-NCM-N',
        src: 'url("%%URL%%/mjx-ncm-n.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-B */': {
        'font-family': 'MJX-NCM-B',
        src: 'url("%%URL%%/mjx-ncm-b.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-I */': {
        'font-family': 'MJX-NCM-I',
        src: 'url("%%URL%%/mjx-ncm-i.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-BI */': {
        'font-family': 'MJX-NCM-BI',
        src: 'url("%%URL%%/mjx-ncm-bi.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-DS */': {
        'font-family': 'MJX-NCM-DS',
        src: 'url("%%URL%%/mjx-ncm-ds.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-F */': {
        'font-family': 'MJX-NCM-F',
        src: 'url("%%URL%%/mjx-ncm-f.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-FB */': {
        'font-family': 'MJX-NCM-FB',
        src: 'url("%%URL%%/mjx-ncm-fb.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-SS */': {
        'font-family': 'MJX-NCM-SS',
        src: 'url("%%URL%%/mjx-ncm-ss.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-SSB */': {
        'font-family': 'MJX-NCM-SSB',
        src: 'url("%%URL%%/mjx-ncm-ssb.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-SSI */': {
        'font-family': 'MJX-NCM-SSI',
        src: 'url("%%URL%%/mjx-ncm-ssi.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-SSBI */': {
        'font-family': 'MJX-NCM-SSBI',
        src: 'url("%%URL%%/mjx-ncm-ssbi.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-M */': {
        'font-family': 'MJX-NCM-M',
        src: 'url("%%URL%%/mjx-ncm-m.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-SO */': {
        'font-family': 'MJX-NCM-SO',
        src: 'url("%%URL%%/mjx-ncm-so.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-LO */': {
        'font-family': 'MJX-NCM-LO',
        src: 'url("%%URL%%/mjx-ncm-lo.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-S3 */': {
        'font-family': 'MJX-NCM-S3',
        src: 'url("%%URL%%/mjx-ncm-s3.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-S4 */': {
        'font-family': 'MJX-NCM-S4',
        src: 'url("%%URL%%/mjx-ncm-s4.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-S5 */': {
        'font-family': 'MJX-NCM-S5',
        src: 'url("%%URL%%/mjx-ncm-s5.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-S6 */': {
        'font-family': 'MJX-NCM-S6',
        src: 'url("%%URL%%/mjx-ncm-s6.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-S7 */': {
        'font-family': 'MJX-NCM-S7',
        src: 'url("%%URL%%/mjx-ncm-s7.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-MI */': {
        'font-family': 'MJX-NCM-MI',
        src: 'url("%%URL%%/mjx-ncm-mi.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-C */': {
        'font-family': 'MJX-NCM-C',
        src: 'url("%%URL%%/mjx-ncm-c.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-CB */': {
        'font-family': 'MJX-NCM-CB',
        src: 'url("%%URL%%/mjx-ncm-cb.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-OS */': {
        'font-family': 'MJX-NCM-OS',
        src: 'url("%%URL%%/mjx-ncm-os.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-OB */': {
        'font-family': 'MJX-NCM-OB',
        src: 'url("%%URL%%/mjx-ncm-ob.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-V */': {
        'font-family': 'MJX-NCM-V',
        src: 'url("%%URL%%/mjx-ncm-v.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-LT */': {
        'font-family': 'MJX-NCM-LT',
        src: 'url("%%URL%%/mjx-ncm-lt.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-RB */': {
        'font-family': 'MJX-NCM-RB',
        src: 'url("%%URL%%/mjx-ncm-rb.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-EM */': {
        'font-family': 'MJX-NCM-EM',
        src: 'url("%%URL%%/mjx-ncm-em.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-Be */': {
        'font-family': 'MJX-NCM-Be',
        src: 'url("%%URL%%/mjx-ncm-be.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-U */': {
        'font-family': 'MJX-NCM-U',
        src: 'url("%%URL%%/mjx-ncm-u.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-Ue */': {
        'font-family': 'MJX-NCM-Ue',
        src: 'url("%%URL%%/mjx-ncm-ue.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-S */': {
        'font-family': 'MJX-NCM-S',
        src: 'url("%%URL%%/mjx-ncm-s.woff2") format("woff2")'
    }, '@font-face /* MJX-NCM-SB */': {
        'font-family': 'MJX-NCM-SB',
        src: 'url("%%URL%%/mjx-ncm-sb.woff2") format("woff2")'
    } });
MathJaxNewcmFont.dynamicFiles = ChtmlFontData.defineDynamicFiles([
    ['latin', {
            'normal': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E9B], 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['latin-b', {
            'bold': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['latin-i', {
            'italic': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9]
            ]
        }],
    ['latin-bi', {
            'bold-italic': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9]
            ]
        }],
    ['double-struck', {
            'normal': [
                0x2102, 0x210D, 0x2115, 0x2119, 0x211A, 0x211D, 0x2124, [0x213C, 0x2140], [0x2145, 0x2149], 0x1D538, 0x1D539, [0x1D53B, 0x1D53E], [0x1D540, 0x1D544], 0x1D546, [0x1D54A, 0x1D550], [0x1D552, 0x1D56B], [0x1D7D8, 0x1D7E1]
            ],
            'double-struck': [
                0x131, 0x237
            ]
        }],
    ['fraktur', {
            'normal': [
                0x210C, 0x2111, 0x211C, 0x2128, 0x212D, 0x1D504, 0x1D505, [0x1D507, 0x1D50A], [0x1D50D, 0x1D514], [0x1D516, 0x1D51C], [0x1D51E, 0x1D537], [0x1D56C, 0x1D59F]
            ],
            'fraktur': [
                0x131, 0x237
            ],
            'bold-fraktur': [
                0x131, 0x237
            ]
        }],
    ['script', {
            'normal': [
                0x210A, 0x210B, 0x2110, 0x2112, 0x2113, 0x2118, 0x211B, 0x212C, [0x212F, 0x2131], 0x2133, 0x2134, 0x1D49C, 0x1D49E, 0x1D49F, 0x1D4A2, 0x1D4A5, 0x1D4A6, [0x1D4A9, 0x1D4AC], [0x1D4AE, 0x1D4B9], 0x1D4BB, [0x1D4BD, 0x1D4C3], [0x1D4C5, 0x1D503]
            ],
            'script': [],
            'bold-script': []
        }],
    ['sans-serif', {
            'normal': [
                [0x2141, 0x2144], [0x1D5A0, 0x1D66F], [0x1D756, 0x1D7C9], [0x1D7E2, 0x1D7F5]
            ],
            'sans-serif': [
                [0x20, 0x2F], [0x3A, 0x40], [0x5B, 0x60], [0x7B, 0x7E], 0xA0, 0xA3, 0xA5, 0xA7, 0xA8, 0xAC, [0xAF, 0xB1], [0xB4, 0xB7], 0xD7, 0xF0, 0xF7, 0x131, 0x237, 0x2C6, 0x2C7, [0x2C9, 0x2CB], [0x2D8, 0x2DA], 0x2DC, [0x300, 0x308], 0x30A, 0x30C, [0x391, 0x3A1], [0x3A3, 0x3A9], [0x3B1, 0x3C9], 0x3D1, 0x3D2, 0x3D5, 0x3D6, 0x3F0, 0x3F1, [0x3F4, 0x3F6], [0x2010, 0x2014], 0x2016, 0x2018, 0x2019, 0x201C, 0x201D, 0x2020, 0x2021, 0x2026, 0x2044, 0x20AC, 0x2126, 0x2127, [0x2190, 0x2193], 0x2212, 0x221E
            ],
            'bold-sans-serif': [
                0x20, 0x21, [0x23, 0x2F], 0x3A, 0x3B, 0x3D, 0x3F, 0x40, [0x5B, 0x60], [0x7B, 0x7E], 0xA0, 0xA3, 0xA5, 0xA7, 0xA8, 0xAC, [0xAF, 0xB1], [0xB4, 0xB7], 0xD7, 0xF0, 0xF7, 0x131, 0x237, 0x2C6, 0x2C7, [0x2C9, 0x2CB], [0x2D8, 0x2DA], 0x2DC, [0x300, 0x308], 0x30A, 0x30C, 0x3D2, 0x3F6, [0x2010, 0x2014], 0x2016, 0x2018, 0x2019, 0x201C, 0x201D, 0x2020, 0x2021, 0x2026, 0x2044, 0x20AC, 0x2126, 0x2127, [0x2190, 0x2193], 0x2212, 0x221E
            ],
            'sans-serif-italic': [
                [0x20, 0x40], [0x5B, 0x60], [0x7B, 0x7E], 0xA0, 0xA3, 0xA5, 0xA7, 0xA8, 0xAC, [0xAF, 0xB1], [0xB4, 0xB7], 0xD7, 0xF0, 0xF7, 0x131, 0x237, 0x2C6, 0x2C7, [0x2C9, 0x2CB], [0x2D8, 0x2DA], 0x2DC, [0x300, 0x308], 0x30A, 0x30C, [0x391, 0x3A1], [0x3A3, 0x3A9], [0x3B1, 0x3C9], 0x3D1, 0x3D2, 0x3D5, 0x3D6, 0x3F0, 0x3F1, [0x3F4, 0x3F6], [0x2010, 0x2014], 0x2016, 0x2018, 0x2019, 0x201C, 0x201D, 0x2020, 0x2021, 0x2026, 0x2044, 0x20AC, 0x2126, 0x2127, [0x2190, 0x2193], 0x2212, 0x221E
            ],
            'sans-serif-bold-italic': [
                0x20, 0x21, [0x23, 0x3B], 0x3D, 0x3F, 0x40, [0x5B, 0x60], [0x7B, 0x7E], 0xA0, 0xA3, 0xA5, 0xA7, 0xA8, 0xAC, [0xAF, 0xB1], [0xB4, 0xB7], 0xD7, 0xF0, 0xF7, 0x131, 0x237, 0x2C6, 0x2C7, [0x2C9, 0x2CB], [0x2D8, 0x2DA], 0x2DC, [0x300, 0x308], 0x30A, 0x30C, 0x3D2, 0x3F6, [0x2010, 0x2014], 0x2016, 0x2018, 0x2019, 0x201C, 0x201D, 0x2020, 0x2021, 0x2026, 0x2044, 0x20AC, 0x2126, 0x2127, [0x2190, 0x2193], 0x2212, 0x221E
            ]
        }],
    ['sans-serif-r', {
            'sans-serif': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['sans-serif-b', {
            'bold-sans-serif': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['sans-serif-i', {
            'sans-serif-italic': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['sans-serif-bi', {
            'sans-serif-bold-italic': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['sans-serif-ex', {
            'sans-serif': [
                0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, 0xB8, [0xBA, 0xBF], [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x34E], [0x350, 0x36F], 0xE3F, 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9, 0x200C, 0x200D, 0x201A, 0x201B, 0x201E, 0x201F, 0x2022, 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x207F, 0x2080, 0x20A1, 0x20A6, 0x20A9, 0x20AB, 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, [0x2190, 0x2193], 0x221A, 0x2222, 0x2300, 0x2329, 0x232A, 0x2422, 0x2423, 0x2502, 0x2551, 0x25E6, 0x262D, 0x2640, 0x266A, 0x26AD, 0x26AE, 0x26B2, 0x271D, 0x27E6, 0x27E7, 0x2E18, 0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA37, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, 0xEB0F, 0xEB11, 0xEB12, 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE, [0xFB00, 0xFB04], 0xFE66
            ],
            'bold-sans-serif': [
                0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, 0xB8, [0xBA, 0xBF], [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x34E], [0x350, 0x36F], 0xE3F, 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9, 0x200C, 0x200D, 0x201A, 0x201B, 0x201E, 0x201F, 0x2022, 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x207F, 0x2080, 0x20A1, 0x20A6, 0x20A9, 0x20AB, 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, [0x2190, 0x2193], 0x221A, 0x2222, 0x2300, 0x2329, 0x232A, 0x2422, 0x2423, 0x2502, 0x2551, 0x25E6, 0x262D, 0x2640, 0x266A, 0x26AD, 0x26AE, 0x26B2, 0x271D, 0x27E6, 0x27E7, 0x2E18, 0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE, [0xFB00, 0xFB04], 0xFE66
            ],
            'sans-serif-italic': [
                0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, 0xB8, [0xBA, 0xBF], [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x34E], [0x350, 0x36F], 0xE3F, 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9, 0x200C, 0x200D, 0x201A, 0x201B, 0x201E, 0x201F, 0x2022, 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x207F, 0x2080, 0x20A1, 0x20A6, 0x20A9, 0x20AB, 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, [0x2190, 0x2193], 0x221A, 0x2222, 0x2300, 0x2329, 0x232A, 0x2422, 0x2423, 0x2502, 0x2551, 0x25E6, 0x262D, 0x2640, 0x266A, 0x26AD, 0x26AE, 0x26B2, 0x271D, 0x27E6, 0x27E7, 0x2E18, 0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE, [0xFB00, 0xFB04], 0xFE66
            ],
            'sans-serif-bold-italic': [
                0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, 0xB8, [0xBA, 0xBF], [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x36F], 0xE3F, 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9, 0x200C, 0x200D, 0x201A, 0x201B, 0x201E, 0x201F, 0x2022, 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x207F, 0x2080, 0x20A1, 0x20A6, 0x20A9, 0x20AB, 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, [0x2190, 0x2193], 0x221A, 0x2222, 0x2300, 0x2329, 0x232A, 0x2422, 0x2423, 0x2502, 0x2551, 0x25E6, 0x262D, 0x2640, 0x266A, 0x26AD, 0x26AE, 0x26B2, 0x271D, 0x27E6, 0x27E7, 0x2E18, 0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE, [0xFB00, 0xFB04], 0xFE66
            ]
        }],
    ['monospace', {
            'normal': [
                [0x1D670, 0x1D6A3], [0x1D7F6, 0x1D7FF]
            ],
            'monospace': [
                [0x20, 0x2F], [0x3A, 0x40], [0x5B, 0x60], [0x7B, 0x7E], 0xA0, 0xA3, 0xA5, 0xA7, 0xA8, 0xAC, [0xAF, 0xB1], [0xB4, 0xB7], 0xD7, 0xF0, 0xF7, 0x131, 0x237, 0x2C6, 0x2C7, [0x2D8, 0x2DA], 0x2DC, [0x300, 0x308], 0x30A, 0x30C, [0x391, 0x3A1], [0x3A3, 0x3A9], [0x3B1, 0x3C9], 0x3D1, 0x3D2, 0x3D5, 0x3D6, 0x3F0, 0x3F1, [0x3F4, 0x3F6], [0x2010, 0x2014], 0x2016, 0x2018, 0x2019, 0x201C, 0x201D, 0x2020, 0x2021, 0x2026, 0x2044, 0x20AC, 0x2126, 0x2127, [0x2190, 0x2193], 0x2212, 0x221E
            ]
        }],
    ['monospace-l', {
            'monospace': [
                [0xC0, 0xD6], [0xD8, 0xEF], [0xF1, 0xF6], [0xF8, 0x130], [0x132, 0x236], [0x238, 0x24F], [0x1E00, 0x1E13], [0x1E18, 0x1E1B], [0x1E1E, 0x1E27], [0x1E2A, 0x1E4B], [0x1E54, 0x1E63], [0x1E68, 0x1E77], [0x1E7C, 0x1E99], 0x1E9B, 0x1E9E, [0x1EA0, 0x1EF9], 0x2C71
            ]
        }],
    ['monospace-ex', {
            'monospace': [
                0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, 0xB8, [0xBA, 0xBF], [0x250, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3E3], 0x3F2, 0x3F3, [0x3F7, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D], 0xE3F, 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97, 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9, [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE], 0x201A, 0x201B, 0x201E, 0x201F, 0x2022, 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x207F, 0x2080, 0x20A1, 0x20A6, 0x20A9, 0x20AB, 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, [0x2190, 0x2193], 0x221A, 0x2222, 0x2300, 0x2329, 0x232A, 0x2422, 0x2423, 0x2500, 0x2502, 0x250C, 0x2510, 0x2514, 0x2518, 0x251C, 0x2524, 0x252C, 0x2534, 0x253C, [0x2550, 0x256B], 0x25E6, 0x262D, 0x2640, 0x266A, 0x26AD, 0x26AE, 0x26B2, 0x271D, 0x27E6, 0x27E7, 0x2E18, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE, [0xFB00, 0xFB06], 0xFE66
            ]
        }],
    ['calligraphic', {
            '-tex-calligraphic': [
                [0x41, 0x5A]
            ],
            '-tex-bold-calligraphic': [
                [0x41, 0x5A]
            ]
        }],
    ['math', {
            'normal': [
                0x220A, 0x220D, 0x221B, 0x221C, 0x223A, 0x223B, 0x224E, 0x224F, [0x2251, 0x2253], [0x2256, 0x225C], 0x225E, 0x228C, [0x22B6, 0x22B9], [0x22BB, 0x22BF], 0x22C7, [0x22D0, 0x22E1], [0x22E4, 0x22E9], [0x22F2, 0x22FF], [0x27C0, 0x27D7], [0x27DA, 0x27DC], [0x27DF, 0x27E5], [0x2981, 0x2996], [0x2999, 0x29F4], 0x29F6, [0x29FA, 0x29FF], 0x2A0A, 0x2A0B, [0x2A1D, 0x2A2E], [0x2A30, 0x2A3E], [0x2A40, 0x2A7C], [0x2A7F, 0x2A84], [0x2A8D, 0x2A94], [0x2A97, 0x2AAE], [0x2ABB, 0x2AC4], [0x2AC7, 0x2ACA], [0x2ACD, 0x2ADD], [0x2AEC, 0x2AF1], [0x2AF6, 0x2AFB], [0x2AFD, 0x2AFF]
            ]
        }],
    ['symbols', {
            'normal': [
                0x7F, 0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, 0xB2, 0xB3, [0xB9, 0xBF], 0xE3F, 0x200C, 0x200D, 0x2017, 0x201A, 0x201B, 0x201E, 0x201F, [0x2022, 0x2025], 0x2029, 0x2030, 0x2031, [0x2038, 0x2043], [0x2045, 0x2056], [0x2058, 0x205E], 0x207F, 0x2080, 0x20A1, 0x20A6, [0x20A9, 0x20AB], 0x20B1, 0x20B2, 0x2100, 0x2101, [0x2103, 0x2106], 0x2108, 0x2109, 0x2114, 0x2116, 0x2117, [0x211E, 0x2123], 0x2125, 0x2129, 0x212E, [0x2139, 0x213B], [0x214A, 0x214F], [0x2300, 0x2306], [0x2311, 0x2318], 0x231A, 0x231B, [0x2324, 0x2328], [0x232B, 0x239A], 0x23B6, [0x23BA, 0x23CD], 0x23CF, [0x23D1, 0x23DB], [0x23E2, 0x23F3], [0x23F8, 0x23FF], 0x2422, 0x2423, 0x2B97, 0x2BB9, 0x2BC9, [0x2BD0, 0x2BE9], [0x2BF0, 0x2BFF], 0x2E18, 0x3012, 0x3016, 0x3017, 0x3030, [0xFB00, 0xFB06], 0xFE66, 0xFEFF
            ]
        }, [0x2017]],
    ['symbols-b-i', {
            'bold': [
                0xA1, 0xA2, 0xA4, 0xA6, [0xA9, 0xAB], 0xAD, 0xAE, [0xBA, 0xBF], 0xE3F, 0x200C, 0x200D, 0x201A, 0x201B, 0x201E, 0x201F, 0x2022, 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x207F, 0x2080, 0x20A1, 0x20A6, [0x20A9, 0x20AB], 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, 0x2300, 0x2422, 0x2423, 0x2E18, [0xFB00, 0xFB06], 0xFE66
            ],
            'italic': [
                [0xA1, 0xA7], [0xA9, 0xAE], 0xB1, [0xB5, 0xB7], [0xBA, 0xBF], 0xD7, 0xF0, 0xF7, 0xE3F, 0x200C, 0x200D, 0x201A, 0x201B, [0x201E, 0x2022], 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x2080, 0x20A1, 0x20A6, 0x20A9, 0x20AB, 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, 0x2300, 0x2422, 0x2423, 0x2E18, [0xFB00, 0xFB06], 0xFE66
            ],
            'bold-italic': [
                [0xA1, 0xA7], [0xA9, 0xAE], 0xB1, [0xB5, 0xB7], [0xBA, 0xBF], 0xD7, 0xF0, 0xF7, 0xE3F, 0x200C, 0x200D, 0x201A, 0x201B, [0x201E, 0x2022], 0x2029, 0x2030, 0x2031, [0x2039, 0x203B], 0x203D, 0x203F, 0x2040, 0x2045, 0x2046, 0x2052, 0x2054, 0x2080, 0x20A1, 0x20A6, [0x20A9, 0x20AB], 0x20B1, 0x20B2, 0x2103, 0x2116, 0x2117, 0x211E, 0x2120, 0x2122, 0x212E, 0x2300, 0x2422, 0x2423, 0x2E18, [0xFB00, 0xFB06], 0xFE66
            ]
        }],
    ['greek', {
            'normal': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE], [0x2C80, 0x2CF3], [0x2CF9, 0x2CFF]
            ],
            'bold': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3DB], [0x3DE, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE], [0x2C80, 0x2CF3], [0x2CF9, 0x2CFF]
            ],
            'italic': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE], [0x2C80, 0x2CF3], [0x2CF9, 0x2CFF]
            ],
            'bold-italic': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE], [0x2C80, 0x2CF3], [0x2CF9, 0x2CFF]
            ]
        }],
    ['greek-ss', {
            'sans-serif': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE]
            ],
            'bold-sans-serif': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FB9], [0x1FBB, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE]
            ],
            'sans-serif-italic': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE]
            ],
            'sans-serif-bold-italic': [
                [0x370, 0x377], [0x37A, 0x37F], [0x384, 0x38A], 0x38C, [0x38E, 0x390], [0x3AA, 0x3B0], [0x3CA, 0x3D0], 0x3D3, 0x3D4, [0x3D7, 0x3EF], 0x3F2, 0x3F3, [0x3F7, 0x3FF], [0x1F00, 0x1F15], [0x1F18, 0x1F1D], [0x1F20, 0x1F45], [0x1F48, 0x1F4D], [0x1F50, 0x1F57], 0x1F59, 0x1F5B, 0x1F5D, [0x1F5F, 0x1F7D], [0x1F80, 0x1FB4], [0x1FB6, 0x1FB9], [0x1FBB, 0x1FC4], [0x1FC6, 0x1FD3], [0x1FD6, 0x1FDB], [0x1FDD, 0x1FEF], [0x1FF2, 0x1FF4], [0x1FF6, 0x1FFE]
            ]
        }],
    ['cyrillic', {
            'normal': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ],
            'bold': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ],
            'italic': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4C9], [0x4CB, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ],
            'bold-italic': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4C9], [0x4CB, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ]
        }],
    ['cyrillic-ss', {
            'sans-serif': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ],
            'bold-sans-serif': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ],
            'sans-serif-italic': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ],
            'sans-serif-bold-italic': [
                [0x400, 0x477], [0x47A, 0x486], [0x488, 0x4CE], [0x4D0, 0x4F9], [0x4FC, 0x4FF], 0x512, 0x513, [0x51A, 0x51D]
            ]
        }],
    ['phonetics', {
            'normal': [
                [0x250, 0x2AF], 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97
            ],
            'bold': [
                [0x250, 0x2AF], 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97
            ],
            'italic': [
                [0x250, 0x2AD], 0x2AF
            ],
            'bold-italic': [
                [0x250, 0x2AF]
            ]
        }],
    ['phonetics-ss', {
            'sans-serif': [
                [0x250, 0x2AF], 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97
            ],
            'bold-sans-serif': [
                [0x250, 0x2AF], 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97
            ],
            'sans-serif-italic': [
                [0x250, 0x2AF], 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97
            ],
            'sans-serif-bold-italic': [
                [0x250, 0x2AF], 0x1D00, 0x1D07, 0x1D0A, 0x1D0B, 0x1D0D, 0x1D18, 0x1D19, 0x1D1C, [0x1D43, 0x1D4B], 0x1D4D, [0x1D4F, 0x1D53], [0x1D56, 0x1D58], 0x1D5A, 0x1D5B, 0x1D5D, 0x1D5E, 0x1D60, 0x1D61, 0x1D78, [0x1D90, 0x1D93], 0x1D97
            ]
        }],
    ['hebrew', {
            'normal': [
                [0x591, 0x5C7], [0x5D0, 0x5EA], [0x5EF, 0x5F5], 0x5F7, [0xFB1D, 0xFB4F]
            ],
            'bold': [
                [0x591, 0x5C7], [0x5D0, 0x5EB], [0x5EF, 0x5F5], 0x5F7, [0xFB1D, 0xFB4F]
            ],
            'italic': [
                [0x591, 0x5C7], [0x5D0, 0x5EA], [0x5EF, 0x5F5], 0x5F7, [0xFB1D, 0xFB4F]
            ],
            'bold-italic': [
                [0x591, 0x5C7], [0x5D0, 0x5EB], [0x5EF, 0x5F5], 0x5F7, [0xFB1D, 0xFB4F]
            ]
        }],
    ['devanagari', {
            'normal': [
                [0x900, 0x97F]
            ],
            'bold': [],
            'italic': [],
            'bold-italic': []
        }],
    ['cherokee', {
            'normal': [
                [0x13A0, 0x13F5], [0x13F8, 0x13FD]
            ],
            'bold': [
                [0x13A0, 0x13F5], [0x13F8, 0x13FD]
            ],
            'italic': [
                [0x13A0, 0x13FB]
            ],
            'bold-italic': [
                [0x13A0, 0x13FB]
            ]
        }],
    ['arabic', {
            'normal': [
                [0x1EE00, 0x1EE22], 0x1EE24, 0x1EE27, [0x1EE29, 0x1EE32], [0x1EE34, 0x1EE37], 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, [0x1EE4D, 0x1EE4F], 0x1EE51, 0x1EE52, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE61, 0x1EE62, 0x1EE64, [0x1EE67, 0x1EE6A], [0x1EE6C, 0x1EE72], [0x1EE74, 0x1EE77], [0x1EE79, 0x1EE7C], [0x1EE7E, 0x1EE89], [0x1EE8B, 0x1EE9B], [0x1EEA1, 0x1EEA3], [0x1EEA5, 0x1EEA9], [0x1EEAB, 0x1EEBB], 0x1EEF0, 0x1EEF1
            ],
            'bold': [],
            'italic': [],
            'bold-italic': []
        }],
    ['braille-d', {
            'normal': [
                [0x2800, 0x28FF]
            ]
        }],
    ['braille', {
            'sans-serif': [
                [0x2800, 0x28FF]
            ]
        }],
    ['arrows', {
            'normal': [
                0x219C, 0x219D, 0x219F, 0x21A1, 0x21A5, 0x21A7, 0x21A8, 0x21AD, [0x21AF, 0x21B5], 0x21B8, 0x21B9, [0x21D6, 0x21D9], [0x21DC, 0x21DF], [0x21E6, 0x21F4], [0x21F7, 0x21FF], 0x23CE, 0x27A1, [0x27F0, 0x27F4], 0x27FF, [0x2900, 0x2909], [0x290C, 0x2949], 0x294C, 0x294D, 0x294F, 0x2951, 0x2954, 0x2955, 0x2958, 0x2959, 0x295C, 0x295D, [0x2960, 0x2969], [0x2970, 0x297B], [0x2B00, 0x2B12], [0x2B30, 0x2B4F], [0x2B5A, 0x2B73], [0x2B76, 0x2B95], [0x2B98, 0x2BB8], [0x2BEC, 0x2BEF]
            ],
            '-largeop': [
                0x2191, 0x2193, [0x2195, 0x219B], [0x219E, 0x21A3], 0x21A5, 0x21A7, [0x21A9, 0x21AE], [0x21B0, 0x21B3], 0x21B6, 0x21B7, [0x21BC, 0x21CF], 0x21D1, 0x21D3, [0x21D5, 0x21DB], [0x21E6, 0x21E9], 0x21F3, 0x21F5, 0x21F6, [0x2B04, 0x2B07], 0x2B0C, 0x2B0D, 0x2B31
            ],
            '-lf-tp': [
                [0x21E6, 0x21E9], 0x2907, 0x2B05, 0x2B06
            ],
            '-rt-bt': [
                [0x21E6, 0x21E9], 0x2906, 0x2B07, 0x2B0C
            ],
            '-ex-md': [
                0x21E6, 0x21E7, 0x2B05, 0x2B06
            ]
        }, [0x219F, 0x21A1, 0x21A5, 0x21A7, 0x21AD, 0x21AE, [0x21B0, 0x21B3], [0x21D6, 0x21D9], 0x21DC, 0x21DD, [0x21E6, 0x21E9], 0x21F3, 0x27A1, 0x27FD, 0x27FE, 0x2906, 0x2907, 0x294C, 0x294D, 0x294F, 0x2951, 0x295C, 0x295D, 0x2960, 0x2961, [0x2B04, 0x2B07], 0x2B0C, 0x2B0D, 0x2B31]],
    ['marrows', {
            'normal': [
                [0x1F800, 0x1F80B], [0x1F810, 0x1F847], [0x1F850, 0x1F859], [0x1F860, 0x1F887], [0x1F890, 0x1F8AD], 0x1F8B0, 0x1F8B1
            ]
        }],
    ['accents', {
            'normal': [
                0xB8, [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x36F], 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9, [0x20D3, 0x20D5], 0x20D8, [0x20DD, 0x20DF], [0x20E4, 0x20EB], 0x20F0
            ],
            '-smallop': [
                0x311, [0x32C, 0x330], 0x332, 0x333, 0x33F, 0x34D
            ],
            '-largeop': [
                0x311, [0x32C, 0x330]
            ],
            '-size3': [
                0x311, [0x32C, 0x330]
            ],
            '-size4': [
                0x311, [0x32C, 0x330]
            ],
            '-size5': [
                0x311, [0x32C, 0x330]
            ],
            '-size6': [
                0x311, [0x32C, 0x330]
            ],
            '-size7': [
                0x311, [0x32C, 0x330]
            ],
            '-ex-md': [
                0x332, 0x333, 0x33F, 0x34D
            ]
        }, [0x311, [0x32C, 0x330], 0x332, 0x333, 0x33F, 0x34D, 0x20E9]],
    ['accents-b-i', {
            'bold': [
                0xB8, [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x34E], [0x350, 0x36F], 0x1DC4, 0x1DC5, 0x1DC8, 0x1DC9
            ],
            'italic': [
                0xB8, [0x2B0, 0x2BC], [0x2BE, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x34E], [0x350, 0x36F]
            ],
            'bold-italic': [
                0xB8, [0x2B0, 0x2C5], 0x2C8, 0x2CC, [0x2CE, 0x2D7], 0x2DB, [0x2DD, 0x2FE], 0x309, 0x30B, [0x30D, 0x337], [0x339, 0x34E], [0x350, 0x36F]
            ]
        }],
    ['shapes', {
            'normal': [
                0x2302, [0x2326, 0x2328], 0x232B, [0x23FB, 0x23FE], [0x2500, 0x259F], [0x25A2, 0x25A9], [0x25AC, 0x25B1], 0x25C8, 0x25C9, [0x25CC, 0x25CE], [0x25D0, 0x25E5], [0x25E7, 0x25EE], [0x25F0, 0x25F7], 0x2600, 0x2605, 0x2606, 0x2609, 0x2621, 0x262D, [0x2639, 0x263E], 0x2640, 0x2642, [0x2660, 0x2667], [0x2669, 0x266B], [0x266D, 0x266F], 0x267E, [0x2680, 0x2689], 0x26A5, [0x26AA, 0x26AE], 0x26B2, 0x2713, 0x271D, 0x2720, 0x272A, 0x2736, 0x273D, 0x2772, 0x2773, 0x279B, 0x27A1, [0x2B12, 0x2B2F], [0x2B50, 0x2B59], [0x2BBA, 0x2BC8], [0x2BCA, 0x2BCF], 0x2BEA, 0x2BEB
            ],
            'bold': [
                0x2502, 0x2551, 0x262D, 0x2640, 0x266A, 0x26AD, 0x26AE, 0x26B2, 0x271D
            ],
            'italic': [
                0x262D, 0x266A, 0x26AD, 0x26AE, 0x271D
            ],
            'bold-italic': [
                0x262D, 0x266A, 0x26AD, 0x26AE, 0x271D
            ]
        }],
    ['mshapes', {
            'normal': [
                [0x1F780, 0x1F7D8], [0x1F7E0, 0x1F7EB]
            ]
        }],
    ['variants', {
            '-tex-variant': [
                0x22, 0x27, 0x2A, 0x60, 0x7E, 0xAA, 0xB0, 0xB2, 0xB3, 0xB9, 0xBA, 0x2014, 0x2061, 0x2070, 0x2071, [0x2074, 0x208E]
            ]
        }],
    ['PUA', {
            'normal': [
                [0xE000, 0xE033], [0xE041, 0xE072], [0xE780, 0xE78A], 0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE
            ],
            'bold': [
                0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, [0xF141, 0xF146], [0xF14B, 0xF15C], [0xF15F, 0xF165], 0xF168, [0xF16C, 0xF172], 0xF175, [0xF179, 0xF17B], [0xF17E, 0xF180], 0xF182, 0xF184, 0xF185, [0xF188, 0xF18F], 0xF192, 0xF19A, 0xF19E, 0xF19F, 0xF1A1, 0xF1A3, 0xF1A4, [0xF1A7, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, [0xF2A7, 0xF2A9], 0xF2AC, 0xF2AE, 0xF2AF, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, [0xF6D3, 0xF6D6], 0xF6DE
            ],
            'italic': [
                0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, 0xF1AB, 0xF1AC, [0xF1B1, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, 0xF2A7, 0xF2A8, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, 0xF6C4, [0xF6C6, 0xF6C8], [0xF6D3, 0xF6D6], 0xF6DE
            ],
            'bold-italic': [
                0xE803, [0xEA04, 0xEA06], 0xEA09, 0xEA0B, 0xEA0D, 0xEA10, 0xEA17, 0xEA1A, 0xEA1C, 0xEA1E, 0xEA1F, 0xEA26, 0xEA2A, 0xEA2C, 0xEA2F, 0xEA35, 0xEA3A, 0xEA3E, 0xEA42, 0xEA45, 0xEB03, 0xEB04, 0xEB08, [0xEB0F, 0xEB12], 0xEB16, 0xEB19, 0xEB1E, 0xEB1F, 0xEB28, 0xEB29, 0xEB2B, 0xEB31, 0xEB35, 0xEB36, 0xEB3A, 0xEB3B, 0xEB40, 0xEB48, 0xEB49, 0xEB4D, 0xEB61, 0xEB63, 0xEB65, 0xEB6E, 0xEB6F, [0xEC08, 0xEC0E], 0xEC10, 0xEC11, 0xF103, 0xF104, 0xF109, [0xF117, 0xF11E], [0xF121, 0xF123], [0xF126, 0xF12D], 0xF12F, [0xF133, 0xF138], 0xF13D, 0xF1AB, 0xF1AC, [0xF1B1, 0xF1B5], 0xF282, 0xF283, 0xF29E, 0xF2A1, 0xF2A4, 0xF2A7, 0xF2A8, [0xF460, 0xF468], [0xF46A, 0xF472], 0xF6BE, 0xF6C4, [0xF6C6, 0xF6C8], [0xF6D3, 0xF6D6], 0xF6DE
            ]
        }]
]);
//# sourceMappingURL=chtml.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/chtml/default.js

const Font = {
    fontName: 'mathjax-newcm',
    DefaultFont: MathJaxNewcmFont
};
//# sourceMappingURL=default.js.map
;// ./mjs/output/chtml/DefaultFont.js

const fontName = Font.fontName;
const DefaultFont = Font.DefaultFont;
//# sourceMappingURL=DefaultFont.js.map
;// ./mjs/output/chtml.js







class CHTML extends CommonOutputJax {
    constructor(options = {}) {
        super(options, ChtmlWrapperFactory, DefaultFont);
        this.chtmlStyles = null;
        this.font.adaptiveCSS(this.options.adaptiveCSS);
        this.wrapperUsage = new Usage();
    }
    addExtension(font, prefix = '') {
        const css = super.addExtension(font, prefix);
        if (css.length && this.options.adaptiveCSS && this.chtmlStyles) {
            this.adaptor.insertRules(this.chtmlStyles, css);
        }
        return [];
    }
    escaped(math, html) {
        this.setDocument(html);
        return this.html('span', {}, [this.text(math.math)]);
    }
    styleSheet(html) {
        if (this.chtmlStyles) {
            const styles = new StyleJsonSheet();
            if (this.options.adaptiveCSS) {
                this.addWrapperStyles(styles);
                this.updateFontStyles(styles);
            }
            styles.addStyles(this.font.updateDynamicStyles());
            this.adaptor.insertRules(this.chtmlStyles, styles.getStyleRules());
            return this.chtmlStyles;
        }
        const sheet = (this.chtmlStyles = super.styleSheet(html));
        this.adaptor.setAttribute(sheet, 'id', CHTML.STYLESHEETID);
        this.wrapperUsage.update();
        return sheet;
    }
    updateFontStyles(styles) {
        styles.addStyles(this.font.updateStyles({}));
    }
    addWrapperStyles(styles) {
        if (!this.options.adaptiveCSS) {
            super.addWrapperStyles(styles);
            return;
        }
        for (const kind of this.wrapperUsage.update()) {
            const wrapper = this.factory.getNodeClass(kind);
            if (wrapper) {
                this.addClassStyles(wrapper, styles);
            }
        }
    }
    addClassStyles(wrapper, styles) {
        const CLASS = wrapper;
        if (CLASS.autoStyle && CLASS.kind !== 'unknown') {
            styles.addStyles({
                ['mjx-' + CLASS.kind]: {
                    display: 'inline-block',
                    'text-align': 'left',
                },
            });
        }
        this.wrapperUsage.add(CLASS.kind);
        super.addClassStyles(wrapper, styles);
    }
    insertStyles(styles) {
        if (this.chtmlStyles) {
            this.adaptor.insertRules(this.chtmlStyles, new StyleJsonSheet(styles).getStyleRules());
        }
    }
    processMath(wrapper, parent) {
        wrapper.toCHTML([parent]);
    }
    clearCache() {
        this.styleJson.clear();
        this.font.clearCache();
        this.wrapperUsage.clear();
        this.chtmlStyles = null;
    }
    reset() {
        this.clearCache();
    }
    unknownText(text, variant, width = null) {
        const styles = {};
        const scale = 100 / this.math.metrics.scale;
        if (scale !== 100) {
            styles['font-size'] = this.fixed(scale, 1) + '%';
            styles.padding =
                em(75 / scale) + ' 0 ' + em(20 / scale) + ' 0';
        }
        if (variant !== '-explicitFont') {
            const c = unicodeChars(text);
            if (c.length !== 1 || c[0] < 0x1d400 || c[0] > 0x1d7ff) {
                this.cssFontStyles(this.font.getCssFont(variant), styles);
            }
        }
        if (width !== null) {
            styles.width = this.fixed(width * this.math.metrics.scale) + 'em';
        }
        return this.html('mjx-utext', { variant: variant, style: styles }, [
            this.text(text),
        ]);
    }
    measureTextNode(textNode) {
        const adaptor = this.adaptor;
        const text = adaptor.clone(textNode);
        adaptor.setStyle(text, 'font-family', adaptor.getStyle(text, 'font-family').replace(/MJXZERO, /g, ''));
        const em = this.math.metrics.em;
        const style = {
            position: 'absolute',
            top: 0,
            left: 0,
            'white-space': 'nowrap',
            'font-size': this.fixed(em, 3) + 'px',
        };
        const node = this.html('mjx-measure-text', { style }, [text]);
        adaptor.append(adaptor.parent(this.math.start.node), this.container);
        adaptor.append(this.container, node);
        const w = adaptor.nodeSize(text, em)[0];
        adaptor.remove(this.container);
        adaptor.remove(node);
        return { w: w, h: 0.75, d: 0.2 };
    }
}
CHTML.NAME = 'CHTML';
CHTML.OPTIONS = Object.assign(Object.assign({}, CommonOutputJax.OPTIONS), { adaptiveCSS: true, matchFontHeight: true });
CHTML.commonStyles = Object.assign(Object.assign({}, CommonOutputJax.commonStyles), { 'mjx-container[jax="CHTML"]': {
        'white-space': 'nowrap',
    }, [[
        'mjx-mo > mjx-c',
        'mjx-mi > mjx-c',
        'mjx-mn > mjx-c',
        'mjx-ms > mjx-c',
        'mjx-mtext > mjx-c',
    ].join(', ')]: {
        'clip-path': 'padding-box xywh(-1em -2px calc(100% + 2em) calc(100% + 4px))',
    }, 'mjx-stretchy-h': {
        'clip-path': 'padding-box xywh(0 -2px 100% calc(100% + 4px))',
    }, 'mjx-stretchy-v': {
        'clip-path': 'padding-box xywh(-2px 0 calc(100% + 4px) 100%)',
    }, 'mjx-container [space="1"]': { 'margin-left': '.111em' }, 'mjx-container [space="2"]': { 'margin-left': '.167em' }, 'mjx-container [space="3"]': { 'margin-left': '.222em' }, 'mjx-container [space="4"]': { 'margin-left': '.278em' }, 'mjx-container [space="5"]': { 'margin-left': '.333em' }, 'mjx-container [rspace="1"]': { 'margin-right': '.111em' }, 'mjx-container [rspace="2"]': { 'margin-right': '.167em' }, 'mjx-container [rspace="3"]': { 'margin-right': '.222em' }, 'mjx-container [rspace="4"]': { 'margin-right': '.278em' }, 'mjx-container [rspace="5"]': { 'margin-right': '.333em' }, 'mjx-container [size="s"]': { 'font-size': '70.7%' }, 'mjx-container [size="ss"]': { 'font-size': '50%' }, 'mjx-container [size="Tn"]': { 'font-size': '60%' }, 'mjx-container [size="sm"]': { 'font-size': '85%' }, 'mjx-container [size="lg"]': { 'font-size': '120%' }, 'mjx-container [size="Lg"]': { 'font-size': '144%' }, 'mjx-container [size="LG"]': { 'font-size': '173%' }, 'mjx-container [size="hg"]': { 'font-size': '207%' }, 'mjx-container [size="HG"]': { 'font-size': '249%' }, 'mjx-container [width="full"]': { width: '100%' }, 'mjx-box': { display: 'inline-block' }, 'mjx-block': { display: 'block' }, 'mjx-itable': { display: 'inline-table' }, 'mjx-row': { display: 'table-row' }, 'mjx-row > *': { display: 'table-cell' }, 'mjx-container [inline-breaks]': { display: 'inline' }, 'mjx-mtext': {
        display: 'inline-block',
    }, 'mjx-mstyle': {
        display: 'inline-block',
    }, 'mjx-merror': {
        display: 'inline-block',
        color: 'red',
        'background-color': 'yellow',
    }, 'mjx-mphantom': {
        visibility: 'hidden',
    } });
CHTML.STYLESHEETID = 'MJX-CHTML-styles';
//# sourceMappingURL=chtml.js.map
;// ./mjs/output/chtml/DynamicFonts.js
function AddFontIds(ranges, prefix) {
    const variants = {};
    for (const id of Object.keys(ranges)) {
        const map = ranges[id];
        for (const variant of Object.keys(map)) {
            if (!variants[variant]) {
                variants[variant] = {};
            }
            const chars = map[variant];
            if (id) {
                for (const c of Object.keys(chars)) {
                    const data = chars[parseInt(c)];
                    if (!data[3]) {
                        data[3] = {};
                    }
                    if (prefix) {
                        data[3].ff = prefix + '-' + id;
                    }
                    else {
                        data[3].f = id;
                    }
                }
            }
            Object.assign(variants[variant], chars);
        }
    }
    return variants;
}
//# sourceMappingURL=DynamicFonts.js.map
;// ./components/mjs/output/chtml/lib/chtml.js











































































if (MathJax.loader) {
  MathJax.loader.checkVersion('output/chtml', VERSION, 'output');
}

combineWithMathJax({_: {
  output: {
    chtml_ts: output_chtml_namespaceObject,
    chtml: {
      DefaultFont: DefaultFont_namespaceObject,
      DynamicFonts: DynamicFonts_namespaceObject,
      FontData: chtml_FontData_namespaceObject,
      Notation: chtml_Notation_namespaceObject,
      Usage: Usage_namespaceObject,
      Wrapper: chtml_Wrapper_namespaceObject,
      WrapperFactory: chtml_WrapperFactory_namespaceObject,
      Wrappers_ts: Wrappers_namespaceObject,
      Wrappers: {
        HtmlNode: Wrappers_HtmlNode_namespaceObject,
        TeXAtom: chtml_Wrappers_TeXAtom_namespaceObject,
        TextNode: Wrappers_TextNode_namespaceObject,
        maction: chtml_Wrappers_maction_namespaceObject,
        math: chtml_Wrappers_math_namespaceObject,
        menclose: chtml_Wrappers_menclose_namespaceObject,
        mfenced: chtml_Wrappers_mfenced_namespaceObject,
        mfrac: chtml_Wrappers_mfrac_namespaceObject,
        mglyph: chtml_Wrappers_mglyph_namespaceObject,
        mi: chtml_Wrappers_mi_namespaceObject,
        mmultiscripts: chtml_Wrappers_mmultiscripts_namespaceObject,
        mn: chtml_Wrappers_mn_namespaceObject,
        mo: chtml_Wrappers_mo_namespaceObject,
        mpadded: chtml_Wrappers_mpadded_namespaceObject,
        mroot: chtml_Wrappers_mroot_namespaceObject,
        mrow: chtml_Wrappers_mrow_namespaceObject,
        ms: chtml_Wrappers_ms_namespaceObject,
        mspace: chtml_Wrappers_mspace_namespaceObject,
        msqrt: chtml_Wrappers_msqrt_namespaceObject,
        msubsup: chtml_Wrappers_msubsup_namespaceObject,
        mtable: chtml_Wrappers_mtable_namespaceObject,
        mtd: chtml_Wrappers_mtd_namespaceObject,
        mtext: chtml_Wrappers_mtext_namespaceObject,
        mtr: chtml_Wrappers_mtr_namespaceObject,
        munderover: chtml_Wrappers_munderover_namespaceObject,
        scriptbase: Wrappers_scriptbase_namespaceObject,
        semantics: chtml_Wrappers_semantics_namespaceObject
      }
    },
    common_ts: common_namespaceObject,
    common: {
      Direction: Direction_namespaceObject,
      FontData: FontData_namespaceObject,
      LineBBox: LineBBox_namespaceObject,
      LinebreakVisitor: LinebreakVisitor_namespaceObject,
      Notation: Notation_namespaceObject,
      Wrapper: common_Wrapper_namespaceObject,
      WrapperFactory: common_WrapperFactory_namespaceObject,
      Wrappers: {
        TeXAtom: Wrappers_TeXAtom_namespaceObject,
        TextNode: TextNode_namespaceObject,
        XmlNode: XmlNode_namespaceObject,
        maction: Wrappers_maction_namespaceObject,
        math: Wrappers_math_namespaceObject,
        menclose: Wrappers_menclose_namespaceObject,
        mfenced: Wrappers_mfenced_namespaceObject,
        mfrac: Wrappers_mfrac_namespaceObject,
        mglyph: Wrappers_mglyph_namespaceObject,
        mi: Wrappers_mi_namespaceObject,
        mmultiscripts: Wrappers_mmultiscripts_namespaceObject,
        mn: Wrappers_mn_namespaceObject,
        mo: Wrappers_mo_namespaceObject,
        mpadded: Wrappers_mpadded_namespaceObject,
        mroot: Wrappers_mroot_namespaceObject,
        mrow: Wrappers_mrow_namespaceObject,
        ms: Wrappers_ms_namespaceObject,
        mspace: Wrappers_mspace_namespaceObject,
        msqrt: Wrappers_msqrt_namespaceObject,
        msubsup: Wrappers_msubsup_namespaceObject,
        mtable: Wrappers_mtable_namespaceObject,
        mtd: Wrappers_mtd_namespaceObject,
        mtext: Wrappers_mtext_namespaceObject,
        mtr: Wrappers_mtr_namespaceObject,
        munderover: Wrappers_munderover_namespaceObject,
        scriptbase: scriptbase_namespaceObject,
        semantics: Wrappers_semantics_namespaceObject
      }
    }
  }
}});

;// ./components/mjs/output/util.js




const util_FONTPATH = hasWindow ?
                        'https://cdn.jsdelivr.net/npm/@mathjax/%%FONT%%-font':
                        '@mathjax/%%FONT%%-font';
const OutputUtil = {
  config(jax, jaxClass, defaultFont, fontClass) {

    if (MathJax.loader) {

      combineDefaults(MathJax.config, jax, MathJax.config.output || {});

      let config = MathJax.config[jax];
      let font = config.font || config.fontData || defaultFont;
      if (typeof(font) !== 'string') {
        config.fontData = font;
        config.font = font = font.NAME;
      }

      if (font.charAt(0) !== '[') {
        const path = (config.fontPath || util_FONTPATH);
        const name = (font.match(/^[a-z]+:/) ? (font.match(/[^/:\\]*$/) || [jax])[0] : font);
        combineDefaults(MathJax.config.loader, 'paths', {
          [name]: (name === font ? path.replace(/%%FONT%%/g, font) : font)
        });
        font = `[${name}]`;
      }
      const name = font.substring(1, font.length - 1);

      if (name !== defaultFont || !fontClass) {

        MathJax.loader.addPackageData(`output/${jax}`, {extraLoads: [`${font}/${jax}`]});

      } else {

        const extraLoads = MathJax.config.loader[`${font}/${jax}`]?.extraLoads;
        if (extraLoads) {
          MathJax.loader.addPackageData(`output/${jax}`, {extraLoads});
        }

        combineWithMathJax({_: {
          output: {
            fonts: {
              [name]: {
                [jax + '_ts']: {
                  [fontClass.NAME + 'Font']: fontClass
                }
              }
            }
          }
        }});

        combineDefaults(MathJax, 'config', {
          output: {
            font: font,
          },
          [jax]: {
            fontData: fontClass,
            dynamicPrefix: `${font}/${jax}/dynamic`
          }
        });
        if (jax === 'chtml') {
          combineDefaults(MathJax.config, jax, {
            fontURL: Package.resolvePath(`${font}/${jax}/woff2`, false),
          });
        }

      }
    }

    if (MathJax.startup) {
      MathJax.startup.registerConstructor(jax, jaxClass);
      MathJax.startup.useOutput(jax);
    }

  },

  loadFont(startup, jax, font, preloaded) {
    if (!MathJax.loader) {
      return startup;
    }
    if (preloaded) {
      MathJax.loader.preLoaded(`[${font}]/${jax}`);
    }
    return Package.loadPromise(`output/${jax}`).then(startup);
  }

};

;// ./components/mjs/output/chtml/chtml.js






OutputUtil.config('chtml', CHTML, fontName, DefaultFont);

function loadFont(startup, preload) {
  return OutputUtil.loadFont(startup, 'chtml', fontName, preload);
}


;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/key_navigatable.js
var KEY;
(function (KEY) {
    KEY[KEY["RETURN"] = 13] = "RETURN";
    KEY[KEY["ESCAPE"] = 27] = "ESCAPE";
    KEY[KEY["SPACE"] = 32] = "SPACE";
    KEY[KEY["LEFT"] = 37] = "LEFT";
    KEY[KEY["UP"] = 38] = "UP";
    KEY[KEY["RIGHT"] = 39] = "RIGHT";
    KEY[KEY["DOWN"] = 40] = "DOWN";
})(KEY || (KEY = {}));
//# sourceMappingURL=key_navigatable.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/mouse_navigatable.js
const MOUSE = {
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DOWN: 'mousedown',
    UP: 'mouseup',
    OVER: 'mouseover',
    OUT: 'mouseout',
    MOVE: 'mousemove',
    SELECTEND: 'selectend',
    SELECTSTART: 'selectstart'
};
//# sourceMappingURL=mouse_navigatable.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/abstract_navigatable.js


class AbstractNavigatable {
    constructor() {
        this.bubble = false;
    }
    bubbleKey() {
        this.bubble = true;
    }
    keydown(event) {
        switch (event.keyCode) {
            case KEY.ESCAPE:
                this.escape(event);
                break;
            case KEY.RIGHT:
                this.right(event);
                break;
            case KEY.LEFT:
                this.left(event);
                break;
            case KEY.UP:
                this.up(event);
                break;
            case KEY.DOWN:
                this.down(event);
                break;
            case KEY.RETURN:
            case KEY.SPACE:
                this.space(event);
                break;
            default:
                return;
        }
        this.bubble ? (this.bubble = false) : this.stop(event);
    }
    escape(_event) { }
    space(_event) { }
    left(_event) { }
    right(_event) { }
    up(_event) { }
    down(_event) { }
    stop(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
            event.cancelBubble = true;
        }
    }
    mousedown(event) {
        return this.stop(event);
    }
    mouseup(event) {
        return this.stop(event);
    }
    mouseover(event) {
        return this.stop(event);
    }
    mouseout(event) {
        return this.stop(event);
    }
    click(event) {
        return this.stop(event);
    }
    addEvents(element) {
        element.addEventListener(MOUSE.DOWN, this.mousedown.bind(this));
        element.addEventListener(MOUSE.UP, this.mouseup.bind(this));
        element.addEventListener(MOUSE.OVER, this.mouseover.bind(this));
        element.addEventListener(MOUSE.OUT, this.mouseout.bind(this));
        element.addEventListener(MOUSE.CLICK, this.click.bind(this));
        element.addEventListener('keydown', this.keydown.bind(this));
        element.addEventListener('dragstart', this.stop.bind(this));
        element.addEventListener(MOUSE.SELECTSTART, this.stop.bind(this));
        element.addEventListener('contextmenu', this.stop.bind(this));
        element.addEventListener(MOUSE.DBLCLICK, this.stop.bind(this));
    }
}
//# sourceMappingURL=abstract_navigatable.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/menu_element.js

class MenuElement extends AbstractNavigatable {
    addAttributes(attributes) {
        for (const attr in attributes) {
            this.html.setAttribute(attr, attributes[attr]);
        }
    }
    get html() {
        if (!this._html) {
            this.generateHtml();
        }
        return this._html;
    }
    set html(html) {
        this._html = html;
        this.addEvents(html);
    }
    generateHtml() {
        const html = document.createElement('div');
        html.classList.add(this.className);
        html.setAttribute('role', this.role);
        this.html = html;
    }
    focus() {
        const html = this.html;
        html.setAttribute('tabindex', '0');
        html.focus();
    }
    unfocus() {
        const html = this.html;
        if (html.hasAttribute('tabindex')) {
            html.setAttribute('tabindex', '-1');
        }
        try {
            html.blur();
        }
        catch (e) {
        }
        html.blur();
    }
}
//# sourceMappingURL=menu_element.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/abstract_postable.js

class AbstractPostable extends MenuElement {
    constructor() {
        super(...arguments);
        this.posted = false;
    }
    isPosted() {
        return this.posted;
    }
    post(x, y) {
        if (this.posted) {
            return;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined') {
            this.html.setAttribute('style', 'left: ' + x + 'px; top: ' + y + 'px;');
        }
        this.display();
        this.posted = true;
    }
    unpost() {
        if (!this.posted) {
            return;
        }
        const html = this.html;
        if (html.parentNode) {
            html.parentNode.removeChild(html);
        }
        this.posted = false;
    }
}
//# sourceMappingURL=abstract_postable.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/html_classes.js
const PREFIX = 'CtxtMenu';
function prefix_(name) {
    return PREFIX + '_' + name;
}
function prefixClass_(name) {
    return prefix_(name);
}
function prefixAttr_(name) {
    return prefix_(name);
}
const HtmlClasses = {
    ATTACHED: prefixClass_('Attached'),
    CONTEXTMENU: prefixClass_('ContextMenu'),
    MENU: prefixClass_('Menu'),
    MENUARROW: prefixClass_('MenuArrow'),
    MENUACTIVE: prefixClass_('MenuActive'),
    MENUCHECK: prefixClass_('MenuCheck'),
    MENUCLOSE: prefixClass_('MenuClose'),
    MENUCOMBOBOX: prefixClass_('MenuComboBox'),
    MENUDISABLED: prefixClass_('MenuDisabled'),
    MENUFRAME: prefixClass_('MenuFrame'),
    MENUITEM: prefixClass_('MenuItem'),
    MENULABEL: prefixClass_('MenuLabel'),
    MENURADIOCHECK: prefixClass_('MenuRadioCheck'),
    MENUINPUTBOX: prefixClass_('MenuInputBox'),
    MENURULE: prefixClass_('MenuRule'),
    MENUSLIDER: prefixClass_('MenuSlider'),
    MOUSEPOST: prefixClass_('MousePost'),
    RTL: prefixClass_('RTL'),
    INFO: prefixClass_('Info'),
    INFOCLOSE: prefixClass_('InfoClose'),
    INFOCONTENT: prefixClass_('InfoContent'),
    INFOSIGNATURE: prefixClass_('InfoSignature'),
    INFOTITLE: prefixClass_('InfoTitle'),
    SLIDERVALUE: prefixClass_('SliderValue'),
    SLIDERBAR: prefixClass_('SliderBar'),
    SELECTION: prefixClass_('Selection'),
    SELECTIONBOX: prefixClass_('SelectionBox'),
    SELECTIONMENU: prefixClass_('SelectionMenu'),
    SELECTIONDIVIDER: prefixClass_('SelectionDivider'),
    SELECTIONITEM: prefixClass_('SelectionItem')
};
const HtmlAttrs = {
    COUNTER: prefixAttr_('Counter'),
    KEYDOWNFUNC: prefixAttr_('keydownFunc'),
    CONTEXTMENUFUNC: prefixAttr_('contextmenuFunc'),
    OLDTAB: prefixAttr_('Oldtabindex'),
    TOUCHFUNC: prefixAttr_('TouchFunc')
};
//# sourceMappingURL=html_classes.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/abstract_entry.js


class AbstractEntry extends MenuElement {
    constructor(_menu, _type) {
        super();
        this._menu = _menu;
        this._type = _type;
        this.className = HtmlClasses['MENUITEM'];
        this.role = 'menuitem';
        this.hidden = false;
    }
    get menu() {
        return this._menu;
    }
    set menu(menu) {
        this._menu = menu;
    }
    get type() {
        return this._type;
    }
    hide() {
        this.hidden = true;
        this.menu.generateMenu();
    }
    show() {
        this.hidden = false;
        this.menu.generateMenu();
    }
    isHidden() {
        return this.hidden;
    }
}
//# sourceMappingURL=abstract_entry.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/menu_util.js
function menu_util_close(item) {
    const menu = item.menu;
    if (menu.baseMenu) {
        menu.baseMenu.unpost();
    }
    else {
        menu.unpost();
    }
}
function getActiveElement(item) {
    const menu = item.menu;
    const baseMenu = (menu.baseMenu ? menu.baseMenu : menu);
    return baseMenu.store.active;
}
function error(_error, msg) {
    console.error('ContextMenu Error: ' + msg);
}
function counter() {
    return count++;
}
let count = 0;
//# sourceMappingURL=menu_util.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/abstract_item.js



class AbstractItem extends AbstractEntry {
    constructor(menu, type, _content, id) {
        super(menu, type);
        this._content = _content;
        this.disabled = false;
        this.callbacks = [];
        this._id = id ? id : _content;
    }
    get content() {
        return this._content;
    }
    set content(content) {
        this._content = content;
        this.generateHtml();
        if (this.menu) {
            this.menu.generateHtml();
        }
    }
    get id() {
        return this._id;
    }
    press() {
        if (!this.disabled) {
            this.executeAction();
            this.executeCallbacks_();
        }
    }
    executeAction() { }
    registerCallback(func) {
        if (this.callbacks.indexOf(func) === -1) {
            this.callbacks.push(func);
        }
    }
    unregisterCallback(func) {
        const index = this.callbacks.indexOf(func);
        if (index !== -1) {
            this.callbacks.splice(index, 1);
        }
    }
    mousedown(event) {
        this.press();
        this.stop(event);
    }
    mouseover(event) {
        this.focus();
        this.stop(event);
    }
    mouseout(event) {
        this.deactivate();
        this.stop(event);
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        html.setAttribute('aria-disabled', 'false');
        html.textContent = this.content;
    }
    activate() {
        if (!this.disabled) {
            this.html.classList.add(HtmlClasses['MENUACTIVE']);
        }
    }
    deactivate() {
        this.html.classList.remove(HtmlClasses['MENUACTIVE']);
    }
    focus() {
        this.menu.focused = this;
        super.focus();
        this.activate();
    }
    unfocus() {
        this.deactivate();
        super.unfocus();
    }
    escape(_event) {
        menu_util_close(this);
    }
    up(event) {
        this.menu.up(event);
    }
    down(event) {
        this.menu.down(event);
    }
    left(event) {
        this.menu.left(event);
    }
    right(event) {
        this.menu.right(event);
    }
    space(_event) {
        this.press();
    }
    disable() {
        this.disabled = true;
        const html = this.html;
        html.classList.add(HtmlClasses['MENUDISABLED']);
        html.setAttribute('aria-disabled', 'true');
    }
    enable() {
        this.disabled = false;
        const html = this.html;
        html.classList.remove(HtmlClasses['MENUDISABLED']);
        html.removeAttribute('aria-disabled');
    }
    executeCallbacks_() {
        for (const func of this.callbacks) {
            try {
                func(this);
            }
            catch (e) {
                error(e, 'Callback for menu entry ' + this.id + ' failed.');
            }
        }
    }
}
//# sourceMappingURL=abstract_item.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_submenu.js


class Submenu extends AbstractItem {
    static fromJson(factory, { content: content, menu: submenu, id: id }, menu) {
        const item = new this(menu, content, id);
        const sm = factory.get('subMenu')(factory, submenu, item);
        item.submenu = sm;
        return item;
    }
    constructor(menu, content, id) {
        super(menu, 'submenu', content, id);
        this._submenu = null;
    }
    set submenu(menu) {
        this._submenu = menu;
    }
    get submenu() {
        return this._submenu;
    }
    mouseover(event) {
        this.focus();
        this.stop(event);
    }
    mouseout(event) {
        this.stop(event);
    }
    unfocus() {
        if (!this.submenu.isPosted()) {
            super.unfocus();
            return;
        }
        if (this.menu.focused !== this) {
            super.unfocus();
            this.menu.unpostSubmenus();
            return;
        }
        this.html.setAttribute('tabindex', '-1');
        this.html.blur();
    }
    focus() {
        super.focus();
        if (!this.submenu.isPosted() && !this.disabled) {
            this.submenu.post();
        }
    }
    executeAction() {
        this.submenu.isPosted() ? this.submenu.unpost() : this.submenu.post();
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        this.span = document.createElement('span');
        this.span.textContent = '\u25BA';
        this.span.classList.add(HtmlClasses['MENUARROW']);
        html.appendChild(this.span);
        html.setAttribute('aria-haspopup', 'true');
    }
    left(event) {
        if (this.submenu.isPosted()) {
            this.submenu.unpost();
        }
        else {
            super.left(event);
        }
    }
    right(event) {
        if (!this.submenu.isPosted()) {
            this.submenu.post();
        }
        else {
            this.submenu.down(event);
        }
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_submenu.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/abstract_menu.js




class AbstractMenu extends AbstractPostable {
    constructor() {
        super(...arguments);
        this.className = HtmlClasses['CONTEXTMENU'];
        this.role = 'menu';
        this._items = [];
        this._baseMenu = null;
    }
    set baseMenu(menu) {
        this._baseMenu = menu;
    }
    get baseMenu() {
        return this._baseMenu;
    }
    get items() {
        return this._items;
    }
    set items(items) {
        this._items = items;
    }
    get pool() {
        return this.variablePool;
    }
    get focused() {
        return this._focused;
    }
    set focused(item) {
        if (this._focused === item) {
            return;
        }
        if (!this._focused) {
            this.unfocus();
        }
        const old = this._focused;
        this._focused = item;
        if (old) {
            old.unfocus();
        }
    }
    up(_event) {
        const items = this.items.filter((x) => x instanceof AbstractItem && !x.isHidden());
        if (items.length === 0) {
            return;
        }
        if (!this.focused) {
            items[items.length - 1].focus();
            return;
        }
        let index = items.indexOf(this.focused);
        if (index === -1) {
            return;
        }
        index = index ? --index : items.length - 1;
        items[index].focus();
    }
    down(_event) {
        const items = this.items.filter((x) => x instanceof AbstractItem && !x.isHidden());
        if (items.length === 0) {
            return;
        }
        if (!this.focused) {
            items[0].focus();
            return;
        }
        let index = items.indexOf(this.focused);
        if (index === -1) {
            return;
        }
        index++;
        index = index === items.length ? 0 : index;
        items[index].focus();
    }
    generateHtml() {
        super.generateHtml();
        this.generateMenu();
    }
    generateMenu() {
        const html = this.html;
        html.classList.add(HtmlClasses['MENU']);
        for (const item of this.items) {
            if (!item.isHidden()) {
                html.appendChild(item.html);
                continue;
            }
            const itemHtml = item.html;
            if (itemHtml.parentNode) {
                itemHtml.parentNode.removeChild(itemHtml);
            }
        }
    }
    post(x, y) {
        this.variablePool.update();
        super.post(x, y);
    }
    unpostSubmenus() {
        const submenus = this.items.filter((x) => x instanceof Submenu);
        for (const submenu of submenus) {
            submenu.submenu.unpost();
            if (submenu !== this.focused) {
                submenu.unfocus();
            }
        }
    }
    unpost() {
        super.unpost();
        this.unpostSubmenus();
        this.focused = null;
    }
    find(id) {
        for (const item of this.items) {
            if (item.type === 'rule') {
                continue;
            }
            if (item.id === id) {
                return item;
            }
            if (item.type === 'submenu') {
                const result = item.submenu.find(id);
                if (result) {
                    return result;
                }
            }
        }
        return null;
    }
}
//# sourceMappingURL=abstract_menu.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/menu_store.js



class MenuStore {
    constructor(menu) {
        this.menu = menu;
        this.store = [];
        this._active = null;
        this.counter = 0;
        this.attachedClass = HtmlClasses['ATTACHED'] + '_' + counter();
        this.taborder = true;
        this.attrMap = {};
    }
    set active(element) {
        do {
            if (this.store.indexOf(element) !== -1) {
                this._active = element;
                break;
            }
            element = element.parentNode;
        } while (element);
    }
    get active() {
        return this._active;
    }
    next() {
        const length = this.store.length;
        if (length === 0) {
            this.active = null;
            return null;
        }
        let index = this.store.indexOf(this.active);
        index = index === -1 ? 0 : index < length - 1 ? index + 1 : 0;
        this.active = this.store[index];
        return this.active;
    }
    previous() {
        const length = this.store.length;
        if (length === 0) {
            this.active = null;
            return null;
        }
        const last = length - 1;
        let index = this.store.indexOf(this.active);
        index = index === -1 ? last : index === 0 ? last : index - 1;
        this.active = this.store[index];
        return this.active;
    }
    clear() {
        this.remove(this.store);
    }
    insert(elementOrList) {
        const elements = elementOrList instanceof HTMLElement ? [elementOrList] : elementOrList;
        for (const element of elements) {
            this.insertElement(element);
        }
        this.sort();
    }
    remove(elementOrList) {
        const elements = elementOrList instanceof HTMLElement ? [elementOrList] : elementOrList;
        for (const element of elements) {
            this.removeElement(element);
        }
        this.sort();
    }
    inTaborder(flag) {
        if (this.taborder && !flag) {
            this.removeTaborder();
        }
        if (!this.taborder && flag) {
            this.insertTaborder();
        }
        this.taborder = flag;
    }
    insertTaborder() {
        if (this.taborder) {
            this.insertTaborder_();
        }
    }
    removeTaborder() {
        if (this.taborder) {
            this.removeTaborder_();
        }
    }
    insertElement(element) {
        if (element.classList.contains(this.attachedClass)) {
            return;
        }
        element.classList.add(this.attachedClass);
        if (this.taborder) {
            this.addTabindex(element);
        }
        this.addEvents(element);
    }
    removeElement(element) {
        if (!element.classList.contains(this.attachedClass)) {
            return;
        }
        element.classList.remove(this.attachedClass);
        if (this.taborder) {
            this.removeTabindex(element);
        }
        this.removeEvents(element);
    }
    sort() {
        const nodes = document.getElementsByClassName(this.attachedClass);
        this.store = [].slice.call(nodes);
    }
    insertTaborder_() {
        this.store.forEach((x) => x.setAttribute('tabindex', '0'));
    }
    removeTaborder_() {
        this.store.forEach((x) => x.setAttribute('tabindex', '-1'));
    }
    addTabindex(element) {
        if (element.hasAttribute('tabindex')) {
            element.setAttribute(HtmlAttrs['OLDTAB'], element.getAttribute('tabindex'));
        }
        element.setAttribute('tabindex', '0');
    }
    removeTabindex(element) {
        if (element.hasAttribute(HtmlAttrs['OLDTAB'])) {
            element.setAttribute('tabindex', element.getAttribute(HtmlAttrs['OLDTAB']));
            element.removeAttribute(HtmlAttrs['OLDTAB']);
        }
        else {
            element.removeAttribute('tabindex');
        }
    }
    addEvents(element) {
        if (element.hasAttribute(HtmlAttrs['COUNTER'])) {
            return;
        }
        this.addEvent(element, 'contextmenu', this.menu.post.bind(this.menu));
        this.addEvent(element, 'keydown', this.keydown.bind(this));
        element.setAttribute(HtmlAttrs['COUNTER'], this.counter.toString());
        this.counter++;
    }
    addEvent(element, name, func) {
        const attrName = HtmlAttrs[name.toUpperCase() + 'FUNC'];
        this.attrMap[attrName + this.counter] = func;
        element.addEventListener(name, func);
    }
    removeEvents(element) {
        if (!element.hasAttribute(HtmlAttrs['COUNTER'])) {
            return;
        }
        const counter = element.getAttribute(HtmlAttrs['COUNTER']);
        this.removeEvent(element, 'contextmenu', counter);
        this.removeEvent(element, 'keydown', counter);
        element.removeAttribute(HtmlAttrs['COUNTER']);
    }
    removeEvent(element, name, counter) {
        const attrName = HtmlAttrs[name.toUpperCase() + 'FUNC'];
        const menuFunc = this.attrMap[attrName + counter];
        element.removeEventListener(name, menuFunc);
    }
    keydown(event) {
        if (event.keyCode === KEY.SPACE) {
            this.menu.post(event);
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }
}
//# sourceMappingURL=menu_store.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/variable_pool.js
class VariablePool {
    constructor() {
        this.pool = {};
    }
    insert(variable) {
        this.pool[variable.name] = variable;
    }
    lookup(name) {
        return this.pool[name];
    }
    remove(name) {
        delete this.pool[name];
    }
    update() {
        for (const variable in this.pool) {
            this.pool[variable].update();
        }
    }
}
//# sourceMappingURL=variable_pool.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/context_menu.js




class ContextMenu extends AbstractMenu {
    static fromJson(factory, { pool: pool, items: items, id: id = '' }) {
        const ctxtMenu = new this(factory);
        ctxtMenu.id = id;
        const varParser = factory.get('variable');
        pool.forEach((x) => varParser(factory, x, ctxtMenu.pool));
        const itemList = factory.get('items')(factory, items, ctxtMenu);
        ctxtMenu.items = itemList;
        return ctxtMenu;
    }
    constructor(factory) {
        super();
        this.factory = factory;
        this.id = '';
        this.moving = false;
        this._store = new MenuStore(this);
        this.widgets = [];
        this.variablePool = new VariablePool();
    }
    generateHtml() {
        if (this.isPosted()) {
            this.unpost();
        }
        super.generateHtml();
        this._frame = document.createElement('div');
        this._frame.classList.add(HtmlClasses['MENUFRAME']);
        const styleString = 'left: 0px; top: 0px; z-index: 200; width: 100%; ' +
            'height: 100%; border: 0px; padding: 0px; margin: 0px;';
        this._frame.setAttribute('style', 'position: absolute; ' + styleString);
        const innerDiv = document.createElement('div');
        innerDiv.setAttribute('style', 'position: fixed; ' + styleString);
        this._frame.appendChild(innerDiv);
        innerDiv.addEventListener('mousedown', function (event) {
            this.unpost();
            this.unpostWidgets();
            this.stop(event);
        }.bind(this));
    }
    display() {
        document.body.appendChild(this.frame);
        this.frame.appendChild(this.html);
        this.focus();
    }
    escape(_event) {
        this.unpost();
        this.unpostWidgets();
    }
    unpost() {
        super.unpost();
        if (this.widgets.length > 0) {
            return;
        }
        this.frame.parentNode.removeChild(this.frame);
        const store = this.store;
        if (!this.moving) {
            store.insertTaborder();
        }
        store.active.focus();
    }
    left(_event) {
        this.move_(this.store.previous());
    }
    right(_event) {
        this.move_(this.store.next());
    }
    get frame() {
        return this._frame;
    }
    get store() {
        return this._store;
    }
    post(numberOrEvent, isY) {
        if (typeof isY !== 'undefined') {
            if (!this.moving) {
                this.store.removeTaborder();
            }
            super.post(numberOrEvent, isY);
            return;
        }
        const event = numberOrEvent;
        let node;
        if (event instanceof Event) {
            node = event.target;
            this.stop(event);
        }
        else {
            node = event;
        }
        let x;
        let y;
        if (event instanceof MouseEvent) {
            x = event.pageX;
            y = event.pageY;
            if (!x && !y && event.clientX) {
                x =
                    event.clientX +
                        document.body.scrollLeft +
                        document.documentElement.scrollLeft;
                y =
                    event.clientY +
                        document.body.scrollTop +
                        document.documentElement.scrollTop;
            }
        }
        if (!x && !y && node) {
            const offsetX = window.pageXOffset || document.documentElement.scrollLeft;
            const offsetY = window.pageYOffset || document.documentElement.scrollTop;
            const rect = node.getBoundingClientRect();
            x = (rect.right + rect.left) / 2 + offsetX;
            y = (rect.bottom + rect.top) / 2 + offsetY;
        }
        this.store.active = node;
        this.anchor = this.store.active;
        const menu = this.html;
        const margin = 5;
        if (x + menu.offsetWidth > document.body.offsetWidth - margin) {
            x = document.body.offsetWidth - menu.offsetWidth - margin;
        }
        this.post(x, y);
    }
    registerWidget(widget) {
        this.widgets.push(widget);
    }
    unregisterWidget(widget) {
        const index = this.widgets.indexOf(widget);
        if (index > -1) {
            this.widgets.splice(index, 1);
        }
        if (this.widgets.length === 0) {
            this.unpost();
        }
    }
    unpostWidgets() {
        this.widgets.forEach((x) => x.unpost());
    }
    toJson() {
        return { type: '' };
    }
    move_(next) {
        if (this.anchor && next !== this.anchor) {
            this.moving = true;
            this.unpost();
            this.post(next);
            this.moving = false;
        }
    }
}
//# sourceMappingURL=context_menu.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/sub_menu.js

class SubMenu extends AbstractMenu {
    static fromJson(factory, { items: its }, anchor) {
        const submenu = new this(anchor);
        const itemList = factory.get('items')(factory, its, submenu);
        submenu.items = itemList;
        return submenu;
    }
    constructor(_anchor) {
        super();
        this._anchor = _anchor;
        this.variablePool = this.anchor.menu.pool;
        this.setBaseMenu();
    }
    get anchor() {
        return this._anchor;
    }
    post() {
        if (!this.anchor.menu.isPosted()) {
            return;
        }
        const mobileFlag = false;
        const rtlFlag = false;
        const margin = 5;
        let parent = this.anchor.html;
        const menu = this.html;
        const base = this.baseMenu.frame;
        const mw = parent.offsetWidth;
        let x = mobileFlag ? 30 : mw - 2;
        let y = 0;
        while (parent && parent !== base) {
            x += parent.offsetLeft;
            y += parent.offsetTop;
            parent = parent.parentNode;
        }
        if (!mobileFlag) {
            if ((rtlFlag && x - mw - menu.offsetWidth > margin) ||
                (!rtlFlag && x + menu.offsetWidth > document.body.offsetWidth - margin)) {
                x = Math.max(margin, x - mw - menu.offsetWidth + 6);
            }
        }
        super.post(x, y);
    }
    display() {
        this.baseMenu.frame.appendChild(this.html);
    }
    setBaseMenu() {
        let menu = this;
        do {
            menu = menu.anchor.menu;
        } while (menu instanceof SubMenu);
        this.baseMenu = menu;
    }
    left(_event) {
        this.focused = null;
        this.anchor.focus();
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=sub_menu.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/close_button.js


class CloseButton extends AbstractPostable {
    constructor(element) {
        super();
        this.element = element;
        this.className = HtmlClasses['MENUCLOSE'];
        this.role = 'button';
    }
    generateHtml() {
        const html = document.createElement('span');
        html.classList.add(this.className);
        html.setAttribute('role', this.role);
        html.setAttribute('tabindex', '0');
        const content = document.createElement('span');
        content.textContent = '\u00D7';
        html.appendChild(content);
        this.html = html;
    }
    display() { }
    unpost() {
        super.unpost();
        this.element.unpost();
    }
    keydown(event) {
        this.bubbleKey();
        super.keydown(event);
    }
    space(event) {
        this.unpost();
        this.stop(event);
    }
    mousedown(event) {
        this.unpost();
        this.stop(event);
    }
}
//# sourceMappingURL=close_button.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/info.js



class Info extends AbstractPostable {
    constructor(title, content, signature) {
        super();
        this.title = title;
        this.signature = signature;
        this.className = HtmlClasses['INFO'];
        this.role = 'dialog';
        this.contentDiv = this.generateContent();
        this.close = this.generateClose();
        this.content =
            content ||
                function () {
                    return '';
                };
    }
    attachMenu(menu) {
        this.menu = menu;
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        html.appendChild(this.generateTitle());
        html.appendChild(this.contentDiv);
        html.appendChild(this.generateSignature());
        html.appendChild(this.close.html);
        html.setAttribute('tabindex', '0');
    }
    post() {
        super.post();
        const doc = document.documentElement;
        const html = this.html;
        const H = window.innerHeight || doc.clientHeight || doc.scrollHeight || 0;
        const x = Math.floor(-html.offsetWidth / 2);
        const y = Math.floor((H - html.offsetHeight) / 3);
        html.setAttribute('style', 'margin-left: ' + x + 'px; top: ' + y + 'px;');
        if (window.event instanceof MouseEvent) {
            html.classList.add(HtmlClasses['MOUSEPOST']);
        }
        html.focus();
    }
    display() {
        this.menu.registerWidget(this);
        this.contentDiv.innerHTML = this.content();
        const html = this.menu.html;
        if (html.parentNode) {
            html.parentNode.removeChild(html);
        }
        this.menu.frame.appendChild(this.html);
    }
    click(_event) { }
    keydown(event) {
        this.bubbleKey();
        super.keydown(event);
    }
    escape(_event) {
        this.unpost();
    }
    unpost() {
        super.unpost();
        this.html.classList.remove(HtmlClasses['MOUSEPOST']);
        this.menu.unregisterWidget(this);
    }
    generateClose() {
        const close = new CloseButton(this);
        const html = close.html;
        html.classList.add(HtmlClasses['INFOCLOSE']);
        html.setAttribute('aria-label', 'Close Dialog Box');
        return close;
    }
    generateTitle() {
        const span = document.createElement('span');
        span.innerHTML = this.title;
        span.classList.add(HtmlClasses['INFOTITLE']);
        return span;
    }
    generateContent() {
        const div = document.createElement('div');
        div.classList.add(HtmlClasses['INFOCONTENT']);
        div.setAttribute('tabindex', '0');
        return div;
    }
    generateSignature() {
        const span = document.createElement('span');
        span.innerHTML = this.signature;
        span.classList.add(HtmlClasses['INFOSIGNATURE']);
        return span;
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=info.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/abstract_variable_item.js

class AbstractVariableItem extends AbstractItem {
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        if (!this.span) {
            this.generateSpan();
        }
        html.appendChild(this.span);
        this.update();
    }
    register() {
        this.variable.register(this);
    }
    unregister() {
        this.variable.unregister(this);
    }
    update() {
        this.updateAria();
        if (this.span) {
            this.updateSpan();
        }
    }
}
//# sourceMappingURL=abstract_variable_item.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_radio.js



class Radio extends AbstractVariableItem {
    static fromJson(_factory, { content: content, variable: variable, id: id }, menu) {
        return new this(menu, content, variable, id);
    }
    constructor(menu, content, variable, id) {
        super(menu, 'radio', content, id);
        this.role = 'menuitemradio';
        this.variable = menu.pool.lookup(variable);
        this.register();
    }
    executeAction() {
        this.variable.setValue(this.id);
        menu_util_close(this);
    }
    generateSpan() {
        this.span = document.createElement('span');
        this.span.textContent = '\u2713';
        this.span.classList.add(HtmlClasses['MENURADIOCHECK']);
    }
    updateAria() {
        this.html.setAttribute('aria-checked', this.variable.getValue() === this.id ? 'true' : 'false');
    }
    updateSpan() {
        this.span.style.display =
            this.variable.getValue() === this.id ? '' : 'none';
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_radio.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_rule.js


class Rule extends AbstractEntry {
    static fromJson(_factory, _json, menu) {
        return new this(menu);
    }
    constructor(menu) {
        super(menu, 'rule');
        this.className = HtmlClasses['MENUITEM'];
        this.role = 'separator';
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        html.classList.add(HtmlClasses['MENURULE']);
        html.setAttribute('aria-orientation', 'vertical');
    }
    addEvents(_element) { }
    toJson() {
        return { type: 'rule' };
    }
}
//# sourceMappingURL=item_rule.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_command.js


class Command extends AbstractItem {
    static fromJson(_factory, { content: content, action: action, id: id }, menu) {
        return new this(menu, content, action, id);
    }
    constructor(menu, content, command, id) {
        super(menu, 'command', content, id);
        this.command = command;
    }
    executeAction() {
        try {
            this.command(getActiveElement(this));
        }
        catch (e) {
            error(e, 'Illegal command callback.');
        }
        menu_util_close(this);
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_command.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/variable.js

class Variable {
    static fromJson(_factory, { name, getter, setter }, pool) {
        const variable = new this(name, getter, setter);
        pool.insert(variable);
    }
    constructor(_name, getter, setter) {
        this._name = _name;
        this.getter = getter;
        this.setter = setter;
        this.items = [];
    }
    get name() {
        return this._name;
    }
    getValue(node) {
        try {
            return this.getter(node);
        }
        catch (e) {
            error(e, 'Command of variable ' + this.name + ' failed.');
            return null;
        }
    }
    setValue(value, node) {
        try {
            this.setter(value, node);
        }
        catch (e) {
            error(e, 'Command of variable ' + this.name + ' failed.');
        }
        this.update();
    }
    register(item) {
        if (this.items.indexOf(item) === -1) {
            this.items.push(item);
        }
    }
    unregister(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
    }
    update() {
        this.items.forEach((x) => x.update());
    }
    registerCallback(func) {
        this.items.forEach((x) => x.registerCallback(func));
    }
    unregisterCallback(func) {
        this.items.forEach((x) => x.unregisterCallback(func));
    }
    toJson() {
        return {
            type: 'variable',
            name: this.name,
            getter: this.getter.toString(),
            setter: this.setter.toString()
        };
    }
}
//# sourceMappingURL=variable.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_checkbox.js



class Checkbox extends AbstractVariableItem {
    static fromJson(_factory, { content: content, variable: variable, id: id }, menu) {
        return new this(menu, content, variable, id);
    }
    constructor(menu, content, variable, id) {
        super(menu, 'checkbox', content, id);
        this.role = 'menuitemcheckbox';
        this.variable = menu.pool.lookup(variable);
        this.register();
    }
    executeAction() {
        this.variable.setValue(!this.variable.getValue());
        menu_util_close(this);
    }
    generateSpan() {
        this.span = document.createElement('span');
        this.span.textContent = '\u2713';
        this.span.classList.add(HtmlClasses['MENUCHECK']);
    }
    updateAria() {
        this.html.setAttribute('aria-checked', this.variable.getValue() ? 'true' : 'false');
    }
    updateSpan() {
        this.span.style.display = this.variable.getValue() ? '' : 'none';
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_checkbox.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_combo.js




class Combo extends AbstractVariableItem {
    static fromJson(_factory, { content: content, variable: variable, id: id }, menu) {
        return new this(menu, content, variable, id);
    }
    constructor(menu, content, variable, id) {
        super(menu, 'combobox', content, id);
        this.role = 'combobox';
        this.inputEvent = false;
        this.variable = menu.pool.lookup(variable);
        this.register();
    }
    executeAction() {
        this.variable.setValue(this.input.value, getActiveElement(this));
    }
    space(event) {
        super.space(event);
        menu_util_close(this);
    }
    focus() {
        super.focus();
        this.input.focus();
    }
    unfocus() {
        super.unfocus();
        this.updateSpan();
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        html.classList.add(HtmlClasses['MENUCOMBOBOX']);
    }
    generateSpan() {
        this.span = document.createElement('span');
        this.span.classList.add(HtmlClasses['MENUINPUTBOX']);
        this.input = document.createElement('input');
        this.input.addEventListener('keydown', this.inputKey.bind(this));
        this.input.setAttribute('size', '10em');
        this.input.setAttribute('type', 'text');
        this.input.setAttribute('tabindex', '-1');
        this.span.appendChild(this.input);
    }
    inputKey(_event) {
        this.bubbleKey();
        this.inputEvent = true;
    }
    keydown(event) {
        if (this.inputEvent &&
            event.keyCode !== KEY.ESCAPE &&
            event.keyCode !== KEY.RETURN) {
            this.inputEvent = false;
            event.stopPropagation();
            return;
        }
        super.keydown(event);
        event.stopPropagation();
    }
    updateAria() { }
    updateSpan() {
        let initValue;
        try {
            initValue = this.variable.getValue(getActiveElement(this));
        }
        catch (e) {
            initValue = '';
        }
        this.input.value = initValue;
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_combo.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_label.js


class item_label_Label extends AbstractItem {
    static fromJson(_factory, { content: content, id: id }, menu) {
        return new this(menu, content, id);
    }
    constructor(menu, content, id) {
        super(menu, 'label', content, id);
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        html.classList.add(HtmlClasses['MENULABEL']);
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_label.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/item_slider.js




class Slider extends AbstractVariableItem {
    static fromJson(_factory, { content: content, variable: variable, id: id }, menu) {
        return new this(menu, content, variable, id);
    }
    constructor(menu, content, variable, id) {
        super(menu, 'slider', content, id);
        this.role = 'slider';
        this.labelId = 'ctx_slideLabel' + counter();
        this.valueId = 'ctx_slideValue' + counter();
        this.inputEvent = false;
        this.variable = menu.pool.lookup(variable);
        this.register();
    }
    executeAction() {
        this.variable.setValue(this.input.value, getActiveElement(this));
        this.update();
    }
    space(event) {
        super.space(event);
        menu_util_close(this);
    }
    focus() {
        super.focus();
        this.input.focus();
    }
    unfocus() {
        super.unfocus();
        this.updateSpan();
    }
    generateHtml() {
        super.generateHtml();
        const html = this.html;
        html.classList.add(HtmlClasses['MENUSLIDER']);
        this.valueSpan = document.createElement('span');
        this.valueSpan.setAttribute('id', this.valueId);
        this.valueSpan.classList.add(HtmlClasses['SLIDERVALUE']);
        this.html.appendChild(this.valueSpan);
    }
    generateSpan() {
        this.span = document.createElement('span');
        this.labelSpan = document.createElement('span');
        this.labelSpan.setAttribute('id', this.labelId);
        this.labelSpan.appendChild(this.html.childNodes[0]);
        this.html.appendChild(this.labelSpan);
        this.input = document.createElement('input');
        this.input.setAttribute('type', 'range');
        this.input.setAttribute('min', '0');
        this.input.setAttribute('max', '100');
        this.input.setAttribute('aria-valuemin', '0');
        this.input.setAttribute('aria-valuemax', '100');
        this.input.setAttribute('aria-labelledby', this.labelId);
        this.input.addEventListener('keydown', this.inputKey.bind(this));
        this.input.addEventListener('input', this.executeAction.bind(this));
        this.input.classList.add(HtmlClasses['SLIDERBAR']);
        this.span.appendChild(this.input);
    }
    inputKey(_event) {
        this.inputEvent = true;
    }
    mousedown(event) {
        event.stopPropagation();
    }
    mouseup(_event) {
        event.stopPropagation();
    }
    keydown(event) {
        const code = event.keyCode;
        if (code === KEY.UP || code === KEY.DOWN) {
            event.preventDefault();
            super.keydown(event);
            return;
        }
        if (this.inputEvent && code !== KEY.ESCAPE && code !== KEY.RETURN) {
            this.inputEvent = false;
            event.stopPropagation();
            return;
        }
        super.keydown(event);
        event.stopPropagation();
    }
    updateAria() {
        const value = this.variable.getValue();
        if (value && this.input) {
            this.input.setAttribute('aria-valuenow', value);
            this.input.setAttribute('aria-valuetext', value + '%');
        }
    }
    updateSpan() {
        let initValue;
        try {
            initValue = this.variable.getValue(getActiveElement(this));
            this.valueSpan.innerHTML = initValue + '%';
        }
        catch (e) {
            initValue = '';
        }
        this.input.value = initValue;
    }
    toJson() {
        return { type: '' };
    }
}
//# sourceMappingURL=item_slider.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/selection_box.js




class SelectionMenu extends AbstractMenu {
    static fromJson(factory, { title: title, values: values, variable: variable }, sb) {
        const selection = new this(sb);
        const tit = factory.get('label')(factory, { content: title || '', id: title || 'id' }, selection);
        const rul = factory.get('rule')(factory, {}, selection);
        const radios = values.map((x) => factory.get('radio')(factory, { content: x, variable: variable, id: x }, selection));
        const items = [tit, rul].concat(radios);
        selection.items = items;
        return selection;
    }
    constructor(anchor) {
        super();
        this.anchor = anchor;
        this.className = HtmlClasses['SELECTIONMENU'];
        this.variablePool = this.anchor.menu.pool;
        this.baseMenu = this.anchor.menu;
    }
    generateHtml() {
        super.generateHtml();
        this.items.forEach((item) => item.html.classList.add(HtmlClasses['SELECTIONITEM']));
    }
    display() { }
    right(event) {
        this.anchor.right(event);
    }
    left(event) {
        this.anchor.left(event);
    }
}
class SelectionBox extends Info {
    static fromJson(factory, { title: title, signature: signature, selections: selections, order: order, grid: grid }, ctxt) {
        const sb = new this(title, signature, order, grid);
        sb.attachMenu(ctxt);
        const sels = selections.map((x) => factory.get('selectionMenu')(factory, x, sb));
        sb.selections = sels;
        return sb;
    }
    constructor(title, signature, style = "none", grid = "vertical") {
        super(title, null, signature);
        this.style = style;
        this.grid = grid;
        this._selections = [];
        this.prefix = 'ctxt-selection';
        this._balanced = true;
    }
    attachMenu(menu) {
        this.menu = menu;
    }
    get selections() {
        return this._selections;
    }
    set selections(selections) {
        this._selections = [];
        selections.forEach((x) => this.addSelection(x));
    }
    addSelection(selection) {
        selection.anchor = this;
        this._selections.push(selection);
    }
    rowDiv(sels) {
        const div = document.createElement('div');
        this.contentDiv.appendChild(div);
        const rects = sels.map((sel) => {
            div.appendChild(sel.html);
            if (!sel.html.id) {
                sel.html.id = this.prefix + counter();
            }
            return sel.html.getBoundingClientRect();
        });
        const column = rects.map((x) => x.width);
        const width = column.reduce((x, y) => x + y, 0);
        const height = rects.reduce((x, y) => Math.max(x, y.height), 0);
        div.classList.add(HtmlClasses['SELECTIONDIVIDER']);
        div.setAttribute('style', 'height: ' + height + 'px;');
        return [div, width, height, column];
    }
    display() {
        super.display();
        this.order();
        if (!this.selections.length) {
            return;
        }
        const outerDivs = [];
        let maxWidth = 0;
        let balancedColumn = [];
        const chunks = this.getChunkSize(this.selections.length);
        for (let i = 0; i < this.selections.length; i += chunks) {
            const sels = this.selections.slice(i, i + chunks);
            const [div, width, height, column] = this.rowDiv(sels);
            outerDivs.push(div);
            maxWidth = Math.max(maxWidth, width);
            sels.forEach((sel) => (sel.html.style.height = height + 'px'));
            balancedColumn = this.combineColumn(balancedColumn, column);
        }
        if (this._balanced) {
            this.balanceColumn(outerDivs, balancedColumn);
            maxWidth = balancedColumn.reduce((x, y) => x + y, 20);
        }
        outerDivs.forEach((div) => (div.style.width = maxWidth + 'px'));
    }
    getChunkSize(size) {
        switch (this.grid) {
            case "square":
                return Math.floor(Math.sqrt(size));
            case "horizontal":
                return Math.floor(size / SelectionBox.chunkSize);
            case "vertical":
            default:
                return SelectionBox.chunkSize;
        }
    }
    balanceColumn(divs, column) {
        divs.forEach((div) => {
            const children = Array.from(div.children);
            for (let i = 0, child; (child = children[i]); i++) {
                child.style.width = column[i] + 'px';
            }
        });
    }
    combineColumn(col1, col2) {
        let result = [];
        let i = 0;
        while (col1[i] || col2[i]) {
            if (!col1[i]) {
                result = result.concat(col2.slice(i));
                break;
            }
            if (!col2[i]) {
                result = result.concat(col1.slice(i));
                break;
            }
            result.push(Math.max(col1[i], col2[i]));
            i++;
        }
        return result;
    }
    left(event) {
        this.move(event, (index) => (index === 0 ? this.selections.length : index) - 1);
    }
    right(event) {
        this.move(event, (index) => index === this.selections.length - 1 ? 0 : index + 1);
    }
    generateHtml() {
        super.generateHtml();
        this.html.classList.add(HtmlClasses['SELECTION']);
    }
    generateContent() {
        const div = super.generateContent();
        div.classList.add(HtmlClasses['SELECTIONBOX']);
        div.removeAttribute('tabindex');
        return div;
    }
    findSelection(event) {
        const target = event.target;
        let selection = null;
        if (target.id) {
            selection = this.selections.find((x) => x.html.id === target.id);
        }
        if (!selection) {
            const id = target.parentElement.id;
            selection = this.selections.find((x) => x.html.id === id);
        }
        return selection;
    }
    move(event, isNext) {
        const selection = this.findSelection(event);
        if (selection.focused) {
            selection.focused.unfocus();
        }
        const index = this.selections.indexOf(selection);
        const next = isNext(index);
        this.selections[next].focus();
    }
    order() {
        this.selections.sort(SelectionBox.orderMethod.get(this.style));
    }
    toJson() {
        return { type: '' };
    }
}
SelectionBox.chunkSize = 4;
SelectionBox.orderMethod = new Map([
    [
        "alphabetical",
        (x, y) => x.items[0].content.localeCompare(y.items[0].content)
    ],
    ["none", (_x, _y) => 1],
    [
        "decreasing",
        (x, y) => {
            const xl = x.items.length;
            const yl = y.items.length;
            return xl < yl ? 1 : yl < xl ? -1 : 0;
        }
    ],
    [
        "increasing",
        (x, y) => {
            const xl = x.items.length;
            const yl = y.items.length;
            return xl < yl ? -1 : yl < xl ? 1 : 0;
        }
    ]
]);

//# sourceMappingURL=selection_box.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/parser_factory.js
class ParserFactory {
    constructor(init) {
        this._parser = new Map(init);
    }
    get(name) {
        return this._parser.get(name);
    }
    add(name, method) {
        this._parser.set(name, method);
    }
}
//# sourceMappingURL=parser_factory.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/parse.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};













class Parser {
    constructor(init = []) {
        this._initList = [
            ['command', Command.fromJson.bind(Command)],
            ['checkbox', Checkbox.fromJson.bind(Checkbox)],
            ['combo', Combo.fromJson.bind(Combo)],
            ['slider', Slider.fromJson.bind(Slider)],
            ['label', item_label_Label.fromJson.bind(item_label_Label)],
            ['radio', Radio.fromJson.bind(Radio)],
            ['rule', Rule.fromJson.bind(Rule)],
            ['submenu', Submenu.fromJson.bind(Submenu)],
            ['contextMenu', ContextMenu.fromJson.bind(ContextMenu)],
            ['subMenu', SubMenu.fromJson.bind(SubMenu)],
            ['variable', Variable.fromJson.bind(Variable)],
            ['items', this.items.bind(this)],
            ['selectionMenu', SelectionMenu.fromJson.bind(SelectionMenu)],
            ['selectionBox', SelectionBox.fromJson.bind(SelectionBox)]
        ];
        this._factory = new ParserFactory(this._initList);
        init.forEach(([x, y]) => this.factory.add(x, y));
    }
    get factory() {
        return this._factory;
    }
    items(_factory, its, ctxt) {
        const hidden = [];
        for (const item of its) {
            const entry = this.parse(item, ctxt);
            if (!entry) {
                continue;
            }
            ctxt.items.push(entry);
            if (item.disabled) {
                entry.disable();
            }
            if (item.hidden) {
                hidden.push(entry);
            }
        }
        hidden.forEach((x) => x.hide());
        return ctxt.items;
    }
    parse(_a, ...rest) {
        var { type: kind } = _a, json = __rest(_a, ["type"]);
        const func = this.factory.get(kind);
        return func ? func(this.factory, json, ...rest) : null;
    }
}
//# sourceMappingURL=parse.js.map
;// ./node_modules/.pnpm/mj-context-menu@0.9.1/node_modules/mj-context-menu/js/css_util.js

function makeClass_(name) {
    return '.' + (HtmlClasses[name] || name);
}
const INFO_STYLES = {};
INFO_STYLES[makeClass_('INFOCLOSE')] = '{' + '  top:.2em; right:.2em;' + '}';
INFO_STYLES[makeClass_('INFOCONTENT')] =
    '{' +
        '  overflow:auto; text-align:left; font-size:80%;' +
        '  padding:.4em .6em; border:1px inset; margin:1em 0px;' +
        '  max-height:20em; max-width:30em; background-color:#EEEEEE;' +
        '  white-space:normal;' +
        '}';
INFO_STYLES[makeClass_('INFO') + makeClass_('MOUSEPOST')] =
    '{' + 'outline:none;' + '}';
INFO_STYLES[makeClass_('INFO')] =
    '{' +
        '  position:fixed; left:50%; width:auto; text-align:center;' +
        '  border:3px outset; padding:1em 2em; background-color:#DDDDDD;' +
        '  color:black;' +
        '  cursor:default; font-family:message-box; font-size:120%;' +
        '  font-style:normal; text-indent:0; text-transform:none;' +
        '  line-height:normal; letter-spacing:normal; word-spacing:normal;' +
        '  word-wrap:normal; white-space:nowrap; float:none; z-index:201;' +
        '  border-radius: 15px;                     /* Opera 10.5 and IE9 */' +
        '  -webkit-border-radius:15px;               /* Safari and Chrome */' +
        '  -moz-border-radius:15px;                  /* Firefox */' +
        '  -khtml-border-radius:15px;                /* Konqueror */' +
        '  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */' +
        '  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */' +
        '  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */' +
        '  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */' +
        '  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2,' +
        ' OffY=2, Color="gray", Positive="true"); /* IE */' +
        '}';
const MENU_STYLES = {};
MENU_STYLES[makeClass_('MENU')] =
    '{' +
        '  position:absolute;' +
        '  background-color:white;' +
        '  color:black;' +
        '  width:auto; padding:5px 0px;' +
        '  border:1px solid #CCCCCC; margin:0; cursor:default;' +
        '  font: menu; text-align:left; text-indent:0; text-transform:none;' +
        '  line-height:normal; letter-spacing:normal; word-spacing:normal;' +
        '  word-wrap:normal; white-space:nowrap; float:none; z-index:201;' +
        '  border-radius: 5px;                     /* Opera 10.5 and IE9 */' +
        '  -webkit-border-radius: 5px;             /* Safari and Chrome */' +
        '  -moz-border-radius: 5px;                /* Firefox */' +
        '  -khtml-border-radius: 5px;              /* Konqueror */' +
        '  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */' +
        '  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */' +
        '  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */' +
        '  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */' +
        '}';
MENU_STYLES[makeClass_('MENUITEM')] =
    '{' + '  padding: 1px 2em;' + '  background:transparent;' + '}';
MENU_STYLES[makeClass_('MENUARROW')] =
    '{' +
        '  position:absolute; right:.5em; padding-top:.25em; color:#666666;' +
        '  font-family: null; font-size: .75em' +
        '}';
MENU_STYLES[makeClass_('MENUACTIVE') + ' ' + makeClass_('MENUARROW')] =
    '{color:white}';
MENU_STYLES[makeClass_('MENUARROW') + makeClass_('RTL')] =
    '{left:.5em; right:auto}';
MENU_STYLES[makeClass_('MENUCHECK')] =
    '{' + '  position:absolute; left:.7em;' + '  font-family: null' + '}';
MENU_STYLES[makeClass_('MENUCHECK') + makeClass_('RTL')] =
    '{ right:.7em; left:auto }';
MENU_STYLES[makeClass_('MENURADIOCHECK')] =
    '{' + '  position:absolute; left: .7em;' + '}';
MENU_STYLES[makeClass_('MENURADIOCHECK') + makeClass_('RTL')] =
    '{' + '  right: .7em; left:auto' + '}';
MENU_STYLES[makeClass_('MENUINPUTBOX')] =
    '{' +
        '  padding-left: 1em; right:.5em; color:#666666;' +
        '  font-family: null;' +
        '}';
MENU_STYLES[makeClass_('MENUINPUTBOX') + makeClass_('RTL')] =
    '{' + '  left: .1em;' + '}';
MENU_STYLES[makeClass_('MENUCOMBOBOX')] =
    '{' + '  left:.1em; padding-bottom:.5em;' + '}';
MENU_STYLES[makeClass_('MENUSLIDER')] = '{' + '  left: .1em;' + '}';
MENU_STYLES[makeClass_('SLIDERVALUE')] =
    '{' +
        '  position:absolute; right:.1em; padding-top:.25em; color:#333333;' +
        '  font-size: .75em' +
        '}';
MENU_STYLES[makeClass_('SLIDERBAR')] =
    '{' + '  outline: none; background: #d3d3d3' + '}';
MENU_STYLES[makeClass_('MENULABEL')] =
    '{' + '  padding: 1px 2em 3px 1.33em;' + '  font-style:italic' + '}';
MENU_STYLES[makeClass_('MENURULE')] =
    '{' + '  border-top: 1px solid #DDDDDD;' + '  margin: 4px 3px;' + '}';
MENU_STYLES[makeClass_('MENUDISABLED')] = '{' + '  color:GrayText' + '}';
MENU_STYLES[makeClass_('MENUACTIVE')] =
    '{' + '  background-color: #606872;' + '  color: white;' + '}';
MENU_STYLES[makeClass_('MENUDISABLED') + ':focus'] =
    '{' + '  background-color: #E8E8E8' + '}';
MENU_STYLES[makeClass_('MENULABEL') + ':focus'] =
    '{' + '  background-color: #E8E8E8' + '}';
MENU_STYLES[makeClass_('CONTEXTMENU') + ':focus'] =
    '{' + '  outline:none' + '}';
MENU_STYLES[makeClass_('CONTEXTMENU') + ' ' + makeClass_('MENUITEM') + ':focus'] = '{' + '  outline:none' + '}';
MENU_STYLES[makeClass_('SELECTIONMENU')] =
    '{' +
        '  position:relative; float:left;' +
        '  border-bottom: none;' +
        ' -webkit-box-shadow:none;' +
        ' -webkit-border-radius:0px; ' +
        '}';
MENU_STYLES[makeClass_('SELECTIONITEM')] = '{' + '  padding-right: 1em;' + '}';
MENU_STYLES[makeClass_('SELECTION')] = '{' + '  right: 40%; width:50%; ' + '}';
MENU_STYLES[makeClass_('SELECTIONBOX')] =
    '{' +
        '  padding: 0em; max-height:20em; max-width: none;' +
        '  background-color:#FFFFFF;' +
        '}';
MENU_STYLES[makeClass_('SELECTIONDIVIDER')] =
    '{' + '  clear: both; border-top: 2px solid #000000;' + '}';
MENU_STYLES[makeClass_('MENU') + ' ' + makeClass_('MENUCLOSE')] =
    '{' + '  top:-10px; left:-10px' + '}';
const CLOSE_ICON_STYLES = {};
CLOSE_ICON_STYLES[makeClass_('MENUCLOSE')] =
    '{' +
        '  position:absolute;' +
        '  cursor:pointer;' +
        '  display:inline-block;' +
        '  border:2px solid #AAA;' +
        '  border-radius:18px;' +
        '  -webkit-border-radius: 18px;             /* Safari and Chrome */' +
        '  -moz-border-radius: 18px;                /* Firefox */' +
        '  -khtml-border-radius: 18px;              /* Konqueror */' +
        '  font-family: "Courier New", Courier;' +
        '  font-size:24px;' +
        '  color:#F0F0F0' +
        '}';
CLOSE_ICON_STYLES[makeClass_('MENUCLOSE') + ' span'] =
    '{' +
        '  display:block; background-color:#AAA; border:1.5px solid;' +
        '  border-radius:18px;' +
        '  -webkit-border-radius: 18px;             /* Safari and Chrome */' +
        '  -moz-border-radius: 18px;                /* Firefox */' +
        '  -khtml-border-radius: 18px;              /* Konqueror */' +
        '  line-height:0;' +
        '  padding:8px 0 6px     /* may need to be browser-specific */' +
        '}';
CLOSE_ICON_STYLES[makeClass_('MENUCLOSE') + ':hover'] =
    '{' + '  color:white!important;' + '  border:2px solid #CCC!important' + '}';
CLOSE_ICON_STYLES[makeClass_('MENUCLOSE') + ':hover span'] =
    '{' + '  background-color:#CCC!important' + '}';
CLOSE_ICON_STYLES[makeClass_('MENUCLOSE') + ':hover:focus'] =
    '{' + '  outline:none' + '}';
let INFO_ADDED = false;
let MENU_ADDED = false;
let CLOSE_ICON_ADDED = false;
function addMenuStyles(opt_document) {
    if (MENU_ADDED) {
        return;
    }
    addStyles_(MENU_STYLES, opt_document);
    MENU_ADDED = true;
    addCloseIconStyles_(opt_document);
}
function addInfoStyles(opt_document) {
    if (INFO_ADDED) {
        return;
    }
    addStyles_(INFO_STYLES, opt_document);
    INFO_ADDED = true;
    addCloseIconStyles_(opt_document);
}
function addCloseIconStyles_(opt_document) {
    if (CLOSE_ICON_ADDED) {
        return;
    }
    addStyles_(CLOSE_ICON_STYLES, opt_document);
    CLOSE_ICON_ADDED = true;
}
function addStyles_(styles, opt_document) {
    const doc = opt_document || document;
    const element = doc.createElement('style');
    element.type = 'text/css';
    let inner = '';
    for (const style in styles) {
        inner += style;
        inner += ' ';
        inner += styles[style];
        inner += '\n';
    }
    element.innerHTML = inner;
    doc.head.appendChild(element);
}
//# sourceMappingURL=css_util.js.map
;// ./mjs/ui/menu/mj-context-menu.js










//# sourceMappingURL=mj-context-menu.js.map
;// ./mjs/ui/menu/MJContextMenu.js

class MJContextMenu extends ContextMenu {
    constructor() {
        super(...arguments);
        this.mathItem = null;
        this.nofocus = false;
        this.errorMsg = '';
    }
    post(x, y) {
        var _a, _b;
        if (this.mathItem) {
            const speech = (_b = (_a = this.mathItem) === null || _a === void 0 ? void 0 : _a.explorers) === null || _b === void 0 ? void 0 : _b.speech;
            if (speech === null || speech === void 0 ? void 0 : speech.active) {
                speech.restarted = speech.semanticFocus();
            }
            if (y !== undefined) {
                this.getOriginalMenu();
                this.getSemanticsMenu();
                this.getSpeechMenu();
                this.getBrailleMenu();
                this.getSvgMenu();
                this.getErrorMessage();
                this.dynamicSubmenus();
            }
            super.post(x, y);
        }
    }
    unpost() {
        super.unpost();
        if (this.mathItem) {
            this.mathItem.outputData.nofocus = this.nofocus;
        }
        this.mathItem = null;
        this.nofocus = false;
    }
    findID(...names) {
        let menu = this;
        let item = null;
        for (const name of names) {
            if (!menu)
                return null;
            for (item of menu.items) {
                if (item.id === name) {
                    menu = item instanceof Submenu ? item.submenu : null;
                    break;
                }
                menu = item = null;
            }
        }
        return item;
    }
    setJax(jax) {
        this.jax = jax;
    }
    getOriginalMenu() {
        const input = this.mathItem.inputJax.name;
        const original = this.findID('Show', 'Original');
        original.content =
            input === 'MathML' ? 'Original MathML' : input + ' Commands';
        const clipboard = this.findID('Copy', 'Original');
        clipboard.content = original.content;
    }
    getSemanticsMenu() {
        const semantics = this.findID('Settings', 'MathmlIncludes', 'semantics');
        this.mathItem.inputJax.name === 'MathML'
            ? semantics.disable()
            : semantics.enable();
    }
    getSpeechMenu() {
        const speech = this.mathItem.outputData.speech;
        this.findID('Show', 'Speech')[speech ? 'enable' : 'disable']();
        this.findID('Copy', 'Speech')[speech ? 'enable' : 'disable']();
    }
    getBrailleMenu() {
        const braille = this.mathItem.outputData.braille;
        this.findID('Show', 'Braille')[braille ? 'enable' : 'disable']();
        this.findID('Copy', 'Braille')[braille ? 'enable' : 'disable']();
    }
    getSvgMenu() {
        const svg = this.jax.SVG;
        this.findID('Show', 'SVG')[svg ? 'enable' : 'disable']();
        this.findID('Copy', 'SVG')[svg ? 'enable' : 'disable']();
    }
    getErrorMessage() {
        const children = this.mathItem.root.childNodes[0].childNodes;
        let disable = true;
        this.errorMsg = '';
        if (children.length === 1 && children[0].isKind('merror')) {
            const attributes = children[0].attributes;
            this.errorMsg = (attributes.get('data-mjx-error') ||
                attributes.get('data-mjx-message') ||
                '');
            disable = !this.errorMsg;
        }
        this.findID('Show', 'Error')[disable ? 'disable' : 'enable']();
        this.findID('Copy', 'Error')[disable ? 'disable' : 'enable']();
    }
    dynamicSubmenus() {
        for (const [id, [method, option]] of MJContextMenu.DynamicSubmenus) {
            const menu = this.find(id);
            if (!menu)
                continue;
            method(this, menu, (sub) => {
                var _a;
                menu.submenu = sub;
                if (((_a = sub === null || sub === void 0 ? void 0 : sub.items) === null || _a === void 0 ? void 0 : _a.length) && (!option || this.settings[option])) {
                    menu.enable();
                }
                else {
                    menu.disable();
                }
            });
        }
    }
}
MJContextMenu.DynamicSubmenus = new Map();
//# sourceMappingURL=MJContextMenu.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/rule_engine/dynamic_cstr.js
var Axis;
(function (Axis) {
    Axis["DOMAIN"] = "domain";
    Axis["STYLE"] = "style";
    Axis["LOCALE"] = "locale";
    Axis["TOPIC"] = "topic";
    Axis["MODALITY"] = "modality";
})(Axis || (Axis = {}));
class DynamicProperties {
    static createProp(...cstrList) {
        const axes = DynamicCstr.DEFAULT_ORDER;
        const dynamicCstr = {};
        for (let i = 0, l = cstrList.length, k = axes.length; i < l && i < k; i++) {
            dynamicCstr[axes[i]] = cstrList[i];
        }
        return new DynamicProperties(dynamicCstr);
    }
    constructor(properties, order = Object.keys(properties)) {
        this.properties = properties;
        this.order = order;
    }
    getProperties() {
        return this.properties;
    }
    getOrder() {
        return this.order;
    }
    getAxes() {
        return this.order;
    }
    getProperty(key) {
        return this.properties[key];
    }
    updateProperties(props) {
        this.properties = props;
    }
    allProperties() {
        const propLists = [];
        this.order.forEach((key) => propLists.push(this.getProperty(key).slice()));
        return propLists;
    }
    toString() {
        const cstrStrings = [];
        this.order.forEach((key) => cstrStrings.push(key + ': ' + this.getProperty(key).toString()));
        return cstrStrings.join('\n');
    }
}
class DynamicCstr extends DynamicProperties {
    static createCstr(...cstrList) {
        const axes = DynamicCstr.DEFAULT_ORDER;
        const dynamicCstr = {};
        for (let i = 0, l = cstrList.length, k = axes.length; i < l && i < k; i++) {
            dynamicCstr[axes[i]] = cstrList[i];
        }
        return new DynamicCstr(dynamicCstr);
    }
    static defaultCstr() {
        return DynamicCstr.createCstr.apply(null, DynamicCstr.DEFAULT_ORDER.map(function (x) {
            return DynamicCstr.DEFAULT_VALUES[x];
        }));
    }
    static validOrder(order) {
        const axes = DynamicCstr.DEFAULT_ORDER.slice();
        return order.every((x) => {
            const index = axes.indexOf(x);
            return index !== -1 && axes.splice(index, 1);
        });
    }
    constructor(components_, order) {
        const properties = {};
        for (const [key, value] of Object.entries(components_)) {
            properties[key] = [value];
        }
        super(properties, order);
        this.components = components_;
    }
    getComponents() {
        return this.components;
    }
    getValue(key) {
        return this.components[key];
    }
    getValues() {
        return this.order.map((key) => this.getValue(key));
    }
    allProperties() {
        const propLists = super.allProperties();
        for (let i = 0, props, key; (props = propLists[i]), (key = this.order[i]); i++) {
            const value = this.getValue(key);
            if (props.indexOf(value) === -1) {
                props.unshift(value);
            }
        }
        return propLists;
    }
    toString() {
        return this.getValues().join('.');
    }
    equal(cstr) {
        const keys1 = cstr.getAxes();
        if (this.order.length !== keys1.length) {
            return false;
        }
        for (let j = 0, key; (key = keys1[j]); j++) {
            const comp2 = this.getValue(key);
            if (!comp2 || cstr.getValue(key) !== comp2) {
                return false;
            }
        }
        return true;
    }
}
DynamicCstr.DEFAULT_ORDER = [
    Axis.LOCALE,
    Axis.MODALITY,
    Axis.DOMAIN,
    Axis.STYLE,
    Axis.TOPIC
];
DynamicCstr.BASE_LOCALE = 'base';
DynamicCstr.DEFAULT_VALUE = 'default';
DynamicCstr.DEFAULT_VALUES = {
    [Axis.LOCALE]: 'en',
    [Axis.DOMAIN]: DynamicCstr.DEFAULT_VALUE,
    [Axis.STYLE]: DynamicCstr.DEFAULT_VALUE,
    [Axis.TOPIC]: DynamicCstr.DEFAULT_VALUE,
    [Axis.MODALITY]: 'speech'
};
class DynamicCstrParser {
    constructor(order) {
        this.order = order;
    }
    parse(str) {
        const order = str.split('.');
        const cstr = {};
        if (order.length > this.order.length) {
            throw new Error('Invalid dynamic constraint: ' + cstr);
        }
        let j = 0;
        for (let i = 0, key; (key = this.order[i]), order.length; i++, j++) {
            const value = order.shift();
            cstr[key] = value;
        }
        return new DynamicCstr(cstr, this.order.slice(0, j));
    }
}
class DefaultComparator {
    constructor(reference, fallback = new DynamicProperties(reference.getProperties(), reference.getOrder())) {
        this.reference = reference;
        this.fallback = fallback;
        this.order = this.reference.getOrder();
    }
    getReference() {
        return this.reference;
    }
    setReference(cstr, props) {
        this.reference = cstr;
        this.fallback =
            props || new DynamicProperties(cstr.getProperties(), cstr.getOrder());
        this.order = this.reference.getOrder();
    }
    match(cstr) {
        const keys1 = cstr.getAxes();
        return (keys1.length === this.reference.getAxes().length &&
            keys1.every((key) => {
                const value = cstr.getValue(key);
                return (value === this.reference.getValue(key) ||
                    this.fallback.getProperty(key).indexOf(value) !== -1);
            }));
    }
    compare(cstr1, cstr2) {
        let ignore = false;
        for (let i = 0, key; (key = this.order[i]); i++) {
            const value1 = cstr1.getValue(key);
            const value2 = cstr2.getValue(key);
            if (!ignore) {
                const ref = this.reference.getValue(key);
                if (ref === value1 && ref !== value2) {
                    return -1;
                }
                if (ref === value2 && ref !== value1) {
                    return 1;
                }
                if (ref === value1 && ref === value2) {
                    continue;
                }
                if (ref !== value1 && ref !== value2) {
                    ignore = true;
                }
            }
            const prop = this.fallback.getProperty(key);
            const index1 = prop.indexOf(value1);
            const index2 = prop.indexOf(value2);
            if (index1 < index2) {
                return -1;
            }
            if (index2 < index1) {
                return 1;
            }
        }
        return 0;
    }
    toString() {
        return this.reference.toString() + '\n' + this.fallback.toString();
    }
}
//# sourceMappingURL=dynamic_cstr.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/engine_const.js
var Mode;
(function (Mode) {
    Mode["SYNC"] = "sync";
    Mode["ASYNC"] = "async";
    Mode["HTTP"] = "http";
})(Mode || (Mode = {}));
var personalityProps;
(function (personalityProps) {
    personalityProps["PITCH"] = "pitch";
    personalityProps["RATE"] = "rate";
    personalityProps["VOLUME"] = "volume";
    personalityProps["PAUSE"] = "pause";
    personalityProps["JOIN"] = "join";
    personalityProps["LAYOUT"] = "layout";
})(personalityProps || (personalityProps = {}));
const personalityPropList = [
    personalityProps.PITCH,
    personalityProps.RATE,
    personalityProps.VOLUME,
    personalityProps.PAUSE,
    personalityProps.JOIN
];
var Speech;
(function (Speech) {
    Speech["NONE"] = "none";
    Speech["SHALLOW"] = "shallow";
    Speech["DEEP"] = "deep";
})(Speech || (Speech = {}));
var Markup;
(function (Markup) {
    Markup["NONE"] = "none";
    Markup["LAYOUT"] = "layout";
    Markup["COUNTING"] = "counting";
    Markup["PUNCTUATION"] = "punctuation";
    Markup["SSML"] = "ssml";
    Markup["ACSS"] = "acss";
    Markup["SABLE"] = "sable";
    Markup["VOICEXML"] = "voicexml";
})(Markup || (Markup = {}));
const DOMAIN_TO_STYLES = {
    mathspeak: 'default',
    clearspeak: 'default'
};
//# sourceMappingURL=engine_const.js.map
// EXTERNAL MODULE: ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/system_external.js
var system_external = __webpack_require__(74);
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/file_util.js

function makePath(path) {
    return path.match('/$') ? path : path + '/';
}
function localePath(locale, ext = 'json') {
    return (makePath(SystemExternal.jsonPath) +
        locale +
        (ext.match(/^\./) ? ext : '.' + ext));
}
//# sourceMappingURL=file_util.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/debugger.js

class Debugger {
    static getInstance() {
        Debugger.instance = Debugger.instance || new Debugger();
        return Debugger.instance;
    }
    init(opt_file) {
        if (opt_file) {
            this.startDebugFile_(opt_file);
        }
        this.isActive_ = true;
        return this.fileHandle;
    }
    output(...args) {
        if (this.isActive_) {
            this.output_(args);
        }
    }
    generate(func) {
        if (this.isActive_) {
            this.output_(func.apply(func, []));
        }
    }
    exit(callback = () => { }) {
        this.fileHandle.then(() => {
            if (this.isActive_ && this.stream_) {
                this.stream_.end('', '', callback);
            }
        });
    }
    constructor() {
        this.isActive_ = false;
        this.fileHandle = Promise.resolve();
        this.stream_ = null;
    }
    startDebugFile_(filename) {
        this.fileHandle = system_external/* SystemExternal */.f.fs.promises.open(filename, 'w');
        this.fileHandle = this.fileHandle.then((handle) => {
            this.stream_ = handle.createWriteStream(filename);
            this.outputFunction = function (...args) {
                this.stream_.write(args.join(' '));
                this.stream_.write('\n');
            }.bind(this);
            this.stream_.on('error', function (_error) {
                console.info('Invalid log file. Debug information sent to console.');
                this.outputFunction = console.info;
            }.bind(this));
            this.stream_.on('finish', function () {
                console.info('Finalizing debug file.');
            });
        });
    }
    output_(outputList) {
        if (this.stream_) {
            this.fileHandle.then(() => this.outputFunction.apply(this.outputFunction, ['Speech Rule Engine Debugger:'].concat(outputList)));
            return;
        }
        console.info.apply(console, ['Speech Rule Engine Debugger:'].concat(outputList));
    }
}
//# sourceMappingURL=debugger.js.map
// EXTERNAL MODULE: ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/variables.js
var variables = __webpack_require__(714);
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/options.js


class Options {
    constructor(options = {}) {
        this.delay = false;
        this.domain = 'clearspeak';
        this.style = DynamicCstr.DEFAULT_VALUES[Axis.STYLE];
        this.locale = DynamicCstr.DEFAULT_VALUES[Axis.LOCALE];
        this.subiso = '';
        this.modality = DynamicCstr.DEFAULT_VALUES[Axis.MODALITY];
        this.speech = Speech.NONE;
        this.markup = Markup.NONE;
        this.mark = true;
        this.automark = false;
        this.character = true;
        this.cleanpause = true;
        this.cayleyshort = true;
        this.linebreaks = false;
        this.rate = '100';
        this.walker = 'Table';
        this.structure = false;
        this.aria = false;
        this.tree = false;
        this.strict = false;
        this.pprint = false;
        this.rules = '';
        this.prune = '';
        this.set(options);
    }
    set(options) {
        this.ensureDomain(options);
        for (const [option, value] of Object.entries(options)) {
            if (Options.BINARY_FEATURES.includes(option) ||
                Options.STRING_FEATURES.includes(option)) {
                this[option] = value;
                continue;
            }
        }
    }
    json() {
        const features = {};
        const engineFeatures = [].concat(Options.STRING_FEATURES, Options.BINARY_FEATURES);
        engineFeatures.forEach((x) => (features[x] = this[x]));
        return features;
    }
    ensureDomain(feature) {
        if ((feature.modality && feature.modality !== 'speech') ||
            (!feature.modality && this.modality !== 'speech')) {
            return;
        }
        if (!feature.domain && !feature.locale) {
            return;
        }
        if (feature.domain === 'default') {
            feature.domain = 'mathspeak';
            return;
        }
        const locale = (feature.locale || this.locale);
        const domain = (feature.domain || this.domain);
        if (MATHSPEAK_ONLY.indexOf(locale) !== -1 && domain !== 'mathspeak') {
            feature.domain = 'mathspeak';
            return;
        }
        if (locale === 'en') {
            if (EN_RULES.indexOf(domain) === -1) {
                feature.domain = 'mathspeak';
            }
            return;
        }
        if (domain !== 'mathspeak' && domain !== 'clearspeak') {
            feature.domain = 'mathspeak';
        }
    }
}
Options.BINARY_FEATURES = [
    'automark',
    'mark',
    'character',
    'cleanpause',
    'strict',
    'structure',
    'aria',
    'pprint',
    'cayleyshort',
    'linebreaks',
    'tree'
];
Options.STRING_FEATURES = [
    'markup',
    'style',
    'domain',
    'speech',
    'walker',
    'locale',
    'delay',
    'modality',
    'rate',
    'rules',
    'subiso',
    'prune'
];
const MATHSPEAK_ONLY = ['ca', 'da', 'es'];
const EN_RULES = [
    'chromevox',
    'clearspeak',
    'mathspeak',
    'emacspeak',
    'html'
];
//# sourceMappingURL=options.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/engine.js







class SREError extends Error {
    constructor(message = '') {
        super();
        this.message = message;
        this.name = 'SRE Error';
    }
}
class Engine {
    set defaultLocale(loc) {
        this._defaultLocale = variables/* Variables */.u.ensureLocale(loc, this._defaultLocale);
    }
    get defaultLocale() {
        return this._defaultLocale;
    }
    static getInstance() {
        Engine.instance = Engine.instance || new Engine();
        return Engine.instance;
    }
    static defaultEvaluator(str, _cstr) {
        return str;
    }
    static evaluateNode(node) {
        return Engine.nodeEvaluator(node);
    }
    getRate() {
        const numeric = parseInt(this.options.rate, 10);
        return isNaN(numeric) ? 100 : numeric;
    }
    setDynamicCstr(opt_dynamic) {
        if (this.defaultLocale) {
            DynamicCstr.DEFAULT_VALUES[Axis.LOCALE] = this.defaultLocale;
        }
        if (opt_dynamic) {
            const keys = Object.keys(opt_dynamic);
            for (let i = 0; i < keys.length; i++) {
                const feature = keys[i];
                if (DynamicCstr.DEFAULT_ORDER.indexOf(feature) !== -1) {
                    const value = opt_dynamic[feature];
                    this.options[feature] = value;
                }
            }
        }
        const dynamic = [
            this.options.locale,
            this.options.modality,
            this.options.domain,
            this.options.style
        ].join('.');
        const fallback = DynamicProperties.createProp([DynamicCstr.DEFAULT_VALUES[Axis.LOCALE]], [DynamicCstr.DEFAULT_VALUES[Axis.MODALITY]], [DynamicCstr.DEFAULT_VALUES[Axis.DOMAIN]], [DynamicCstr.DEFAULT_VALUES[Axis.STYLE]]);
        const comparator = this.comparators[this.options.domain];
        const parser = this.parsers[this.options.domain];
        this.parser = parser ? parser : this.defaultParser;
        this.dynamicCstr = this.parser.parse(dynamic);
        this.dynamicCstr.updateProperties(fallback.getProperties());
        this.comparator = comparator
            ? comparator()
            : new DefaultComparator(this.dynamicCstr);
    }
    constructor() {
        this.options = new Options();
        this.config = false;
        this.customLoader = null;
        this.parsers = {};
        this.comparator = null;
        this.mode = Mode.SYNC;
        this.init = true;
        this.comparators = {};
        this._defaultLocale = DynamicCstr.DEFAULT_VALUES[Axis.LOCALE];
        this.options.locale = this.defaultLocale;
        this.evaluator = Engine.defaultEvaluator;
        this.defaultParser = new DynamicCstrParser(DynamicCstr.DEFAULT_ORDER);
        this.parser = this.defaultParser;
        this.dynamicCstr = DynamicCstr.defaultCstr();
    }
    configurate(feature) {
        if (this.mode === Mode.HTTP &&
            !system_external/* SystemExternal */.f.webworker &&
            !this.config) {
            configBlocks(feature);
            this.config = true;
        }
        configFeature(feature);
    }
    setCustomLoader(fn) {
        if (fn) {
            this.customLoader = fn;
        }
    }
    setup(feature) {
        if (typeof feature['mode'] !== 'undefined') {
            this.mode = feature['mode'];
        }
        this.configurate(feature);
        this.options.set(feature);
        if (feature.json) {
            system_external/* SystemExternal */.f.jsonPath = makePath(feature.json);
        }
        this.setCustomLoader(feature.custom);
    }
    json() {
        return Object.assign({ mode: this.mode }, this.options.json());
    }
    reset() {
        this.options = new Options();
    }
}
Engine.nodeEvaluator = function (_node) {
    return [];
};
function configFeature(feature) {
    if (typeof SREfeature !== 'undefined') {
        for (const [name, feat] of Object.entries(SREfeature)) {
            feature[name] = feat;
        }
    }
}
function configBlocks(feature) {
    const scripts = document.documentElement.querySelectorAll('script[type="text/x-sre-config"]');
    for (let i = 0, m = scripts.length; i < m; i++) {
        let inner;
        try {
            inner = scripts[i].innerHTML;
            const config = JSON.parse(inner);
            for (const [key, val] of Object.entries(config)) {
                feature[key] = val;
            }
        }
        catch (_err) {
            Debugger.getInstance().output('Illegal configuration ', inner);
        }
    }
}
class engine_EnginePromise {
    static get(locale = Engine.getInstance().options.locale) {
        return engine_EnginePromise.promises[locale] || Promise.resolve('');
    }
    static getall() {
        return Promise.all(Object.values(engine_EnginePromise.promises));
    }
}
engine_EnginePromise.loaded = {};
engine_EnginePromise.promises = {};
//# sourceMappingURL=engine.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/xpath_util.js



const xpath = system_external/* SystemExternal */.f.xpath;
const nameSpaces = {
    xhtml: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    mml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg'
};
function resolveNameSpace(prefix) {
    return nameSpaces[prefix] || null;
}
class Resolver {
    constructor() {
        this.lookupNamespaceURI = resolveNameSpace;
    }
}
function evaluateXpath(expression, rootNode, type) {
    return xpath.evaluate(expression, rootNode, new Resolver(), type, null);
}
function evalXPath(expression, rootNode) {
    let iterator;
    try {
        iterator = evaluateXpath(expression, rootNode, xpath.result.ORDERED_NODE_ITERATOR_TYPE);
    }
    catch (_err) {
        return [];
    }
    const results = [];
    for (let xpathNode = iterator.iterateNext(); xpathNode; xpathNode = iterator.iterateNext()) {
        results.push(xpathNode);
    }
    return results;
}
function evaluateBoolean(expression, rootNode) {
    let result;
    try {
        result = evaluateXpath(expression, rootNode, xpath.result.BOOLEAN_TYPE);
    }
    catch (_err) {
        return false;
    }
    return result.booleanValue;
}
function evaluateString(expression, rootNode) {
    let result;
    try {
        result = evaluateXpath(expression, rootNode, xpath.result.STRING_TYPE);
    }
    catch (_err) {
        return '';
    }
    return result.stringValue;
}
function updateEvaluator(node) {
    if (Engine.getInstance().mode !== Mode.HTTP)
        return;
    let parent = node;
    while (parent && !parent.evaluate) {
        parent = parent.parentNode;
    }
    if (parent && parent.evaluate) {
        xpath.currentDocument = parent;
    }
    else if (node.ownerDocument) {
        xpath.currentDocument = node.ownerDocument;
    }
}
//# sourceMappingURL=xpath_util.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/dom_util.js




function toArray(nodeList) {
    const nodeArray = [];
    for (let i = 0, m = nodeList.length; i < m; i++) {
        nodeArray.push(nodeList[i]);
    }
    return nodeArray;
}
function trimInput(input) {
    input = input.replace(/&nbsp;/g, '');
    return input.replace(/>[ \f\n\r\t\v\u200b]+</g, '><').trim();
}
function parseInput(input) {
    const dp = new system_external/* SystemExternal */.f.xmldom.DOMParser();
    const clean_input = trimInput(input);
    const allValues = clean_input.match(/&(?!lt|gt|amp|quot|apos)\w+;/g);
    const html = !!allValues;
    if (!clean_input) {
        throw new Error('Empty input!');
    }
    try {
        const doc = dp.parseFromString(clean_input, html ? 'text/html' : 'text/xml');
        if (Engine.getInstance().mode === Mode.HTTP) {
            xpath.currentDocument = doc;
            return (html ? doc.body.childNodes[0] : doc.documentElement);
        }
        return doc.documentElement;
    }
    catch (err) {
        throw new SREError('Illegal input: ' + err.message);
    }
}
var NodeType;
(function (NodeType) {
    NodeType[NodeType["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
    NodeType[NodeType["ATTRIBUTE_NODE"] = 2] = "ATTRIBUTE_NODE";
    NodeType[NodeType["TEXT_NODE"] = 3] = "TEXT_NODE";
    NodeType[NodeType["CDATA_SECTION_NODE"] = 4] = "CDATA_SECTION_NODE";
    NodeType[NodeType["ENTITY_REFERENCE_NODE"] = 5] = "ENTITY_REFERENCE_NODE";
    NodeType[NodeType["ENTITY_NODE"] = 6] = "ENTITY_NODE";
    NodeType[NodeType["PROCESSING_INSTRUCTION_NODE"] = 7] = "PROCESSING_INSTRUCTION_NODE";
    NodeType[NodeType["COMMENT_NODE"] = 8] = "COMMENT_NODE";
    NodeType[NodeType["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
    NodeType[NodeType["DOCUMENT_TYPE_NODE"] = 10] = "DOCUMENT_TYPE_NODE";
    NodeType[NodeType["DOCUMENT_FRAGMENT_NODE"] = 11] = "DOCUMENT_FRAGMENT_NODE";
    NodeType[NodeType["NOTATION_NODE"] = 12] = "NOTATION_NODE";
})(NodeType || (NodeType = {}));
function replaceNode(oldNode, newNode) {
    if (!oldNode.parentNode) {
        return;
    }
    oldNode.parentNode.insertBefore(newNode, oldNode);
    oldNode.parentNode.removeChild(oldNode);
}
function createElement(tag) {
    return system_external/* SystemExternal */.f.document.createElement(tag);
}
function createElementNS(url, tag) {
    return SystemExternal.document.createElementNS(url, tag);
}
function createTextNode(content) {
    return system_external/* SystemExternal */.f.document.createTextNode(content);
}
function formatXml(xml) {
    let formatted = '';
    let reg = /(>)(<)(\/*)/g;
    xml = xml.replace(reg, '$1\r\n$2$3');
    let pad = 0;
    let split = xml.split('\r\n');
    reg = /(\.)*(<)(\/*)/g;
    split = split
        .map((x) => x.replace(reg, '$1\r\n$2$3').split('\r\n'))
        .reduce((x, y) => x.concat(y), []);
    while (split.length) {
        let node = split.shift();
        if (!node) {
            continue;
        }
        let indent = 0;
        if (node.match(/^<\w[^>/]*>[^>]+$/)) {
            const match = matchingStartEnd(node, split[0]);
            if (match[0]) {
                if (match[1]) {
                    node = node + split.shift().slice(0, -match[1].length);
                    if (match[1].trim()) {
                        split.unshift(match[1]);
                    }
                }
                else {
                    node = node + split.shift();
                }
            }
            else {
                indent = 1;
            }
        }
        else if (node.match(/^<\/\w/)) {
            if (pad !== 0) {
                pad -= 1;
            }
        }
        else if (node.match(/^<\w[^>]*[^/]>.*$/)) {
            indent = 1;
        }
        else if (node.match(/^<\w[^>]*\/>.+$/)) {
            const position = node.indexOf('>') + 1;
            const rest = node.slice(position);
            if (rest.trim()) {
                split.unshift();
            }
            node = node.slice(0, position) + rest;
        }
        else {
            indent = 0;
        }
        formatted += new Array(pad + 1).join('  ') + node + '\r\n';
        pad += indent;
    }
    return formatted;
}
function matchingStartEnd(start, end) {
    if (!end) {
        return [false, ''];
    }
    const tag1 = start.match(/^<([^> ]+).*>/);
    const tag2 = end.match(/^<\/([^>]+)>(.*)/);
    return tag1 && tag2 && tag1[1] === tag2[1] ? [true, tag2[2]] : [false, ''];
}
function querySelectorAllByAttr(node, attr) {
    return node.querySelectorAll
        ? toArray(node.querySelectorAll(`[${attr}]`))
        : XpathUtil.evalXPath(`.//*[@${attr}]`, node);
}
function querySelectorAllByAttrValue(node, attr, value) {
    return node.querySelectorAll
        ? toArray(node.querySelectorAll(`[${attr}="${value}"]`))
        : XpathUtil.evalXPath(`.//*[@${attr}="${value}"]`, node);
}
function querySelectorAll(node, tag) {
    return node.querySelectorAll
        ? toArray(node.querySelectorAll(tag))
        : XpathUtil.evalXPath(`.//${tag}`, node);
}
function dom_util_tagName(node) {
    return node.tagName.toUpperCase();
}
function cloneNode(node) {
    return node.cloneNode(true);
}
function serializeXml(node) {
    const xmls = new system_external/* SystemExternal */.f.xmldom.XMLSerializer();
    return xmls.serializeToString(node);
}
//# sourceMappingURL=dom_util.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_annotator.js
class SemanticAnnotator {
    constructor(domain, name, func) {
        this.domain = domain;
        this.name = name;
        this.func = func;
        this.active = false;
    }
    annotate(node) {
        node.childNodes.forEach(this.annotate.bind(this));
        node.contentNodes.forEach(this.annotate.bind(this));
        node.addAnnotation(this.domain, this.func(node));
    }
}
class SemanticVisitor {
    constructor(domain, name, func, def = {}) {
        this.domain = domain;
        this.name = name;
        this.func = func;
        this.def = def;
        this.active = false;
    }
    visit(node, info) {
        let result = this.func(node, info);
        node.addAnnotation(this.domain, result[0]);
        for (let i = 0, child; (child = node.childNodes[i]); i++) {
            result = this.visit(child, result[1]);
        }
        for (let i = 0, content; (content = node.contentNodes[i]); i++) {
            result = this.visit(content, result[1]);
        }
        return result;
    }
}
//# sourceMappingURL=semantic_annotator.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_annotations.js

const annotators = new Map();
const visitors = new Map();
function register(annotator) {
    const name = annotator.domain + ':' + annotator.name;
    annotator instanceof SemanticAnnotator
        ? annotators.set(name, annotator)
        : visitors.set(name, annotator);
}
function activate(domain, name) {
    const key = domain + ':' + name;
    const annotator = annotators.get(key) || visitors.get(key);
    if (annotator) {
        annotator.active = true;
    }
}
function deactivate(domain, name) {
    const key = domain + ':' + name;
    const annotator = annotators.get(key) || visitors.get(key);
    if (annotator) {
        annotator.active = false;
    }
}
function annotate(node) {
    for (const annotator of annotators.values()) {
        if (annotator.active) {
            annotator.annotate(node);
        }
    }
    for (const visitor of visitors.values()) {
        if (visitor.active) {
            visitor.visit(node, Object.assign({}, visitor.def));
        }
    }
}
//# sourceMappingURL=semantic_annotations.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/speech_rules/alphabet.js
var alphabet_Font;
(function (Font) {
    Font["BOLD"] = "bold";
    Font["BOLDFRAKTUR"] = "bold-fraktur";
    Font["BOLDITALIC"] = "bold-italic";
    Font["BOLDSCRIPT"] = "bold-script";
    Font["DOUBLESTRUCK"] = "double-struck";
    Font["DOUBLESTRUCKITALIC"] = "double-struck-italic";
    Font["FULLWIDTH"] = "fullwidth";
    Font["FRAKTUR"] = "fraktur";
    Font["ITALIC"] = "italic";
    Font["MONOSPACE"] = "monospace";
    Font["NORMAL"] = "normal";
    Font["SCRIPT"] = "script";
    Font["SANSSERIF"] = "sans-serif";
    Font["SANSSERIFITALIC"] = "sans-serif-italic";
    Font["SANSSERIFBOLD"] = "sans-serif-bold";
    Font["SANSSERIFBOLDITALIC"] = "sans-serif-bold-italic";
})(alphabet_Font || (alphabet_Font = {}));
var Embellish;
(function (Embellish) {
    Embellish["SUPER"] = "super";
    Embellish["SUB"] = "sub";
    Embellish["CIRCLED"] = "circled";
    Embellish["PARENTHESIZED"] = "parenthesized";
    Embellish["PERIOD"] = "period";
    Embellish["NEGATIVECIRCLED"] = "negative-circled";
    Embellish["DOUBLECIRCLED"] = "double-circled";
    Embellish["CIRCLEDSANSSERIF"] = "circled-sans-serif";
    Embellish["NEGATIVECIRCLEDSANSSERIF"] = "negative-circled-sans-serif";
    Embellish["COMMA"] = "comma";
    Embellish["SQUARED"] = "squared";
    Embellish["NEGATIVESQUARED"] = "negative-squared";
})(Embellish || (Embellish = {}));
var alphabet_Base;
(function (Base) {
    Base["LATINCAP"] = "latinCap";
    Base["LATINSMALL"] = "latinSmall";
    Base["GREEKCAP"] = "greekCap";
    Base["GREEKSMALL"] = "greekSmall";
    Base["DIGIT"] = "digit";
})(alphabet_Base || (alphabet_Base = {}));
function num2str(num) {
    const str = num.toString(16).toUpperCase();
    return str.length > 3 ? str : ('000' + str).slice(-4);
}
function makeInterval([a, b], subst) {
    const start = parseInt(a, 16);
    const end = parseInt(b, 16);
    const result = [];
    for (let i = start; i <= end; i++) {
        let key = num2str(i);
        const sub = subst[key];
        if (sub === false) {
            continue;
        }
        key = subst[key] || key;
        result.push(key);
    }
    return result;
}
function makeCharInterval(int, subst = {}) {
    return makeInterval(int, subst).map((x) => String.fromCodePoint(parseInt(x, 16)));
}
function makeMultiInterval(ints) {
    let result = [];
    for (const int of ints) {
        if (Array.isArray(int)) {
            result = result.concat(makeCharInterval(int));
            continue;
        }
        result.push(String.fromCodePoint(parseInt(int, 16)));
    }
    return result;
}
function makeCodeInterval(ints) {
    let result = [];
    for (const int of ints) {
        if (Array.isArray(int)) {
            result = result.concat(makeInterval(int, {}).map((x) => parseInt(x, 16)));
            continue;
        }
        result.push(parseInt(int, 16));
    }
    return result;
}
const PROTO_INTERVALS = [
    {
        interval: ['1D400', '1D419'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.BOLD
    },
    {
        interval: ['1D41A', '1D433'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.BOLD
    },
    {
        interval: ['1D56C', '1D585'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.BOLDFRAKTUR
    },
    {
        interval: ['1D586', '1D59F'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.BOLDFRAKTUR
    },
    {
        interval: ['1D468', '1D481'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.BOLDITALIC
    },
    {
        interval: ['1D482', '1D49B'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.BOLDITALIC
    },
    {
        interval: ['1D4D0', '1D4E9'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.BOLDSCRIPT
    },
    {
        interval: ['1D4EA', '1D503'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.BOLDSCRIPT
    },
    {
        interval: ['1D538', '1D551'],
        base: alphabet_Base.LATINCAP,
        subst: {
            '1D53A': '2102',
            '1D53F': '210D',
            '1D545': '2115',
            '1D547': '2119',
            '1D548': '211A',
            '1D549': '211D',
            '1D551': '2124'
        },
        capital: true,
        category: 'Lu',
        font: alphabet_Font.DOUBLESTRUCK
    },
    {
        interval: ['1D552', '1D56B'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.DOUBLESTRUCK
    },
    {
        interval: ['1D504', '1D51D'],
        base: alphabet_Base.LATINCAP,
        subst: {
            '1D506': '212D',
            '1D50B': '210C',
            '1D50C': '2111',
            '1D515': '211C',
            '1D51D': '2128'
        },
        capital: true,
        category: 'Lu',
        font: alphabet_Font.FRAKTUR
    },
    {
        interval: ['1D51E', '1D537'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.FRAKTUR
    },
    {
        interval: ['FF21', 'FF3A'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.FULLWIDTH
    },
    {
        interval: ['FF41', 'FF5A'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.FULLWIDTH
    },
    {
        interval: ['1D434', '1D44D'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.ITALIC
    },
    {
        interval: ['1D44E', '1D467'],
        base: alphabet_Base.LATINSMALL,
        subst: { '1D455': '210E' },
        capital: false,
        category: 'Ll',
        font: alphabet_Font.ITALIC
    },
    {
        interval: ['1D670', '1D689'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.MONOSPACE
    },
    {
        interval: ['1D68A', '1D6A3'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.MONOSPACE
    },
    {
        interval: ['0041', '005A'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.NORMAL
    },
    {
        interval: ['0061', '007A'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.NORMAL
    },
    {
        interval: ['1D49C', '1D4B5'],
        base: alphabet_Base.LATINCAP,
        subst: {
            '1D49D': '212C',
            '1D4A0': '2130',
            '1D4A1': '2131',
            '1D4A3': '210B',
            '1D4A4': '2110',
            '1D4A7': '2112',
            '1D4A8': '2133',
            '1D4AD': '211B'
        },
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SCRIPT
    },
    {
        interval: ['1D4B6', '1D4CF'],
        base: alphabet_Base.LATINSMALL,
        subst: { '1D4BA': '212F', '1D4BC': '210A', '1D4C4': '2134' },
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SCRIPT
    },
    {
        interval: ['1D5A0', '1D5B9'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SANSSERIF
    },
    {
        interval: ['1D5BA', '1D5D3'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SANSSERIF
    },
    {
        interval: ['1D608', '1D621'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SANSSERIFITALIC
    },
    {
        interval: ['1D622', '1D63B'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SANSSERIFITALIC
    },
    {
        interval: ['1D5D4', '1D5ED'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SANSSERIFBOLD
    },
    {
        interval: ['1D5EE', '1D607'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SANSSERIFBOLD
    },
    {
        interval: ['1D63C', '1D655'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SANSSERIFBOLDITALIC
    },
    {
        interval: ['1D656', '1D66F'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SANSSERIFBOLDITALIC
    },
    {
        interval: ['0391', '03A9'],
        base: alphabet_Base.GREEKCAP,
        subst: { '03A2': '03F4' },
        capital: true,
        category: 'Lu',
        font: alphabet_Font.NORMAL
    },
    {
        interval: ['03B0', '03D0'],
        base: alphabet_Base.GREEKSMALL,
        subst: {
            '03B0': '2207',
            '03CA': '2202',
            '03CB': '03F5',
            '03CC': '03D1',
            '03CD': '03F0',
            '03CE': '03D5',
            '03CF': '03F1',
            '03D0': '03D6'
        },
        capital: false,
        category: 'Ll',
        font: alphabet_Font.NORMAL
    },
    {
        interval: ['1D6A8', '1D6C0'],
        base: alphabet_Base.GREEKCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.BOLD
    },
    {
        interval: ['1D6C1', '1D6E1'],
        base: alphabet_Base.GREEKSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.BOLD
    },
    {
        interval: ['1D6E2', '1D6FA'],
        base: alphabet_Base.GREEKCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.ITALIC
    },
    {
        interval: ['1D6FB', '1D71B'],
        base: alphabet_Base.GREEKSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.ITALIC
    },
    {
        interval: ['1D71C', '1D734'],
        base: alphabet_Base.GREEKCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.BOLDITALIC
    },
    {
        interval: ['1D735', '1D755'],
        base: alphabet_Base.GREEKSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.BOLDITALIC
    },
    {
        interval: ['1D756', '1D76E'],
        base: alphabet_Base.GREEKCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SANSSERIFBOLD
    },
    {
        interval: ['1D76F', '1D78F'],
        base: alphabet_Base.GREEKSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SANSSERIFBOLD
    },
    {
        interval: ['1D790', '1D7A8'],
        base: alphabet_Base.GREEKCAP,
        subst: {},
        capital: true,
        category: 'Lu',
        font: alphabet_Font.SANSSERIFBOLDITALIC
    },
    {
        interval: ['1D7A9', '1D7C9'],
        base: alphabet_Base.GREEKSMALL,
        subst: {},
        capital: false,
        category: 'Ll',
        font: alphabet_Font.SANSSERIFBOLDITALIC
    },
    {
        interval: ['0030', '0039'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.NORMAL
    },
    {
        interval: ['2070', '2079'],
        base: alphabet_Base.DIGIT,
        subst: { 2071: '00B9', 2072: '00B2', 2073: '00B3' },
        offset: 0,
        category: 'No',
        font: Embellish.SUPER
    },
    {
        interval: ['2080', '2089'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'No',
        font: Embellish.SUB
    },
    {
        interval: ['245F', '2473'],
        base: alphabet_Base.DIGIT,
        subst: { '245F': '24EA' },
        offset: 0,
        category: 'No',
        font: Embellish.CIRCLED
    },
    {
        interval: ['3251', '325F'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 21,
        category: 'No',
        font: Embellish.CIRCLED
    },
    {
        interval: ['32B1', '32BF'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 36,
        category: 'No',
        font: Embellish.CIRCLED
    },
    {
        interval: ['2474', '2487'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 1,
        category: 'No',
        font: Embellish.PARENTHESIZED
    },
    {
        interval: ['2487', '249B'],
        base: alphabet_Base.DIGIT,
        subst: { 2487: '1F100' },
        offset: 0,
        category: 'No',
        font: Embellish.PERIOD
    },
    {
        interval: ['2775', '277F'],
        base: alphabet_Base.DIGIT,
        subst: { 2775: '24FF' },
        offset: 0,
        category: 'No',
        font: Embellish.NEGATIVECIRCLED
    },
    {
        interval: ['24EB', '24F4'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 11,
        category: 'No',
        font: Embellish.NEGATIVECIRCLED
    },
    {
        interval: ['24F5', '24FE'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 1,
        category: 'No',
        font: Embellish.DOUBLECIRCLED
    },
    {
        interval: ['277F', '2789'],
        base: alphabet_Base.DIGIT,
        subst: { '277F': '1F10B' },
        offset: 0,
        category: 'No',
        font: Embellish.CIRCLEDSANSSERIF
    },
    {
        interval: ['2789', '2793'],
        base: alphabet_Base.DIGIT,
        subst: { 2789: '1F10C' },
        offset: 0,
        category: 'No',
        font: Embellish.NEGATIVECIRCLEDSANSSERIF
    },
    {
        interval: ['FF10', 'FF19'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.FULLWIDTH
    },
    {
        interval: ['1D7CE', '1D7D7'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.BOLD
    },
    {
        interval: ['1D7D8', '1D7E1'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.DOUBLESTRUCK
    },
    {
        interval: ['1D7E2', '1D7EB'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.SANSSERIF
    },
    {
        interval: ['1D7EC', '1D7F5'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.SANSSERIFBOLD
    },
    {
        interval: ['1D7F6', '1D7FF'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'Nd',
        font: alphabet_Font.MONOSPACE
    },
    {
        interval: ['1F101', '1F10A'],
        base: alphabet_Base.DIGIT,
        subst: {},
        offset: 0,
        category: 'No',
        font: Embellish.COMMA
    },
    {
        interval: ['24B6', '24CF'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'So',
        font: Embellish.CIRCLED
    },
    {
        interval: ['24D0', '24E9'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'So',
        font: Embellish.CIRCLED
    },
    {
        interval: ['1F110', '1F129'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'So',
        font: Embellish.PARENTHESIZED
    },
    {
        interval: ['249C', '24B5'],
        base: alphabet_Base.LATINSMALL,
        subst: {},
        capital: false,
        category: 'So',
        font: Embellish.PARENTHESIZED
    },
    {
        interval: ['1F130', '1F149'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'So',
        font: Embellish.SQUARED
    },
    {
        interval: ['1F170', '1F189'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'So',
        font: Embellish.NEGATIVESQUARED
    },
    {
        interval: ['1F150', '1F169'],
        base: alphabet_Base.LATINCAP,
        subst: {},
        capital: true,
        category: 'So',
        font: Embellish.NEGATIVECIRCLED
    }
];
const INTERVALS = new Map();
function alphabetName(base, font) {
    const capFont = font
        .split('-')
        .map((x) => x[0].toUpperCase() + x.slice(1))
        .join('');
    return base + capFont;
}
for (const proto of PROTO_INTERVALS) {
    const key = alphabetName(proto.base, proto.font);
    const interval = makeCharInterval(proto.interval, proto.subst);
    let alphabet = INTERVALS.get(key);
    if (alphabet) {
        alphabet.unicode = alphabet.unicode.concat(interval);
        continue;
    }
    alphabet = proto;
    alphabet.unicode = interval;
    INTERVALS.set(key, alphabet);
}
//# sourceMappingURL=alphabet.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_meaning.js

var Types;
(function (Types) {
    Types["PUNCTUATION"] = "punctuation";
    Types["FENCE"] = "fence";
    Types["NUMBER"] = "number";
    Types["IDENTIFIER"] = "identifier";
    Types["TEXT"] = "text";
    Types["OPERATOR"] = "operator";
    Types["RELATION"] = "relation";
    Types["LARGEOP"] = "largeop";
    Types["FUNCTION"] = "function";
    Types["ACCENT"] = "accent";
    Types["FENCED"] = "fenced";
    Types["FRACTION"] = "fraction";
    Types["PUNCTUATED"] = "punctuated";
    Types["RELSEQ"] = "relseq";
    Types["MULTIREL"] = "multirel";
    Types["INFIXOP"] = "infixop";
    Types["PREFIXOP"] = "prefixop";
    Types["POSTFIXOP"] = "postfixop";
    Types["APPL"] = "appl";
    Types["INTEGRAL"] = "integral";
    Types["BIGOP"] = "bigop";
    Types["SQRT"] = "sqrt";
    Types["ROOT"] = "root";
    Types["LIMUPPER"] = "limupper";
    Types["LIMLOWER"] = "limlower";
    Types["LIMBOTH"] = "limboth";
    Types["SUBSCRIPT"] = "subscript";
    Types["SUPERSCRIPT"] = "superscript";
    Types["UNDERSCORE"] = "underscore";
    Types["OVERSCORE"] = "overscore";
    Types["TENSOR"] = "tensor";
    Types["TABLE"] = "table";
    Types["MULTILINE"] = "multiline";
    Types["MATRIX"] = "matrix";
    Types["VECTOR"] = "vector";
    Types["CASES"] = "cases";
    Types["ROW"] = "row";
    Types["LINE"] = "line";
    Types["CELL"] = "cell";
    Types["ENCLOSE"] = "enclose";
    Types["INFERENCE"] = "inference";
    Types["RULELABEL"] = "rulelabel";
    Types["CONCLUSION"] = "conclusion";
    Types["PREMISES"] = "premises";
    Types["UNKNOWN"] = "unknown";
    Types["EMPTY"] = "empty";
})(Types || (Types = {}));
const semantic_meaning_SemanticType = Object.assign({}, Types);
var Roles;
(function (Roles) {
    Roles["COMMA"] = "comma";
    Roles["SEMICOLON"] = "semicolon";
    Roles["ELLIPSIS"] = "ellipsis";
    Roles["FULLSTOP"] = "fullstop";
    Roles["QUESTION"] = "question";
    Roles["EXCLAMATION"] = "exclamation";
    Roles["QUOTES"] = "quotes";
    Roles["DASH"] = "dash";
    Roles["TILDE"] = "tilde";
    Roles["PRIME"] = "prime";
    Roles["DEGREE"] = "degree";
    Roles["VBAR"] = "vbar";
    Roles["COLON"] = "colon";
    Roles["OPENFENCE"] = "openfence";
    Roles["CLOSEFENCE"] = "closefence";
    Roles["APPLICATION"] = "application";
    Roles["DUMMY"] = "dummy";
    Roles["UNIT"] = "unit";
    Roles["LABEL"] = "label";
    Roles["OPEN"] = "open";
    Roles["CLOSE"] = "close";
    Roles["TOP"] = "top";
    Roles["BOTTOM"] = "bottom";
    Roles["NEUTRAL"] = "neutral";
    Roles["METRIC"] = "metric";
    Roles["LATINLETTER"] = "latinletter";
    Roles["GREEKLETTER"] = "greekletter";
    Roles["OTHERLETTER"] = "otherletter";
    Roles["NUMBERSET"] = "numbersetletter";
    Roles["INTEGER"] = "integer";
    Roles["FLOAT"] = "float";
    Roles["OTHERNUMBER"] = "othernumber";
    Roles["INFTY"] = "infty";
    Roles["MIXED"] = "mixed";
    Roles["MULTIACCENT"] = "multiaccent";
    Roles["OVERACCENT"] = "overaccent";
    Roles["UNDERACCENT"] = "underaccent";
    Roles["UNDEROVER"] = "underover";
    Roles["SUBSUP"] = "subsup";
    Roles["LEFTSUB"] = "leftsub";
    Roles["LEFTSUPER"] = "leftsuper";
    Roles["RIGHTSUB"] = "rightsub";
    Roles["RIGHTSUPER"] = "rightsuper";
    Roles["LEFTRIGHT"] = "leftright";
    Roles["ABOVEBELOW"] = "abovebelow";
    Roles["INTERVAL"] = "interval";
    Roles["SETEMPTY"] = "set empty";
    Roles["SETEXT"] = "set extended";
    Roles["SETSINGLE"] = "set singleton";
    Roles["SETCOLLECT"] = "set collection";
    Roles["STRING"] = "string";
    Roles["SPACE"] = "space";
    Roles["ANNOTATION"] = "annotation";
    Roles["TEXT"] = "text";
    Roles["SEQUENCE"] = "sequence";
    Roles["ENDPUNCT"] = "endpunct";
    Roles["STARTPUNCT"] = "startpunct";
    Roles["NEGATIVE"] = "negative";
    Roles["POSITIVE"] = "positive";
    Roles["NEGATION"] = "negation";
    Roles["MULTIOP"] = "multiop";
    Roles["PREFIXOP"] = "prefix operator";
    Roles["POSTFIXOP"] = "postfix operator";
    Roles["LIMFUNC"] = "limit function";
    Roles["INFIXFUNC"] = "infix function";
    Roles["PREFIXFUNC"] = "prefix function";
    Roles["POSTFIXFUNC"] = "postfix function";
    Roles["SIMPLEFUNC"] = "simple function";
    Roles["COMPFUNC"] = "composed function";
    Roles["SUM"] = "sum";
    Roles["INTEGRAL"] = "integral";
    Roles["GEOMETRY"] = "geometry";
    Roles["BOX"] = "box";
    Roles["BLOCK"] = "block";
    Roles["ADDITION"] = "addition";
    Roles["MULTIPLICATION"] = "multiplication";
    Roles["SUBTRACTION"] = "subtraction";
    Roles["IMPLICIT"] = "implicit";
    Roles["DIVISION"] = "division";
    Roles["VULGAR"] = "vulgar";
    Roles["EQUALITY"] = "equality";
    Roles["INEQUALITY"] = "inequality";
    Roles["ARROW"] = "arrow";
    Roles["ELEMENT"] = "element";
    Roles["NONELEMENT"] = "nonelement";
    Roles["REELEMENT"] = "reelement";
    Roles["RENONELEMENT"] = "renonelement";
    Roles["SET"] = "set";
    Roles["DETERMINANT"] = "determinant";
    Roles["ROWVECTOR"] = "rowvector";
    Roles["BINOMIAL"] = "binomial";
    Roles["SQUAREMATRIX"] = "squarematrix";
    Roles["CYCLE"] = "cycle";
    Roles["MULTILINE"] = "multiline";
    Roles["MATRIX"] = "matrix";
    Roles["VECTOR"] = "vector";
    Roles["CASES"] = "cases";
    Roles["TABLE"] = "table";
    Roles["CAYLEY"] = "cayley";
    Roles["PROOF"] = "proof";
    Roles["LEFT"] = "left";
    Roles["RIGHT"] = "right";
    Roles["UP"] = "up";
    Roles["DOWN"] = "down";
    Roles["FINAL"] = "final";
    Roles["SINGLE"] = "single";
    Roles["HYP"] = "hyp";
    Roles["AXIOM"] = "axiom";
    Roles["LOGIC"] = "logic";
    Roles["UNKNOWN"] = "unknown";
    Roles["MGLYPH"] = "mglyph";
})(Roles || (Roles = {}));
const semantic_meaning_SemanticRole = Object.assign({}, Roles);
var ExtraFont;
(function (ExtraFont) {
    ExtraFont["CALIGRAPHIC"] = "caligraphic";
    ExtraFont["CALIGRAPHICBOLD"] = "caligraphic-bold";
    ExtraFont["OLDSTYLE"] = "oldstyle";
    ExtraFont["OLDSTYLEBOLD"] = "oldstyle-bold";
    ExtraFont["UNKNOWN"] = "unknown";
})(ExtraFont || (ExtraFont = {}));
const SemanticFont = Object.assign(Object.assign(Object.assign({}, alphabet_Font), ExtraFont), Embellish);
var SecondaryEnum;
(function (SecondaryEnum) {
    SecondaryEnum["ALLLETTERS"] = "allLetters";
    SecondaryEnum["D"] = "d";
    SecondaryEnum["BAR"] = "bar";
    SecondaryEnum["TILDE"] = "tilde";
})(SecondaryEnum || (SecondaryEnum = {}));
const SemanticSecondary = Object.assign(Object.assign({}, alphabet_Base), SecondaryEnum);
//# sourceMappingURL=semantic_meaning.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_attr.js
var semantic_attr_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const NamedSymbol = {
    functionApplication: String.fromCodePoint(0x2061),
    invisibleTimes: String.fromCodePoint(0x2062),
    invisibleComma: String.fromCodePoint(0x2063),
    invisiblePlus: String.fromCodePoint(0x2064)
};
class meaningMap extends Map {
    get(symbol) {
        return (super.get(symbol) || {
            role: semantic_meaning_SemanticRole.UNKNOWN,
            type: semantic_meaning_SemanticType.UNKNOWN,
            font: SemanticFont.UNKNOWN
        });
    }
}
class secondaryMap extends Map {
    set(char, kind, annotation = '') {
        super.set(this.secKey(kind, char), annotation || kind);
        return this;
    }
    has(char, kind) {
        return super.has(this.secKey(kind, char));
    }
    get(char, kind) {
        return super.get(this.secKey(kind, char));
    }
    secKey(kind, char) {
        return char ? `${kind} ${char}` : `${kind}`;
    }
}
const SemanticMap = {
    Meaning: new meaningMap(),
    Secondary: new secondaryMap(),
    FencesHoriz: new Map(),
    FencesVert: new Map(),
    LatexCommands: new Map()
};
function addMeaning(symbols, meaning) {
    for (const symbol of symbols) {
        SemanticMap.Meaning.set(symbol, {
            role: meaning.role || semantic_meaning_SemanticRole.UNKNOWN,
            type: meaning.type || semantic_meaning_SemanticType.UNKNOWN,
            font: meaning.font || SemanticFont.UNKNOWN
        });
        if (meaning.secondary) {
            SemanticMap.Secondary.set(symbol, meaning.secondary);
        }
    }
}
function initMeaning() {
    const sets = [
        {
            set: [
                '23',
                '26',
                '40',
                '5c',
                'a1',
                'a7',
                'b6',
                'bf',
                '2017',
                ['2022', '2025'],
                '2027',
                '203b',
                '203c',
                ['2041', '2043'],
                ['2047', '2049'],
                ['204b', '204d'],
                '2050',
                '2055',
                '2056',
                ['2058', '205e'],
                '2234',
                '2235',
                'fe45',
                'fe46',
                'fe5f',
                'fe60',
                'fe68',
                'fe6b',
                'ff03',
                'ff06',
                'ff0f',
                'ff20',
                'ff3c'
            ],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.UNKNOWN
        },
        {
            set: [
                '22',
                'ab',
                'bb',
                '2dd',
                ['2018', '201f'],
                '2039',
                '203a',
                ['301d', '301f'],
                'fe10',
                'ff02',
                'ff07'
            ],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.QUOTES
        },
        {
            set: ['3b', '204f', '2a1f', '2a3e', 'fe14', 'fe54', 'ff1b'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.SEMICOLON
        },
        {
            set: ['3f', '203d', 'fe16', 'fe56', 'ff1f'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.QUESTION
        },
        {
            set: ['21', 'fe15', 'fe57', 'ff01'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.EXCLAMATION
        },
        {
            set: [
                '5e',
                '60',
                'a8',
                'aa',
                'b4',
                'ba',
                '2c7',
                ['2d8', '2da'],
                '2040',
                '207a',
                '207d',
                '207e',
                'ff3e',
                'ff40'
            ],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.OVERACCENT
        },
        {
            set: ['b8', '2db', '2038', '203f', '2054', '208a', '208d', '208e'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.UNDERACCENT
        },
        {
            set: ['3a', '2982', 'fe13', 'fe30', 'fe55', 'ff1a'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.COLON
        },
        {
            set: ['2c', '2063', 'fe50', 'ff0c'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.COMMA
        },
        {
            set: ['2026', ['22ee', '22f1'], 'fe19'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.ELLIPSIS
        },
        {
            set: ['2e', 'fe52', 'ff0e'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.FULLSTOP
        },
        {
            set: ['2d', '207b', '208b', '2212', '2796', 'fe63', 'ff0d'],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.DASH,
            secondary: SemanticSecondary.BAR
        },
        {
            set: [
                '5f',
                'af',
                ['2010', '2015'],
                '203e',
                '208b',
                ['fe49', 'fe4f'],
                'fe58',
                'ff3f',
                'ffe3'
            ],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.DASH,
            secondary: SemanticSecondary.BAR
        },
        {
            set: [
                '7e',
                '2dc',
                '2f7',
                '303',
                '330',
                '334',
                '2053',
                '223c',
                '223d',
                '301c',
                'ff5e'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.TILDE,
            secondary: SemanticSecondary.TILDE
        },
        {
            set: ['27', '2b9', '2ba', ['2032', '2037'], '2057'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.PRIME
        },
        {
            set: ['b0'],
            type: semantic_meaning_SemanticType.PUNCTUATION,
            role: semantic_meaning_SemanticRole.DEGREE
        },
        {
            set: [
                '2b',
                'b1',
                '2064',
                '2213',
                '2214',
                '2228',
                '222a',
                ['228c', '228e'],
                '2294',
                '2295',
                '229d',
                '229e',
                '22bb',
                '22bd',
                '22c4',
                '22ce',
                '22d3',
                '2304',
                '271b',
                '271c',
                '2795',
                '27cf',
                '29fa',
                '29fb',
                '29fe',
                ['2a22', '2a28'],
                '2a2d',
                '2a2e',
                '2a39',
                '2a42',
                '2a45',
                '2a46',
                '2a48',
                '2a4a',
                '2a4c',
                '2a4f',
                '2a50',
                '2a52',
                '2a54',
                '2a56',
                '2a57',
                '2a59',
                '2a5b',
                '2a5d',
                ['2a61', '2a63'],
                '2adc',
                '2add',
                'fe62',
                'ff0b'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.ADDITION
        },
        {
            set: [
                '2a',
                'b7',
                'd7',
                '2020',
                '2021',
                '204e',
                '2051',
                '2062',
                ['2217', '2219'],
                '2227',
                '2229',
                '2240',
                '2293',
                '2297',
                ['2299', '229b'],
                '22a0',
                '22a1',
                '22b9',
                '22bc',
                ['22c5', '22cc'],
                '22cf',
                '22d2',
                '22d4',
                '2303',
                '2305',
                '2306',
                '25cb',
                '2715',
                '2716',
                '27ce',
                '27d1',
                ['29d1', '29d7'],
                '29e2',
                '2a1d',
                ['2a2f', '2a37'],
                ['2a3b', '2a3d'],
                '2a40',
                '2a43',
                '2a44',
                '2a47',
                '2a49',
                '2a4b',
                '2a4d',
                '2a4e',
                '2a51',
                '2a53',
                '2a55',
                '2a58',
                '2a5a',
                '2a5c',
                ['2a5e', '2a60'],
                '2ada',
                '2adb',
                'fe61',
                'ff0a'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.MULTIPLICATION
        },
        {
            set: [
                '2d',
                'af',
                '2010',
                '2011',
                '2052',
                '207b',
                '208b',
                '2212',
                '2216',
                '2238',
                '2242',
                '2296',
                '229f',
                '2796',
                '29ff',
                ['2a29', '2a2c'],
                '2a3a',
                '2a41',
                'fe63',
                'ff0d'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.SUBTRACTION
        },
        {
            set: [
                '2f',
                'f7',
                '2044',
                '2215',
                '2298',
                '2797',
                '27cc',
                '29bc',
                ['29f5', '29f9'],
                '2a38'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.DIVISION
        },
        {
            set: ['25', '2030', '2031', 'ff05', 'fe6a'],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.POSTFIXOP
        },
        {
            set: [
                'ac',
                '2200',
                '2201',
                '2203',
                '2204',
                '2206',
                ['221a', '221c'],
                '2310',
                'ffe2'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.PREFIXOP
        },
        {
            set: [
                '2320',
                '2321',
                '23aa',
                '23ae',
                '23af',
                '23b2',
                '23b3',
                '23b6',
                '23b7'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.PREFIXOP
        },
        {
            set: ['1d7ca', '1d7cb'],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.PREFIXOP,
            font: SemanticFont.BOLD
        },
        {
            set: [
                '3d',
                '7e',
                '207c',
                '208c',
                '221d',
                '2237',
                ['223a', '223f'],
                '2243',
                '2245',
                '2248',
                ['224a', '224e'],
                ['2251', '225f'],
                '2261',
                '2263',
                '229c',
                '22cd',
                '22d5',
                '29e4',
                '29e6',
                '2a66',
                '2a67',
                ['2a6a', '2a6c'],
                ['2a6c', '2a78'],
                'fe66',
                'ff1d'
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.EQUALITY
        },
        {
            set: [
                '3c',
                '3e',
                '2241',
                '2242',
                '2244',
                '2246',
                '2247',
                '2249',
                '224f',
                '2250',
                '2260',
                '2262',
                ['2264', '2281'],
                '22b0',
                '22b1',
                ['22d6', '22e1'],
                ['22e6', '22e9'],
                ['2976', '2978'],
                '29c0',
                '29c1',
                '29e1',
                '29e3',
                '29e5',
                ['2a79', '2abc'],
                ['2af7', '2afa'],
                'fe64',
                'fe65',
                'ff1c',
                'ff1e'
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.INEQUALITY
        },
        {
            set: [
                ['2282', '228b'],
                ['228f', '2292'],
                ['22b2', '22b8'],
                '22d0',
                '22d1',
                ['22e2', '22e5'],
                ['22ea', '22ed'],
                '27c3',
                '27c4',
                ['27c7', '27c9'],
                ['27d5', '27d7'],
                '27dc',
                ['2979', '297b'],
                '29df',
                ['2abd', '2ad8']
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.SET
        },
        {
            set: [
                '2236',
                ['27e0', '27e5'],
                '292b',
                '292c',
                ['29b5', '29bb'],
                '29be',
                '29bf',
                ['29c2', '29d0']
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.UNKNOWN
        },
        {
            set: ['2205', ['29b0', '29b4']],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.SETEMPTY
        },
        {
            set: ['1ab2', '221e', ['29dc', '29de']],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.INFTY
        },
        {
            set: [
                '22a2',
                '22a3',
                ['22a6', '22af'],
                '27da',
                '27db',
                '27dd',
                '27de',
                '2ade',
                ['2ae2', '2ae6'],
                '2aec',
                '2aed'
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.LOGIC
        },
        {
            set: [
                '22a4',
                '22a5',
                '22ba',
                '27d8',
                '27d9',
                '27df',
                '2adf',
                '2ae0',
                ['2ae7', '2aeb'],
                '2af1'
            ],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.LOGIC
        },
        {
            set: [
                ['2190', '21ff'],
                '2301',
                '2324',
                '238b',
                '2794',
                ['2798', '27af'],
                ['27b1', '27be'],
                ['27f0', '27ff'],
                ['2900', '292a'],
                ['292d', '2975'],
                ['297c', '297f'],
                ['2b00', '2b11'],
                ['2b30', '2b4c'],
                ['ffe9', 'ffec']
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.ARROW
        },
        {
            set: ['2208', '220a', ['22f2', '22f9'], '22ff', '27d2', '2ad9'],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.ELEMENT
        },
        {
            set: ['2209'],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.NONELEMENT
        },
        {
            set: ['220b', '220d', ['22fa', '22fe']],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.REELEMENT
        },
        {
            set: ['220c'],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.RENONELEMENT
        },
        {
            set: [
                ['220f', '2211'],
                ['22c0', '22c3'],
                ['2a00', '2a0b'],
                '2a3f',
                '2afc',
                '2aff'
            ],
            type: semantic_meaning_SemanticType.LARGEOP,
            role: semantic_meaning_SemanticRole.SUM
        },
        {
            set: ['2140'],
            type: semantic_meaning_SemanticType.LARGEOP,
            role: semantic_meaning_SemanticRole.SUM,
            font: SemanticFont.DOUBLESTRUCK
        },
        {
            set: [
                ['222b', '2233'],
                ['2a0c', '2a17'],
                ['2a17', '2a1c']
            ],
            type: semantic_meaning_SemanticType.LARGEOP,
            role: semantic_meaning_SemanticRole.INTEGRAL
        },
        {
            set: [['2500', '257F']],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.BOX
        },
        {
            set: [['2580', '259F']],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.BLOCK
        },
        {
            set: [
                ['25A0', '25FF'],
                ['2B12', '2B2F'],
                ['2B50', '2B59']
            ],
            type: semantic_meaning_SemanticType.RELATION,
            role: semantic_meaning_SemanticRole.GEOMETRY
        },
        {
            set: [
                '220e',
                '2300',
                '2302',
                '2311',
                '29bd',
                '29e0',
                ['29e8', '29f3'],
                '2a1e',
                '2afe',
                'ffed',
                'ffee'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.GEOMETRY
        },
        {
            set: [
                ['221f', '2222'],
                '22be',
                '22bf',
                ['2312', '2314'],
                '237c',
                '27c0',
                ['299b', '29af']
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.GEOMETRY
        },
        {
            set: [
                '24',
                ['a2', 'a5'],
                'b5',
                '2123',
                ['2125', '2127'],
                '212a',
                '212b',
                'fe69',
                'ff04',
                'ffe0',
                'ffe1',
                'ffe5',
                'ffe6'
            ],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.UNKNOWN
        },
        {
            set: [
                'a9',
                'ae',
                '210f',
                '2114',
                '2116',
                '2117',
                ['211e', '2122'],
                '212e',
                '2132',
                ['2139', '213b'],
                ['2141', '2144'],
                '214d',
                '214e',
                ['1f12a', '1f12c'],
                '1f18a'
            ],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.OTHERLETTER
        },
        {
            set: [
                '2224',
                '2226',
                '2239',
                '2307',
                '27b0',
                '27bf',
                '27c1',
                '27c2',
                '27ca',
                '27cb',
                '27cd',
                '27d0',
                '27d3',
                '27d4',
                '2981',
                '2999',
                '299a',
                '29e7',
                '29f4',
                '2a20',
                '2a21',
                '2a64',
                '2a65',
                '2a68',
                '2a69',
                '2ae1',
                ['2aee', '2af0'],
                '2af2',
                '2af3',
                '2af5',
                '2af6',
                '2afb',
                '2afd'
            ],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.UNKNOWN
        },
        {
            set: ['2605', '2606', '26aa', '26ab', ['2720', '274d']],
            type: semantic_meaning_SemanticType.OPERATOR,
            role: semantic_meaning_SemanticRole.UNKNOWN
        },
        {
            set: [['2145', '2149']],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.LATINLETTER,
            font: SemanticFont.DOUBLESTRUCKITALIC,
            secondary: SemanticSecondary.ALLLETTERS
        },
        {
            set: [['213c', '213f']],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.GREEKLETTER,
            font: SemanticFont.DOUBLESTRUCK,
            secondary: SemanticSecondary.ALLLETTERS
        },
        {
            set: [
                '3d0',
                '3d7',
                '3f6',
                ['1d26', '1d2a'],
                '1d5e',
                '1d60',
                ['1d66', '1d6a']
            ],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.GREEKLETTER,
            font: SemanticFont.NORMAL,
            secondary: SemanticSecondary.ALLLETTERS
        },
        {
            set: [['2135', '2138']],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.OTHERLETTER,
            font: SemanticFont.NORMAL,
            secondary: SemanticSecondary.ALLLETTERS
        },
        {
            set: ['131', '237'],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.LATINLETTER,
            font: SemanticFont.NORMAL
        },
        {
            set: ['1d6a4', '1d6a5'],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.LATINLETTER,
            font: SemanticFont.ITALIC
        },
        {
            set: ['2113', '2118'],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.LATINLETTER,
            font: SemanticFont.SCRIPT
        },
        {
            set: [
                ['c0', 'd6'],
                ['d8', 'f6'],
                ['f8', '1bf'],
                ['1c4', '2af'],
                ['1d00', '1d25'],
                ['1d6b', '1d9a'],
                ['1e00', '1ef9'],
                ['363', '36f'],
                ['1dd3', '1de6'],
                ['1d62', '1d65'],
                '1dca',
                '2071',
                '207f',
                ['2090', '209c'],
                '2c7c'
            ],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.LATINLETTER,
            font: SemanticFont.NORMAL
        },
        {
            set: [['00bc', '00be'], ['2150', '215f'], '2189'],
            type: semantic_meaning_SemanticType.NUMBER,
            role: semantic_meaning_SemanticRole.FLOAT
        },
        {
            set: ['23E8', ['3248', '324f']],
            type: semantic_meaning_SemanticType.NUMBER,
            role: semantic_meaning_SemanticRole.INTEGER
        },
        {
            set: [['214A', '214C'], '2705', '2713', '2714', '2717', '2718'],
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.UNKNOWN
        },
        {
            set: [
                '20',
                'a0',
                'ad',
                ['2000', '200f'],
                ['2028', '202f'],
                ['205f', '2060'],
                '206a',
                '206b',
                '206e',
                '206f',
                'feff',
                ['fff9', 'fffb']
            ],
            type: semantic_meaning_SemanticType.TEXT,
            role: semantic_meaning_SemanticRole.SPACE
        },
        {
            set: [
                '7c',
                'a6',
                '2223',
                '23b8',
                '23b9',
                '23d0',
                '2758',
                ['fe31', 'fe34'],
                'ff5c',
                'ffe4',
                'ffe8'
            ],
            type: semantic_meaning_SemanticType.FENCE,
            role: semantic_meaning_SemanticRole.NEUTRAL
        },
        {
            set: ['2016', '2225', '2980', '2af4'],
            type: semantic_meaning_SemanticType.FENCE,
            role: semantic_meaning_SemanticRole.METRIC
        }
    ];
    sets.forEach((_a) => {
        var { set: s } = _a, m = semantic_attr_rest(_a, ["set"]);
        return addMeaning(makeMultiInterval(s), m);
    });
}
function addFences(map, ints, sep = 1) {
    const used = {};
    const codes = makeCodeInterval(ints);
    for (const code of codes) {
        if (used[code])
            continue;
        map.set(String.fromCodePoint(code), String.fromCodePoint(code + sep));
        used[code] = true;
        used[code + sep] = true;
    }
}
function initFences() {
    addFences(SemanticMap.FencesVert, [
        '23b4',
        ['23dc', '23e1'],
        ['fe35', 'fe44'],
        'fe47'
    ]);
    addFences(SemanticMap.FencesHoriz, [
        '28',
        '2045',
        '207D',
        '208D',
        ['2308', '230f'],
        ['231c', '231f'],
        '2329',
        '23b0',
        ['2768', '2775'],
        '27c5',
        ['27e6', '27ef'],
        ['2983', '2998'],
        ['29d8', '29db'],
        '29fc',
        ['2e22', '2e29'],
        ['3008', '3011'],
        ['3014', '301b'],
        'fd3e',
        'fe17',
        ['fe59', 'fe5e'],
        'ff08',
        'ff5f',
        'ff62'
    ]);
    addFences(SemanticMap.FencesHoriz, ['5b', '7b', 'ff3b', 'ff5b'], 2);
    addFences(SemanticMap.FencesHoriz, [['239b', '23a6']], 3);
    addFences(SemanticMap.FencesHoriz, [['23a7', '23a9']], 4);
    addMeaning([...SemanticMap.FencesHoriz.keys()], {
        type: semantic_meaning_SemanticType.FENCE,
        role: semantic_meaning_SemanticRole.OPEN
    });
    addMeaning([...SemanticMap.FencesHoriz.values()], {
        type: semantic_meaning_SemanticType.FENCE,
        role: semantic_meaning_SemanticRole.CLOSE
    });
    addMeaning([...SemanticMap.FencesVert.keys()], {
        type: semantic_meaning_SemanticType.FENCE,
        role: semantic_meaning_SemanticRole.TOP
    });
    addMeaning([...SemanticMap.FencesVert.values()], {
        type: semantic_meaning_SemanticType.FENCE,
        role: semantic_meaning_SemanticRole.BOTTOM
    });
}
const trigonometricFunctions = [
    'cos',
    'cot',
    'csc',
    'sec',
    'sin',
    'tan',
    'arccos',
    'arccot',
    'arccsc',
    'arcsec',
    'arcsin',
    'arctan'
];
const hyperbolicFunctions = [
    'cosh',
    'coth',
    'csch',
    'sech',
    'sinh',
    'tanh',
    'arcosh',
    'arcoth',
    'arcsch',
    'arsech',
    'arsinh',
    'artanh'
];
const algebraicFunctions = ['deg', 'det', 'dim', 'hom', 'ker', 'Tr'];
const elementaryFunctions = [
    'log',
    'ln',
    'lg',
    'exp',
    'gcd',
    'lcm',
    'arg',
    'im',
    're',
    'Pr'
];
const prefixFunctions = trigonometricFunctions.concat(hyperbolicFunctions, algebraicFunctions, elementaryFunctions);
function initFunctions() {
    addMeaning([
        'inf',
        'lim',
        'liminf',
        'limsup',
        'max',
        'min',
        'sup',
        'injlim',
        'projlim'
    ], {
        type: semantic_meaning_SemanticType.FUNCTION,
        role: semantic_meaning_SemanticRole.LIMFUNC
    });
    addMeaning(prefixFunctions, {
        type: semantic_meaning_SemanticType.FUNCTION,
        role: semantic_meaning_SemanticRole.PREFIXFUNC
    });
    addMeaning(['mod', 'rem'], {
        type: semantic_meaning_SemanticType.OPERATOR,
        role: semantic_meaning_SemanticRole.PREFIXFUNC
    });
}
function addFunctionSemantic(base, names) {
    const meaning = SemanticMap.Meaning.get(base) || {
        type: SemanticType.FUNCTION,
        role: SemanticRole.PREFIXFUNC
    };
    addMeaning(names, meaning);
}
function equal(meaning1, meaning2) {
    return (meaning1.type === meaning2.type &&
        meaning1.role === meaning2.role &&
        meaning1.font === meaning2.font);
}
function isMatchingFence(open, close) {
    const meaning = SemanticMap.Meaning.get(open);
    if (meaning.type !== SemanticType.FENCE) {
        return false;
    }
    if (meaning.role === SemanticRole.NEUTRAL ||
        meaning.role === SemanticRole.METRIC) {
        return open === close;
    }
    return (SemanticMap.FencesHoriz.get(open) === close ||
        SemanticMap.FencesVert.get(open) === close);
}
function changeSemantics(alphabet, change) {
    for (const [pos, meaning] of Object.entries(change)) {
        const character = alphabet[pos];
        if (character !== undefined) {
            SemanticMap.Meaning.set(character, meaning);
        }
    }
}
function addSecondaries(alphabet, change) {
    for (const [pos, meaning] of Object.entries(change)) {
        const character = alphabet[pos];
        if (character !== undefined) {
            SemanticMap.Secondary.set(character, meaning);
        }
    }
}
function singleAlphabet(alphabet, type, role, font, semfont, secondaries = [], change = {}, secondary = {}) {
    const interval = INTERVALS.get(alphabetName(alphabet, font));
    if (interval) {
        interval.unicode.forEach((x) => {
            SemanticMap.Meaning.set(x, {
                type: type,
                role: role,
                font: semfont
            });
            secondaries.forEach((sec) => SemanticMap.Secondary.set(x, sec));
        });
        changeSemantics(interval.unicode, change);
        addSecondaries(interval.unicode, secondary);
    }
}
function initAlphabets() {
    for (const [name, font] of Object.entries(SemanticFont)) {
        const emb = !!Embellish[name];
        const semfont = emb
            ? SemanticFont.UNKNOWN
            : font === SemanticFont.FULLWIDTH
                ? SemanticFont.NORMAL
                : font;
        singleAlphabet(alphabet_Base.LATINCAP, semantic_meaning_SemanticType.IDENTIFIER, semantic_meaning_SemanticRole.LATINLETTER, font, semfont, [SemanticSecondary.ALLLETTERS]);
        singleAlphabet(alphabet_Base.LATINSMALL, semantic_meaning_SemanticType.IDENTIFIER, semantic_meaning_SemanticRole.LATINLETTER, font, semfont, [SemanticSecondary.ALLLETTERS], {}, { 3: SemanticSecondary.D });
        singleAlphabet(alphabet_Base.GREEKCAP, semantic_meaning_SemanticType.IDENTIFIER, semantic_meaning_SemanticRole.GREEKLETTER, font, semfont, [SemanticSecondary.ALLLETTERS]);
        singleAlphabet(alphabet_Base.GREEKSMALL, semantic_meaning_SemanticType.IDENTIFIER, semantic_meaning_SemanticRole.GREEKLETTER, font, semfont, [SemanticSecondary.ALLLETTERS], {
            0: {
                type: semantic_meaning_SemanticType.OPERATOR,
                role: semantic_meaning_SemanticRole.PREFIXOP,
                font: semfont
            },
            26: {
                type: semantic_meaning_SemanticType.OPERATOR,
                role: semantic_meaning_SemanticRole.PREFIXOP,
                font: semfont
            }
        });
        singleAlphabet(alphabet_Base.DIGIT, semantic_meaning_SemanticType.NUMBER, semantic_meaning_SemanticRole.INTEGER, font, semfont);
    }
}
initMeaning();
initFences();
initAlphabets();
initFunctions();
//# sourceMappingURL=semantic_attr.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_ordering.js

const comparators = [];
function semantic_ordering_add(comparator) {
    comparators.push(comparator);
}
function apply(meaning1, meaning2) {
    for (let i = 0, comparator; (comparator = comparators[i]); i++) {
        const result = comparator.compare(meaning1, meaning2);
        if (result !== 0) {
            return result;
        }
    }
    return 0;
}
function sort(meanings) {
    meanings.sort(apply);
}
function reduce(meanings) {
    if (meanings.length <= 1) {
        return meanings;
    }
    const copy = meanings.slice();
    sort(copy);
    const result = [];
    let last;
    do {
        last = copy.pop();
        result.push(last);
    } while (last && copy.length && apply(copy[copy.length - 1], last) === 0);
    return result;
}
class SemanticComparator {
    constructor(comparator, type = null) {
        this.comparator = comparator;
        this.type = type;
        semantic_ordering_add(this);
    }
    compare(meaning1, meaning2) {
        return this.type &&
            this.type === meaning1.type &&
            this.type === meaning2.type
            ? this.comparator(meaning1, meaning2)
            : 0;
    }
}
function simpleFunction(meaning1, meaning2) {
    if (meaning1.role === semantic_meaning_SemanticRole.SIMPLEFUNC) {
        return 1;
    }
    if (meaning2.role === semantic_meaning_SemanticRole.SIMPLEFUNC) {
        return -1;
    }
    return 0;
}
new SemanticComparator(simpleFunction, semantic_meaning_SemanticType.IDENTIFIER);
//# sourceMappingURL=semantic_ordering.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_default.js


function key(symbol, font) {
    return symbol.match(/^.+:.+$/) || !font ? symbol : symbol + ':' + font;
}
class SemanticDefault extends Map {
    set(symbol, meaning) {
        super.set(key(symbol, meaning.font), meaning);
        return this;
    }
    setNode(node) {
        this.set(node.textContent, node.meaning());
    }
    get(symbol, font = null) {
        return super.get(key(symbol, font));
    }
    getNode(node) {
        return this.get(node.textContent, node.font);
    }
}
class SemanticCollator extends Map {
    add(symbol, entry) {
        const list = this.get(symbol);
        if (list) {
            list.push(entry);
        }
        else {
            super.set(symbol, [entry]);
        }
    }
    get(symbol, font = null) {
        return super.get(key(symbol, font));
    }
    getNode(node) {
        return this.get(node.textContent, node.font);
    }
    minimize() {
        for (const [key, entry] of this) {
            if (entry.length === 1) {
                this.delete(key);
            }
        }
    }
    isMultiValued() {
        for (const value of this.values()) {
            if (value.length > 1) {
                return true;
            }
        }
        return false;
    }
}
class SemanticNodeCollator extends SemanticCollator {
    add(symbol, entry) {
        super.add(key(symbol, entry.font), entry);
    }
    addNode(node) {
        this.add(node.textContent, node);
    }
    toString() {
        const outer = [];
        for (const [key, nodes] of this) {
            const length = Array(key.length + 3).join(' ');
            const inner = nodes.map((node) => node.toString()).join('\n' + length);
            outer.push(key + ': ' + inner);
        }
        return outer.join('\n');
    }
    collateMeaning() {
        const collator = new SemanticMeaningCollator();
        for (const [key, val] of this) {
            collator.set(key, val.map((node) => node.meaning()));
        }
        return collator;
    }
}
class SemanticMeaningCollator extends SemanticCollator {
    add(symbol, entry) {
        const list = this.get(symbol, entry.font);
        if (!list ||
            !list.find(function (x) {
                return equal(x, entry);
            })) {
            super.add(key(symbol, entry.font), entry);
        }
    }
    addNode(node) {
        this.add(node.textContent, node.meaning());
    }
    toString() {
        const outer = [];
        for (const [key, nodes] of this) {
            const length = Array(key.length + 3).join(' ');
            const inner = nodes
                .map((node) => `{type: ${node.type}, role: ${node.role}, font: ${node.font}}`)
                .join('\n' + length);
            outer.push(key + ': ' + inner);
        }
        return outer.join('\n');
    }
    reduce() {
        for (const [key, val] of this) {
            if (val.length !== 1) {
                this.set(key, reduce(val));
            }
        }
    }
    default() {
        const def = new SemanticDefault();
        for (const [key, val] of this) {
            if (val.length === 1) {
                def.set(key, val[0]);
            }
        }
        return def;
    }
    newDefault() {
        const oldDefault = this.default();
        this.reduce();
        const newDefault = this.default();
        return oldDefault.size !== newDefault.size ? newDefault : null;
    }
}
//# sourceMappingURL=semantic_default.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_util.js

var MMLTAGS;
(function (MMLTAGS) {
    MMLTAGS["ANNOTATION"] = "ANNOTATION";
    MMLTAGS["ANNOTATIONXML"] = "ANNOTATION-XML";
    MMLTAGS["MACTION"] = "MACTION";
    MMLTAGS["MALIGNGROUP"] = "MALIGNGROUP";
    MMLTAGS["MALIGNMARK"] = "MALIGNMARK";
    MMLTAGS["MATH"] = "MATH";
    MMLTAGS["MENCLOSE"] = "MENCLOSE";
    MMLTAGS["MERROR"] = "MERROR";
    MMLTAGS["MFENCED"] = "MFENCED";
    MMLTAGS["MFRAC"] = "MFRAC";
    MMLTAGS["MGLYPH"] = "MGLYPH";
    MMLTAGS["MI"] = "MI";
    MMLTAGS["MLABELEDTR"] = "MLABELEDTR";
    MMLTAGS["MMULTISCRIPTS"] = "MMULTISCRIPTS";
    MMLTAGS["MN"] = "MN";
    MMLTAGS["MO"] = "MO";
    MMLTAGS["MOVER"] = "MOVER";
    MMLTAGS["MPADDED"] = "MPADDED";
    MMLTAGS["MPHANTOM"] = "MPHANTOM";
    MMLTAGS["MPRESCRIPTS"] = "MPRESCRIPTS";
    MMLTAGS["MROOT"] = "MROOT";
    MMLTAGS["MROW"] = "MROW";
    MMLTAGS["MS"] = "MS";
    MMLTAGS["MSPACE"] = "MSPACE";
    MMLTAGS["MSQRT"] = "MSQRT";
    MMLTAGS["MSTYLE"] = "MSTYLE";
    MMLTAGS["MSUB"] = "MSUB";
    MMLTAGS["MSUBSUP"] = "MSUBSUP";
    MMLTAGS["MSUP"] = "MSUP";
    MMLTAGS["MTABLE"] = "MTABLE";
    MMLTAGS["MTD"] = "MTD";
    MMLTAGS["MTEXT"] = "MTEXT";
    MMLTAGS["MTR"] = "MTR";
    MMLTAGS["MUNDER"] = "MUNDER";
    MMLTAGS["MUNDEROVER"] = "MUNDEROVER";
    MMLTAGS["NONE"] = "NONE";
    MMLTAGS["SEMANTICS"] = "SEMANTICS";
})(MMLTAGS || (MMLTAGS = {}));
const ALLTAGS = Object.values(MMLTAGS);
const LEAFTAGS = [
    MMLTAGS.MO,
    MMLTAGS.MI,
    MMLTAGS.MN,
    MMLTAGS.MTEXT,
    MMLTAGS.MS,
    MMLTAGS.MSPACE
];
const IGNORETAGS = [
    MMLTAGS.MERROR,
    MMLTAGS.MPHANTOM,
    MMLTAGS.MALIGNGROUP,
    MMLTAGS.MALIGNMARK,
    MMLTAGS.MPRESCRIPTS,
    MMLTAGS.ANNOTATION,
    MMLTAGS.ANNOTATIONXML
];
const EMPTYTAGS = [
    MMLTAGS.MATH,
    MMLTAGS.MROW,
    MMLTAGS.MPADDED,
    MMLTAGS.MACTION,
    MMLTAGS.NONE,
    MMLTAGS.MSTYLE,
    MMLTAGS.SEMANTICS
];
const DISPLAYTAGS = [MMLTAGS.MROOT, MMLTAGS.MSQRT];
const directSpeechKeys = ['aria-label', 'exact-speech', 'alt'];
function hasMathTag(node) {
    return !!node && dom_util_tagName(node) === MMLTAGS.MATH;
}
function hasLeafTag(node) {
    return !!node && LEAFTAGS.includes(dom_util_tagName(node));
}
function hasIgnoreTag(node) {
    return (!!node &&
        (IGNORETAGS.includes(dom_util_tagName(node)) ||
            !ALLTAGS.includes(dom_util_tagName(node))));
}
function hasEmptyTag(node) {
    return !!node && EMPTYTAGS.includes(dom_util_tagName(node));
}
function hasDisplayTag(node) {
    return !!node && DISPLAYTAGS.includes(dom_util_tagName(node));
}
function isOrphanedGlyph(node) {
    return (!!node &&
        dom_util_tagName(node) === MMLTAGS.MGLYPH &&
        !hasLeafTag(node.parentNode));
}
function purgeNodes(nodes) {
    const nodeArray = [];
    for (let i = 0, node; (node = nodes[i]); i++) {
        if (node.nodeType !== NodeType.ELEMENT_NODE) {
            continue;
        }
        const tagName = dom_util_tagName(node);
        if (IGNORETAGS.includes(tagName)) {
            continue;
        }
        if (EMPTYTAGS.includes(tagName) && node.childNodes.length === 0) {
            continue;
        }
        nodeArray.push(node);
    }
    return nodeArray;
}
function isZeroLength(length) {
    if (!length) {
        return false;
    }
    const negativeNamedSpaces = [
        'negativeveryverythinmathspace',
        'negativeverythinmathspace',
        'negativethinmathspace',
        'negativemediummathspace',
        'negativethickmathspace',
        'negativeverythickmathspace',
        'negativeveryverythickmathspace'
    ];
    if (negativeNamedSpaces.includes(length)) {
        return true;
    }
    const value = length.match(/[0-9.]+/);
    if (!value) {
        return false;
    }
    return parseFloat(value[0]) === 0;
}
function addAttributes(to, from) {
    var _a;
    if ((_a = from.attributes) === null || _a === void 0 ? void 0 : _a.length) {
        const attrs = from.attributes;
        for (let i = attrs.length - 1; i >= 0; i--) {
            const key = attrs[i].name;
            if (key.match(/^ext/)) {
                to.attributes[key] = attrs[i].value;
                to.nobreaking = true;
            }
            if (directSpeechKeys.includes(key)) {
                to.attributes['ext-speech'] = attrs[i].value;
                to.nobreaking = true;
            }
            if (key.match(/texclass$/)) {
                to.attributes['texclass'] = attrs[i].value;
            }
            if (key.toLowerCase() === 'data-latex') {
                to.attributes['latex'] = attrs[i].value;
            }
            if (key === 'href') {
                to.attributes['href'] = attrs[i].value;
                to.nobreaking = true;
            }
        }
    }
}
function getEmbellishedInner(node) {
    if (node && node.embellished && node.childNodes.length > 0) {
        return getEmbellishedInner(node.childNodes[0]);
    }
    return node;
}
function sliceNodes(nodes, pred, opt_reverse) {
    if (opt_reverse) {
        nodes.reverse();
    }
    const head = [];
    for (let i = 0, node; (node = nodes[i]); i++) {
        if (pred(node)) {
            if (opt_reverse) {
                return {
                    head: nodes.slice(i + 1).reverse(),
                    div: node,
                    tail: head.reverse()
                };
            }
            return { head: head, div: node, tail: nodes.slice(i + 1) };
        }
        head.push(node);
    }
    if (opt_reverse) {
        return { head: [], div: null, tail: head.reverse() };
    }
    return { head: head, div: null, tail: [] };
}
function partitionNodes(nodes, pred) {
    let restNodes = nodes;
    const rel = [];
    const comp = [];
    let result = null;
    do {
        result = sliceNodes(restNodes, pred);
        comp.push(result.head);
        rel.push(result.div);
        restNodes = result.tail;
    } while (result.div);
    rel.pop();
    return { rel: rel, comp: comp };
}
//# sourceMappingURL=semantic_util.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_node.js




var Attribute;
(function (Attribute) {
    Attribute["EMBELLISHED"] = "embellished";
    Attribute["FENCEPOINTER"] = "fencepointer";
    Attribute["FONT"] = "font";
    Attribute["ID"] = "id";
    Attribute["ANNOTATION"] = "annotation";
    Attribute["ROLE"] = "role";
    Attribute["TYPE"] = "type";
    Attribute["CHILDREN"] = "children";
    Attribute["CONTENT"] = "content";
    Attribute["TEXT"] = "$t";
})(Attribute || (Attribute = {}));
class SemanticNode {
    static fromXml(xml) {
        const id = parseInt(xml.getAttribute('id'), 10);
        const node = new SemanticNode(id);
        node.type = xml.tagName;
        SemanticNode.setAttribute(node, xml, 'role');
        SemanticNode.setAttribute(node, xml, 'font');
        SemanticNode.setAttribute(node, xml, 'embellished');
        SemanticNode.setAttribute(node, xml, 'fencepointer', 'fencePointer');
        if (xml.getAttribute('annotation')) {
            node.parseAnnotation(xml.getAttribute('annotation'));
        }
        addAttributes(node, xml);
        SemanticNode.processChildren(node, xml);
        return node;
    }
    static setAttribute(node, xml, attribute, opt_name) {
        opt_name = opt_name || attribute;
        const value = xml.getAttribute(attribute);
        if (value) {
            node[opt_name] = value;
        }
    }
    static processChildren(node, xml) {
        for (const child of toArray(xml.childNodes)) {
            if (child.nodeType === NodeType.TEXT_NODE) {
                node.textContent = child.textContent;
                continue;
            }
            const children = toArray(child.childNodes).map(SemanticNode.fromXml);
            children.forEach((x) => (x.parent = node));
            if (dom_util_tagName(child) === 'CONTENT') {
                node.contentNodes = children;
            }
            else {
                node.childNodes = children;
            }
        }
    }
    constructor(id) {
        this.id = id;
        this.mathml = [];
        this.parent = null;
        this.type = semantic_meaning_SemanticType.UNKNOWN;
        this.role = semantic_meaning_SemanticRole.UNKNOWN;
        this.font = SemanticFont.UNKNOWN;
        this.embellished = null;
        this.fencePointer = '';
        this.childNodes = [];
        this.textContent = '';
        this.mathmlTree = null;
        this.contentNodes = [];
        this.annotation = {};
        this.attributes = {};
        this.nobreaking = false;
    }
    querySelectorAll(pred) {
        let result = [];
        for (let i = 0, child; (child = this.childNodes[i]); i++) {
            result = result.concat(child.querySelectorAll(pred));
        }
        for (let i = 0, content; (content = this.contentNodes[i]); i++) {
            result = result.concat(content.querySelectorAll(pred));
        }
        if (pred(this)) {
            result.unshift(this);
        }
        return result;
    }
    xml(xml, brief) {
        const xmlNodeList = function (tag, nodes) {
            const xmlNodes = nodes.map(function (x) {
                return x.xml(xml, brief);
            });
            const tagNode = xml.createElementNS('', tag);
            for (let i = 0, child; (child = xmlNodes[i]); i++) {
                tagNode.appendChild(child);
            }
            return tagNode;
        };
        const node = xml.createElementNS('', this.type);
        if (!brief) {
            this.xmlAttributes(node);
        }
        node.textContent = this.textContent;
        if (this.contentNodes.length > 0) {
            node.appendChild(xmlNodeList(Attribute.CONTENT, this.contentNodes));
        }
        if (this.childNodes.length > 0) {
            node.appendChild(xmlNodeList(Attribute.CHILDREN, this.childNodes));
        }
        return node;
    }
    toString(brief = false) {
        const xml = parseInput('<snode/>');
        return serializeXml(this.xml(xml.ownerDocument, brief));
    }
    allAttributes() {
        const attributes = [];
        attributes.push([Attribute.ROLE, this.role]);
        if (this.font !== SemanticFont.UNKNOWN) {
            attributes.push([Attribute.FONT, this.font]);
        }
        if (Object.keys(this.annotation).length) {
            attributes.push([Attribute.ANNOTATION, this.annotationXml()]);
        }
        if (this.embellished) {
            attributes.push([Attribute.EMBELLISHED, this.embellished]);
        }
        if (this.fencePointer) {
            attributes.push([Attribute.FENCEPOINTER, this.fencePointer]);
        }
        attributes.push([Attribute.ID, this.id.toString()]);
        return attributes;
    }
    annotationXml() {
        const result = [];
        for (const [key, val] of Object.entries(this.annotation)) {
            val.forEach((mean) => result.push(key + ':' + mean));
        }
        return result.join(';');
    }
    attributesXml() {
        const result = [];
        for (const [key, value] of Object.entries(this.attributes)) {
            result.push(key + ':' + SemanticNode.escapeValue(value));
        }
        return result.join(';');
    }
    toJson() {
        const json = {};
        json[Attribute.TYPE] = this.type;
        const attributes = this.allAttributes();
        for (let i = 0, attr; (attr = attributes[i]); i++) {
            json[attr[0]] = attr[1].toString();
        }
        if (this.textContent) {
            json[Attribute.TEXT] = this.textContent;
        }
        if (this.childNodes.length) {
            json[Attribute.CHILDREN] = this.childNodes.map(function (child) {
                return child.toJson();
            });
        }
        if (this.contentNodes.length) {
            json[Attribute.CONTENT] = this.contentNodes.map(function (child) {
                return child.toJson();
            });
        }
        return json;
    }
    updateContent(content, text) {
        const newContent = text
            ? content
                .replace(/^[ \f\n\r\t\v\u200b]*/, '')
                .replace(/[ \f\n\r\t\v\u200b]*$/, '')
            : content.trim();
        content = content && !newContent ? content : newContent;
        if (this.textContent === content) {
            return;
        }
        const meaning = SemanticMap.Meaning.get(content.replace(/\s/g, ' '));
        this.textContent = content;
        this.role = meaning.role;
        this.type = meaning.type;
        this.font = meaning.font;
    }
    addMathmlNodes(mmlNodes) {
        for (let i = 0, mml; (mml = mmlNodes[i]); i++) {
            if (this.mathml.indexOf(mml) === -1) {
                this.mathml.push(mml);
            }
        }
    }
    appendChild(child) {
        this.childNodes.push(child);
        this.addMathmlNodes(child.mathml);
        child.parent = this;
    }
    replaceChild(oldNode, newNode) {
        const index = this.childNodes.indexOf(oldNode);
        if (index === -1) {
            return;
        }
        oldNode.parent = null;
        newNode.parent = this;
        this.childNodes[index] = newNode;
        const removeMathml = oldNode.mathml.filter(function (x) {
            return newNode.mathml.indexOf(x) === -1;
        });
        const addMathml = newNode.mathml.filter(function (x) {
            return oldNode.mathml.indexOf(x) === -1;
        });
        this.removeMathmlNodes(removeMathml);
        this.addMathmlNodes(addMathml);
    }
    appendContentNode(node) {
        if (node) {
            this.contentNodes.push(node);
            this.addMathmlNodes(node.mathml);
            node.parent = this;
        }
    }
    removeContentNode(node) {
        if (node) {
            const index = this.contentNodes.indexOf(node);
            if (index !== -1) {
                this.contentNodes.slice(index, 1);
            }
        }
    }
    equals(node) {
        if (!node) {
            return false;
        }
        if (this.type !== node.type ||
            this.role !== node.role ||
            this.textContent !== node.textContent ||
            this.childNodes.length !== node.childNodes.length ||
            this.contentNodes.length !== node.contentNodes.length) {
            return false;
        }
        for (let i = 0, node1, node2; (node1 = this.childNodes[i]), (node2 = node.childNodes[i]); i++) {
            if (!node1.equals(node2)) {
                return false;
            }
        }
        for (let i = 0, node1, node2; (node1 = this.contentNodes[i]), (node2 = node.contentNodes[i]); i++) {
            if (!node1.equals(node2)) {
                return false;
            }
        }
        return true;
    }
    displayTree() {
        console.info(this.displayTree_(0));
    }
    addAnnotation(domain, annotation) {
        if (annotation) {
            this.addAnnotation_(domain, annotation);
        }
    }
    getAnnotation(domain) {
        const content = this.annotation[domain];
        return content ? content : [];
    }
    hasAnnotation(domain, annotation) {
        const content = this.annotation[domain];
        if (!content) {
            return false;
        }
        return content.indexOf(annotation) !== -1;
    }
    parseAnnotation(stateStr) {
        const annotations = stateStr.split(';');
        for (let i = 0, l = annotations.length; i < l; i++) {
            const annotation = annotations[i].split(':');
            this.addAnnotation(annotation[0], annotation[1]);
        }
    }
    meaning() {
        return { type: this.type, role: this.role, font: this.font };
    }
    xmlAttributes(node) {
        const attributes = this.allAttributes();
        for (let i = 0, attr; (attr = attributes[i]); i++) {
            node.setAttribute(attr[0], attr[1]);
        }
        this.addExternalAttributes(node);
    }
    addExternalAttributes(node) {
        for (const [attr, val] of Object.entries(this.attributes)) {
            node.setAttribute(attr, val);
        }
    }
    static escapeValue(value) {
        return value.replace(/;/g, '\\0003B');
    }
    parseAttributes(stateStr) {
        if (!stateStr)
            return;
        const attributes = stateStr.split(';');
        for (let i = 0, l = attributes.length; i < l; i++) {
            const [key, ...values] = attributes[i].split(':');
            if (key) {
                this.attributes[key] = values.join('').replace(/\\0003B/g, ';');
            }
        }
    }
    removeMathmlNodes(mmlNodes) {
        const mmlList = this.mathml;
        for (let i = 0, mml; (mml = mmlNodes[i]); i++) {
            const index = mmlList.indexOf(mml);
            if (index !== -1) {
                mmlList.splice(index, 1);
            }
        }
        this.mathml = mmlList;
    }
    displayTree_(depth) {
        depth++;
        const depthString = Array(depth).join('  ');
        let result = '';
        result += '\n' + depthString + this.toString();
        result += '\n' + depthString + 'MathmlTree:';
        result += '\n' + depthString + this.mathmlTreeString();
        result += '\n' + depthString + 'MathML:';
        for (let i = 0, mml; (mml = this.mathml[i]); i++) {
            result += '\n' + depthString + mml.toString();
        }
        result += '\n' + depthString + 'Begin Content';
        this.contentNodes.forEach(function (x) {
            result += x.displayTree_(depth);
        });
        result += '\n' + depthString + 'End Content';
        result += '\n' + depthString + 'Begin Children';
        this.childNodes.forEach(function (x) {
            result += x.displayTree_(depth);
        });
        result += '\n' + depthString + 'End Children';
        return result;
    }
    mathmlTreeString() {
        return this.mathmlTree ? this.mathmlTree.toString() : 'EMPTY';
    }
    addAnnotation_(domain, annotation) {
        const content = this.annotation[domain];
        if (content && !content.includes(annotation)) {
            content.push(annotation);
        }
        else {
            this.annotation[domain] = [annotation];
        }
    }
}
//# sourceMappingURL=semantic_node.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_node_factory.js




class SemanticNodeFactory {
    constructor() {
        this.leafMap = new SemanticNodeCollator();
        this.defaultMap = new SemanticDefault();
        this.idCounter_ = -1;
    }
    makeNode(id) {
        return this.createNode_(id);
    }
    makeUnprocessed(mml) {
        const node = this.createNode_();
        node.mathml = [mml];
        node.mathmlTree = mml;
        return node;
    }
    makeEmptyNode() {
        const node = this.createNode_();
        node.type = semantic_meaning_SemanticType.EMPTY;
        return node;
    }
    makeContentNode(content) {
        const node = this.createNode_();
        node.updateContent(content);
        return node;
    }
    makeMultipleContentNodes(num, content) {
        const nodes = [];
        for (let i = 0; i < num; i++) {
            nodes.push(this.makeContentNode(content));
        }
        return nodes;
    }
    makeLeafNode(content, font) {
        if (!content) {
            return this.makeEmptyNode();
        }
        const node = this.makeContentNode(content);
        node.font = font || node.font;
        const meaning = this.defaultMap.getNode(node);
        if (meaning) {
            node.type = meaning.type;
            node.role = meaning.role;
            node.font = meaning.font;
        }
        this.leafMap.addNode(node);
        return node;
    }
    makeBranchNode(type, children, contentNodes, opt_content) {
        const node = this.createNode_();
        if (opt_content) {
            node.updateContent(opt_content);
        }
        node.type = type;
        node.childNodes = children;
        node.contentNodes = contentNodes;
        children.concat(contentNodes).forEach(function (x) {
            x.parent = node;
            node.addMathmlNodes(x.mathml);
        });
        return node;
    }
    createNode_(id) {
        if (typeof id !== 'undefined') {
            this.idCounter_ = Math.max(this.idCounter_, id);
        }
        else {
            id = ++this.idCounter_;
        }
        return new SemanticNode(id);
    }
}
//# sourceMappingURL=semantic_node_factory.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_parser.js

class SemanticAbstractParser {
    constructor(type) {
        this.type = type;
        this.factory_ = new SemanticNodeFactory();
    }
    getFactory() {
        return this.factory_;
    }
    setFactory(factory) {
        this.factory_ = factory;
    }
    getType() {
        return this.type;
    }
    parseList(list) {
        const result = [];
        for (let i = 0, element; (element = list[i]); i++) {
            result.push(this.parse(element));
        }
        return result;
    }
}
//# sourceMappingURL=semantic_parser.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_pred.js



function isType(node, attr) {
    return node.type === attr;
}
function embellishedType(node, attr) {
    return node.embellished === attr;
}
function isRole(node, attr) {
    return node.role === attr;
}
function isAccent(node) {
    return (isType(node, semantic_meaning_SemanticType.FENCE) ||
        isType(node, semantic_meaning_SemanticType.PUNCTUATION) ||
        isType(node, semantic_meaning_SemanticType.OPERATOR) ||
        isType(node, semantic_meaning_SemanticType.RELATION));
}
function isSimpleFunctionScope(node) {
    const children = node.childNodes;
    if (children.length === 0) {
        return true;
    }
    if (children.length > 1) {
        return false;
    }
    const child = children[0];
    if (child.type === semantic_meaning_SemanticType.INFIXOP) {
        if (child.role !== semantic_meaning_SemanticRole.IMPLICIT) {
            return false;
        }
        if (child.childNodes.some((x) => isType(x, semantic_meaning_SemanticType.INFIXOP))) {
            return false;
        }
    }
    return true;
}
function isPrefixFunctionBoundary(node) {
    return ((isOperator(node) && !isRole(node, semantic_meaning_SemanticRole.DIVISION)) ||
        isType(node, semantic_meaning_SemanticType.APPL) ||
        isGeneralFunctionBoundary(node));
}
function isBigOpBoundary(node) {
    return isOperator(node) || isGeneralFunctionBoundary(node);
}
function isIntegralDxBoundary(firstNode, secondNode) {
    return (!!secondNode &&
        isType(secondNode, semantic_meaning_SemanticType.IDENTIFIER) &&
        SemanticMap.Secondary.has(firstNode.textContent, SemanticSecondary.D));
}
function isIntegralDxBoundarySingle(node) {
    if (isType(node, semantic_meaning_SemanticType.IDENTIFIER)) {
        const firstChar = node.textContent[0];
        return (firstChar &&
            node.textContent[1] &&
            SemanticMap.Secondary.has(firstChar, SemanticSecondary.D));
    }
    return false;
}
function isGeneralFunctionBoundary(node) {
    return isRelation(node) || isPunctuation(node);
}
function isEmbellished(node) {
    if (node.embellished) {
        return node.embellished;
    }
    if (isEmbellishedType(node.type)) {
        return node.type;
    }
    return null;
}
function isEmbellishedType(type) {
    return (type === semantic_meaning_SemanticType.OPERATOR ||
        type === semantic_meaning_SemanticType.RELATION ||
        type === semantic_meaning_SemanticType.FENCE ||
        type === semantic_meaning_SemanticType.PUNCTUATION);
}
function isOperator(node) {
    return (isType(node, semantic_meaning_SemanticType.OPERATOR) ||
        embellishedType(node, semantic_meaning_SemanticType.OPERATOR));
}
function isRelation(node) {
    return (isType(node, semantic_meaning_SemanticType.RELATION) ||
        embellishedType(node, semantic_meaning_SemanticType.RELATION));
}
function isPunctuation(node) {
    return (isType(node, semantic_meaning_SemanticType.PUNCTUATION) ||
        embellishedType(node, semantic_meaning_SemanticType.PUNCTUATION));
}
function isFence(node) {
    return (isType(node, semantic_meaning_SemanticType.FENCE) ||
        embellishedType(node, semantic_meaning_SemanticType.FENCE));
}
function isElligibleEmbellishedFence(node) {
    if (!node || !isFence(node)) {
        return false;
    }
    if (!node.embellished) {
        return true;
    }
    return recurseBaseNode(node);
}
function bothSide(node) {
    return (isType(node, semantic_meaning_SemanticType.TENSOR) &&
        (!isType(node.childNodes[1], semantic_meaning_SemanticType.EMPTY) ||
            !isType(node.childNodes[2], semantic_meaning_SemanticType.EMPTY)) &&
        (!isType(node.childNodes[3], semantic_meaning_SemanticType.EMPTY) ||
            !isType(node.childNodes[4], semantic_meaning_SemanticType.EMPTY)));
}
function recurseBaseNode(node) {
    if (!node.embellished) {
        return true;
    }
    if (bothSide(node)) {
        return false;
    }
    if (isRole(node, semantic_meaning_SemanticRole.CLOSE) && isType(node, semantic_meaning_SemanticType.TENSOR)) {
        return false;
    }
    if (isRole(node, semantic_meaning_SemanticRole.OPEN) &&
        (isType(node, semantic_meaning_SemanticType.SUBSCRIPT) ||
            isType(node, semantic_meaning_SemanticType.SUPERSCRIPT))) {
        return false;
    }
    return recurseBaseNode(node.childNodes[0]);
}
function isTableOrMultiline(node) {
    return (!!node &&
        (isType(node, semantic_meaning_SemanticType.TABLE) || isType(node, semantic_meaning_SemanticType.MULTILINE)));
}
function tableIsMatrixOrVector(node) {
    return (!!node && isFencedElement(node) && isTableOrMultiline(node.childNodes[0]));
}
function isFencedElement(node) {
    return (!!node &&
        isType(node, semantic_meaning_SemanticType.FENCED) &&
        (isRole(node, semantic_meaning_SemanticRole.LEFTRIGHT) || isNeutralFence(node)) &&
        node.childNodes.length === 1);
}
function tableIsCases(_table, prevNodes) {
    return (prevNodes.length > 0 &&
        isRole(prevNodes[prevNodes.length - 1], semantic_meaning_SemanticRole.OPENFENCE));
}
function tableIsMultiline(table) {
    return table.childNodes.every(function (row) {
        const length = row.childNodes.length;
        return length <= 1;
    });
}
function lineIsLabelled(line) {
    return (isType(line, semantic_meaning_SemanticType.LINE) &&
        line.contentNodes.length &&
        isRole(line.contentNodes[0], semantic_meaning_SemanticRole.LABEL));
}
function isBinomial(table) {
    return table.childNodes.length === 2;
}
function isLimitBase(node) {
    return (isType(node, semantic_meaning_SemanticType.LARGEOP) ||
        isType(node, semantic_meaning_SemanticType.LIMBOTH) ||
        isType(node, semantic_meaning_SemanticType.LIMLOWER) ||
        isType(node, semantic_meaning_SemanticType.LIMUPPER) ||
        (isType(node, semantic_meaning_SemanticType.FUNCTION) &&
            isRole(node, semantic_meaning_SemanticRole.LIMFUNC)) ||
        ((isType(node, semantic_meaning_SemanticType.OVERSCORE) ||
            isType(node, semantic_meaning_SemanticType.UNDERSCORE)) &&
            isLimitBase(node.childNodes[0])));
}
function isSimpleFunctionHead(node) {
    return (node.type === semantic_meaning_SemanticType.IDENTIFIER ||
        node.role === semantic_meaning_SemanticRole.LATINLETTER ||
        node.role === semantic_meaning_SemanticRole.GREEKLETTER ||
        node.role === semantic_meaning_SemanticRole.OTHERLETTER);
}
function singlePunctAtPosition(nodes, puncts, position) {
    return (puncts.length === 1 &&
        (nodes[position].type === semantic_meaning_SemanticType.PUNCTUATION ||
            nodes[position].embellished === semantic_meaning_SemanticType.PUNCTUATION) &&
        nodes[position] === puncts[0]);
}
function isSimpleFunction(node) {
    return (isType(node, semantic_meaning_SemanticType.IDENTIFIER) &&
        isRole(node, semantic_meaning_SemanticRole.SIMPLEFUNC));
}
function isLeftBrace(node) {
    const leftBrace = ['{', '', ''];
    return !!node && leftBrace.indexOf(node.textContent) !== -1;
}
function isRightBrace(node) {
    const rightBrace = ['}', '', ''];
    return !!node && rightBrace.indexOf(node.textContent) !== -1;
}
function isSetNode(node) {
    return (isLeftBrace(node.contentNodes[0]) && isRightBrace(node.contentNodes[1]));
}
const illegalSingleton = [
    semantic_meaning_SemanticType.PUNCTUATION,
    semantic_meaning_SemanticType.PUNCTUATED,
    semantic_meaning_SemanticType.RELSEQ,
    semantic_meaning_SemanticType.MULTIREL,
    semantic_meaning_SemanticType.TABLE,
    semantic_meaning_SemanticType.MULTILINE,
    semantic_meaning_SemanticType.CASES,
    semantic_meaning_SemanticType.INFERENCE
];
const scriptedElement = [
    semantic_meaning_SemanticType.LIMUPPER,
    semantic_meaning_SemanticType.LIMLOWER,
    semantic_meaning_SemanticType.LIMBOTH,
    semantic_meaning_SemanticType.SUBSCRIPT,
    semantic_meaning_SemanticType.SUPERSCRIPT,
    semantic_meaning_SemanticType.UNDERSCORE,
    semantic_meaning_SemanticType.OVERSCORE,
    semantic_meaning_SemanticType.TENSOR
];
function isSingletonSetContent(node) {
    const type = node.type;
    if (illegalSingleton.indexOf(type) !== -1 ||
        (type === semantic_meaning_SemanticType.INFIXOP && node.role !== semantic_meaning_SemanticRole.IMPLICIT)) {
        return false;
    }
    if (type === semantic_meaning_SemanticType.FENCED) {
        return node.role === semantic_meaning_SemanticRole.LEFTRIGHT
            ? isSingletonSetContent(node.childNodes[0])
            : true;
    }
    if (scriptedElement.indexOf(type) !== -1) {
        return isSingletonSetContent(node.childNodes[0]);
    }
    return true;
}
function isNumber(node) {
    return (node.type === semantic_meaning_SemanticType.NUMBER &&
        (node.role === semantic_meaning_SemanticRole.INTEGER || node.role === semantic_meaning_SemanticRole.FLOAT));
}
function isUnitCounter(node) {
    return (isNumber(node) ||
        node.role === semantic_meaning_SemanticRole.VULGAR ||
        node.role === semantic_meaning_SemanticRole.MIXED);
}
function isPureUnit(node) {
    const children = node.childNodes;
    return (node.role === semantic_meaning_SemanticRole.UNIT &&
        (!children.length || children[0].role === semantic_meaning_SemanticRole.UNIT));
}
function isUnitProduct(node) {
    const children = node.childNodes;
    return (node.type === semantic_meaning_SemanticType.INFIXOP &&
        (node.role === semantic_meaning_SemanticRole.MULTIPLICATION ||
            node.role === semantic_meaning_SemanticRole.IMPLICIT) &&
        children.length &&
        (isPureUnit(children[0]) || isUnitCounter(children[0])) &&
        node.childNodes.slice(1).every(isPureUnit));
}
function isImplicit(node) {
    return (node.type === semantic_meaning_SemanticType.INFIXOP &&
        (node.role === semantic_meaning_SemanticRole.IMPLICIT ||
            (node.role === semantic_meaning_SemanticRole.UNIT &&
                !!node.contentNodes.length &&
                node.contentNodes[0].textContent === NamedSymbol.invisibleTimes)));
}
function isImplicitOp(node) {
    return (node.type === semantic_meaning_SemanticType.INFIXOP && node.role === semantic_meaning_SemanticRole.IMPLICIT);
}
function isNeutralFence(fence) {
    return (fence.role === semantic_meaning_SemanticRole.NEUTRAL || fence.role === semantic_meaning_SemanticRole.METRIC);
}
function compareNeutralFences(fence1, fence2) {
    return (isNeutralFence(fence1) &&
        isNeutralFence(fence2) &&
        getEmbellishedInner(fence1).textContent ===
            getEmbellishedInner(fence2).textContent);
}
function elligibleLeftNeutral(fence) {
    if (!isNeutralFence(fence)) {
        return false;
    }
    if (!fence.embellished) {
        return true;
    }
    if (fence.type === semantic_meaning_SemanticType.SUPERSCRIPT ||
        fence.type === semantic_meaning_SemanticType.SUBSCRIPT) {
        return false;
    }
    if (fence.type === semantic_meaning_SemanticType.TENSOR &&
        (fence.childNodes[3].type !== semantic_meaning_SemanticType.EMPTY ||
            fence.childNodes[4].type !== semantic_meaning_SemanticType.EMPTY)) {
        return false;
    }
    return true;
}
function elligibleRightNeutral(fence) {
    if (!isNeutralFence(fence)) {
        return false;
    }
    if (!fence.embellished) {
        return true;
    }
    if (fence.type === semantic_meaning_SemanticType.TENSOR &&
        (fence.childNodes[1].type !== semantic_meaning_SemanticType.EMPTY ||
            fence.childNodes[2].type !== semantic_meaning_SemanticType.EMPTY)) {
        return false;
    }
    return true;
}
function isMembership(element) {
    return [
        semantic_meaning_SemanticRole.ELEMENT,
        semantic_meaning_SemanticRole.NONELEMENT,
        semantic_meaning_SemanticRole.REELEMENT,
        semantic_meaning_SemanticRole.RENONELEMENT
    ].includes(element.role);
}
//# sourceMappingURL=semantic_pred.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_heuristic_factory.js

const SemanticHeuristics = {
    factory: null,
    options: new Options(),
    updateFactory: function (nodeFactory) {
        SemanticHeuristics.factory = nodeFactory;
    },
    heuristics: new Map(),
    flags: {
        combine_juxtaposition: true,
        convert_juxtaposition: true,
        multioperator: true
    },
    blacklist: {},
    add: function (heuristic) {
        const name = heuristic.name;
        SemanticHeuristics.heuristics.set(name, heuristic);
        if (!SemanticHeuristics.flags[name]) {
            SemanticHeuristics.flags[name] = false;
        }
    },
    run: function (name, root, opt_alternative) {
        const heuristic = SemanticHeuristics.heuristics.get(name);
        return heuristic &&
            !SemanticHeuristics.blacklist[name] &&
            (SemanticHeuristics.flags[name] || heuristic.applicable(root))
            ? heuristic.apply(root)
            : opt_alternative
                ? opt_alternative(root)
                : root;
    }
};
//# sourceMappingURL=semantic_heuristic_factory.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_processor.js








class SemanticProcessor {
    static getInstance() {
        SemanticProcessor.instance =
            SemanticProcessor.instance || new SemanticProcessor();
        return SemanticProcessor.instance;
    }
    static tableToMultiline(table) {
        if (!tableIsMultiline(table)) {
            return SemanticHeuristics.run('rewrite_subcases', table, SemanticProcessor.classifyTable);
        }
        table.type = semantic_meaning_SemanticType.MULTILINE;
        for (let i = 0, row; (row = table.childNodes[i]); i++) {
            SemanticProcessor.rowToLine_(row, semantic_meaning_SemanticRole.MULTILINE);
        }
        if (table.childNodes.length === 1 &&
            !lineIsLabelled(table.childNodes[0]) &&
            isFencedElement(table.childNodes[0].childNodes[0])) {
            SemanticProcessor.tableToMatrixOrVector_(SemanticProcessor.rewriteFencedLine_(table));
        }
        SemanticProcessor.binomialForm_(table);
        SemanticProcessor.classifyMultiline(table);
        return table;
    }
    static number(node) {
        if (node.type === semantic_meaning_SemanticType.UNKNOWN ||
            node.type === semantic_meaning_SemanticType.IDENTIFIER) {
            node.type = semantic_meaning_SemanticType.NUMBER;
        }
        SemanticProcessor.meaningFromContent(node, SemanticProcessor.numberRole_);
        SemanticProcessor.exprFont_(node);
    }
    static classifyMultiline(multiline) {
        let index = 0;
        const length = multiline.childNodes.length;
        let line;
        while (index < length &&
            (!(line = multiline.childNodes[index]) || !line.childNodes.length)) {
            index++;
        }
        if (index >= length) {
            return;
        }
        const firstRole = line.childNodes[0].role;
        if (firstRole !== semantic_meaning_SemanticRole.UNKNOWN &&
            multiline.childNodes.every(function (x) {
                const cell = x.childNodes[0];
                return (!cell ||
                    (cell.role === firstRole &&
                        (isType(cell, semantic_meaning_SemanticType.RELATION) ||
                            isType(cell, semantic_meaning_SemanticType.RELSEQ))));
            })) {
            multiline.role = firstRole;
        }
    }
    static classifyTable(table) {
        const columns = SemanticProcessor.computeColumns_(table);
        SemanticProcessor.classifyByColumns_(table, columns, semantic_meaning_SemanticRole.EQUALITY) ||
            SemanticProcessor.classifyByColumns_(table, columns, semantic_meaning_SemanticRole.INEQUALITY, [semantic_meaning_SemanticRole.EQUALITY]) ||
            SemanticProcessor.classifyByColumns_(table, columns, semantic_meaning_SemanticRole.ARROW) ||
            SemanticProcessor.detectCaleyTable(table);
        return table;
    }
    static detectCaleyTable(table) {
        if (!table.mathmlTree) {
            return false;
        }
        const tree = table.mathmlTree;
        const cl = tree.getAttribute('columnlines');
        const rl = tree.getAttribute('rowlines');
        if (!cl || !rl) {
            return false;
        }
        if (SemanticProcessor.cayleySpacing(cl) &&
            SemanticProcessor.cayleySpacing(rl)) {
            table.role = semantic_meaning_SemanticRole.CAYLEY;
            return true;
        }
        return false;
    }
    static cayleySpacing(lines) {
        const list = lines.split(' ');
        return ((list[0] === 'solid' || list[0] === 'dashed') &&
            list.slice(1).every((x) => x === 'none'));
    }
    static proof(node, semantics, parse) {
        const attrs = SemanticProcessor.separateSemantics(semantics);
        return SemanticProcessor.getInstance().proof(node, attrs, parse);
    }
    static findSemantics(node, attr, opt_value) {
        const value = opt_value == null ? null : opt_value;
        const semantics = SemanticProcessor.getSemantics(node);
        if (!semantics) {
            return false;
        }
        if (!semantics[attr]) {
            return false;
        }
        return value == null ? true : semantics[attr] === value;
    }
    static getSemantics(node) {
        const semantics = node.getAttribute('semantics');
        if (!semantics) {
            return null;
        }
        return SemanticProcessor.separateSemantics(semantics);
    }
    static removePrefix(name) {
        const [, ...rest] = name.split('_');
        return rest.join('_');
    }
    static separateSemantics(attr) {
        const result = {};
        attr.split(';').forEach(function (x) {
            const [name, value] = x.split(':');
            result[SemanticProcessor.removePrefix(name)] = value;
        });
        return result;
    }
    static matchSpaces_(nodes, ops) {
        for (let i = 0, op; (op = ops[i]); i++) {
            const node = nodes[i];
            const mt1 = node.mathmlTree;
            const mt2 = nodes[i + 1].mathmlTree;
            if (!mt1 || !mt2) {
                continue;
            }
            const sibling = mt1.nextSibling;
            if (!sibling || sibling === mt2) {
                continue;
            }
            const spacer = SemanticProcessor.getSpacer_(sibling);
            if (spacer) {
                op.mathml.push(spacer);
                op.mathmlTree = spacer;
                op.role = semantic_meaning_SemanticRole.SPACE;
            }
        }
    }
    static getSpacer_(node) {
        if (dom_util_tagName(node) === MMLTAGS.MSPACE) {
            return node;
        }
        while (hasEmptyTag(node) && node.childNodes.length === 1) {
            node = node.childNodes[0];
            if (dom_util_tagName(node) === MMLTAGS.MSPACE) {
                return node;
            }
        }
        return null;
    }
    static fenceToPunct_(fence) {
        const newRole = SemanticProcessor.FENCE_TO_PUNCT_[fence.role];
        if (!newRole) {
            return;
        }
        while (fence.embellished) {
            fence.embellished = semantic_meaning_SemanticType.PUNCTUATION;
            if (!(isRole(fence, semantic_meaning_SemanticRole.SUBSUP) ||
                isRole(fence, semantic_meaning_SemanticRole.UNDEROVER))) {
                fence.role = newRole;
            }
            fence = fence.childNodes[0];
        }
        fence.type = semantic_meaning_SemanticType.PUNCTUATION;
        fence.role = newRole;
    }
    static classifyFunction_(funcNode, restNodes) {
        if (funcNode.type === semantic_meaning_SemanticType.APPL ||
            funcNode.type === semantic_meaning_SemanticType.BIGOP ||
            funcNode.type === semantic_meaning_SemanticType.INTEGRAL) {
            return '';
        }
        if (restNodes[0] &&
            restNodes[0].textContent === NamedSymbol.functionApplication) {
            SemanticProcessor.getInstance().funcAppls[funcNode.id] =
                restNodes.shift();
            let role = semantic_meaning_SemanticRole.SIMPLEFUNC;
            SemanticHeuristics.run('simple2prefix', funcNode);
            if (funcNode.role === semantic_meaning_SemanticRole.PREFIXFUNC ||
                funcNode.role === semantic_meaning_SemanticRole.LIMFUNC) {
                role = funcNode.role;
            }
            SemanticProcessor.propagateFunctionRole_(funcNode, role);
            return 'prefix';
        }
        const kind = SemanticProcessor.CLASSIFY_FUNCTION_[funcNode.role];
        return kind
            ? kind
            : isSimpleFunctionHead(funcNode)
                ? 'simple'
                : '';
    }
    static propagateFunctionRole_(funcNode, tag) {
        if (funcNode) {
            if (funcNode.type === semantic_meaning_SemanticType.INFIXOP) {
                return;
            }
            if (!(isRole(funcNode, semantic_meaning_SemanticRole.SUBSUP) ||
                isRole(funcNode, semantic_meaning_SemanticRole.UNDEROVER))) {
                funcNode.role = tag;
            }
            SemanticProcessor.propagateFunctionRole_(funcNode.childNodes[0], tag);
        }
    }
    static getFunctionOp_(tree, pred) {
        if (pred(tree)) {
            return tree;
        }
        for (let i = 0, child; (child = tree.childNodes[i]); i++) {
            const op = SemanticProcessor.getFunctionOp_(child, pred);
            if (op) {
                return op;
            }
        }
        return null;
    }
    static tableToMatrixOrVector_(node) {
        const matrix = node.childNodes[0];
        isType(matrix, semantic_meaning_SemanticType.MULTILINE)
            ? SemanticProcessor.tableToVector_(node)
            : SemanticProcessor.tableToMatrix_(node);
        node.contentNodes.forEach(matrix.appendContentNode.bind(matrix));
        for (let i = 0, row; (row = matrix.childNodes[i]); i++) {
            SemanticProcessor.assignRoleToRow_(row, SemanticProcessor.getComponentRoles_(matrix));
        }
        matrix.parent = null;
        return matrix;
    }
    static tableToVector_(node) {
        const vector = node.childNodes[0];
        vector.type = semantic_meaning_SemanticType.VECTOR;
        if (vector.childNodes.length === 1) {
            SemanticProcessor.tableToSquare_(node);
            return;
        }
        SemanticProcessor.binomialForm_(vector);
    }
    static binomialForm_(node) {
        if (!isRole(node, semantic_meaning_SemanticRole.UNKNOWN)) {
            return;
        }
        if (isBinomial(node)) {
            node.role = semantic_meaning_SemanticRole.BINOMIAL;
            node.childNodes[0].role = semantic_meaning_SemanticRole.BINOMIAL;
            node.childNodes[1].role = semantic_meaning_SemanticRole.BINOMIAL;
        }
    }
    static tableToMatrix_(node) {
        const matrix = node.childNodes[0];
        matrix.type = semantic_meaning_SemanticType.MATRIX;
        if (matrix.childNodes &&
            matrix.childNodes.length > 0 &&
            matrix.childNodes[0].childNodes &&
            matrix.childNodes.length === matrix.childNodes[0].childNodes.length) {
            SemanticProcessor.tableToSquare_(node);
            return;
        }
        if (matrix.childNodes && matrix.childNodes.length === 1) {
            matrix.role = semantic_meaning_SemanticRole.ROWVECTOR;
        }
    }
    static tableToSquare_(node) {
        const matrix = node.childNodes[0];
        if (!isRole(matrix, semantic_meaning_SemanticRole.UNKNOWN)) {
            return;
        }
        if (isNeutralFence(node)) {
            matrix.role = semantic_meaning_SemanticRole.DETERMINANT;
            return;
        }
        matrix.role = semantic_meaning_SemanticRole.SQUAREMATRIX;
    }
    static getComponentRoles_(node) {
        const role = node.role;
        if (role && role !== semantic_meaning_SemanticRole.UNKNOWN) {
            return role;
        }
        return node.type.toLowerCase() || semantic_meaning_SemanticRole.UNKNOWN;
    }
    static tableToCases_(table, openFence) {
        for (let i = 0, row; (row = table.childNodes[i]); i++) {
            SemanticProcessor.assignRoleToRow_(row, semantic_meaning_SemanticRole.CASES);
        }
        table.type = semantic_meaning_SemanticType.CASES;
        table.appendContentNode(openFence);
        if (tableIsMultiline(table)) {
            SemanticProcessor.binomialForm_(table);
        }
        return table;
    }
    static rewriteFencedLine_(table) {
        const line = table.childNodes[0];
        const fenced = table.childNodes[0].childNodes[0];
        const element = table.childNodes[0].childNodes[0].childNodes[0];
        fenced.parent = table.parent;
        table.parent = fenced;
        element.parent = line;
        fenced.childNodes = [table];
        line.childNodes = [element];
        return fenced;
    }
    static rowToLine_(row, opt_role) {
        const role = opt_role || semantic_meaning_SemanticRole.UNKNOWN;
        if (isType(row, semantic_meaning_SemanticType.ROW)) {
            row.type = semantic_meaning_SemanticType.LINE;
            row.role = role;
            if (row.childNodes.length === 1 &&
                isType(row.childNodes[0], semantic_meaning_SemanticType.CELL)) {
                row.childNodes = row.childNodes[0].childNodes;
                row.childNodes.forEach(function (x) {
                    x.parent = row;
                });
            }
        }
    }
    static assignRoleToRow_(row, role) {
        if (isType(row, semantic_meaning_SemanticType.LINE)) {
            row.role = role;
            return;
        }
        if (isType(row, semantic_meaning_SemanticType.ROW)) {
            row.role = role;
            row.childNodes.forEach(function (cell) {
                if (isType(cell, semantic_meaning_SemanticType.CELL)) {
                    cell.role = role;
                }
            });
        }
    }
    static nextSeparatorFunction_(separators) {
        let sepList;
        if (separators) {
            if (separators.match(/^\s+$/)) {
                return null;
            }
            else {
                sepList = separators
                    .replace(/\s/g, '')
                    .split('')
                    .filter(function (x) {
                    return x;
                });
            }
        }
        else {
            sepList = [','];
        }
        return function () {
            if (sepList.length > 1) {
                return sepList.shift();
            }
            return sepList[0];
        };
    }
    static meaningFromContent(node, func) {
        const content = [...node.textContent].filter((x) => x.match(/[^\s]/));
        const meaning = content.map((x) => SemanticMap.Meaning.get(x));
        func(node, content, meaning);
    }
    static numberRole_(node, content, meaning) {
        if (node.role !== semantic_meaning_SemanticRole.UNKNOWN) {
            return;
        }
        if (meaning.every(function (x) {
            return ((x.type === semantic_meaning_SemanticType.NUMBER && x.role === semantic_meaning_SemanticRole.INTEGER) ||
                (x.type === semantic_meaning_SemanticType.PUNCTUATION && x.role === semantic_meaning_SemanticRole.COMMA));
        })) {
            node.role = semantic_meaning_SemanticRole.INTEGER;
            if (content[0] === '0') {
                node.addAnnotation('general', 'basenumber');
            }
            return;
        }
        if (meaning.every(function (x) {
            return ((x.type === semantic_meaning_SemanticType.NUMBER && x.role === semantic_meaning_SemanticRole.INTEGER) ||
                x.type === semantic_meaning_SemanticType.PUNCTUATION);
        })) {
            node.role = semantic_meaning_SemanticRole.FLOAT;
            return;
        }
        node.role = semantic_meaning_SemanticRole.OTHERNUMBER;
    }
    static exprFont_(node) {
        if (node.font !== SemanticFont.UNKNOWN) {
            return;
        }
        SemanticProcessor.compSemantics(node, 'font', SemanticFont);
    }
    static compSemantics(node, field, sem) {
        const content = [...node.textContent];
        const meaning = content.map((x) => SemanticMap.Meaning.get(x));
        const single = meaning.reduce(function (prev, curr) {
            if (!prev ||
                !curr[field] ||
                curr[field] === sem.UNKNOWN ||
                curr[field] === prev) {
                return prev;
            }
            if (prev === sem.UNKNOWN) {
                return curr[field];
            }
            return null;
        }, sem.UNKNOWN);
        if (single) {
            node[field] = single;
        }
    }
    static purgeFences_(partition) {
        const rel = partition.rel;
        const comp = partition.comp;
        const newRel = [];
        const newComp = [];
        while (rel.length > 0) {
            const currentRel = rel.shift();
            let currentComp = comp.shift();
            if (isElligibleEmbellishedFence(currentRel)) {
                newRel.push(currentRel);
                newComp.push(currentComp);
                continue;
            }
            SemanticProcessor.fenceToPunct_(currentRel);
            currentComp.push(currentRel);
            currentComp = currentComp.concat(comp.shift());
            comp.unshift(currentComp);
        }
        newComp.push(comp.shift());
        return { rel: newRel, comp: newComp };
    }
    static rewriteFencedNode_(fenced) {
        const ofence = fenced.contentNodes[0];
        const cfence = fenced.contentNodes[1];
        let rewritten = SemanticProcessor.rewriteFence_(fenced, ofence);
        fenced.contentNodes[0] = rewritten.fence;
        rewritten = SemanticProcessor.rewriteFence_(rewritten.node, cfence);
        fenced.contentNodes[1] = rewritten.fence;
        fenced.contentNodes[0].parent = fenced;
        fenced.contentNodes[1].parent = fenced;
        rewritten.node.parent = null;
        return rewritten.node;
    }
    static rewriteFence_(node, fence) {
        if (!fence.embellished) {
            return { node: node, fence: fence };
        }
        const newFence = fence.childNodes[0];
        const rewritten = SemanticProcessor.rewriteFence_(node, newFence);
        if (isType(fence, semantic_meaning_SemanticType.SUPERSCRIPT) ||
            isType(fence, semantic_meaning_SemanticType.SUBSCRIPT) ||
            isType(fence, semantic_meaning_SemanticType.TENSOR)) {
            if (!isRole(fence, semantic_meaning_SemanticRole.SUBSUP)) {
                fence.role = node.role;
            }
            if (newFence !== rewritten.node) {
                fence.replaceChild(newFence, rewritten.node);
                newFence.parent = node;
            }
            SemanticProcessor.propagateFencePointer_(fence, newFence);
            return { node: fence, fence: rewritten.fence };
        }
        fence.replaceChild(newFence, rewritten.fence);
        if (fence.mathmlTree && fence.mathml.indexOf(fence.mathmlTree) === -1) {
            fence.mathml.push(fence.mathmlTree);
        }
        return { node: rewritten.node, fence: fence };
    }
    static propagateFencePointer_(oldNode, newNode) {
        oldNode.fencePointer = newNode.fencePointer || newNode.id.toString();
        oldNode.embellished = null;
    }
    static classifyByColumns_(table, columns, relation, alternatives = []) {
        const relations = [relation].concat(alternatives);
        const test1 = (x) => SemanticProcessor.isPureRelation_(x, relations);
        const test2 = (x) => SemanticProcessor.isEndRelation_(x, relations) ||
            SemanticProcessor.isPureRelation_(x, relations);
        const test3 = (x) => SemanticProcessor.isEndRelation_(x, relations, true) ||
            SemanticProcessor.isPureRelation_(x, relations);
        if ((columns.length === 3 &&
            SemanticProcessor.testColumns_(columns, 1, test1)) ||
            (columns.length === 2 &&
                (SemanticProcessor.testColumns_(columns, 1, test2) ||
                    SemanticProcessor.testColumns_(columns, 0, test3)))) {
            table.role = relation;
            return true;
        }
        return false;
    }
    static isEndRelation_(node, relations, opt_right) {
        const position = opt_right ? node.childNodes.length - 1 : 0;
        return (isType(node, semantic_meaning_SemanticType.RELSEQ) &&
            relations.some((relation) => isRole(node, relation)) &&
            isType(node.childNodes[position], semantic_meaning_SemanticType.EMPTY));
    }
    static isPureRelation_(node, relations) {
        return (isType(node, semantic_meaning_SemanticType.RELATION) &&
            relations.some((relation) => isRole(node, relation)));
    }
    static computeColumns_(table) {
        const columns = [];
        for (let i = 0, row; (row = table.childNodes[i]); i++) {
            for (let j = 0, cell; (cell = row.childNodes[j]); j++) {
                const column = columns[j];
                column ? columns[j].push(cell) : (columns[j] = [cell]);
            }
        }
        return columns;
    }
    static testColumns_(columns, index, pred) {
        const column = columns[index];
        return column
            ? column.some(function (cell) {
                return (cell.childNodes.length && pred(cell.childNodes[0]));
            }) &&
                column.every(function (cell) {
                    return (!cell.childNodes.length ||
                        pred(cell.childNodes[0]));
                })
            : false;
    }
    setNodeFactory(factory) {
        SemanticProcessor.getInstance().factory_ = factory;
        SemanticHeuristics.updateFactory(SemanticProcessor.getInstance().factory_);
    }
    getNodeFactory() {
        return SemanticProcessor.getInstance().factory_;
    }
    identifierNode(leaf, font, unit) {
        if (unit === 'MathML-Unit') {
            leaf.type = semantic_meaning_SemanticType.IDENTIFIER;
            leaf.role = semantic_meaning_SemanticRole.UNIT;
        }
        else if (!font &&
            leaf.textContent.length === 1 &&
            (leaf.role === semantic_meaning_SemanticRole.INTEGER ||
                leaf.role === semantic_meaning_SemanticRole.LATINLETTER ||
                leaf.role === semantic_meaning_SemanticRole.GREEKLETTER) &&
            leaf.font === SemanticFont.NORMAL) {
            leaf.font = SemanticFont.ITALIC;
            return SemanticHeuristics.run('simpleNamedFunction', leaf);
        }
        if (leaf.type === semantic_meaning_SemanticType.UNKNOWN) {
            leaf.type = semantic_meaning_SemanticType.IDENTIFIER;
        }
        SemanticProcessor.exprFont_(leaf);
        return SemanticHeuristics.run('simpleNamedFunction', leaf);
    }
    implicitNode(nodes) {
        nodes = SemanticProcessor.getInstance().getMixedNumbers_(nodes);
        nodes = SemanticProcessor.getInstance().combineUnits_(nodes);
        if (nodes.length === 1) {
            return nodes[0];
        }
        const node = SemanticProcessor.getInstance().implicitNode_(nodes);
        return SemanticHeuristics.run('combine_juxtaposition', node);
    }
    text(leaf, type) {
        SemanticProcessor.exprFont_(leaf);
        leaf.type = semantic_meaning_SemanticType.TEXT;
        if (type === MMLTAGS.ANNOTATIONXML) {
            leaf.role = semantic_meaning_SemanticRole.ANNOTATION;
            return leaf;
        }
        if (type === MMLTAGS.MS) {
            leaf.role = semantic_meaning_SemanticRole.STRING;
            return leaf;
        }
        if (type === MMLTAGS.MSPACE || leaf.textContent.match(/^\s*$/)) {
            leaf.role = semantic_meaning_SemanticRole.SPACE;
            return leaf;
        }
        if (/\s/.exec(leaf.textContent)) {
            leaf.role = semantic_meaning_SemanticRole.TEXT;
            return leaf;
        }
        leaf.role = semantic_meaning_SemanticRole.UNKNOWN;
        return leaf;
    }
    row(nodes) {
        nodes = nodes.filter(function (x) {
            return !isType(x, semantic_meaning_SemanticType.EMPTY);
        });
        if (nodes.length === 0) {
            return SemanticProcessor.getInstance().factory_.makeEmptyNode();
        }
        nodes = SemanticProcessor.getInstance().getFencesInRow_(nodes);
        nodes = SemanticProcessor.getInstance().tablesInRow(nodes);
        nodes = SemanticProcessor.getInstance().getPunctuationInRow_(nodes);
        nodes = SemanticProcessor.getInstance().getTextInRow_(nodes);
        nodes = SemanticProcessor.getInstance().getFunctionsInRow_(nodes);
        return SemanticProcessor.getInstance().relationsInRow_(nodes);
    }
    limitNode(mmlTag, children) {
        if (!children.length) {
            return SemanticProcessor.getInstance().factory_.makeEmptyNode();
        }
        let center = children[0];
        let type = semantic_meaning_SemanticType.UNKNOWN;
        if (!children[1]) {
            return center;
        }
        let result;
        SemanticHeuristics.run('op_with_limits', children);
        if (isLimitBase(center)) {
            result = SemanticProcessor.MML_TO_LIMIT_[mmlTag];
            const length = result.length;
            type = result.type;
            children = children.slice(0, result.length + 1);
            if ((length === 1 && isAccent(children[1])) ||
                (length === 2 &&
                    isAccent(children[1]) &&
                    isAccent(children[2]))) {
                result = SemanticProcessor.MML_TO_BOUNDS_[mmlTag];
                return SemanticProcessor.getInstance().accentNode_(center, children, result.type, result.length, result.accent);
            }
            if (length === 2) {
                if (isAccent(children[1])) {
                    center = SemanticProcessor.getInstance().accentNode_(center, [center, children[1]], {
                        MSUBSUP: semantic_meaning_SemanticType.SUBSCRIPT,
                        MUNDEROVER: semantic_meaning_SemanticType.UNDERSCORE
                    }[mmlTag], 1, true);
                    return !children[2]
                        ? center
                        : SemanticProcessor.getInstance().makeLimitNode_(center, [center, children[2]], null, semantic_meaning_SemanticType.LIMUPPER);
                }
                if (children[2] && isAccent(children[2])) {
                    center = SemanticProcessor.getInstance().accentNode_(center, [center, children[2]], {
                        MSUBSUP: semantic_meaning_SemanticType.SUPERSCRIPT,
                        MUNDEROVER: semantic_meaning_SemanticType.OVERSCORE
                    }[mmlTag], 1, true);
                    return SemanticProcessor.getInstance().makeLimitNode_(center, [center, children[1]], null, semantic_meaning_SemanticType.LIMLOWER);
                }
                if (!children[length]) {
                    type = semantic_meaning_SemanticType.LIMLOWER;
                }
            }
            return SemanticProcessor.getInstance().makeLimitNode_(center, children, null, type);
        }
        result = SemanticProcessor.MML_TO_BOUNDS_[mmlTag];
        return SemanticProcessor.getInstance().accentNode_(center, children, result.type, result.length, result.accent);
    }
    tablesInRow(nodes) {
        let partition = partitionNodes(nodes, tableIsMatrixOrVector);
        let result = [];
        for (let i = 0, matrix; (matrix = partition.rel[i]); i++) {
            result = result.concat(partition.comp.shift());
            result.push(SemanticProcessor.tableToMatrixOrVector_(matrix));
        }
        result = result.concat(partition.comp.shift());
        partition = partitionNodes(result, isTableOrMultiline);
        result = [];
        for (let i = 0, table; (table = partition.rel[i]); i++) {
            const prevNodes = partition.comp.shift();
            if (tableIsCases(table, prevNodes)) {
                SemanticProcessor.tableToCases_(table, prevNodes.pop());
            }
            result = result.concat(prevNodes);
            result.push(table);
        }
        return result.concat(partition.comp.shift());
    }
    mfenced(open, close, sepValue, children) {
        if (sepValue && children.length > 0) {
            const separators = SemanticProcessor.nextSeparatorFunction_(sepValue);
            const newChildren = [children.shift()];
            children.forEach((child) => {
                newChildren.push(SemanticProcessor.getInstance().factory_.makeContentNode(separators()));
                newChildren.push(child);
            });
            children = newChildren;
        }
        if (open && close) {
            return SemanticProcessor.getInstance().horizontalFencedNode_(SemanticProcessor.getInstance().factory_.makeContentNode(open), SemanticProcessor.getInstance().factory_.makeContentNode(close), children);
        }
        if (open) {
            children.unshift(SemanticProcessor.getInstance().factory_.makeContentNode(open));
        }
        if (close) {
            children.push(SemanticProcessor.getInstance().factory_.makeContentNode(close));
        }
        return SemanticProcessor.getInstance().row(children);
    }
    fractionLikeNode(denom, enume, linethickness, bevelled) {
        let node;
        if (!bevelled && isZeroLength(linethickness)) {
            const child0 = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.LINE, [denom], []);
            const child1 = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.LINE, [enume], []);
            node = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.MULTILINE, [child0, child1], []);
            SemanticProcessor.binomialForm_(node);
            SemanticProcessor.classifyMultiline(node);
            return node;
        }
        else {
            node = SemanticProcessor.getInstance().fractionNode_(denom, enume);
            if (bevelled) {
                node.addAnnotation('general', 'bevelled');
            }
            return node;
        }
    }
    tensor(base, lsub, lsup, rsub, rsup) {
        const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.TENSOR, [
            base,
            SemanticProcessor.getInstance().scriptNode_(lsub, semantic_meaning_SemanticRole.LEFTSUB),
            SemanticProcessor.getInstance().scriptNode_(lsup, semantic_meaning_SemanticRole.LEFTSUPER),
            SemanticProcessor.getInstance().scriptNode_(rsub, semantic_meaning_SemanticRole.RIGHTSUB),
            SemanticProcessor.getInstance().scriptNode_(rsup, semantic_meaning_SemanticRole.RIGHTSUPER)
        ], []);
        newNode.role = base.role;
        newNode.embellished = isEmbellished(base);
        return newNode;
    }
    pseudoTensor(base, sub, sup) {
        const isEmpty = (x) => !isType(x, semantic_meaning_SemanticType.EMPTY);
        const nonEmptySub = sub.filter(isEmpty).length;
        const nonEmptySup = sup.filter(isEmpty).length;
        if (!nonEmptySub && !nonEmptySup) {
            return base;
        }
        const mmlTag = nonEmptySub
            ? nonEmptySup
                ? MMLTAGS.MSUBSUP
                : MMLTAGS.MSUB
            : MMLTAGS.MSUP;
        const mmlchild = [base];
        if (nonEmptySub) {
            mmlchild.push(SemanticProcessor.getInstance().scriptNode_(sub, semantic_meaning_SemanticRole.RIGHTSUB, true));
        }
        if (nonEmptySup) {
            mmlchild.push(SemanticProcessor.getInstance().scriptNode_(sup, semantic_meaning_SemanticRole.RIGHTSUPER, true));
        }
        return SemanticProcessor.getInstance().limitNode(mmlTag, mmlchild);
    }
    font(font) {
        const mathjaxFont = SemanticProcessor.MATHJAX_FONTS[font];
        return mathjaxFont ? mathjaxFont : font;
    }
    proof(node, semantics, parse) {
        if (!semantics['inference'] && !semantics['axiom']) {
            console.log('Noise');
        }
        if (semantics['axiom']) {
            const cleaned = SemanticProcessor.getInstance().cleanInference(node.childNodes);
            const axiom = cleaned.length
                ? SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.INFERENCE, parse(cleaned), [])
                : SemanticProcessor.getInstance().factory_.makeEmptyNode();
            axiom.role = semantic_meaning_SemanticRole.AXIOM;
            axiom.mathmlTree = node;
            return axiom;
        }
        const inference = SemanticProcessor.getInstance().inference(node, semantics, parse);
        if (semantics['proof']) {
            inference.role = semantic_meaning_SemanticRole.PROOF;
            inference.childNodes[0].role = semantic_meaning_SemanticRole.FINAL;
        }
        return inference;
    }
    inference(node, semantics, parse) {
        if (semantics['inferenceRule']) {
            const formulas = SemanticProcessor.getInstance().getFormulas(node, [], parse);
            const inference = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.INFERENCE, [formulas.conclusion, formulas.premises], []);
            return inference;
        }
        const label = semantics['labelledRule'];
        const children = toArray(node.childNodes);
        const content = [];
        if (label === 'left' || label === 'both') {
            content.push(SemanticProcessor.getInstance().getLabel(node, children, parse, semantic_meaning_SemanticRole.LEFT));
        }
        if (label === 'right' || label === 'both') {
            content.push(SemanticProcessor.getInstance().getLabel(node, children, parse, semantic_meaning_SemanticRole.RIGHT));
        }
        const formulas = SemanticProcessor.getInstance().getFormulas(node, children, parse);
        const inference = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.INFERENCE, [formulas.conclusion, formulas.premises], content);
        inference.mathmlTree = node;
        return inference;
    }
    getLabel(_node, children, parse, side) {
        const label = SemanticProcessor.getInstance().findNestedRow(children, 'prooflabel', side);
        const sem = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.RULELABEL, parse(toArray(label.childNodes)), []);
        sem.role = side;
        sem.mathmlTree = label;
        return sem;
    }
    getFormulas(node, children, parse) {
        const inf = children.length
            ? SemanticProcessor.getInstance().findNestedRow(children, 'inferenceRule')
            : node;
        const up = SemanticProcessor.getSemantics(inf)['inferenceRule'] === 'up';
        const premRow = up ? inf.childNodes[1] : inf.childNodes[0];
        const concRow = up ? inf.childNodes[0] : inf.childNodes[1];
        const premTable = premRow.childNodes[0].childNodes[0];
        const topRow = toArray(premTable.childNodes[0].childNodes);
        const premNodes = [];
        let i = 1;
        for (const cell of topRow) {
            if (i % 2) {
                premNodes.push(cell.childNodes[0]);
            }
            i++;
        }
        const premises = parse(premNodes);
        const conclusion = parse(toArray(concRow.childNodes[0].childNodes))[0];
        const prem = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.PREMISES, premises, []);
        prem.mathmlTree = premTable;
        const conc = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.CONCLUSION, [conclusion], []);
        conc.mathmlTree = concRow.childNodes[0].childNodes[0];
        return { conclusion: conc, premises: prem };
    }
    findNestedRow(nodes, semantic, opt_value) {
        return SemanticProcessor.getInstance().findNestedRow_(nodes, semantic, 0, opt_value);
    }
    cleanInference(nodes) {
        return toArray(nodes).filter(function (x) {
            return dom_util_tagName(x) !== 'MSPACE';
        });
    }
    operatorNode(node) {
        if (node.type === semantic_meaning_SemanticType.UNKNOWN) {
            node.type = semantic_meaning_SemanticType.OPERATOR;
        }
        return SemanticHeuristics.run('multioperator', node);
    }
    constructor() {
        this.funcAppls = {};
        this.splitRoles = new Map([
            [semantic_meaning_SemanticRole.SUBTRACTION, semantic_meaning_SemanticRole.NEGATIVE],
            [semantic_meaning_SemanticRole.ADDITION, semantic_meaning_SemanticRole.POSITIVE]
        ]);
        this.splitOps = ['', '-', '', '', '+'];
        this.factory_ = new SemanticNodeFactory();
        SemanticHeuristics.updateFactory(this.factory_);
    }
    implicitNode_(nodes) {
        const operators = SemanticProcessor.getInstance().factory_.makeMultipleContentNodes(nodes.length - 1, NamedSymbol.invisibleTimes);
        SemanticProcessor.matchSpaces_(nodes, operators);
        const newNode = SemanticProcessor.getInstance().infixNode_(nodes, operators[0]);
        newNode.role = semantic_meaning_SemanticRole.IMPLICIT;
        operators.forEach(function (op) {
            op.parent = newNode;
        });
        newNode.contentNodes = operators;
        return newNode;
    }
    infixNode_(children, opNode) {
        let node = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.INFIXOP, children, [opNode], getEmbellishedInner(opNode).textContent);
        node.role = opNode.role;
        node = SemanticHeuristics.run('propagateInterval', node);
        return SemanticHeuristics.run('propagateSimpleFunction', node);
    }
    explicitMixed_(nodes) {
        const partition = partitionNodes(nodes, function (x) {
            return x.textContent === NamedSymbol.invisiblePlus;
        });
        if (!partition.rel.length) {
            return nodes;
        }
        let result = [];
        for (let i = 0, rel; (rel = partition.rel[i]); i++) {
            const prev = partition.comp[i];
            const next = partition.comp[i + 1];
            const last = prev.length - 1;
            if (prev[last] &&
                next[0] &&
                isType(prev[last], semantic_meaning_SemanticType.NUMBER) &&
                !isRole(prev[last], semantic_meaning_SemanticRole.MIXED) &&
                isType(next[0], semantic_meaning_SemanticType.FRACTION)) {
                const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.NUMBER, [prev[last], next[0]], []);
                newNode.role = semantic_meaning_SemanticRole.MIXED;
                result = result.concat(prev.slice(0, last));
                result.push(newNode);
                next.shift();
            }
            else {
                result = result.concat(prev);
                result.push(rel);
            }
        }
        return result.concat(partition.comp[partition.comp.length - 1]);
    }
    concatNode_(inner, nodeList, type) {
        if (nodeList.length === 0) {
            return inner;
        }
        const content = nodeList
            .map(function (x) {
            return getEmbellishedInner(x).textContent;
        })
            .join(' ');
        const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(type, [inner], nodeList, content);
        if (nodeList.length > 1) {
            newNode.role = semantic_meaning_SemanticRole.MULTIOP;
        }
        return newNode;
    }
    prefixNode_(node, prefixes) {
        const newPrefixes = this.splitSingles(prefixes);
        let newNode = node;
        while (newPrefixes.length > 0) {
            const op = newPrefixes.pop();
            newNode = SemanticProcessor.getInstance().concatNode_(newNode, op, semantic_meaning_SemanticType.PREFIXOP);
            if (op.length === 1 && this.splitOps.indexOf(op[0].textContent) !== -1) {
                newNode.role = this.splitRoles.get(op[0].role);
            }
        }
        return newNode;
    }
    splitSingles(prefixes) {
        let lastOp = 0;
        const result = [];
        let i = 0;
        while (i < prefixes.length) {
            const op = prefixes[i];
            if (this.splitRoles.has(op.role) &&
                (!prefixes[i - 1] || prefixes[i - 1].role !== op.role) &&
                (!prefixes[i + 1] || prefixes[i + 1].role !== op.role) &&
                this.splitOps.indexOf(op.textContent) !== -1) {
                result.push(prefixes.slice(lastOp, i));
                result.push(prefixes.slice(i, i + 1));
                lastOp = i + 1;
            }
            i++;
        }
        if (lastOp < i) {
            result.push(prefixes.slice(lastOp, i));
        }
        return result;
    }
    postfixNode_(node, postfixes) {
        if (!postfixes.length) {
            return node;
        }
        return SemanticProcessor.getInstance().concatNode_(node, postfixes, semantic_meaning_SemanticType.POSTFIXOP);
    }
    combineUnits_(nodes) {
        const partition = partitionNodes(nodes, function (x) {
            return !isRole(x, semantic_meaning_SemanticRole.UNIT);
        });
        if (nodes.length === partition.rel.length) {
            return partition.rel;
        }
        const result = [];
        let rel;
        let last;
        do {
            const comp = partition.comp.shift();
            rel = partition.rel.shift();
            let unitNode = null;
            last = result.pop();
            if (last) {
                if (!comp.length || !isUnitCounter(last)) {
                    result.push(last);
                }
                else {
                    comp.unshift(last);
                }
            }
            if (comp.length === 1) {
                unitNode = comp.pop();
            }
            if (comp.length > 1) {
                unitNode = SemanticProcessor.getInstance().implicitNode_(comp);
                unitNode.role = semantic_meaning_SemanticRole.UNIT;
            }
            if (unitNode) {
                result.push(unitNode);
            }
            if (rel) {
                result.push(rel);
            }
        } while (rel);
        return result;
    }
    getMixedNumbers_(nodes) {
        const partition = partitionNodes(nodes, function (x) {
            return (isType(x, semantic_meaning_SemanticType.FRACTION) &&
                isRole(x, semantic_meaning_SemanticRole.VULGAR));
        });
        if (!partition.rel.length) {
            return nodes;
        }
        let result = [];
        for (let i = 0, rel; (rel = partition.rel[i]); i++) {
            const comp = partition.comp[i];
            const last = comp.length - 1;
            if (comp[last] &&
                isType(comp[last], semantic_meaning_SemanticType.NUMBER) &&
                (isRole(comp[last], semantic_meaning_SemanticRole.INTEGER) ||
                    isRole(comp[last], semantic_meaning_SemanticRole.FLOAT))) {
                const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.NUMBER, [comp[last], rel], []);
                newNode.role = semantic_meaning_SemanticRole.MIXED;
                result = result.concat(comp.slice(0, last));
                result.push(newNode);
            }
            else {
                result = result.concat(comp);
                result.push(rel);
            }
        }
        return result.concat(partition.comp[partition.comp.length - 1]);
    }
    getTextInRow_(nodes) {
        if (nodes.length === 0) {
            return nodes;
        }
        if (nodes.length === 1) {
            if (nodes[0].type === semantic_meaning_SemanticType.TEXT &&
                nodes[0].role === semantic_meaning_SemanticRole.UNKNOWN) {
                nodes[0].role = semantic_meaning_SemanticRole.ANNOTATION;
            }
            return nodes;
        }
        const { rel: rel, comp: comp } = partitionNodes(nodes, (x) => isType(x, semantic_meaning_SemanticType.TEXT));
        if (rel.length === 0) {
            return nodes;
        }
        const result = [];
        let prevComp = comp.shift();
        while (rel.length > 0) {
            let currentRel = rel.shift();
            let nextComp = comp.shift();
            const text = [];
            while (!nextComp.length &&
                rel.length &&
                currentRel.role !== semantic_meaning_SemanticRole.SPACE &&
                rel[0].role !== semantic_meaning_SemanticRole.SPACE) {
                text.push(currentRel);
                currentRel = rel.shift();
                nextComp = comp.shift();
            }
            if (text.length) {
                if (prevComp.length) {
                    result.push(SemanticProcessor.getInstance().row(prevComp));
                }
                text.push(currentRel);
                const dummy = SemanticProcessor.getInstance().dummyNode_(text);
                result.push(dummy);
                prevComp = nextComp;
                continue;
            }
            if (currentRel.role !== semantic_meaning_SemanticRole.UNKNOWN) {
                if (prevComp.length) {
                    result.push(SemanticProcessor.getInstance().row(prevComp));
                }
                result.push(currentRel);
                prevComp = nextComp;
                continue;
            }
            const meaning = SemanticMap.Meaning.get(currentRel.textContent);
            if (meaning.type === semantic_meaning_SemanticType.PUNCTUATION) {
                currentRel.role = meaning.role;
                currentRel.font = meaning.font;
                if (prevComp.length) {
                    result.push(SemanticProcessor.getInstance().row(prevComp));
                }
                result.push(currentRel);
                prevComp = nextComp;
                continue;
            }
            if (meaning.type !== semantic_meaning_SemanticType.UNKNOWN) {
                currentRel.type = meaning.type;
                currentRel.role = meaning.role;
                currentRel.font = meaning.font;
                currentRel.addAnnotation('general', 'text');
                prevComp.push(currentRel);
                prevComp = prevComp.concat(nextComp);
                continue;
            }
            SemanticProcessor.meaningFromContent(currentRel, (n, c, m) => {
                if (n.role !== semantic_meaning_SemanticRole.UNKNOWN) {
                    return;
                }
                SemanticProcessor.numberRole_(n, c, m);
                if (n.role !== semantic_meaning_SemanticRole.OTHERNUMBER) {
                    n.type = semantic_meaning_SemanticType.NUMBER;
                    return;
                }
                if (m.some((x) => x.type !== semantic_meaning_SemanticType.NUMBER &&
                    x.type !== semantic_meaning_SemanticType.IDENTIFIER)) {
                    n.type = semantic_meaning_SemanticType.TEXT;
                    n.role = semantic_meaning_SemanticRole.ANNOTATION;
                    return;
                }
                n.role = semantic_meaning_SemanticRole.UNKNOWN;
            });
            if (currentRel.type === semantic_meaning_SemanticType.TEXT &&
                currentRel.role !== semantic_meaning_SemanticRole.UNKNOWN) {
                if (prevComp.length) {
                    result.push(SemanticProcessor.getInstance().row(prevComp));
                }
                result.push(currentRel);
                prevComp = nextComp;
                continue;
            }
            if (currentRel.role === semantic_meaning_SemanticRole.UNKNOWN) {
                if (rel.length || nextComp.length) {
                    if (nextComp.length && nextComp[0].type === semantic_meaning_SemanticType.FENCED) {
                        currentRel.type = semantic_meaning_SemanticType.FUNCTION;
                        currentRel.role = semantic_meaning_SemanticRole.PREFIXFUNC;
                    }
                    else {
                        currentRel.role = semantic_meaning_SemanticRole.TEXT;
                    }
                }
                else {
                    currentRel.type = semantic_meaning_SemanticType.IDENTIFIER;
                    currentRel.role = semantic_meaning_SemanticRole.UNIT;
                }
            }
            prevComp.push(currentRel);
            prevComp = prevComp.concat(nextComp);
        }
        if (prevComp.length > 0) {
            result.push(SemanticProcessor.getInstance().row(prevComp));
        }
        return result.length > 1
            ? [SemanticProcessor.getInstance().dummyNode_(result)]
            : result;
    }
    relationsInRow_(nodes) {
        const partition = partitionNodes(nodes, isRelation);
        const firstRel = partition.rel[0];
        if (!firstRel) {
            return SemanticProcessor.getInstance().operationsInRow_(nodes);
        }
        if (nodes.length === 1) {
            return nodes[0];
        }
        const children = partition.comp.map(SemanticProcessor.getInstance().operationsInRow_);
        let node;
        if (partition.rel.some(function (x) {
            return !x.equals(firstRel);
        })) {
            node = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.MULTIREL, children, partition.rel);
            if (partition.rel.every(function (x) {
                return x.role === firstRel.role;
            })) {
                node.role = firstRel.role;
            }
            return node;
        }
        node = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.RELSEQ, children, partition.rel, getEmbellishedInner(firstRel).textContent);
        node.role = firstRel.role;
        return node;
    }
    operationsInRow_(nodes) {
        if (nodes.length === 0) {
            return SemanticProcessor.getInstance().factory_.makeEmptyNode();
        }
        nodes = SemanticProcessor.getInstance().explicitMixed_(nodes);
        if (nodes.length === 1) {
            return nodes[0];
        }
        const prefix = [];
        while (nodes.length > 0 && isOperator(nodes[0])) {
            prefix.push(nodes.shift());
        }
        if (nodes.length === 0) {
            return SemanticProcessor.getInstance().prefixNode_(prefix.pop(), prefix);
        }
        if (nodes.length === 1) {
            return SemanticProcessor.getInstance().prefixNode_(nodes[0], prefix);
        }
        nodes = SemanticHeuristics.run('convert_juxtaposition', nodes);
        const split = sliceNodes(nodes, isOperator);
        const node = SemanticProcessor.getInstance().wrapFactor(prefix, split);
        return SemanticProcessor.getInstance().addFactor(node, split);
    }
    wrapPostfix(split) {
        var _a;
        if (((_a = split.div) === null || _a === void 0 ? void 0 : _a.role) === semantic_meaning_SemanticRole.POSTFIXOP) {
            if (!split.tail.length || split.tail[0].type === semantic_meaning_SemanticType.OPERATOR) {
                split.head = [
                    SemanticProcessor.getInstance().postfixNode_(SemanticProcessor.getInstance().implicitNode(split.head), [split.div])
                ];
                split.div = split.tail.shift();
                SemanticProcessor.getInstance().wrapPostfix(split);
            }
            else {
                split.div.role = semantic_meaning_SemanticRole.DIVISION;
            }
        }
    }
    wrapFactor(prefix, split) {
        SemanticProcessor.getInstance().wrapPostfix(split);
        return SemanticProcessor.getInstance().prefixNode_(SemanticProcessor.getInstance().implicitNode(split.head), prefix);
    }
    addFactor(node, split) {
        if (!split.div) {
            if (isUnitProduct(node)) {
                node.role = semantic_meaning_SemanticRole.UNIT;
            }
            return node;
        }
        return SemanticProcessor.getInstance().operationsTree_(split.tail, node, split.div);
    }
    operationsTree_(nodes, root, lastop, prefix = []) {
        if (nodes.length === 0) {
            prefix.unshift(lastop);
            if (root.type === semantic_meaning_SemanticType.INFIXOP) {
                const node = SemanticProcessor.getInstance().postfixNode_(root.childNodes.pop(), prefix);
                root.appendChild(node);
                return root;
            }
            return SemanticProcessor.getInstance().postfixNode_(root, prefix);
        }
        const split = sliceNodes(nodes, isOperator);
        if (split.head.length === 0) {
            prefix.push(split.div);
            return SemanticProcessor.getInstance().operationsTree_(split.tail, root, lastop, prefix);
        }
        const node = SemanticProcessor.getInstance().wrapFactor(prefix, split);
        const newNode = SemanticProcessor.getInstance().appendOperand_(root, lastop, node);
        return SemanticProcessor.getInstance().addFactor(newNode, split);
    }
    appendOperand_(root, op, node) {
        if (root.type !== semantic_meaning_SemanticType.INFIXOP) {
            return SemanticProcessor.getInstance().infixNode_([root, node], op);
        }
        const division = SemanticProcessor.getInstance().appendDivisionOp_(root, op, node);
        if (division) {
            return division;
        }
        if (SemanticProcessor.getInstance().appendExistingOperator_(root, op, node)) {
            return root;
        }
        return op.role === semantic_meaning_SemanticRole.MULTIPLICATION
            ? SemanticProcessor.getInstance().appendMultiplicativeOp_(root, op, node)
            : SemanticProcessor.getInstance().appendAdditiveOp_(root, op, node);
    }
    appendDivisionOp_(root, op, node) {
        if (op.role === semantic_meaning_SemanticRole.DIVISION) {
            if (isImplicit(root)) {
                return SemanticProcessor.getInstance().infixNode_([root, node], op);
            }
            return SemanticProcessor.getInstance().appendLastOperand_(root, op, node);
        }
        return root.role === semantic_meaning_SemanticRole.DIVISION
            ? SemanticProcessor.getInstance().infixNode_([root, node], op)
            : null;
    }
    appendLastOperand_(root, op, node) {
        let lastRoot = root;
        let lastChild = root.childNodes[root.childNodes.length - 1];
        while (lastChild &&
            lastChild.type === semantic_meaning_SemanticType.INFIXOP &&
            !isImplicit(lastChild)) {
            lastRoot = lastChild;
            lastChild = lastRoot.childNodes[root.childNodes.length - 1];
        }
        const newNode = SemanticProcessor.getInstance().infixNode_([lastRoot.childNodes.pop(), node], op);
        lastRoot.appendChild(newNode);
        return root;
    }
    appendMultiplicativeOp_(root, op, node) {
        if (isImplicit(root)) {
            return SemanticProcessor.getInstance().infixNode_([root, node], op);
        }
        let lastRoot = root;
        let lastChild = root.childNodes[root.childNodes.length - 1];
        while (lastChild &&
            lastChild.type === semantic_meaning_SemanticType.INFIXOP &&
            !isImplicit(lastChild)) {
            lastRoot = lastChild;
            lastChild = lastRoot.childNodes[root.childNodes.length - 1];
        }
        const newNode = SemanticProcessor.getInstance().infixNode_([lastRoot.childNodes.pop(), node], op);
        lastRoot.appendChild(newNode);
        return root;
    }
    appendAdditiveOp_(root, op, node) {
        return SemanticProcessor.getInstance().infixNode_([root, node], op);
    }
    appendExistingOperator_(root, op, node) {
        if (!root ||
            root.type !== semantic_meaning_SemanticType.INFIXOP ||
            isImplicit(root)) {
            return false;
        }
        if (root.contentNodes[0].equals(op)) {
            root.appendContentNode(op);
            root.appendChild(node);
            return true;
        }
        return SemanticProcessor.getInstance().appendExistingOperator_(root.childNodes[root.childNodes.length - 1], op, node);
    }
    getFencesInRow_(nodes) {
        let partition = partitionNodes(nodes, isFence);
        partition = SemanticProcessor.purgeFences_(partition);
        const felem = partition.comp.shift();
        return SemanticProcessor.getInstance().fences_(partition.rel, partition.comp, [], [felem]);
    }
    fences_(fences, content, openStack, contentStack) {
        if (fences.length === 0 && openStack.length === 0) {
            return contentStack[0];
        }
        const interval = SemanticHeuristics.run('bracketed_interval', [fences[0], fences[1], ...(content[0] || [])], () => null);
        if (interval) {
            fences.shift();
            fences.shift();
            content.shift();
            const stack = contentStack.pop() || [];
            contentStack.push([...stack, interval, ...content.shift()]);
            return SemanticProcessor.getInstance().fences_(fences, content, openStack, contentStack);
        }
        const openPred = (x) => isRole(x, semantic_meaning_SemanticRole.OPEN);
        if (fences.length === 0) {
            const result = contentStack.shift();
            while (openStack.length > 0) {
                if (openPred(openStack[0])) {
                    const firstOpen = openStack.shift();
                    SemanticProcessor.fenceToPunct_(firstOpen);
                    result.push(firstOpen);
                }
                else {
                    const split = sliceNodes(openStack, openPred);
                    const cutLength = split.head.length - 1;
                    const innerNodes = SemanticProcessor.getInstance().neutralFences_(split.head, contentStack.slice(0, cutLength));
                    contentStack = contentStack.slice(cutLength);
                    result.push(...innerNodes);
                    if (split.div) {
                        split.tail.unshift(split.div);
                    }
                    openStack = split.tail;
                }
                result.push(...contentStack.shift());
            }
            return result;
        }
        const lastOpen = openStack[openStack.length - 1];
        const firstRole = fences[0].role;
        if (firstRole === semantic_meaning_SemanticRole.OPEN ||
            (isNeutralFence(fences[0]) &&
                !(lastOpen && compareNeutralFences(fences[0], lastOpen)))) {
            openStack.push(fences.shift());
            const cont = content.shift();
            if (cont) {
                contentStack.push(cont);
            }
            return SemanticProcessor.getInstance().fences_(fences, content, openStack, contentStack);
        }
        if (lastOpen &&
            firstRole === semantic_meaning_SemanticRole.CLOSE &&
            lastOpen.role === semantic_meaning_SemanticRole.OPEN) {
            const fenced = SemanticProcessor.getInstance().horizontalFencedNode_(openStack.pop(), fences.shift(), contentStack.pop());
            contentStack.push(contentStack.pop().concat([fenced], content.shift()));
            return SemanticProcessor.getInstance().fences_(fences, content, openStack, contentStack);
        }
        if (lastOpen &&
            compareNeutralFences(fences[0], lastOpen)) {
            if (!elligibleLeftNeutral(lastOpen) ||
                !elligibleRightNeutral(fences[0])) {
                openStack.push(fences.shift());
                const cont = content.shift();
                if (cont) {
                    contentStack.push(cont);
                }
                return SemanticProcessor.getInstance().fences_(fences, content, openStack, contentStack);
            }
            const fenced = SemanticProcessor.getInstance().horizontalFencedNode_(openStack.pop(), fences.shift(), contentStack.pop());
            contentStack.push(contentStack.pop().concat([fenced], content.shift()));
            return SemanticProcessor.getInstance().fences_(fences, content, openStack, contentStack);
        }
        if (lastOpen &&
            firstRole === semantic_meaning_SemanticRole.CLOSE &&
            isNeutralFence(lastOpen) &&
            openStack.some(openPred)) {
            const split = sliceNodes(openStack, openPred, true);
            const rightContent = contentStack.pop();
            const cutLength = contentStack.length - split.tail.length + 1;
            const innerNodes = SemanticProcessor.getInstance().neutralFences_(split.tail, contentStack.slice(cutLength));
            contentStack = contentStack.slice(0, cutLength);
            const fenced = SemanticProcessor.getInstance().horizontalFencedNode_(split.div, fences.shift(), contentStack.pop().concat(innerNodes, rightContent));
            contentStack.push(contentStack.pop().concat([fenced], content.shift()));
            return SemanticProcessor.getInstance().fences_(fences, content, split.head, contentStack);
        }
        const fenced = fences.shift();
        SemanticProcessor.fenceToPunct_(fenced);
        contentStack.push(contentStack.pop().concat([fenced], content.shift()));
        return SemanticProcessor.getInstance().fences_(fences, content, openStack, contentStack);
    }
    neutralFences_(fences, content) {
        if (fences.length === 0) {
            return fences;
        }
        if (fences.length === 1) {
            SemanticProcessor.fenceToPunct_(fences[0]);
            return fences;
        }
        const firstFence = fences.shift();
        if (!elligibleLeftNeutral(firstFence)) {
            SemanticProcessor.fenceToPunct_(firstFence);
            const restContent = content.shift();
            restContent.unshift(firstFence);
            return restContent.concat(SemanticProcessor.getInstance().neutralFences_(fences, content));
        }
        const split = sliceNodes(fences, function (x) {
            return compareNeutralFences(x, firstFence);
        });
        if (!split.div) {
            SemanticProcessor.fenceToPunct_(firstFence);
            const restContent = content.shift();
            restContent.unshift(firstFence);
            return restContent.concat(SemanticProcessor.getInstance().neutralFences_(fences, content));
        }
        if (!elligibleRightNeutral(split.div)) {
            SemanticProcessor.fenceToPunct_(split.div);
            fences.unshift(firstFence);
            return SemanticProcessor.getInstance().neutralFences_(fences, content);
        }
        const newContent = SemanticProcessor.getInstance().combineFencedContent_(firstFence, split.div, split.head, content);
        if (split.tail.length > 0) {
            const leftContent = newContent.shift();
            const result = SemanticProcessor.getInstance().neutralFences_(split.tail, newContent);
            return leftContent.concat(result);
        }
        return newContent[0];
    }
    combineFencedContent_(leftFence, rightFence, midFences, content) {
        if (midFences.length === 0) {
            const fenced = SemanticProcessor.getInstance().horizontalFencedNode_(leftFence, rightFence, content.shift());
            if (content.length > 0) {
                content[0].unshift(fenced);
            }
            else {
                content = [[fenced]];
            }
            return content;
        }
        const leftContent = content.shift();
        const cutLength = midFences.length - 1;
        const midContent = content.slice(0, cutLength);
        content = content.slice(cutLength);
        const rightContent = content.shift();
        const innerNodes = SemanticProcessor.getInstance().neutralFences_(midFences, midContent);
        leftContent.push(...innerNodes);
        leftContent.push(...rightContent);
        const fenced = SemanticProcessor.getInstance().horizontalFencedNode_(leftFence, rightFence, leftContent);
        if (content.length > 0) {
            content[0].unshift(fenced);
        }
        else {
            content = [[fenced]];
        }
        return content;
    }
    horizontalFencedNode_(ofence, cfence, content) {
        const childNode = SemanticProcessor.getInstance().row(content);
        let newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.FENCED, [childNode], [ofence, cfence]);
        if (ofence.role === semantic_meaning_SemanticRole.OPEN) {
            SemanticProcessor.getInstance().classifyHorizontalFence_(newNode);
            newNode = SemanticHeuristics.run('propagateComposedFunction', newNode);
        }
        else {
            newNode.role = ofence.role;
        }
        newNode = SemanticHeuristics.run('detect_cycle', newNode);
        return SemanticProcessor.rewriteFencedNode_(newNode);
    }
    classifyHorizontalFence_(node) {
        SemanticHeuristics.run('interval_heuristic', node);
        if (node.role === semantic_meaning_SemanticRole.INTERVAL) {
            return;
        }
        ;
        node.role = semantic_meaning_SemanticRole.LEFTRIGHT;
        const children = node.childNodes;
        if (!isSetNode(node) || children.length > 1) {
            return;
        }
        if (children.length === 0 || children[0].type === semantic_meaning_SemanticType.EMPTY) {
            node.role = semantic_meaning_SemanticRole.SETEMPTY;
            return;
        }
        const type = children[0].type;
        if (children.length === 1 &&
            isSingletonSetContent(children[0])) {
            node.role = semantic_meaning_SemanticRole.SETSINGLE;
            return;
        }
        const role = children[0].role;
        if (type !== semantic_meaning_SemanticType.PUNCTUATED || role !== semantic_meaning_SemanticRole.SEQUENCE) {
            return;
        }
        if (children[0].contentNodes[0].role === semantic_meaning_SemanticRole.COMMA) {
            node.role = semantic_meaning_SemanticRole.SETCOLLECT;
            return;
        }
        if (children[0].contentNodes.length === 1 &&
            (children[0].contentNodes[0].role === semantic_meaning_SemanticRole.VBAR ||
                children[0].contentNodes[0].role === semantic_meaning_SemanticRole.COLON)) {
            node.role = semantic_meaning_SemanticRole.SETEXT;
            SemanticProcessor.getInstance().setExtension_(node);
            return;
        }
    }
    setExtension_(set) {
        const extender = set.childNodes[0].childNodes[0];
        if (extender &&
            extender.type === semantic_meaning_SemanticType.INFIXOP &&
            extender.contentNodes.length === 1 &&
            isMembership(extender.contentNodes[0])) {
            extender.addAnnotation('set', 'intensional');
            extender.contentNodes[0].addAnnotation('set', 'intensional');
        }
    }
    getPunctuationInRow_(nodes) {
        if (nodes.length <= 1) {
            return nodes;
        }
        const allowedType = (x) => {
            const type = x.type;
            return (type === 'punctuation' ||
                type === 'text' ||
                type === 'operator' ||
                type === 'relation');
        };
        const partition = partitionNodes(nodes, function (x) {
            if (!isPunctuation(x)) {
                return false;
            }
            if (isPunctuation(x) &&
                !isRole(x, semantic_meaning_SemanticRole.ELLIPSIS)) {
                return true;
            }
            const index = nodes.indexOf(x);
            if (index === 0) {
                if (nodes[1] && allowedType(nodes[1])) {
                    return false;
                }
                return true;
            }
            const prev = nodes[index - 1];
            if (index === nodes.length - 1) {
                if (allowedType(prev)) {
                    return false;
                }
                return true;
            }
            const next = nodes[index + 1];
            if (allowedType(prev) && allowedType(next)) {
                return false;
            }
            return true;
        });
        if (partition.rel.length === 0) {
            return nodes;
        }
        let newNodes = [];
        let firstComp = partition.comp.shift();
        if (firstComp.length > 0) {
            newNodes.push(SemanticProcessor.getInstance().row(firstComp));
        }
        let relCounter = 0;
        while (partition.comp.length > 0) {
            let puncts = [];
            const saveCount = relCounter;
            do {
                puncts.push(partition.rel[relCounter++]);
                firstComp = partition.comp.shift();
            } while (partition.rel[relCounter] &&
                firstComp &&
                firstComp.length === 0);
            puncts = SemanticHeuristics.run('ellipses', puncts);
            partition.rel.splice(saveCount, relCounter - saveCount, ...puncts);
            relCounter = saveCount + puncts.length;
            newNodes = newNodes.concat(puncts);
            if (firstComp && firstComp.length > 0) {
                newNodes.push(SemanticProcessor.getInstance().row(firstComp));
            }
        }
        return newNodes.length === 1 && partition.rel.length === 1
            ? newNodes
            : [
                SemanticProcessor.getInstance().punctuatedNode_(newNodes, partition.rel)
            ];
    }
    punctuatedNode_(nodes, punctuations) {
        const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.PUNCTUATED, nodes, punctuations);
        if (punctuations.length === nodes.length) {
            const firstRole = punctuations[0].role;
            if (firstRole !== semantic_meaning_SemanticRole.UNKNOWN &&
                punctuations.every(function (punct) {
                    return punct.role === firstRole;
                })) {
                newNode.role = firstRole;
                return newNode;
            }
        }
        const fpunct = punctuations[0];
        if (singlePunctAtPosition(nodes, punctuations, 0)) {
            newNode.role =
                fpunct.childNodes.length && !fpunct.embellished
                    ? fpunct.role
                    : semantic_meaning_SemanticRole.STARTPUNCT;
        }
        else if (singlePunctAtPosition(nodes, punctuations, nodes.length - 1)) {
            newNode.role =
                fpunct.childNodes.length && !fpunct.embellished
                    ? fpunct.role
                    : semantic_meaning_SemanticRole.ENDPUNCT;
        }
        else if (punctuations.every((x) => isRole(x, semantic_meaning_SemanticRole.DUMMY))) {
            newNode.role = semantic_meaning_SemanticRole.TEXT;
        }
        else if (punctuations.every((x) => isRole(x, semantic_meaning_SemanticRole.SPACE))) {
            newNode.role = semantic_meaning_SemanticRole.SPACE;
        }
        else {
            newNode.role = semantic_meaning_SemanticRole.SEQUENCE;
        }
        return newNode;
    }
    dummyNode_(children) {
        const commata = SemanticProcessor.getInstance().factory_.makeMultipleContentNodes(children.length - 1, NamedSymbol.invisibleComma);
        commata.forEach(function (comma) {
            comma.role = semantic_meaning_SemanticRole.DUMMY;
        });
        return SemanticProcessor.getInstance().punctuatedNode_(children, commata);
    }
    accentRole_(node, type) {
        if (!isAccent(node)) {
            return false;
        }
        const content = node.textContent;
        const role = SemanticMap.Secondary.get(content, SemanticSecondary.BAR) ||
            SemanticMap.Secondary.get(content, SemanticSecondary.TILDE) ||
            node.role;
        node.role =
            type === semantic_meaning_SemanticType.UNDERSCORE
                ? semantic_meaning_SemanticRole.UNDERACCENT
                : semantic_meaning_SemanticRole.OVERACCENT;
        node.addAnnotation('accent', role);
        return true;
    }
    accentNode_(center, children, type, length, accent) {
        children = children.slice(0, length + 1);
        const child1 = children[1];
        const child2 = children[2];
        let innerNode;
        if (!accent && child2) {
            innerNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.SUBSCRIPT, [center, child1], []);
            innerNode.role = semantic_meaning_SemanticRole.SUBSUP;
            children = [innerNode, child2];
            type = semantic_meaning_SemanticType.SUPERSCRIPT;
        }
        if (accent) {
            const underAccent = SemanticProcessor.getInstance().accentRole_(child1, type);
            if (child2) {
                const overAccent = SemanticProcessor.getInstance().accentRole_(child2, semantic_meaning_SemanticType.OVERSCORE);
                if (overAccent && !underAccent) {
                    innerNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.OVERSCORE, [center, child2], []);
                    children = [innerNode, child1];
                    type = semantic_meaning_SemanticType.UNDERSCORE;
                }
                else {
                    innerNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.UNDERSCORE, [center, child1], []);
                    children = [innerNode, child2];
                    type = semantic_meaning_SemanticType.OVERSCORE;
                }
                innerNode.role = semantic_meaning_SemanticRole.UNDEROVER;
            }
        }
        return SemanticProcessor.getInstance().makeLimitNode_(center, children, innerNode, type);
    }
    makeLimitNode_(center, children, innerNode, type) {
        if (type === semantic_meaning_SemanticType.LIMUPPER &&
            center.type === semantic_meaning_SemanticType.LIMLOWER) {
            center.childNodes.push(children[1]);
            children[1].parent = center;
            center.type = semantic_meaning_SemanticType.LIMBOTH;
            return center;
        }
        if (type === semantic_meaning_SemanticType.LIMLOWER &&
            center.type === semantic_meaning_SemanticType.LIMUPPER) {
            center.childNodes.splice(1, -1, children[1]);
            children[1].parent = center;
            center.type = semantic_meaning_SemanticType.LIMBOTH;
            return center;
        }
        const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(type, children, []);
        const embellished = isEmbellished(center);
        if (innerNode) {
            innerNode.embellished = embellished;
        }
        newNode.embellished = embellished;
        newNode.role = center.role;
        return newNode;
    }
    getFunctionsInRow_(restNodes, opt_result) {
        const result = opt_result || [];
        if (restNodes.length === 0) {
            return result;
        }
        const firstNode = restNodes.shift();
        const heuristic = SemanticProcessor.classifyFunction_(firstNode, restNodes);
        if (!heuristic) {
            result.push(firstNode);
            return SemanticProcessor.getInstance().getFunctionsInRow_(restNodes, result);
        }
        const processedRest = SemanticProcessor.getInstance().getFunctionsInRow_(restNodes, []);
        const newRest = SemanticProcessor.getInstance().getFunctionArgs_(firstNode, processedRest, heuristic);
        return result.concat(newRest);
    }
    getFunctionArgs_(func, rest, heuristic) {
        let partition, arg, funcNode;
        switch (heuristic) {
            case 'integral': {
                const components = SemanticProcessor.getInstance().getIntegralArgs_(rest);
                if (!components.intvar && !components.integrand.length) {
                    components.rest.unshift(func);
                    return components.rest;
                }
                const integrand = SemanticProcessor.getInstance().row(components.integrand);
                funcNode = SemanticProcessor.getInstance().integralNode_(func, integrand, components.intvar);
                SemanticHeuristics.run('intvar_from_fraction', funcNode);
                components.rest.unshift(funcNode);
                return components.rest;
            }
            case 'prefix': {
                if (rest[0] && rest[0].type === semantic_meaning_SemanticType.FENCED) {
                    const arg = rest.shift();
                    if (!isNeutralFence(arg)) {
                        arg.role = semantic_meaning_SemanticRole.LEFTRIGHT;
                    }
                    funcNode = SemanticProcessor.getInstance().functionNode_(func, arg);
                    rest.unshift(funcNode);
                    return rest;
                }
                partition = sliceNodes(rest, isPrefixFunctionBoundary);
                if (!partition.head.length) {
                    if (!partition.div ||
                        !isType(partition.div, semantic_meaning_SemanticType.APPL)) {
                        rest.unshift(func);
                        return rest;
                    }
                    arg = partition.div;
                }
                else {
                    arg = SemanticProcessor.getInstance().row(partition.head);
                    if (partition.div) {
                        partition.tail.unshift(partition.div);
                    }
                }
                funcNode = SemanticProcessor.getInstance().functionNode_(func, arg);
                partition.tail.unshift(funcNode);
                return partition.tail;
            }
            case 'bigop': {
                partition = sliceNodes(rest, isBigOpBoundary);
                if (!partition.head.length) {
                    rest.unshift(func);
                    return rest;
                }
                arg = SemanticProcessor.getInstance().row(partition.head);
                funcNode = SemanticProcessor.getInstance().bigOpNode_(func, arg);
                if (partition.div) {
                    partition.tail.unshift(partition.div);
                }
                partition.tail.unshift(funcNode);
                return partition.tail;
            }
            case 'simple':
            default: {
                if (rest.length === 0) {
                    return [func];
                }
                const firstArg = rest[0];
                if (firstArg.type === semantic_meaning_SemanticType.FENCED &&
                    !isNeutralFence(firstArg) &&
                    isSimpleFunctionScope(firstArg)) {
                    firstArg.role = semantic_meaning_SemanticRole.LEFTRIGHT;
                    SemanticProcessor.propagateFunctionRole_(func, semantic_meaning_SemanticRole.SIMPLEFUNC);
                    funcNode = SemanticProcessor.getInstance().functionNode_(func, rest.shift());
                    rest.unshift(funcNode);
                    return rest;
                }
                rest.unshift(func);
                return rest;
            }
        }
    }
    getIntegralArgs_(nodes, args = []) {
        if (nodes.length === 0) {
            const partition = sliceNodes(args, isBigOpBoundary);
            if (partition.div) {
                partition.tail.unshift(partition.div);
            }
            return { integrand: partition.head, intvar: null, rest: partition.tail };
        }
        SemanticHeuristics.run('intvar_from_implicit', nodes);
        const firstNode = nodes[0];
        if (isGeneralFunctionBoundary(firstNode)) {
            const { integrand: args2, rest: rest2 } = SemanticProcessor.getInstance().getIntegralArgs_(args);
            return { integrand: args2, intvar: null, rest: rest2.concat(nodes) };
        }
        if (isIntegralDxBoundarySingle(firstNode)) {
            firstNode.role = semantic_meaning_SemanticRole.INTEGRAL;
            return { integrand: args, intvar: firstNode, rest: nodes.slice(1) };
        }
        if (nodes[1] && isIntegralDxBoundary(firstNode, nodes[1])) {
            const intvar = SemanticProcessor.getInstance().prefixNode_(nodes[1], [firstNode]);
            intvar.role = semantic_meaning_SemanticRole.INTEGRAL;
            return { integrand: args, intvar: intvar, rest: nodes.slice(2) };
        }
        args.push(nodes.shift());
        return SemanticProcessor.getInstance().getIntegralArgs_(nodes, args);
    }
    functionNode_(func, arg) {
        const applNode = SemanticProcessor.getInstance().factory_.makeContentNode(NamedSymbol.functionApplication);
        const appl = SemanticProcessor.getInstance().funcAppls[func.id];
        if (appl) {
            applNode.mathmlTree = appl.mathmlTree;
            applNode.mathml = appl.mathml;
            applNode.annotation = appl.annotation;
            applNode.attributes = appl.attributes;
            delete SemanticProcessor.getInstance().funcAppls[func.id];
        }
        applNode.type = semantic_meaning_SemanticType.PUNCTUATION;
        applNode.role = semantic_meaning_SemanticRole.APPLICATION;
        const funcop = SemanticProcessor.getFunctionOp_(func, function (node) {
            return (isType(node, semantic_meaning_SemanticType.FUNCTION) ||
                (isType(node, semantic_meaning_SemanticType.IDENTIFIER) &&
                    isRole(node, semantic_meaning_SemanticRole.SIMPLEFUNC)));
        });
        return SemanticProcessor.getInstance().functionalNode_(semantic_meaning_SemanticType.APPL, [func, arg], funcop, [applNode]);
    }
    bigOpNode_(bigOp, arg) {
        const largeop = SemanticProcessor.getFunctionOp_(bigOp, (x) => isType(x, semantic_meaning_SemanticType.LARGEOP));
        return SemanticProcessor.getInstance().functionalNode_(semantic_meaning_SemanticType.BIGOP, [bigOp, arg], largeop, []);
    }
    integralNode_(integral, integrand, intvar) {
        integrand =
            integrand || SemanticProcessor.getInstance().factory_.makeEmptyNode();
        intvar = intvar || SemanticProcessor.getInstance().factory_.makeEmptyNode();
        const largeop = SemanticProcessor.getFunctionOp_(integral, (x) => isType(x, semantic_meaning_SemanticType.LARGEOP));
        return SemanticProcessor.getInstance().functionalNode_(semantic_meaning_SemanticType.INTEGRAL, [integral, integrand, intvar], largeop, []);
    }
    functionalNode_(type, children, operator, content) {
        const funcop = children[0];
        let oldParent;
        if (operator) {
            oldParent = operator.parent;
            content.push(operator);
        }
        const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(type, children, content);
        newNode.role = funcop.role;
        if (oldParent) {
            operator.parent = oldParent;
        }
        return newNode;
    }
    fractionNode_(denom, enume) {
        const newNode = SemanticProcessor.getInstance().factory_.makeBranchNode(semantic_meaning_SemanticType.FRACTION, [denom, enume], []);
        newNode.role = newNode.childNodes.every(function (x) {
            return (isType(x, semantic_meaning_SemanticType.NUMBER) &&
                isRole(x, semantic_meaning_SemanticRole.INTEGER));
        })
            ? semantic_meaning_SemanticRole.VULGAR
            : newNode.childNodes.every(isPureUnit)
                ? semantic_meaning_SemanticRole.UNIT
                : semantic_meaning_SemanticRole.DIVISION;
        return SemanticHeuristics.run('propagateSimpleFunction', newNode);
    }
    scriptNode_(nodes, role, opt_noSingle) {
        let newNode;
        switch (nodes.length) {
            case 0:
                newNode = SemanticProcessor.getInstance().factory_.makeEmptyNode();
                break;
            case 1:
                newNode = nodes[0];
                if (opt_noSingle) {
                    return newNode;
                }
                break;
            default:
                newNode = SemanticProcessor.getInstance().dummyNode_(nodes);
        }
        newNode.role = role;
        return newNode;
    }
    findNestedRow_(nodes, semantic, level, value) {
        if (level > 3) {
            return null;
        }
        for (let i = 0, node; (node = nodes[i]); i++) {
            const tag = dom_util_tagName(node);
            if (tag !== MMLTAGS.MSPACE) {
                if (tag === MMLTAGS.MROW) {
                    return SemanticProcessor.getInstance().findNestedRow_(toArray(node.childNodes), semantic, level + 1, value);
                }
                if (SemanticProcessor.findSemantics(node, semantic, value)) {
                    return node;
                }
            }
        }
        return null;
    }
}
SemanticProcessor.FENCE_TO_PUNCT_ = {
    [semantic_meaning_SemanticRole.METRIC]: semantic_meaning_SemanticRole.METRIC,
    [semantic_meaning_SemanticRole.NEUTRAL]: semantic_meaning_SemanticRole.VBAR,
    [semantic_meaning_SemanticRole.OPEN]: semantic_meaning_SemanticRole.OPENFENCE,
    [semantic_meaning_SemanticRole.CLOSE]: semantic_meaning_SemanticRole.CLOSEFENCE
};
SemanticProcessor.MML_TO_LIMIT_ = {
    [MMLTAGS.MSUB]: { type: semantic_meaning_SemanticType.LIMLOWER, length: 1 },
    [MMLTAGS.MUNDER]: { type: semantic_meaning_SemanticType.LIMLOWER, length: 1 },
    [MMLTAGS.MSUP]: { type: semantic_meaning_SemanticType.LIMUPPER, length: 1 },
    [MMLTAGS.MOVER]: { type: semantic_meaning_SemanticType.LIMUPPER, length: 1 },
    [MMLTAGS.MSUBSUP]: { type: semantic_meaning_SemanticType.LIMBOTH, length: 2 },
    [MMLTAGS.MUNDEROVER]: { type: semantic_meaning_SemanticType.LIMBOTH, length: 2 }
};
SemanticProcessor.MML_TO_BOUNDS_ = {
    [MMLTAGS.MSUB]: { type: semantic_meaning_SemanticType.SUBSCRIPT, length: 1, accent: false },
    [MMLTAGS.MSUP]: {
        type: semantic_meaning_SemanticType.SUPERSCRIPT,
        length: 1,
        accent: false
    },
    [MMLTAGS.MSUBSUP]: {
        type: semantic_meaning_SemanticType.SUBSCRIPT,
        length: 2,
        accent: false
    },
    [MMLTAGS.MUNDER]: {
        type: semantic_meaning_SemanticType.UNDERSCORE,
        length: 1,
        accent: true
    },
    [MMLTAGS.MOVER]: { type: semantic_meaning_SemanticType.OVERSCORE, length: 1, accent: true },
    [MMLTAGS.MUNDEROVER]: {
        type: semantic_meaning_SemanticType.UNDERSCORE,
        length: 2,
        accent: true
    }
};
SemanticProcessor.CLASSIFY_FUNCTION_ = {
    [semantic_meaning_SemanticRole.INTEGRAL]: 'integral',
    [semantic_meaning_SemanticRole.SUM]: 'bigop',
    [semantic_meaning_SemanticRole.PREFIXFUNC]: 'prefix',
    [semantic_meaning_SemanticRole.LIMFUNC]: 'prefix',
    [semantic_meaning_SemanticRole.SIMPLEFUNC]: 'prefix',
    [semantic_meaning_SemanticRole.COMPFUNC]: 'prefix'
};
SemanticProcessor.MATHJAX_FONTS = {
    '-tex-caligraphic': SemanticFont.CALIGRAPHIC,
    '-tex-caligraphic-bold': SemanticFont.CALIGRAPHICBOLD,
    '-tex-calligraphic': SemanticFont.CALIGRAPHIC,
    '-tex-calligraphic-bold': SemanticFont.CALIGRAPHICBOLD,
    '-tex-oldstyle': SemanticFont.OLDSTYLE,
    '-tex-oldstyle-bold': SemanticFont.OLDSTYLEBOLD,
    '-tex-mathit': SemanticFont.ITALIC
};
//# sourceMappingURL=semantic_processor.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_mathml.js









class SemanticMathml extends SemanticAbstractParser {
    static getAttribute_(node, attr, def) {
        if (!node.hasAttribute(attr)) {
            return def;
        }
        const value = node.getAttribute(attr);
        if (value.match(/^\s*$/)) {
            return null;
        }
        return value;
    }
    constructor(options) {
        super('MathML');
        this.options = options;
        SemanticHeuristics.options = options;
        this.parseMap_ = new Map([
            [MMLTAGS.SEMANTICS, this.semantics_.bind(this)],
            [MMLTAGS.MATH, this.rows_.bind(this)],
            [MMLTAGS.MROW, this.rows_.bind(this)],
            [MMLTAGS.MPADDED, this.rows_.bind(this)],
            [MMLTAGS.MSTYLE, this.rows_.bind(this)],
            [MMLTAGS.MFRAC, this.fraction_.bind(this)],
            [MMLTAGS.MSUB, this.limits_.bind(this)],
            [MMLTAGS.MSUP, this.limits_.bind(this)],
            [MMLTAGS.MSUBSUP, this.limits_.bind(this)],
            [MMLTAGS.MOVER, this.limits_.bind(this)],
            [MMLTAGS.MUNDER, this.limits_.bind(this)],
            [MMLTAGS.MUNDEROVER, this.limits_.bind(this)],
            [MMLTAGS.MROOT, this.root_.bind(this)],
            [MMLTAGS.MSQRT, this.sqrt_.bind(this)],
            [MMLTAGS.MTABLE, this.table_.bind(this)],
            [MMLTAGS.MLABELEDTR, this.tableLabeledRow_.bind(this)],
            [MMLTAGS.MTR, this.tableRow_.bind(this)],
            [MMLTAGS.MTD, this.tableCell_.bind(this)],
            [MMLTAGS.MS, this.text_.bind(this)],
            [MMLTAGS.MTEXT, this.text_.bind(this)],
            [MMLTAGS.MSPACE, this.space_.bind(this)],
            [MMLTAGS.ANNOTATIONXML, this.text_.bind(this)],
            [MMLTAGS.MI, this.identifier_.bind(this)],
            [MMLTAGS.MN, this.number_.bind(this)],
            [MMLTAGS.MO, this.operator_.bind(this)],
            [MMLTAGS.MFENCED, this.fenced_.bind(this)],
            [MMLTAGS.MENCLOSE, this.enclosed_.bind(this)],
            [MMLTAGS.MMULTISCRIPTS, this.multiscripts_.bind(this)],
            [MMLTAGS.ANNOTATION, this.empty_.bind(this)],
            [MMLTAGS.NONE, this.empty_.bind(this)],
            [MMLTAGS.MACTION, this.action_.bind(this)]
        ]);
        const meaning = {
            type: semantic_meaning_SemanticType.IDENTIFIER,
            role: semantic_meaning_SemanticRole.NUMBERSET,
            font: SemanticFont.DOUBLESTRUCK
        };
        [
            'C',
            'H',
            'N',
            'P',
            'Q',
            'R',
            'Z',
            '',
            '',
            '',
            '',
            '',
            '',
            ''
        ].forEach(((x) => this.getFactory().defaultMap.set(x, meaning)).bind(this));
    }
    parse(mml) {
        SemanticProcessor.getInstance().setNodeFactory(this.getFactory());
        const children = toArray(mml.childNodes);
        const tag = dom_util_tagName(mml);
        const func = this.parseMap_.get(tag);
        const newNode = (func ? func : this.dummy_.bind(this))(mml, children);
        addAttributes(newNode, mml);
        if ([
            MMLTAGS.MATH,
            MMLTAGS.MROW,
            MMLTAGS.MPADDED,
            MMLTAGS.MSTYLE,
            MMLTAGS.SEMANTICS,
            MMLTAGS.MACTION
        ].indexOf(tag) !== -1) {
            return newNode;
        }
        newNode.mathml.unshift(mml);
        newNode.mathmlTree = mml;
        return newNode;
    }
    semantics_(_node, children) {
        return children.length
            ? this.parse(children[0])
            : this.getFactory().makeEmptyNode();
    }
    rows_(node, children) {
        const semantics = node.getAttribute('semantics');
        if (semantics && semantics.match('bspr_')) {
            return SemanticProcessor.proof(node, semantics, this.parseList.bind(this));
        }
        children = purgeNodes(children);
        let newNode;
        if (children.length === 1) {
            newNode = this.parse(children[0]);
            if (newNode.type === semantic_meaning_SemanticType.EMPTY && !newNode.mathmlTree) {
                newNode.mathmlTree = node;
            }
        }
        else {
            const snode = SemanticHeuristics.run('function_from_identifiers', node);
            newNode =
                snode && snode !== node
                    ? snode
                    : SemanticProcessor.getInstance().row(this.parseList(children));
        }
        newNode.mathml.unshift(node);
        return newNode;
    }
    fraction_(node, children) {
        if (!children.length) {
            return this.getFactory().makeEmptyNode();
        }
        const upper = this.parse(children[0]);
        const lower = children[1]
            ? this.parse(children[1])
            : this.getFactory().makeEmptyNode();
        const sem = SemanticProcessor.getInstance().fractionLikeNode(upper, lower, node.getAttribute('linethickness'), node.getAttribute('bevelled') === 'true');
        return sem;
    }
    limits_(node, children) {
        return SemanticProcessor.getInstance().limitNode(dom_util_tagName(node), this.parseList(children));
    }
    root_(node, children) {
        if (!children[1]) {
            return this.sqrt_(node, children);
        }
        return this.getFactory().makeBranchNode(semantic_meaning_SemanticType.ROOT, [this.parse(children[1]), this.parse(children[0])], []);
    }
    sqrt_(_node, children) {
        const semNodes = this.parseList(purgeNodes(children));
        return this.getFactory().makeBranchNode(semantic_meaning_SemanticType.SQRT, [SemanticProcessor.getInstance().row(semNodes)], []);
    }
    table_(node, children) {
        const semantics = node.getAttribute('semantics');
        if (semantics && semantics.match('bspr_')) {
            return SemanticProcessor.proof(node, semantics, this.parseList.bind(this));
        }
        const newNode = this.getFactory().makeBranchNode(semantic_meaning_SemanticType.TABLE, this.parseList(children), []);
        newNode.mathmlTree = node;
        return SemanticProcessor.tableToMultiline(newNode);
    }
    tableRow_(_node, children) {
        const newNode = this.getFactory().makeBranchNode(semantic_meaning_SemanticType.ROW, this.parseList(children), []);
        newNode.role = semantic_meaning_SemanticRole.TABLE;
        return newNode;
    }
    tableLabeledRow_(node, children) {
        var _a;
        if (!children.length) {
            return this.tableRow_(node, children);
        }
        const label = this.parse(children[0]);
        label.role = semantic_meaning_SemanticRole.LABEL;
        if (((_a = label.childNodes[0]) === null || _a === void 0 ? void 0 : _a.type) === semantic_meaning_SemanticType.TEXT) {
            label.childNodes[0].role = semantic_meaning_SemanticRole.LABEL;
        }
        const newNode = this.getFactory().makeBranchNode(semantic_meaning_SemanticType.ROW, this.parseList(children.slice(1)), [label]);
        newNode.role = semantic_meaning_SemanticRole.TABLE;
        return newNode;
    }
    tableCell_(_node, children) {
        const semNodes = this.parseList(purgeNodes(children));
        let childNodes;
        if (!semNodes.length) {
            childNodes = [];
        }
        else if (semNodes.length === 1 &&
            isType(semNodes[0], semantic_meaning_SemanticType.EMPTY)) {
            childNodes = semNodes;
        }
        else {
            childNodes = [SemanticProcessor.getInstance().row(semNodes)];
        }
        const newNode = this.getFactory().makeBranchNode(semantic_meaning_SemanticType.CELL, childNodes, []);
        newNode.role = semantic_meaning_SemanticRole.TABLE;
        return newNode;
    }
    space_(node, children) {
        const width = node.getAttribute('width');
        const match = width && width.match(/[a-z]*$/);
        if (!match) {
            return this.empty_(node, children);
        }
        const sizes = {
            cm: 0.4,
            pc: 0.5,
            em: 0.5,
            ex: 1,
            in: 0.15,
            pt: 5,
            mm: 5
        };
        const unit = match[0];
        const measure = parseFloat(width.slice(0, match.index));
        const size = sizes[unit];
        if (!size || isNaN(measure) || measure < size) {
            return this.empty_(node, children);
        }
        const newNode = this.getFactory().makeUnprocessed(node);
        return SemanticProcessor.getInstance().text(newNode, dom_util_tagName(node));
    }
    text_(node, children) {
        const newNode = this.leaf_(node, children);
        if (!node.textContent) {
            return newNode;
        }
        newNode.updateContent(node.textContent, true);
        return SemanticProcessor.getInstance().text(newNode, dom_util_tagName(node));
    }
    identifier_(node, children) {
        const newNode = this.leaf_(node, children);
        return SemanticProcessor.getInstance().identifierNode(newNode, SemanticProcessor.getInstance().font(node.getAttribute('mathvariant')), node.getAttribute('class'));
    }
    number_(node, children) {
        const newNode = this.leaf_(node, children);
        SemanticProcessor.number(newNode);
        return newNode;
    }
    operator_(node, children) {
        const newNode = this.leaf_(node, children);
        SemanticProcessor.getInstance().operatorNode(newNode);
        return newNode;
    }
    fenced_(node, children) {
        const semNodes = this.parseList(purgeNodes(children));
        const sepValue = SemanticMathml.getAttribute_(node, 'separators', ',');
        const open = SemanticMathml.getAttribute_(node, 'open', '(');
        const close = SemanticMathml.getAttribute_(node, 'close', ')');
        const newNode = SemanticProcessor.getInstance().mfenced(open, close, sepValue, semNodes);
        const nodes = SemanticProcessor.getInstance().tablesInRow([newNode]);
        return nodes[0];
    }
    enclosed_(node, children) {
        const semNodes = this.parseList(purgeNodes(children));
        const newNode = this.getFactory().makeBranchNode(semantic_meaning_SemanticType.ENCLOSE, [SemanticProcessor.getInstance().row(semNodes)], []);
        newNode.role =
            node.getAttribute('notation') || semantic_meaning_SemanticRole.UNKNOWN;
        return newNode;
    }
    multiscripts_(_node, children) {
        if (!children.length) {
            return this.getFactory().makeEmptyNode();
        }
        const base = this.parse(children.shift());
        if (!children.length) {
            return base;
        }
        const lsup = [];
        const lsub = [];
        const rsup = [];
        const rsub = [];
        let prescripts = false;
        let scriptcount = 0;
        for (let i = 0, child; (child = children[i]); i++) {
            if (dom_util_tagName(child) === MMLTAGS.MPRESCRIPTS) {
                prescripts = true;
                scriptcount = 0;
                continue;
            }
            prescripts
                ? scriptcount & 1
                    ? lsup.push(child)
                    : lsub.push(child)
                : scriptcount & 1
                    ? rsup.push(child)
                    : rsub.push(child);
            scriptcount++;
        }
        if (!purgeNodes(lsup).length &&
            !purgeNodes(lsub).length) {
            return SemanticProcessor.getInstance().pseudoTensor(base, this.parseList(rsub), this.parseList(rsup));
        }
        return SemanticProcessor.getInstance().tensor(base, this.parseList(lsub), this.parseList(lsup), this.parseList(rsub), this.parseList(rsup));
    }
    empty_(_node, _children) {
        return this.getFactory().makeEmptyNode();
    }
    action_(node, children) {
        const selection = children[node.hasAttribute('selection')
            ? parseInt(node.getAttribute('selection'), 10) - 1
            : 0];
        const stree = this.parse(selection);
        stree.mathmlTree = selection;
        return stree;
    }
    dummy_(node, _children) {
        const unknown = this.getFactory().makeUnprocessed(node);
        unknown.role = node.tagName;
        unknown.textContent = node.textContent;
        return unknown;
    }
    leaf_(mml, children) {
        if (children.length === 1 &&
            children[0].nodeType !== NodeType.TEXT_NODE) {
            const node = this.getFactory().makeUnprocessed(mml);
            node.role = children[0].tagName;
            addAttributes(node, children[0]);
            return node;
        }
        const node = this.getFactory().makeLeafNode(mml.textContent, SemanticProcessor.getInstance().font(mml.getAttribute('mathvariant')));
        if (mml.hasAttribute('data-latex')) {
            SemanticMap.LatexCommands.set(mml.getAttribute('data-latex'), mml.textContent);
        }
        return node;
    }
}
//# sourceMappingURL=semantic_mathml.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_heuristic.js
class SemanticAbstractHeuristic {
    constructor(name, method, predicate = (_x) => false) {
        this.name = name;
        this.apply = method;
        this.applicable = predicate;
    }
}
class SemanticTreeHeuristic extends SemanticAbstractHeuristic {
}
class SemanticMultiHeuristic extends SemanticAbstractHeuristic {
}
class SemanticMmlHeuristic extends SemanticAbstractHeuristic {
}
//# sourceMappingURL=semantic_heuristic.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/common/base_util.js
function removeEmpty(strs) {
    return strs.filter((str) => str);
}
function interleaveLists(list1, list2) {
    const result = [];
    while (list1.length || list2.length) {
        if (list1.length) {
            result.push(list1.shift());
        }
        if (list2.length) {
            result.push(list2.shift());
        }
    }
    return result;
}
function setdifference(a, b) {
    if (!a) {
        return [];
    }
    if (!b) {
        return a;
    }
    return a.filter((x) => b.indexOf(x) < 0);
}
//# sourceMappingURL=base_util.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/enrich_attr.js


const Prefix = 'data-semantic-';
var enrich_attr_Attribute;
(function (Attribute) {
    Attribute["ADDED"] = "data-semantic-added";
    Attribute["ALTERNATIVE"] = "data-semantic-alternative";
    Attribute["CHILDREN"] = "data-semantic-children";
    Attribute["COLLAPSED"] = "data-semantic-collapsed";
    Attribute["CONTENT"] = "data-semantic-content";
    Attribute["EMBELLISHED"] = "data-semantic-embellished";
    Attribute["FENCEPOINTER"] = "data-semantic-fencepointer";
    Attribute["FONT"] = "data-semantic-font";
    Attribute["ID"] = "data-semantic-id";
    Attribute["ANNOTATION"] = "data-semantic-annotation";
    Attribute["ATTRIBUTES"] = "data-semantic-attributes";
    Attribute["OPERATOR"] = "data-semantic-operator";
    Attribute["OWNS"] = "data-semantic-owns";
    Attribute["PARENT"] = "data-semantic-parent";
    Attribute["POSTFIX"] = "data-semantic-postfix";
    Attribute["PREFIX"] = "data-semantic-prefix";
    Attribute["ROLE"] = "data-semantic-role";
    Attribute["SPEECH"] = "data-semantic-speech";
    Attribute["STRUCTURE"] = "data-semantic-structure";
    Attribute["SUMMARY"] = "data-semantic-summary";
    Attribute["TYPE"] = "data-semantic-type";
})(enrich_attr_Attribute || (enrich_attr_Attribute = {}));
const EnrichAttributes = [
    enrich_attr_Attribute.ADDED,
    enrich_attr_Attribute.ALTERNATIVE,
    enrich_attr_Attribute.CHILDREN,
    enrich_attr_Attribute.COLLAPSED,
    enrich_attr_Attribute.CONTENT,
    enrich_attr_Attribute.EMBELLISHED,
    enrich_attr_Attribute.FENCEPOINTER,
    enrich_attr_Attribute.FONT,
    enrich_attr_Attribute.ID,
    enrich_attr_Attribute.ANNOTATION,
    enrich_attr_Attribute.ATTRIBUTES,
    enrich_attr_Attribute.OPERATOR,
    enrich_attr_Attribute.OWNS,
    enrich_attr_Attribute.PARENT,
    enrich_attr_Attribute.POSTFIX,
    enrich_attr_Attribute.PREFIX,
    enrich_attr_Attribute.ROLE,
    enrich_attr_Attribute.SPEECH,
    enrich_attr_Attribute.STRUCTURE,
    enrich_attr_Attribute.SUMMARY,
    enrich_attr_Attribute.TYPE
];
function makeIdList(nodes) {
    return nodes
        .map(function (node) {
        return node.id;
    })
        .join(',');
}
function setAttributes(mml, semantic) {
    mml.setAttribute(enrich_attr_Attribute.TYPE, semantic.type);
    const attributes = semantic.allAttributes();
    for (let i = 0, attr; (attr = attributes[i]); i++) {
        mml.setAttribute(Prefix + attr[0].toLowerCase(), attr[1]);
    }
    if (semantic.childNodes.length) {
        mml.setAttribute(enrich_attr_Attribute.CHILDREN, makeIdList(semantic.childNodes));
    }
    if (semantic.contentNodes.length) {
        mml.setAttribute(enrich_attr_Attribute.CONTENT, makeIdList(semantic.contentNodes));
    }
    if (semantic.parent) {
        mml.setAttribute(enrich_attr_Attribute.PARENT, semantic.parent.id.toString());
    }
    const external = semantic.attributesXml();
    if (external) {
        mml.setAttribute(enrich_attr_Attribute.ATTRIBUTES, external);
    }
    setPostfix(mml, semantic);
}
function setPostfix(mml, semantic) {
    const postfix = [];
    if (semantic.role === semantic_meaning_SemanticRole.MGLYPH) {
        postfix.push('image');
    }
    if (semantic.attributes['href']) {
        postfix.push('link');
    }
    if (postfix.length) {
        mml.setAttribute(enrich_attr_Attribute.POSTFIX, postfix.join(' '));
    }
}
function removeAttributePrefix(mml) {
    return mml.toString().replace(new RegExp(Prefix, 'g'), '');
}
function addPrefix(attr) {
    return (Prefix + attr);
}
function addMrow() {
    const mrow = createElement('mrow');
    mrow.setAttribute(enrich_attr_Attribute.ADDED, 'true');
    return mrow;
}
//# sourceMappingURL=enrich_attr.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_skeleton.js




class SemanticSkeleton {
    static fromTree(tree) {
        return SemanticSkeleton.fromNode(tree.root);
    }
    static fromNode(node) {
        return new SemanticSkeleton(SemanticSkeleton.fromNode_(node));
    }
    static fromString(skel) {
        return new SemanticSkeleton(SemanticSkeleton.fromString_(skel));
    }
    static simpleCollapseStructure(strct) {
        return typeof strct === 'number';
    }
    static contentCollapseStructure(strct) {
        return (!!strct &&
            !SemanticSkeleton.simpleCollapseStructure(strct) &&
            strct[0] === 'c');
    }
    static interleaveIds(first, second) {
        return interleaveLists(SemanticSkeleton.collapsedLeafs(first), SemanticSkeleton.collapsedLeafs(second));
    }
    static collapsedLeafs(...args) {
        const collapseStructure = (coll) => {
            if (SemanticSkeleton.simpleCollapseStructure(coll)) {
                return [coll];
            }
            coll = coll;
            return SemanticSkeleton.contentCollapseStructure(coll[1])
                ? coll.slice(2)
                : coll.slice(1);
        };
        return args.reduce((x, y) => x.concat(collapseStructure(y)), []);
    }
    static fromStructure(mml, tree, options) {
        return new SemanticSkeleton(SemanticSkeleton.tree_(mml, tree.root, options));
    }
    static combineContentChildren(type, _role, content, children) {
        switch (type) {
            case semantic_meaning_SemanticType.RELSEQ:
            case semantic_meaning_SemanticType.INFIXOP:
            case semantic_meaning_SemanticType.MULTIREL:
                return interleaveLists(children, content);
            case semantic_meaning_SemanticType.PREFIXOP:
                return content.concat(children);
            case semantic_meaning_SemanticType.POSTFIXOP:
                return children.concat(content);
            case semantic_meaning_SemanticType.MATRIX:
            case semantic_meaning_SemanticType.VECTOR:
            case semantic_meaning_SemanticType.FENCED:
                children.unshift(content[0]);
                children.push(content[1]);
                return children;
            case semantic_meaning_SemanticType.CASES:
                children.unshift(content[0]);
                return children;
            case semantic_meaning_SemanticType.APPL:
                return [children[0], content[0], children[1]];
            case semantic_meaning_SemanticType.ROOT:
                return [children[0], children[1]];
            case semantic_meaning_SemanticType.ROW:
            case semantic_meaning_SemanticType.LINE:
                if (content.length) {
                    children.unshift(content[0]);
                }
                return children;
            default:
                return children;
        }
    }
    static makeSexp_(struct) {
        if (SemanticSkeleton.simpleCollapseStructure(struct)) {
            return struct.toString();
        }
        if (SemanticSkeleton.contentCollapseStructure(struct)) {
            return ('(' +
                'c ' +
                struct.slice(1).map(SemanticSkeleton.makeSexp_).join(' ') +
                ')');
        }
        return ('(' + struct.map(SemanticSkeleton.makeSexp_).join(' ') + ')');
    }
    static fromString_(skeleton) {
        let str = skeleton.replace(/\(/g, '[');
        str = str.replace(/\)/g, ']');
        str = str.replace(/ /g, ',');
        str = str.replace(/c/g, '"c"');
        return JSON.parse(str);
    }
    static fromNode_(node) {
        if (!node) {
            return [];
        }
        const content = node.contentNodes;
        let contentStructure;
        if (content.length) {
            contentStructure = content.map(SemanticSkeleton.fromNode_);
            contentStructure.unshift('c');
        }
        const children = node.childNodes;
        if (!children.length) {
            return content.length ? [node.id, contentStructure] : node.id;
        }
        const structure = children.map(SemanticSkeleton.fromNode_);
        if (content.length) {
            structure.unshift(contentStructure);
        }
        structure.unshift(node.id);
        return structure;
    }
    static tree_(mml, node, options, level = 0, posinset = 1, setsize = 1) {
        if (!node) {
            return [];
        }
        const id = node.id;
        const skeleton = [id];
        updateEvaluator(mml);
        const mmlChild = evalXPath(`.//self::*[@${enrich_attr_Attribute.ID}=${id}]`, mml)[0];
        if (!node.childNodes.length) {
            SemanticSkeleton.addAria(mmlChild, level, posinset, setsize, options);
            return node.id;
        }
        const children = SemanticSkeleton.combineContentChildren(node.type, node.role, node.contentNodes.map(function (x) {
            return x;
        }), node.childNodes.map(function (x) {
            return x;
        }));
        if (mmlChild) {
            SemanticSkeleton.addOwns_(mmlChild, children);
        }
        for (let i = 0, l = children.length, child; (child = children[i]); i++) {
            skeleton.push(SemanticSkeleton.tree_(mml, child, options, level + 1, i + 1, l));
        }
        SemanticSkeleton.addAria(mmlChild, level, posinset, setsize, options);
        return skeleton;
    }
    static addAria(node, level, posinset, setsize, options) {
        const role = !options.tree ? 'treeitem' : level ? 'treeitem' : 'tree';
        if (!options.aria || !node) {
            return;
        }
        node.setAttribute('aria-level', level.toString());
        node.setAttribute('aria-posinset', posinset.toString());
        node.setAttribute('aria-setsize', setsize.toString());
        node.setAttribute('role', role);
        if (node.hasAttribute(enrich_attr_Attribute.OWNS)) {
            node.setAttribute('aria-owns', node.getAttribute(enrich_attr_Attribute.OWNS));
        }
    }
    static addOwns_(node, children) {
        const collapsed = node.getAttribute(enrich_attr_Attribute.COLLAPSED);
        const leafs = collapsed
            ? SemanticSkeleton.realLeafs_(SemanticSkeleton.fromString(collapsed).array)
            : children.map((x) => x.id);
        node.setAttribute(enrich_attr_Attribute.OWNS, leafs.join(' '));
    }
    static realLeafs_(sexp) {
        if (SemanticSkeleton.simpleCollapseStructure(sexp)) {
            return [sexp];
        }
        if (SemanticSkeleton.contentCollapseStructure(sexp)) {
            return [];
        }
        sexp = sexp;
        let result = [];
        for (let i = 1; i < sexp.length; i++) {
            result = result.concat(SemanticSkeleton.realLeafs_(sexp[i]));
        }
        return result;
    }
    constructor(skeleton) {
        this.parents = null;
        this.levelsMap = null;
        skeleton = skeleton === 0 ? skeleton : skeleton || [];
        this.array = skeleton;
    }
    populate() {
        if (this.parents && this.levelsMap) {
            return;
        }
        this.parents = {};
        this.levelsMap = {};
        this.populate_(this.array, this.array, []);
    }
    toString() {
        return SemanticSkeleton.makeSexp_(this.array);
    }
    populate_(element, layer, parents) {
        if (SemanticSkeleton.simpleCollapseStructure(element)) {
            element = element;
            this.levelsMap[element] = layer;
            this.parents[element] =
                element === parents[0] ? parents.slice(1) : parents;
            return;
        }
        const newElement = SemanticSkeleton.contentCollapseStructure(element)
            ? element.slice(1)
            : element;
        const newParents = [newElement[0]].concat(parents);
        for (let i = 0, l = newElement.length; i < l; i++) {
            const current = newElement[i];
            this.populate_(current, element, newParents);
        }
    }
    isRoot(id) {
        const level = this.levelsMap[id];
        return id === level[0];
    }
    directChildren(id) {
        if (!this.isRoot(id)) {
            return [];
        }
        const level = this.levelsMap[id];
        return level.slice(1).map((child) => {
            if (SemanticSkeleton.simpleCollapseStructure(child)) {
                return child;
            }
            if (SemanticSkeleton.contentCollapseStructure(child)) {
                return child[1];
            }
            return child[0];
        });
    }
    subtreeNodes(id) {
        if (!this.isRoot(id)) {
            return [];
        }
        const subtreeNodes_ = (tree, nodes) => {
            if (SemanticSkeleton.simpleCollapseStructure(tree)) {
                nodes.push(tree);
                return;
            }
            tree = tree;
            if (SemanticSkeleton.contentCollapseStructure(tree)) {
                tree = tree.slice(1);
            }
            tree.forEach((x) => subtreeNodes_(x, nodes));
        };
        const level = this.levelsMap[id];
        const subtree = [];
        subtreeNodes_(level.slice(1), subtree);
        return subtree;
    }
}
//# sourceMappingURL=semantic_skeleton.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_heuristics.js











SemanticHeuristics.add(new SemanticTreeHeuristic('combine_juxtaposition', combineJuxtaposition));
function combineJuxtaposition(root) {
    for (let i = root.childNodes.length - 1, child; (child = root.childNodes[i]); i--) {
        if (!isImplicitOp(child) || child.nobreaking) {
            continue;
        }
        root.childNodes.splice(i, 1, ...child.childNodes);
        root.contentNodes.splice(i, 0, ...child.contentNodes);
        child.childNodes.concat(child.contentNodes).forEach(function (x) {
            x.parent = root;
        });
        root.addMathmlNodes(child.mathml);
    }
    return root;
}
SemanticHeuristics.add(new SemanticTreeHeuristic('propagateSimpleFunction', (node) => {
    if ((node.type === semantic_meaning_SemanticType.INFIXOP ||
        node.type === semantic_meaning_SemanticType.FRACTION) &&
        node.childNodes.every(isSimpleFunction)) {
        node.role = semantic_meaning_SemanticRole.COMPFUNC;
    }
    return node;
}, (_node) => SemanticHeuristics.options.domain === 'clearspeak'));
SemanticHeuristics.add(new SemanticTreeHeuristic('simpleNamedFunction', (node) => {
    const specialFunctions = ['f', 'g', 'h', 'F', 'G', 'H'];
    if (node.role !== semantic_meaning_SemanticRole.UNIT &&
        specialFunctions.indexOf(node.textContent) !== -1) {
        node.role = semantic_meaning_SemanticRole.SIMPLEFUNC;
    }
    return node;
}, (_node) => SemanticHeuristics.options.domain === 'clearspeak'));
SemanticHeuristics.add(new SemanticTreeHeuristic('propagateComposedFunction', (node) => {
    if (node.type === semantic_meaning_SemanticType.FENCED &&
        node.childNodes[0].role === semantic_meaning_SemanticRole.COMPFUNC) {
        node.role = semantic_meaning_SemanticRole.COMPFUNC;
    }
    return node;
}, (_node) => SemanticHeuristics.options.domain === 'clearspeak'));
SemanticHeuristics.add(new SemanticTreeHeuristic('multioperator', (node) => {
    if (node.role !== semantic_meaning_SemanticRole.UNKNOWN || node.textContent.length <= 1) {
        return;
    }
    SemanticProcessor.compSemantics(node, 'role', semantic_meaning_SemanticRole);
    SemanticProcessor.compSemantics(node, 'type', semantic_meaning_SemanticType);
}));
SemanticHeuristics.add(new SemanticMultiHeuristic('convert_juxtaposition', (nodes) => {
    let partition = partitionNodes(nodes, function (x) {
        return (x.textContent === NamedSymbol.invisibleTimes &&
            x.type === semantic_meaning_SemanticType.OPERATOR);
    });
    partition = partition.rel.length
        ? juxtapositionPrePost(partition)
        : partition;
    nodes = partition.comp[0];
    for (let i = 1, c, r; (c = partition.comp[i]), (r = partition.rel[i - 1]); i++) {
        nodes.push(r);
        nodes = nodes.concat(c);
    }
    partition = partitionNodes(nodes, function (x) {
        return (x.textContent === NamedSymbol.invisibleTimes &&
            (x.type === semantic_meaning_SemanticType.OPERATOR || x.type === semantic_meaning_SemanticType.INFIXOP));
    });
    if (!partition.rel.length) {
        return nodes;
    }
    return recurseJuxtaposition(partition.comp.shift(), partition.rel, partition.comp);
}));
SemanticHeuristics.add(new SemanticTreeHeuristic('simple2prefix', (node) => {
    if (node.textContent.length > 1 &&
        !node.textContent[0].match(/[A-Z]/)) {
        node.role = semantic_meaning_SemanticRole.PREFIXFUNC;
    }
    return node;
}, (node) => SemanticHeuristics.options.modality === 'braille' &&
    node.type === semantic_meaning_SemanticType.IDENTIFIER));
SemanticHeuristics.add(new SemanticTreeHeuristic('detect_cycle', (node) => {
    node.type = semantic_meaning_SemanticType.MATRIX;
    node.role = semantic_meaning_SemanticRole.CYCLE;
    const row = node.childNodes[0];
    row.type = semantic_meaning_SemanticType.ROW;
    row.role = semantic_meaning_SemanticRole.CYCLE;
    row.textContent = '';
    row.contentNodes = [];
    return node;
}, (node) => node.type === semantic_meaning_SemanticType.FENCED &&
    node.childNodes[0].type === semantic_meaning_SemanticType.INFIXOP &&
    node.childNodes[0].role === semantic_meaning_SemanticRole.IMPLICIT &&
    node.childNodes[0].childNodes.every(function (x) {
        return x.type === semantic_meaning_SemanticType.NUMBER;
    }) &&
    node.childNodes[0].contentNodes.every(function (x) {
        return x.role === semantic_meaning_SemanticRole.SPACE;
    })));
function juxtapositionPrePost(partition) {
    const rels = [];
    const comps = [];
    let next = partition.comp.shift();
    let rel = null;
    let collect = [];
    while (partition.comp.length) {
        collect = [];
        if (next.length) {
            if (rel) {
                rels.push(rel);
            }
            comps.push(next);
            rel = partition.rel.shift();
            next = partition.comp.shift();
            continue;
        }
        if (rel) {
            collect.push(rel);
        }
        while (!next.length && partition.comp.length) {
            next = partition.comp.shift();
            collect.push(partition.rel.shift());
        }
        rel = convertPrePost(collect, next, comps);
    }
    if (!collect.length && !next.length) {
        collect.push(rel);
        convertPrePost(collect, next, comps);
    }
    else {
        rels.push(rel);
        comps.push(next);
    }
    return { rel: rels, comp: comps };
}
function convertPrePost(collect, next, comps) {
    let rel = null;
    if (!collect.length) {
        return rel;
    }
    const prev = comps[comps.length - 1];
    const prevExists = prev && prev.length;
    const nextExists = next && next.length;
    const processor = SemanticProcessor.getInstance();
    if (prevExists && nextExists) {
        if (next[0].type === semantic_meaning_SemanticType.INFIXOP &&
            next[0].role === semantic_meaning_SemanticRole.IMPLICIT) {
            rel = collect.pop();
            prev.push(processor['postfixNode_'](prev.pop(), collect));
            return rel;
        }
        rel = collect.shift();
        const result = processor['prefixNode_'](next.shift(), collect);
        next.unshift(result);
        return rel;
    }
    if (prevExists) {
        prev.push(processor['postfixNode_'](prev.pop(), collect));
        return rel;
    }
    if (nextExists) {
        next.unshift(processor['prefixNode_'](next.shift(), collect));
    }
    return rel;
}
function recurseJuxtaposition(acc, ops, elements) {
    if (!ops.length) {
        return acc;
    }
    const left = acc.pop();
    const op = ops.shift();
    const first = elements.shift();
    if (op.type === semantic_meaning_SemanticType.INFIXOP &&
        (op.role === semantic_meaning_SemanticRole.IMPLICIT || op.role === semantic_meaning_SemanticRole.UNIT)) {
        Debugger.getInstance().output('Juxta Heuristic Case 2');
        const right = (left ? [left, op] : [op]).concat(first);
        return recurseJuxtaposition(acc.concat(right), ops, elements);
    }
    if (!left) {
        Debugger.getInstance().output('Juxta Heuristic Case 3');
        return recurseJuxtaposition([op].concat(first), ops, elements);
    }
    const right = first.shift();
    if (!right) {
        Debugger.getInstance().output('Juxta Heuristic Case 9');
        const newOp = SemanticHeuristics.factory.makeBranchNode(semantic_meaning_SemanticType.INFIXOP, [left, ops.shift()], [op], op.textContent);
        newOp.role = semantic_meaning_SemanticRole.IMPLICIT;
        SemanticHeuristics.run('combine_juxtaposition', newOp);
        ops.unshift(newOp);
        return recurseJuxtaposition(acc, ops, elements);
    }
    if (isOperator(left) || isOperator(right)) {
        Debugger.getInstance().output('Juxta Heuristic Case 4');
        return recurseJuxtaposition(acc.concat([left, op, right]).concat(first), ops, elements);
    }
    let result = null;
    if (isImplicitOp(left) && isImplicitOp(right)) {
        Debugger.getInstance().output('Juxta Heuristic Case 5');
        left.contentNodes.push(op);
        left.contentNodes = left.contentNodes.concat(right.contentNodes);
        left.childNodes.push(right);
        left.childNodes = left.childNodes.concat(right.childNodes);
        right.childNodes.forEach((x) => (x.parent = left));
        op.parent = left;
        left.addMathmlNodes(op.mathml);
        left.addMathmlNodes(right.mathml);
        result = left;
    }
    else if (isImplicitOp(left)) {
        Debugger.getInstance().output('Juxta Heuristic Case 6');
        left.contentNodes.push(op);
        left.childNodes.push(right);
        right.parent = left;
        op.parent = left;
        left.addMathmlNodes(op.mathml);
        left.addMathmlNodes(right.mathml);
        result = left;
    }
    else if (isImplicitOp(right)) {
        Debugger.getInstance().output('Juxta Heuristic Case 7');
        right.contentNodes.unshift(op);
        right.childNodes.unshift(left);
        left.parent = right;
        op.parent = right;
        right.addMathmlNodes(op.mathml);
        right.addMathmlNodes(left.mathml);
        result = right;
    }
    else {
        Debugger.getInstance().output('Juxta Heuristic Case 8');
        result = SemanticHeuristics.factory.makeBranchNode(semantic_meaning_SemanticType.INFIXOP, [left, right], [op], op.textContent);
        result.role = semantic_meaning_SemanticRole.IMPLICIT;
    }
    acc.push(result);
    return recurseJuxtaposition(acc.concat(first), ops, elements);
}
SemanticHeuristics.add(new SemanticMultiHeuristic('intvar_from_implicit', implicitUnpack, (nodes) => nodes[0] && isImplicit(nodes[0])));
function implicitUnpack(nodes) {
    const children = nodes[0].childNodes;
    nodes.splice(0, 1, ...children);
}
SemanticHeuristics.add(new SemanticTreeHeuristic('intvar_from_fraction', integralFractionArg, (node) => {
    if (node.type !== semantic_meaning_SemanticType.INTEGRAL)
        return false;
    const [, integrand, intvar] = node.childNodes;
    return (intvar.type === semantic_meaning_SemanticType.EMPTY &&
        integrand.type === semantic_meaning_SemanticType.FRACTION);
}));
function integralFractionArg(node) {
    const integrand = node.childNodes[1];
    const enumerator = integrand.childNodes[0];
    if (isIntegralDxBoundarySingle(enumerator)) {
        enumerator.role = semantic_meaning_SemanticRole.INTEGRAL;
        return;
    }
    if (!isImplicit(enumerator))
        return;
    const length = enumerator.childNodes.length;
    const first = enumerator.childNodes[length - 2];
    const second = enumerator.childNodes[length - 1];
    if (isIntegralDxBoundarySingle(second)) {
        second.role = semantic_meaning_SemanticRole.INTEGRAL;
        return;
    }
    if (isIntegralDxBoundary(first, second)) {
        const prefix = SemanticProcessor.getInstance()['prefixNode_'](second, [
            first
        ]);
        prefix.role = semantic_meaning_SemanticRole.INTEGRAL;
        if (length === 2) {
            integrand.childNodes[0] = prefix;
        }
        else {
            enumerator.childNodes.pop();
            enumerator.contentNodes.pop();
            enumerator.childNodes[length - 2] = prefix;
            prefix.parent = enumerator;
        }
    }
}
SemanticHeuristics.add(new SemanticTreeHeuristic('rewrite_subcases', rewriteSubcasesTable, (table) => {
    let left = true;
    let right = true;
    const topLeft = table.childNodes[0].childNodes[0];
    if (!eligibleNode(topLeft.mathmlTree)) {
        left = false;
    }
    else {
        for (let i = 1, row; (row = table.childNodes[i]); i++) {
            if (row.childNodes[0].childNodes.length) {
                left = false;
                break;
            }
        }
    }
    if (left) {
        table.addAnnotation('Emph', 'left');
    }
    const topRight = table.childNodes[0].childNodes[table.childNodes[0].childNodes.length - 1];
    if (!eligibleNode(topRight.mathmlTree)) {
        right = false;
    }
    else {
        const firstRow = table.childNodes[0].childNodes.length;
        for (let i = 1, row; (row = table.childNodes[i]); i++) {
            if (row.childNodes.length >= firstRow) {
                right = false;
                break;
            }
        }
    }
    if (right) {
        table.addAnnotation('Emph', 'right');
    }
    return left || right;
}));
function eligibleNode(node) {
    return (node.childNodes[0] &&
        node.childNodes[0].childNodes[0] &&
        dom_util_tagName(node.childNodes[0]) === MMLTAGS.MPADDED &&
        dom_util_tagName(node.childNodes[0].childNodes[0]) ===
            MMLTAGS.MPADDED &&
        dom_util_tagName(node.childNodes[0].childNodes[node.childNodes[0].childNodes.length - 1]) === MMLTAGS.MPHANTOM);
}
const rewritable = [
    semantic_meaning_SemanticType.PUNCTUATED,
    semantic_meaning_SemanticType.RELSEQ,
    semantic_meaning_SemanticType.MULTIREL,
    semantic_meaning_SemanticType.INFIXOP,
    semantic_meaning_SemanticType.PREFIXOP,
    semantic_meaning_SemanticType.POSTFIXOP
];
function rewriteSubcasesTable(table) {
    table.addAnnotation('Emph', 'top');
    let row = [];
    if (table.hasAnnotation('Emph', 'left')) {
        const topLeft = table.childNodes[0].childNodes[0].childNodes[0];
        const cells = rewriteCell(topLeft, true);
        cells.forEach((x) => x.addAnnotation('Emph', 'left'));
        row = row.concat(cells);
        for (let i = 0, line; (line = table.childNodes[i]); i++) {
            line.childNodes.shift();
        }
    }
    row.push(table);
    if (table.hasAnnotation('Emph', 'right')) {
        const topRight = table.childNodes[0].childNodes[table.childNodes[0].childNodes.length - 1]
            .childNodes[0];
        const cells = rewriteCell(topRight);
        cells.forEach((x) => x.addAnnotation('Emph', 'left'));
        row = row.concat(cells);
        table.childNodes[0].childNodes.pop();
    }
    SemanticProcessor.tableToMultiline(table);
    const newNode = SemanticProcessor.getInstance().row(row);
    const annotation = table.annotation['Emph'];
    table.annotation['Emph'] = ['table'];
    annotation.forEach((x) => newNode.addAnnotation('Emph', x));
    return newNode;
}
function rewriteCell(cell, left) {
    if (!cell.childNodes.length) {
        rewriteFence(cell);
        return [cell];
    }
    let fence = null;
    if (cell.type === semantic_meaning_SemanticType.PUNCTUATED &&
        (left
            ? cell.role === semantic_meaning_SemanticRole.ENDPUNCT
            : cell.role === semantic_meaning_SemanticRole.STARTPUNCT)) {
        const children = cell.childNodes;
        if (rewriteFence(children[left ? children.length - 1 : 0])) {
            cell = children[left ? 0 : children.length - 1];
            fence = children[left ? children.length - 1 : 0];
        }
    }
    if (rewritable.indexOf(cell.type) !== -1) {
        const children = cell.childNodes;
        rewriteFence(children[left ? children.length - 1 : 0]);
        const newNodes = SemanticSkeleton.combineContentChildren(cell.type, cell.role, cell.contentNodes, cell.childNodes);
        if (fence) {
            if (left) {
                newNodes.push(fence);
            }
            else {
                newNodes.unshift(fence);
            }
        }
        return newNodes;
    }
    return fence ? (left ? [cell, fence] : [fence, cell]) : [cell];
}
const PUNCT_TO_FENCE_ = {
    [semantic_meaning_SemanticRole.METRIC]: semantic_meaning_SemanticRole.METRIC,
    [semantic_meaning_SemanticRole.VBAR]: semantic_meaning_SemanticRole.NEUTRAL,
    [semantic_meaning_SemanticRole.OPENFENCE]: semantic_meaning_SemanticRole.OPEN,
    [semantic_meaning_SemanticRole.CLOSEFENCE]: semantic_meaning_SemanticRole.CLOSE
};
function rewriteFence(fence) {
    if (fence.type !== semantic_meaning_SemanticType.PUNCTUATION) {
        return false;
    }
    const role = PUNCT_TO_FENCE_[fence.role];
    if (!role) {
        return false;
    }
    fence.role = role;
    fence.type = semantic_meaning_SemanticType.FENCE;
    fence.addAnnotation('Emph', 'fence');
    return true;
}
SemanticHeuristics.add(new SemanticMultiHeuristic('ellipses', (nodes) => {
    const newNodes = [];
    let current = nodes.shift();
    while (current) {
        [current, nodes] = combineNodes(current, nodes, semantic_meaning_SemanticRole.FULLSTOP, semantic_meaning_SemanticRole.ELLIPSIS);
        [current, nodes] = combineNodes(current, nodes, semantic_meaning_SemanticRole.DASH);
        newNodes.push(current);
        current = nodes.shift();
    }
    return newNodes;
}, (nodes) => nodes.length > 1));
function combineNodes(current, nodes, src, target = src) {
    const collect = [];
    while (current && current.role === src) {
        collect.push(current);
        current = nodes.shift();
    }
    if (!collect.length) {
        return [current, nodes];
    }
    if (current) {
        nodes.unshift(current);
    }
    return [
        collect.length === 1 ? collect[0] : combinedNodes(collect, target),
        nodes
    ];
}
function combinedNodes(nodes, role) {
    const node = SemanticHeuristics.factory.makeBranchNode(semantic_meaning_SemanticType.PUNCTUATION, nodes, []);
    node.role = role;
    return node;
}
SemanticHeuristics.add(new SemanticMultiHeuristic('op_with_limits', (nodes) => {
    const center = nodes[0];
    center.type = semantic_meaning_SemanticType.LARGEOP;
    center.role = semantic_meaning_SemanticRole.SUM;
    return nodes;
}, (nodes) => {
    return (nodes[0].type === semantic_meaning_SemanticType.OPERATOR &&
        nodes
            .slice(1)
            .some((node) => node.type === semantic_meaning_SemanticType.RELSEQ ||
            node.type === semantic_meaning_SemanticType.MULTIREL ||
            (node.type === semantic_meaning_SemanticType.INFIXOP &&
                node.role === semantic_meaning_SemanticRole.ELEMENT) ||
            (node.type === semantic_meaning_SemanticType.PUNCTUATED &&
                node.role === semantic_meaning_SemanticRole.SEQUENCE)));
}));
SemanticHeuristics.add(new SemanticMmlHeuristic('function_from_identifiers', (node) => {
    const expr = toArray(node.childNodes)
        .map((x) => x.textContent.trim())
        .join('');
    const meaning = SemanticMap.Meaning.get(expr);
    if (meaning.type === semantic_meaning_SemanticType.UNKNOWN) {
        return node;
    }
    const snode = SemanticHeuristics.factory.makeLeafNode(expr, SemanticProcessor.getInstance().font(node.getAttribute('mathvariant')));
    snode.mathmlTree = node;
    return snode;
}, (node) => {
    const children = toArray(node.childNodes);
    if (children.length < 2) {
        return false;
    }
    return children.every((child) => dom_util_tagName(child) === MMLTAGS.MI &&
        SemanticMap.Meaning.get(child.textContent.trim()).role ===
            semantic_meaning_SemanticRole.LATINLETTER);
}));
SemanticHeuristics.add(new SemanticMultiHeuristic('bracketed_interval', (nodes) => {
    const leftFence = nodes[0];
    const rightFence = nodes[1];
    const content = nodes.slice(2);
    const childNode = SemanticProcessor.getInstance().row(content);
    const fenced = SemanticHeuristics.factory.makeBranchNode(semantic_meaning_SemanticType.FENCED, [childNode], [leftFence, rightFence]);
    fenced.role = semantic_meaning_SemanticRole.INTERVAL;
    return fenced;
}, (nodes) => {
    const leftFence = nodes[0];
    const rightFence = nodes[1];
    const content = nodes.slice(2);
    if (!(leftFence &&
        rightFence &&
        ((isCloseBrack(leftFence.textContent) &&
            (isOpenBrack(rightFence.textContent) || isCloseBrack((rightFence.textContent))) ||
            (isOpenBrack(rightFence.textContent) &&
                (isOpenBrack(leftFence.textContent) || isCloseBrack(leftFence.textContent))))))) {
        return false;
    }
    if (content.length === 1 &&
        content[0].type === semantic_meaning_SemanticType.PUNCTUATED &&
        content[0].contentNodes.length === 1) {
        return true;
    }
    const partition = partitionNodes(content, isPunctuation);
    return !!(partition.rel.length === 1 &&
        partition.comp[0].length &&
        partition.comp[1].length);
}));
function isOpenBrack(str) {
    return ['[', ''].includes(str);
}
function isCloseBrack(str) {
    return [']', ''].includes(str);
}
function isOpenParen(str) {
    return ['(', '', ''].includes(str);
}
function isCloseParen(str) {
    return [')', '', ''].includes(str);
}
function isInfty(node) {
    return node.role === semantic_meaning_SemanticRole.INFTY ||
        (node.type === semantic_meaning_SemanticType.PREFIXOP &&
            node.childNodes[0].role === semantic_meaning_SemanticRole.INFTY);
}
SemanticHeuristics.add(new SemanticTreeHeuristic('interval_heuristic', (node) => {
    node.role = semantic_meaning_SemanticRole.INTERVAL;
    return node;
}, (node) => {
    return isPotentialInterval(node);
}));
function isPotentialInterval(node) {
    const child = node.childNodes[0];
    if (node.type !== semantic_meaning_SemanticType.FENCED ||
        (child === null || child === void 0 ? void 0 : child.type) !== semantic_meaning_SemanticType.PUNCTUATED ||
        (child === null || child === void 0 ? void 0 : child.childNodes.length) !== 3 ||
        (child === null || child === void 0 ? void 0 : child.contentNodes.length) !== 1 ||
        (child === null || child === void 0 ? void 0 : child.childNodes[1].role) !== semantic_meaning_SemanticRole.COMMA) {
        return false;
    }
    const first = node.childNodes[0].childNodes[0];
    const second = node.childNodes[0].childNodes[2];
    const left = node.contentNodes[0].textContent;
    const right = node.contentNodes[1].textContent;
    if ((isOpenBrack(left) && isCloseParen(right)) ||
        (isOpenParen(left) && isCloseBrack(right))) {
        return true;
    }
    if (isOpenParen(left) && isCloseParen(right) &&
        (isInfty(first) || isInfty(second))) {
        return true;
    }
    return false;
}
SemanticHeuristics.add(new SemanticTreeHeuristic('propagateInterval', (node) => {
    node.childNodes.forEach(child => {
        if (isPotentialInterval(child)) {
            child.role = semantic_meaning_SemanticRole.INTERVAL;
        }
    });
    return node;
}, (node) => {
    return isMembership(node);
}));
//# sourceMappingURL=semantic_heuristics.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/special_annotators.js




function isSimpleExpression(node) {
    return (isSimpleNumber_(node) ||
        isSimpleLetters_(node) ||
        isSimpleDegree_(node) ||
        isSimpleNegative_(node) ||
        isSimpleFunction_(node));
}
function isSimpleFunction_(node) {
    return (node.type === semantic_meaning_SemanticType.APPL &&
        (node.childNodes[0].role === semantic_meaning_SemanticRole.PREFIXFUNC ||
            node.childNodes[0].role === semantic_meaning_SemanticRole.SIMPLEFUNC) &&
        (isSimple_(node.childNodes[1]) ||
            (node.childNodes[1].type === semantic_meaning_SemanticType.FENCED &&
                isSimple_(node.childNodes[1].childNodes[0]))));
}
function isSimpleNegative_(node) {
    return (node.type === semantic_meaning_SemanticType.PREFIXOP &&
        node.role === semantic_meaning_SemanticRole.NEGATIVE &&
        isSimple_(node.childNodes[0]) &&
        node.childNodes[0].type !== semantic_meaning_SemanticType.PREFIXOP &&
        node.childNodes[0].type !== semantic_meaning_SemanticType.APPL &&
        node.childNodes[0].type !== semantic_meaning_SemanticType.PUNCTUATED);
}
function isSimpleDegree_(node) {
    return (node.type === semantic_meaning_SemanticType.PUNCTUATED &&
        node.role === semantic_meaning_SemanticRole.ENDPUNCT &&
        node.childNodes.length === 2 &&
        node.childNodes[1].role === semantic_meaning_SemanticRole.DEGREE &&
        (isLetter_(node.childNodes[0]) ||
            isNumber_(node.childNodes[0]) ||
            (node.childNodes[0].type === semantic_meaning_SemanticType.PREFIXOP &&
                node.childNodes[0].role === semantic_meaning_SemanticRole.NEGATIVE &&
                (isLetter_(node.childNodes[0].childNodes[0]) ||
                    isNumber_(node.childNodes[0].childNodes[0])))));
}
function isSimpleLetters_(node) {
    return (isLetter_(node) ||
        (node.type === semantic_meaning_SemanticType.INFIXOP &&
            node.role === semantic_meaning_SemanticRole.IMPLICIT &&
            ((node.childNodes.length === 2 &&
                (isLetter_(node.childNodes[0]) ||
                    isSimpleNumber_(node.childNodes[0])) &&
                isLetter_(node.childNodes[1])) ||
                (node.childNodes.length === 3 &&
                    isSimpleNumber_(node.childNodes[0]) &&
                    isLetter_(node.childNodes[1]) &&
                    isLetter_(node.childNodes[2])))));
}
function isSimple_(node) {
    return node.hasAnnotation('clearspeak', 'simple');
}
function isLetter_(node) {
    return (node.type === semantic_meaning_SemanticType.IDENTIFIER &&
        (node.role === semantic_meaning_SemanticRole.LATINLETTER ||
            node.role === semantic_meaning_SemanticRole.GREEKLETTER ||
            node.role === semantic_meaning_SemanticRole.OTHERLETTER ||
            node.role === semantic_meaning_SemanticRole.SIMPLEFUNC));
}
function isNumber_(node) {
    return (node.type === semantic_meaning_SemanticType.NUMBER &&
        (node.role === semantic_meaning_SemanticRole.INTEGER || node.role === semantic_meaning_SemanticRole.FLOAT));
}
function isSimpleNumber_(node) {
    return isNumber_(node) || isSimpleFraction_(node);
}
function isSimpleFraction_(node) {
    if (hasPreference('Fraction_Over') || hasPreference('Fraction_FracOver')) {
        return false;
    }
    if (node.type !== semantic_meaning_SemanticType.FRACTION ||
        node.role !== semantic_meaning_SemanticRole.VULGAR) {
        return false;
    }
    if (hasPreference('Fraction_Ordinal')) {
        return true;
    }
    const enumerator = parseInt(node.childNodes[0].textContent, 10);
    const denominator = parseInt(node.childNodes[1].textContent, 10);
    return (enumerator > 0 && enumerator < 20 && denominator > 0 && denominator < 11);
}
function hasPreference(pref) {
    return Engine.getInstance().options.style === pref;
}
register(new SemanticAnnotator('clearspeak', 'simple', function (node) {
    return isSimpleExpression(node) ? 'simple' : '';
}));
activate('clearspeak', 'simple');
function isUnitExpression(node) {
    return ((node.type === semantic_meaning_SemanticType.TEXT && node.role !== semantic_meaning_SemanticRole.LABEL) ||
        (node.type === semantic_meaning_SemanticType.PUNCTUATED &&
            node.role === semantic_meaning_SemanticRole.TEXT &&
            isNumber_(node.childNodes[0]) &&
            allTextLastContent_(node.childNodes.slice(1))) ||
        (node.type === semantic_meaning_SemanticType.IDENTIFIER &&
            node.role === semantic_meaning_SemanticRole.UNIT) ||
        (node.type === semantic_meaning_SemanticType.INFIXOP &&
            (node.role === semantic_meaning_SemanticRole.IMPLICIT || node.role === semantic_meaning_SemanticRole.UNIT)));
}
function allTextLastContent_(nodes) {
    for (let i = 0; i < nodes.length - 1; i++) {
        if (!(nodes[i].type === semantic_meaning_SemanticType.TEXT && nodes[i].textContent === '')) {
            return false;
        }
    }
    return nodes[nodes.length - 1].type === semantic_meaning_SemanticType.TEXT;
}
register(new SemanticAnnotator('clearspeak', 'unit', function (node) {
    return isUnitExpression(node) ? 'unit' : '';
}));
activate('clearspeak', 'unit');
const NUMBER_PROPAGATORS = [
    semantic_meaning_SemanticType.MULTIREL,
    semantic_meaning_SemanticType.RELSEQ,
    semantic_meaning_SemanticType.APPL,
    semantic_meaning_SemanticType.ROW,
    semantic_meaning_SemanticType.LINE
];
const NUMBER_INHIBITORS = [
    semantic_meaning_SemanticType.SUBSCRIPT,
    semantic_meaning_SemanticType.SUPERSCRIPT,
    semantic_meaning_SemanticType.OVERSCORE,
    semantic_meaning_SemanticType.UNDERSCORE
];
function checkParent(node, info) {
    const parent = node.parent;
    if (!parent) {
        return false;
    }
    const type = parent.type;
    if (NUMBER_PROPAGATORS.indexOf(type) !== -1 ||
        (type === semantic_meaning_SemanticType.PREFIXOP &&
            parent.role === semantic_meaning_SemanticRole.NEGATIVE &&
            !info.script &&
            !info.enclosed) ||
        (type === semantic_meaning_SemanticType.PREFIXOP &&
            parent.role === semantic_meaning_SemanticRole.GEOMETRY)) {
        return true;
    }
    if (type === semantic_meaning_SemanticType.PUNCTUATED) {
        if (!info.enclosed || parent.role === semantic_meaning_SemanticRole.TEXT) {
            return true;
        }
    }
    return false;
}
function propagateNumber(node, info) {
    if (!node.childNodes.length) {
        if (checkParent(node, info)) {
            info.number = true;
            info.script = false;
            info.enclosed = false;
        }
        return [
            info['number'] ? 'number' : '',
            { number: false, enclosed: info.enclosed, script: info.script }
        ];
    }
    if (NUMBER_INHIBITORS.indexOf(node.type) !== -1) {
        info.script = true;
    }
    if (node.type === semantic_meaning_SemanticType.FENCED) {
        info.number = false;
        info.enclosed = true;
        return ['', info];
    }
    if (node.type === semantic_meaning_SemanticType.PREFIXOP &&
        node.role !== semantic_meaning_SemanticRole.GEOMETRY &&
        node.role !== semantic_meaning_SemanticRole.NEGATIVE) {
        info.number = false;
        return ['', info];
    }
    if (checkParent(node, info)) {
        info.number = true;
        info.enclosed = false;
    }
    return ['', info];
}
register(new SemanticVisitor('nemeth', 'number', propagateNumber, { number: true }));
activate('nemeth', 'number');
function annotateDepth(node) {
    if (!node.parent) {
        return [1];
    }
    const depth = parseInt(node.parent.annotation['depth'][0]);
    return [depth + 1];
}
register(new SemanticVisitor('depth', 'depth', annotateDepth));
activate('depth', 'depth');
//# sourceMappingURL=special_annotators.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic_tree.js










class SemanticTree {
    static empty() {
        const empty = parseInput('<math/>');
        const stree = new SemanticTree(empty, new Options());
        stree.mathml = empty;
        return stree;
    }
    static fromNode(semantic, opt_mathml) {
        const stree = SemanticTree.empty();
        stree.root = semantic;
        if (opt_mathml) {
            stree.mathml = opt_mathml;
        }
        return stree;
    }
    static fromRoot(semantic, opt_mathml) {
        let root = semantic;
        while (root.parent) {
            root = root.parent;
        }
        const stree = SemanticTree.fromNode(root);
        if (opt_mathml) {
            stree.mathml = opt_mathml;
        }
        return stree;
    }
    static fromXml(xml) {
        const stree = SemanticTree.empty();
        if (xml.childNodes[0]) {
            stree.root = SemanticNode.fromXml(xml.childNodes[0]);
        }
        return stree;
    }
    constructor(mathml, options) {
        this.mathml = mathml;
        this.options = options;
        this.parser = new SemanticMathml(options);
        this.root = this.parser.parse(mathml);
        this.collator = this.parser.getFactory().leafMap.collateMeaning();
        const newDefault = this.collator.newDefault();
        if (newDefault) {
            this.parser = new SemanticMathml(options);
            this.parser.getFactory().defaultMap = newDefault;
            this.root = this.parser.parse(mathml);
        }
        unitVisitor.visit(this.root, {});
        annotate(this.root);
    }
    xml(opt_brief) {
        const xml = parseInput('<stree></stree>');
        const xmlRoot = this.root.xml(xml.ownerDocument, opt_brief);
        xml.appendChild(xmlRoot);
        return xml;
    }
    toString(opt_brief) {
        return serializeXml(this.xml(opt_brief));
    }
    formatXml(opt_brief) {
        const xml = this.toString(opt_brief);
        return formatXml(xml);
    }
    displayTree() {
        this.root.displayTree();
    }
    replaceNode(oldNode, newNode) {
        const parent = oldNode.parent;
        if (!parent) {
            this.root = newNode;
            return;
        }
        parent.replaceChild(oldNode, newNode);
    }
    toJson() {
        const json = {};
        json['stree'] = this.root.toJson();
        return json;
    }
}
const unitVisitor = new SemanticVisitor('general', 'unit', (node, _info) => {
    if (isUnitProduct(node)) {
        node.role = semantic_meaning_SemanticRole.UNIT;
    }
    return false;
});
//# sourceMappingURL=semantic_tree.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/semantic_tree/semantic.js


function xmlTree(mml, options) {
    return getTree(mml, options).xml();
}
function getTree(mml, options) {
    return new SemanticTree(mml, options);
}
function getTreeFromString(expr, options) {
    const mml = DomUtil.parseInput(expr);
    return getTree(mml, options);
}
//# sourceMappingURL=semantic.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/enrich_case.js
function getCase(node) {
    for (let i = 0, enrich; (enrich = factory[i]); i++) {
        if (enrich.test(node)) {
            return enrich.constr(node);
        }
    }
    return null;
}
const factory = [];
//# sourceMappingURL=enrich_case.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/enrich_mathml.js










const SETTINGS = {
    collapsed: true,
    implicit: true
};
const IDS = new Map();
function enrich(mml, semantic, options) {
    Debugger.getInstance().generate(() => [
        'Original MathML',
        formattedOutput(mml)
    ]);
    IDS.clear();
    walkTree(semantic.root);
    if (options.structure) {
        mml.setAttribute(enrich_attr_Attribute.STRUCTURE, SemanticSkeleton.fromStructure(mml, semantic, options).toString());
    }
    Debugger.getInstance().generate(() => [
        'Semantic Tree\n',
        formattedOutput(semantic),
        'Semantically enriched MathML\n',
        formattedOutput(mml)
    ]);
    return mml;
}
function walkTree(semantic) {
    Debugger.getInstance().generate(() => [
        'WALKING START: ',
        semantic.toString()
    ]);
    const specialCase = getCase(semantic);
    let newNode;
    if (specialCase) {
        newNode = specialCase.getMathml();
        Debugger.getInstance().generate(() => [
            'WALKING END: ',
            semantic.toString()
        ]);
        return ascendNewNode(newNode);
    }
    if (semantic.mathml.length === 1) {
        Debugger.getInstance().output('Walktree Case 0');
        if (!semantic.childNodes.length) {
            Debugger.getInstance().output('Walktree Case 0.1');
            newNode = semantic.mathml[0];
            setAttributes(newNode, semantic);
            Debugger.getInstance().generate(() => [
                'WALKING END: ',
                semantic.toString()
            ]);
            return ascendNewNode(newNode);
        }
        const fchild = semantic.childNodes[0];
        if (semantic.childNodes.length === 1 &&
            fchild.type === semantic_meaning_SemanticType.EMPTY) {
            Debugger.getInstance().output('Walktree Case 0.2');
            newNode = semantic.mathml[0];
            setAttributes(newNode, semantic);
            newNode.appendChild(walkTree(fchild));
            Debugger.getInstance().generate(() => [
                'WALKING END: ',
                semantic.toString()
            ]);
            return ascendNewNode(newNode);
        }
        semantic.childNodes.forEach((child) => {
            if (!child.mathml.length) {
                child.mathml = [createInvisibleOperator(child)];
            }
        });
    }
    const newContent = semantic.contentNodes.map(cloneContentNode);
    setOperatorAttribute(semantic, newContent);
    const newChildren = semantic.childNodes.map(walkTree);
    const childrenList = SemanticSkeleton.combineContentChildren(semantic.type, semantic.role, newContent, newChildren);
    newNode = semantic.mathmlTree;
    if (newNode === null) {
        Debugger.getInstance().output('Walktree Case 1');
        newNode = introduceNewLayer(childrenList, semantic);
    }
    else {
        const attached = attachedElement(childrenList);
        Debugger.getInstance().output('Walktree Case 2');
        if (attached) {
            Debugger.getInstance().output('Walktree Case 2.1');
            newNode = parentNode(attached);
        }
        else {
            Debugger.getInstance().output('Walktree Case 2.2');
            newNode = getInnerNode(newNode);
        }
    }
    newNode = rewriteMfenced(newNode);
    mergeChildren(newNode, childrenList, semantic);
    if (!IDS.has(semantic.id)) {
        IDS.set(semantic.id, true);
        setAttributes(newNode, semantic);
    }
    Debugger.getInstance().generate(() => ['WALKING END: ', semantic.toString()]);
    return ascendNewNode(newNode);
}
function introduceNewLayer(children, semantic) {
    const lca = mathmlLca(children);
    let newNode = lca.node;
    const info = lca.type;
    if (info !== lcaType.VALID ||
        !hasEmptyTag(newNode) ||
        (!newNode.parentNode && semantic.parent)) {
        Debugger.getInstance().output('Walktree Case 1.1');
        newNode = addMrow();
        if (info === lcaType.PRUNED) {
            Debugger.getInstance().output('Walktree Case 1.1.0');
            newNode = introduceLayerAboveLca(newNode, lca.node, children);
        }
        else if (children[0]) {
            Debugger.getInstance().output('Walktree Case 1.1.1');
            const node = attachedElement(children);
            if (node) {
                const oldChildren = childrenSubset(parentNode(node), children);
                replaceNode(node, newNode);
                oldChildren.forEach(function (x) {
                    newNode.appendChild(x);
                });
            }
            else {
                moveSemanticAttributes(newNode, children[0]);
                newNode = children[0];
            }
        }
    }
    if (!semantic.mathmlTree) {
        semantic.mathmlTree = newNode;
    }
    return newNode;
}
function introduceLayerAboveLca(mrow, lca, children) {
    let innerNode = descendNode(lca);
    if (hasMathTag(innerNode)) {
        Debugger.getInstance().output('Walktree Case 1.1.0.0');
        moveSemanticAttributes(innerNode, mrow);
        toArray(innerNode.childNodes).forEach(function (x) {
            mrow.appendChild(x);
        });
        const auxNode = mrow;
        mrow = innerNode;
        innerNode = auxNode;
    }
    const index = children.indexOf(lca);
    children[index] = innerNode;
    replaceNode(innerNode, mrow);
    mrow.appendChild(innerNode);
    children.forEach(function (x) {
        mrow.appendChild(x);
    });
    return mrow;
}
function moveSemanticAttributes(oldNode, newNode) {
    for (const attr of EnrichAttributes) {
        if (oldNode.hasAttribute(attr)) {
            newNode.setAttribute(attr, oldNode.getAttribute(attr));
            oldNode.removeAttribute(attr);
        }
    }
}
function childrenSubset(node, newChildren) {
    const oldChildren = toArray(node.childNodes);
    let leftIndex = +Infinity;
    let rightIndex = -Infinity;
    newChildren.forEach(function (child) {
        const index = oldChildren.indexOf(child);
        if (index !== -1) {
            leftIndex = Math.min(leftIndex, index);
            rightIndex = Math.max(rightIndex, index);
        }
    });
    return oldChildren.slice(leftIndex, rightIndex + 1);
}
function collateChildNodes(node, children, semantic) {
    const oldChildren = [];
    let newChildren = toArray(node.childNodes);
    let notFirst = false;
    while (newChildren.length) {
        const child = newChildren.shift();
        if (child.hasAttribute(enrich_attr_Attribute.TYPE)) {
            oldChildren.push(child);
            continue;
        }
        const collect = collectChildNodes(child, children);
        if (collect.length === 0) {
            continue;
        }
        if (collect.length === 1) {
            oldChildren.push(child);
            continue;
        }
        if (notFirst) {
            child.setAttribute('AuxiliaryImplicit', true);
        }
        else {
            notFirst = true;
        }
        newChildren = collect.concat(newChildren);
    }
    const rear = [];
    const semChildren = semantic.childNodes.map(function (x) {
        return x.mathmlTree;
    });
    while (semChildren.length) {
        const schild = semChildren.pop();
        if (!schild) {
            continue;
        }
        if (oldChildren.indexOf(schild) !== -1) {
            break;
        }
        if (children.indexOf(schild) !== -1) {
            rear.unshift(schild);
        }
    }
    return oldChildren.concat(rear);
}
function collectChildNodes(node, children) {
    const collect = [];
    let newChildren = toArray(node.childNodes);
    while (newChildren.length) {
        const child = newChildren.shift();
        if (child.nodeType !== NodeType.ELEMENT_NODE) {
            continue;
        }
        if (child.hasAttribute(enrich_attr_Attribute.TYPE) ||
            children.indexOf(child) !== -1) {
            collect.push(child);
            continue;
        }
        newChildren = toArray(child.childNodes).concat(newChildren);
    }
    return collect;
}
function mergeChildren(node, newChildren, semantic) {
    if (!newChildren.length)
        return;
    if (newChildren.length === 1 && node === newChildren[0])
        return;
    const oldChildren = semantic.role === semantic_meaning_SemanticRole.IMPLICIT &&
        SemanticHeuristics.flags.combine_juxtaposition
        ? collateChildNodes(node, newChildren, semantic)
        : toArray(node.childNodes);
    if (!oldChildren.length) {
        newChildren.forEach(function (x) {
            node.appendChild(x);
        });
        return;
    }
    let oldCounter = 0;
    while (newChildren.length) {
        const newChild = newChildren[0];
        if (oldChildren[oldCounter] === newChild ||
            functionApplication(oldChildren[oldCounter], newChild)) {
            newChildren.shift();
            oldCounter++;
            continue;
        }
        if (oldChildren[oldCounter] &&
            newChildren.indexOf(oldChildren[oldCounter]) === -1) {
            oldCounter++;
            continue;
        }
        if (isDescendant(newChild, node)) {
            newChildren.shift();
            continue;
        }
        const oldChild = oldChildren[oldCounter];
        if (!oldChild) {
            if (newChild.parentNode) {
                node = parentNode(newChild);
                newChildren.shift();
                continue;
            }
            const nextChild = newChildren[1];
            if (nextChild && nextChild.parentNode) {
                node = parentNode(nextChild);
                node.insertBefore(newChild, nextChild);
                newChildren.shift();
                newChildren.shift();
                continue;
            }
            node.insertBefore(newChild, null);
            newChildren.shift();
            continue;
        }
        insertNewChild(node, oldChild, newChild);
        newChildren.shift();
    }
}
function insertNewChild(node, oldChild, newChild) {
    let parent = oldChild;
    let next = parentNode(parent);
    while (next &&
        next.firstChild === parent &&
        !parent.hasAttribute('AuxiliaryImplicit') &&
        next !== node) {
        parent = next;
        next = parentNode(parent);
    }
    if (next) {
        next.insertBefore(newChild, parent);
        parent.removeAttribute('AuxiliaryImplicit');
    }
}
function isDescendant(child, node) {
    if (!child) {
        return false;
    }
    do {
        child = parentNode(child);
        if (child === node) {
            return true;
        }
    } while (child);
    return false;
}
function functionApplication(oldNode, newNode) {
    const appl = NamedSymbol.functionApplication;
    if (oldNode &&
        newNode &&
        oldNode.textContent &&
        newNode.textContent &&
        oldNode.textContent === appl &&
        newNode.textContent === appl &&
        newNode.getAttribute(enrich_attr_Attribute.ADDED) === 'true') {
        for (let i = 0, attr; (attr = oldNode.attributes[i]); i++) {
            if (!newNode.hasAttribute(attr.nodeName)) {
                newNode.setAttribute(attr.nodeName, attr.nodeValue);
            }
        }
        replaceNode(oldNode, newNode);
        return true;
    }
    return false;
}
var lcaType;
(function (lcaType) {
    lcaType["VALID"] = "valid";
    lcaType["INVALID"] = "invalid";
    lcaType["PRUNED"] = "pruned";
})(lcaType || (lcaType = {}));
function mathmlLca(children) {
    const leftMost = attachedElement(children);
    if (!leftMost) {
        return { type: lcaType.INVALID, node: null };
    }
    const rightMost = attachedElement(children.slice().reverse());
    if (leftMost === rightMost) {
        return { type: lcaType.VALID, node: leftMost };
    }
    const leftPath = pathToRoot(leftMost);
    const newLeftPath = prunePath(leftPath, children);
    const rightPath = pathToRoot(rightMost, function (x) {
        return newLeftPath.indexOf(x) !== -1;
    });
    const lca = rightPath[0];
    const lIndex = newLeftPath.indexOf(lca);
    if (lIndex === -1) {
        return { type: lcaType.INVALID, node: null };
    }
    return {
        type: newLeftPath.length !== leftPath.length
            ? lcaType.PRUNED
            : validLca(newLeftPath[lIndex + 1], rightPath[1])
                ? lcaType.VALID
                : lcaType.INVALID,
        node: lca
    };
}
function prunePath(path, children) {
    let i = 0;
    while (path[i] && children.indexOf(path[i]) === -1) {
        i++;
    }
    return path.slice(0, i + 1);
}
function attachedElement(nodes) {
    let count = 0;
    let attached = null;
    while (!attached && count < nodes.length) {
        if (nodes[count].parentNode) {
            attached = nodes[count];
        }
        count++;
    }
    return attached;
}
function pathToRoot(node, opt_test) {
    const test = opt_test || ((_x) => false);
    const path = [node];
    while (!test(node) && !hasMathTag(node) && node.parentNode) {
        node = parentNode(node);
        path.unshift(node);
    }
    return path;
}
function validLca(left, right) {
    return !!(left && right && !left.previousSibling && !right.nextSibling);
}
function ascendNewNode(newNode) {
    while (!hasMathTag(newNode) && unitChild(newNode)) {
        newNode = parentNode(newNode);
    }
    return newNode;
}
function descendNode(node) {
    const children = toArray(node.childNodes);
    if (!children) {
        return node;
    }
    const remainder = children.filter(function (child) {
        return (child.nodeType === NodeType.ELEMENT_NODE &&
            !hasIgnoreTag(child));
    });
    if (remainder.length === 1 &&
        hasEmptyTag(remainder[0]) &&
        !remainder[0].hasAttribute(enrich_attr_Attribute.TYPE)) {
        return descendNode(remainder[0]);
    }
    return node;
}
function unitChild(node) {
    const parent = parentNode(node);
    if (!parent || !hasEmptyTag(parent)) {
        return false;
    }
    return toArray(parent.childNodes).every(function (child) {
        return child === node || isIgnorable(child);
    });
}
function isIgnorable(node) {
    if (node.nodeType !== NodeType.ELEMENT_NODE) {
        return true;
    }
    if (!node || hasIgnoreTag(node)) {
        return true;
    }
    const children = toArray(node.childNodes);
    if ((!hasEmptyTag(node) && children.length) ||
        hasDisplayTag(node) ||
        node.hasAttribute(enrich_attr_Attribute.TYPE) ||
        isOrphanedGlyph(node)) {
        return false;
    }
    return toArray(node.childNodes).every(isIgnorable);
}
function parentNode(element) {
    return element.parentNode;
}
function addCollapsedAttribute(node, collapsed) {
    const skeleton = new SemanticSkeleton(collapsed);
    node.setAttribute(enrich_attr_Attribute.COLLAPSED, skeleton.toString());
}
function cloneContentNode(content) {
    if (content.mathml.length) {
        return walkTree(content);
    }
    const clone = SETTINGS.implicit
        ? createInvisibleOperator(content)
        : addMrow();
    content.mathml = [clone];
    return clone;
}
function rewriteMfenced(mml) {
    if (dom_util_tagName(mml) !== MMLTAGS.MFENCED) {
        return mml;
    }
    const newNode = addMrow();
    for (let i = 0, attr; (attr = mml.attributes[i]); i++) {
        if (['open', 'close', 'separators'].indexOf(attr.name) === -1) {
            newNode.setAttribute(attr.name, attr.value);
        }
    }
    toArray(mml.childNodes).forEach(function (x) {
        newNode.appendChild(x);
    });
    replaceNode(mml, newNode);
    return newNode;
}
function createInvisibleOperator(operator) {
    const moNode = createElement('mo');
    const text = createTextNode(operator.textContent);
    moNode.appendChild(text);
    setAttributes(moNode, operator);
    moNode.setAttribute(enrich_attr_Attribute.ADDED, 'true');
    return moNode;
}
function setOperatorAttribute(semantic, content) {
    const operator = semantic.type + (semantic.textContent ? ',' + semantic.textContent : '');
    content.forEach(function (c) {
        getInnerNode(c).setAttribute(enrich_attr_Attribute.OPERATOR, operator);
    });
}
function getInnerNode(node) {
    const children = toArray(node.childNodes);
    if (!children) {
        return node;
    }
    const remainder = children.filter(function (child) {
        return !isIgnorable(child);
    });
    const result = [];
    for (let i = 0, remain; (remain = remainder[i]); i++) {
        if (hasEmptyTag(remain) &&
            remain.getAttribute(enrich_attr_Attribute.TYPE) !==
                semantic_meaning_SemanticType.PUNCTUATION) {
            const nextInner = getInnerNode(remain);
            if (nextInner && nextInner !== remain) {
                result.push(nextInner);
            }
        }
        else {
            result.push(remain);
        }
    }
    if (result.length === 1) {
        return result[0];
    }
    return node;
}
function formattedOutput(element) {
    return removeAttributePrefix(formatXml(element.toString()));
}
function collapsePunctuated(semantic, opt_children) {
    const optional = !!opt_children;
    const children = opt_children || [];
    const parent = semantic.parent;
    const contentIds = semantic.contentNodes.map(function (x) {
        return x.id;
    });
    contentIds.unshift('c');
    const childIds = [semantic.id, contentIds];
    for (let i = 0, child; (child = semantic.childNodes[i]); i++) {
        const mmlChild = walkTree(child);
        children.push(mmlChild);
        const innerNode = getInnerNode(mmlChild);
        if (parent && !optional) {
            innerNode.setAttribute(enrich_attr_Attribute.PARENT, parent.id.toString());
        }
        childIds.push(child.id);
    }
    return childIds;
}
//# sourceMappingURL=enrich_mathml.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/abstract_enrich_case.js
class AbstractEnrichCase {
    constructor(semantic) {
        this.semantic = semantic;
    }
}
//# sourceMappingURL=abstract_enrich_case.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_binomial.js





class CaseBinomial extends AbstractEnrichCase {
    static test(semantic) {
        return (!semantic.mathmlTree &&
            semantic.type === semantic_meaning_SemanticType.LINE &&
            semantic.role === semantic_meaning_SemanticRole.BINOMIAL);
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        if (!this.semantic.childNodes.length) {
            return this.mml;
        }
        const child = this.semantic.childNodes[0];
        this.mml = walkTree(child);
        if (this.mml.hasAttribute(enrich_attr_Attribute.TYPE)) {
            const mrow = addMrow();
            replaceNode(this.mml, mrow);
            mrow.appendChild(this.mml);
            this.mml = mrow;
        }
        setAttributes(this.mml, this.semantic);
        return this.mml;
    }
}
//# sourceMappingURL=case_binomial.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_double_script.js






class CaseDoubleScript extends AbstractEnrichCase {
    static test(semantic) {
        if (!semantic.mathmlTree || !semantic.childNodes.length) {
            return false;
        }
        const mmlTag = dom_util_tagName(semantic.mathmlTree);
        const role = semantic.childNodes[0].role;
        return ((mmlTag === MMLTAGS.MSUBSUP && role === semantic_meaning_SemanticRole.SUBSUP) ||
            (mmlTag === MMLTAGS.MUNDEROVER && role === semantic_meaning_SemanticRole.UNDEROVER));
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        const ignore = this.semantic.childNodes[0];
        const baseSem = ignore.childNodes[0];
        const supSem = this.semantic.childNodes[1];
        const subSem = ignore.childNodes[1];
        const supMml = walkTree(supSem);
        const baseMml = walkTree(baseSem);
        const subMml = walkTree(subSem);
        setAttributes(this.mml, this.semantic);
        this.mml.setAttribute(enrich_attr_Attribute.CHILDREN, makeIdList([baseSem, subSem, supSem]));
        [baseMml, subMml, supMml].forEach((child) => getInnerNode(child).setAttribute(enrich_attr_Attribute.PARENT, this.mml.getAttribute(enrich_attr_Attribute.ID)));
        this.mml.setAttribute(enrich_attr_Attribute.TYPE, ignore.role);
        addCollapsedAttribute(this.mml, [
            this.semantic.id,
            [ignore.id, baseSem.id, subSem.id],
            supSem.id
        ]);
        return this.mml;
    }
}
//# sourceMappingURL=case_double_script.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_multiindex.js






class CaseMultiindex extends AbstractEnrichCase {
    static multiscriptIndex(index) {
        if (index.type === semantic_meaning_SemanticType.PUNCTUATED &&
            index.contentNodes[0].role === semantic_meaning_SemanticRole.DUMMY) {
            return collapsePunctuated(index);
        }
        walkTree(index);
        return index.id;
    }
    static createNone_(semantic) {
        const newNode = createElement('none');
        if (semantic) {
            setAttributes(newNode, semantic);
        }
        newNode.setAttribute(enrich_attr_Attribute.ADDED, 'true');
        return newNode;
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    completeMultiscript(rightIndices, leftIndices) {
        const children = toArray(this.mml.childNodes).slice(1);
        let childCounter = 0;
        const completeIndices = (indices) => {
            for (const index of indices) {
                const child = children[childCounter];
                if (child && index === parseInt(child.getAttribute(enrich_attr_Attribute.ID))) {
                    child.setAttribute(enrich_attr_Attribute.PARENT, this.semantic.id.toString());
                    childCounter++;
                }
                else if (!child ||
                    index !==
                        parseInt(getInnerNode(child).getAttribute(enrich_attr_Attribute.ID))) {
                    const query = this.semantic.querySelectorAll((x) => x.id === index);
                    this.mml.insertBefore(CaseMultiindex.createNone_(query[0]), child || null);
                }
                else {
                    getInnerNode(child).setAttribute(enrich_attr_Attribute.PARENT, this.semantic.id.toString());
                    childCounter++;
                }
            }
        };
        completeIndices(rightIndices);
        if (children[childCounter] &&
            dom_util_tagName(children[childCounter]) !== MMLTAGS.MPRESCRIPTS) {
            this.mml.insertBefore(children[childCounter], createElement('mprescripts'));
        }
        else {
            childCounter++;
        }
        completeIndices(leftIndices);
    }
}
//# sourceMappingURL=case_multiindex.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_multiscripts.js







class CaseMultiscripts extends CaseMultiindex {
    static test(semantic) {
        if (!semantic.mathmlTree) {
            return false;
        }
        const mmlTag = dom_util_tagName(semantic.mathmlTree);
        return (mmlTag === MMLTAGS.MMULTISCRIPTS &&
            (semantic.type === semantic_meaning_SemanticType.SUPERSCRIPT ||
                semantic.type === semantic_meaning_SemanticType.SUBSCRIPT));
    }
    constructor(semantic) {
        super(semantic);
    }
    getMathml() {
        setAttributes(this.mml, this.semantic);
        let baseSem, rsup, rsub;
        if (this.semantic.childNodes[0] &&
            this.semantic.childNodes[0].role === semantic_meaning_SemanticRole.SUBSUP) {
            const ignore = this.semantic.childNodes[0];
            baseSem = ignore.childNodes[0];
            rsup = CaseMultiindex.multiscriptIndex(this.semantic.childNodes[1]);
            rsub = CaseMultiindex.multiscriptIndex(ignore.childNodes[1]);
            const collapsed = [this.semantic.id, [ignore.id, baseSem.id, rsub], rsup];
            addCollapsedAttribute(this.mml, collapsed);
            this.mml.setAttribute(enrich_attr_Attribute.TYPE, ignore.role);
            this.completeMultiscript(SemanticSkeleton.interleaveIds(rsub, rsup), []);
        }
        else {
            baseSem = this.semantic.childNodes[0];
            rsup = CaseMultiindex.multiscriptIndex(this.semantic.childNodes[1]);
            const collapsed = [this.semantic.id, baseSem.id, rsup];
            addCollapsedAttribute(this.mml, collapsed);
        }
        const childIds = SemanticSkeleton.collapsedLeafs(rsub || [], rsup);
        const base = walkTree(baseSem);
        getInnerNode(base).setAttribute(enrich_attr_Attribute.PARENT, this.semantic.id.toString());
        childIds.unshift(baseSem.id);
        this.mml.setAttribute(enrich_attr_Attribute.CHILDREN, childIds.join(','));
        return this.mml;
    }
}
//# sourceMappingURL=case_multiscripts.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_tensor.js





class CaseTensor extends CaseMultiindex {
    static test(semantic) {
        return !!semantic.mathmlTree && semantic.type === semantic_meaning_SemanticType.TENSOR;
    }
    constructor(semantic) {
        super(semantic);
    }
    getMathml() {
        walkTree(this.semantic.childNodes[0]);
        const lsub = CaseMultiindex.multiscriptIndex(this.semantic.childNodes[1]);
        const lsup = CaseMultiindex.multiscriptIndex(this.semantic.childNodes[2]);
        const rsub = CaseMultiindex.multiscriptIndex(this.semantic.childNodes[3]);
        const rsup = CaseMultiindex.multiscriptIndex(this.semantic.childNodes[4]);
        setAttributes(this.mml, this.semantic);
        const collapsed = [
            this.semantic.id,
            this.semantic.childNodes[0].id,
            lsub,
            lsup,
            rsub,
            rsup
        ];
        addCollapsedAttribute(this.mml, collapsed);
        const childIds = SemanticSkeleton.collapsedLeafs(lsub, lsup, rsub, rsup);
        childIds.unshift(this.semantic.childNodes[0].id);
        this.mml.setAttribute(enrich_attr_Attribute.CHILDREN, childIds.join(','));
        this.completeMultiscript(SemanticSkeleton.interleaveIds(rsub, rsup), SemanticSkeleton.interleaveIds(lsub, lsup));
        return this.mml;
    }
}
//# sourceMappingURL=case_tensor.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_embellished.js










class CaseEmbellished extends AbstractEnrichCase {
    static test(semantic) {
        return !!(semantic.mathmlTree &&
            semantic.fencePointer &&
            !semantic.mathmlTree.getAttribute('data-semantic-type'));
    }
    static makeEmptyNode_(id) {
        const mrow = addMrow();
        const empty = new SemanticNode(id);
        empty.type = semantic_meaning_SemanticType.EMPTY;
        empty.mathmlTree = mrow;
        return empty;
    }
    static fencedMap_(fence, ids) {
        ids[fence.id] = fence.mathmlTree;
        if (!fence.embellished) {
            return;
        }
        CaseEmbellished.fencedMap_(fence.childNodes[0], ids);
    }
    constructor(semantic) {
        super(semantic);
        this.fenced = null;
        this.fencedMml = null;
        this.fencedMmlNodes = [];
        this.ofence = null;
        this.ofenceMml = null;
        this.ofenceMap = {};
        this.cfence = null;
        this.cfenceMml = null;
        this.cfenceMap = {};
        this.parentCleanup = [];
    }
    getMathml() {
        this.getFenced_();
        this.fencedMml = walkTree(this.fenced);
        this.getFencesMml_();
        if (this.fenced.type === semantic_meaning_SemanticType.EMPTY && !this.fencedMml.parentNode) {
            this.fencedMml.setAttribute(enrich_attr_Attribute.ADDED, 'true');
            this.cfenceMml.parentNode.insertBefore(this.fencedMml, this.cfenceMml);
        }
        this.getFencedMml_();
        const rewrite = this.rewrite_();
        return rewrite;
    }
    fencedElement(node) {
        return (node.type === semantic_meaning_SemanticType.FENCED ||
            node.type === semantic_meaning_SemanticType.MATRIX ||
            node.type === semantic_meaning_SemanticType.VECTOR);
    }
    getFenced_() {
        let currentNode = this.semantic;
        while (!this.fencedElement(currentNode)) {
            currentNode = currentNode.childNodes[0];
        }
        this.fenced = currentNode.childNodes[0];
        this.ofence = currentNode.contentNodes[0];
        this.cfence = currentNode.contentNodes[1];
        CaseEmbellished.fencedMap_(this.ofence, this.ofenceMap);
        CaseEmbellished.fencedMap_(this.cfence, this.cfenceMap);
    }
    getFencedMml_() {
        let sibling = this.ofenceMml.nextSibling;
        sibling = sibling === this.fencedMml ? sibling : this.fencedMml;
        while (sibling && sibling !== this.cfenceMml) {
            this.fencedMmlNodes.push(sibling);
            sibling = sibling.nextSibling;
        }
    }
    getFencesMml_() {
        let currentNode = this.semantic;
        const ofenceIds = Object.keys(this.ofenceMap);
        const cfenceIds = Object.keys(this.cfenceMap);
        while ((!this.ofenceMml || !this.cfenceMml) &&
            currentNode !== this.fenced) {
            if (ofenceIds.indexOf(currentNode.fencePointer) !== -1 &&
                !this.ofenceMml) {
                this.ofenceMml = currentNode.mathmlTree;
            }
            if (cfenceIds.indexOf(currentNode.fencePointer) !== -1 &&
                !this.cfenceMml) {
                this.cfenceMml = currentNode.mathmlTree;
            }
            currentNode = currentNode.childNodes[0];
        }
        if (!this.ofenceMml) {
            this.ofenceMml = this.ofence.mathmlTree;
        }
        if (!this.cfenceMml) {
            this.cfenceMml = this.cfence.mathmlTree;
        }
        if (this.ofenceMml) {
            this.ofenceMml = ascendNewNode(this.ofenceMml);
        }
        if (this.cfenceMml) {
            this.cfenceMml = ascendNewNode(this.cfenceMml);
        }
    }
    rewrite_() {
        let currentNode = this.semantic;
        let result = null;
        const newNode = this.introduceNewLayer_();
        setAttributes(newNode, this.fenced.parent);
        while (!this.fencedElement(currentNode)) {
            const mml = currentNode.mathmlTree;
            const specialCase = this.specialCase_(currentNode, mml);
            if (specialCase) {
                currentNode = specialCase;
            }
            else {
                setAttributes(mml, currentNode);
                const mmlChildren = [];
                for (let i = 1, child; (child = currentNode.childNodes[i]); i++) {
                    mmlChildren.push(walkTree(child));
                }
                currentNode = currentNode.childNodes[0];
            }
            const dummy = createElement('dummy');
            const saveChild = mml.childNodes[0];
            replaceNode(mml, dummy);
            replaceNode(newNode, mml);
            replaceNode(mml.childNodes[0], newNode);
            replaceNode(dummy, saveChild);
            if (!result) {
                result = mml;
            }
        }
        walkTree(this.ofence);
        walkTree(this.cfence);
        this.cleanupParents_();
        return result || newNode;
    }
    specialCase_(semantic, mml) {
        const mmlTag = dom_util_tagName(mml);
        let parent = null;
        let caller;
        if (mmlTag === MMLTAGS.MSUBSUP) {
            parent = semantic.childNodes[0];
            caller = CaseDoubleScript;
        }
        else if (mmlTag === MMLTAGS.MMULTISCRIPTS) {
            if (semantic.type === semantic_meaning_SemanticType.SUPERSCRIPT ||
                semantic.type === semantic_meaning_SemanticType.SUBSCRIPT) {
                caller = CaseMultiscripts;
            }
            else if (semantic.type === semantic_meaning_SemanticType.TENSOR) {
                caller = CaseTensor;
            }
            if (caller &&
                semantic.childNodes[0] &&
                semantic.childNodes[0].role === semantic_meaning_SemanticRole.SUBSUP) {
                parent = semantic.childNodes[0];
            }
            else {
                parent = semantic;
            }
        }
        if (!parent) {
            return null;
        }
        const base = parent.childNodes[0];
        const empty = CaseEmbellished.makeEmptyNode_(base.id);
        parent.childNodes[0] = empty;
        mml = new caller(semantic).getMathml();
        parent.childNodes[0] = base;
        this.parentCleanup.push(mml);
        return parent.childNodes[0];
    }
    introduceNewLayer_() {
        const fullOfence = this.fullFence(this.ofenceMml);
        const fullCfence = this.fullFence(this.cfenceMml);
        let newNode = addMrow();
        replaceNode(this.fencedMml, newNode);
        this.fencedMmlNodes.forEach((node) => newNode.appendChild(node));
        newNode.insertBefore(fullOfence, this.fencedMml);
        newNode.appendChild(fullCfence);
        if (!newNode.parentNode) {
            const mrow = addMrow();
            while (newNode.childNodes.length > 0) {
                mrow.appendChild(newNode.childNodes[0]);
            }
            newNode.appendChild(mrow);
            newNode = mrow;
        }
        return newNode;
    }
    fullFence(fence) {
        const parent = this.fencedMml.parentNode;
        let currentFence = fence;
        while (currentFence.parentNode && currentFence.parentNode !== parent) {
            currentFence = currentFence.parentNode;
        }
        return currentFence;
    }
    cleanupParents_() {
        this.parentCleanup.forEach(function (x) {
            const parent = x.childNodes[1].getAttribute(enrich_attr_Attribute.PARENT);
            x.childNodes[0].setAttribute(enrich_attr_Attribute.PARENT, parent);
        });
    }
}
//# sourceMappingURL=case_embellished.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_empheq.js





class CaseEmpheq extends AbstractEnrichCase {
    static test(semantic) {
        return !!semantic.mathmlTree && semantic.hasAnnotation('Emph', 'top');
    }
    constructor(semantic) {
        super(semantic);
        this.mrows = [];
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        this.recurseToTable(this.semantic);
        if (this.mrows.length) {
            const newRow = addMrow();
            const parent = this.mml.parentNode;
            parent.insertBefore(newRow, this.mml);
            for (const mrow of this.mrows) {
                newRow.appendChild(mrow);
            }
            newRow.appendChild(this.mml);
        }
        return this.mml;
    }
    recurseToTable(node) {
        var _a, _b;
        if (!(node.hasAnnotation('Emph', 'top') || node.hasAnnotation('Emph', 'fence')) &&
            (node.hasAnnotation('Emph', 'left') ||
                node.hasAnnotation('Emph', 'right'))) {
            walkTree(node);
            return;
        }
        if (!node.mathmlTree ||
            (dom_util_tagName(node.mathmlTree) === MMLTAGS.MTABLE &&
                ((_a = node.annotation['Emph']) === null || _a === void 0 ? void 0 : _a.length) &&
                node.annotation['Emph'][0] !== 'table')) {
            const newNode = addMrow();
            setAttributes(newNode, node);
            this.mrows.unshift(newNode);
        }
        else {
            if (dom_util_tagName(node.mathmlTree) === MMLTAGS.MTABLE &&
                ((_b = node.annotation['Emph']) === null || _b === void 0 ? void 0 : _b.length) &&
                node.annotation['Emph'][0] === 'table') {
                this.finalizeTable(node);
                return;
            }
            setAttributes(node.mathmlTree, node);
        }
        node.childNodes.forEach(this.recurseToTable.bind(this));
        if (node.textContent || node.type === 'punctuated') {
            const newContent = node.contentNodes.map((x) => {
                const newNode = cloneContentNode(x);
                if (newNode.hasAttribute('data-semantic-added')) {
                    this.mrows.unshift(newNode);
                }
                else {
                    this.recurseToTable(x);
                }
                return newNode;
            });
            setOperatorAttribute(node, newContent);
            return;
        }
        node.contentNodes.forEach(this.recurseToTable.bind(this));
    }
    finalizeTable(node) {
        setAttributes(node.mathmlTree, node);
        node.contentNodes.forEach((x) => {
            walkTree(x);
        });
        node.childNodes.forEach((x) => {
            walkTree(x);
        });
    }
}
//# sourceMappingURL=case_empheq.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_limit.js






class CaseLimit extends AbstractEnrichCase {
    static test(semantic) {
        if (!semantic.mathmlTree || !semantic.childNodes.length) {
            return false;
        }
        const mmlTag = dom_util_tagName(semantic.mathmlTree);
        const type = semantic.type;
        return (((type === semantic_meaning_SemanticType.LIMUPPER || type === semantic_meaning_SemanticType.LIMLOWER) &&
            (mmlTag === MMLTAGS.MSUBSUP || mmlTag === MMLTAGS.MUNDEROVER)) ||
            (type === semantic_meaning_SemanticType.LIMBOTH &&
                (mmlTag === MMLTAGS.MSUB ||
                    mmlTag === MMLTAGS.MUNDER ||
                    mmlTag === MMLTAGS.MSUP ||
                    mmlTag === MMLTAGS.MOVER)));
    }
    static walkTree_(node) {
        if (node) {
            walkTree(node);
        }
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        const children = this.semantic.childNodes;
        if (this.semantic.type !== semantic_meaning_SemanticType.LIMBOTH &&
            this.mml.childNodes.length >= 3) {
            this.mml = introduceNewLayer([this.mml], this.semantic);
        }
        setAttributes(this.mml, this.semantic);
        if (!children[0].mathmlTree) {
            children[0].mathmlTree = this.semantic.mathmlTree;
        }
        children.forEach(CaseLimit.walkTree_);
        return this.mml;
    }
}
//# sourceMappingURL=case_limit.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_line.js




class CaseLine extends AbstractEnrichCase {
    static test(semantic) {
        return !!semantic.mathmlTree && semantic.type === semantic_meaning_SemanticType.LINE;
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        if (this.semantic.contentNodes.length) {
            walkTree(this.semantic.contentNodes[0]);
        }
        if (this.semantic.childNodes.length) {
            walkTree(this.semantic.childNodes[0]);
        }
        setAttributes(this.mml, this.semantic);
        return this.mml;
    }
}
//# sourceMappingURL=case_line.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_proof.js




class CaseProof extends AbstractEnrichCase {
    static test(semantic) {
        return (!!semantic.mathmlTree &&
            (semantic.type === semantic_meaning_SemanticType.INFERENCE ||
                semantic.type === semantic_meaning_SemanticType.PREMISES));
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        if (!this.semantic.childNodes.length) {
            return this.mml;
        }
        this.semantic.contentNodes.forEach(function (x) {
            walkTree(x);
            setAttributes(x.mathmlTree, x);
        });
        this.semantic.childNodes.forEach(function (x) {
            walkTree(x);
        });
        setAttributes(this.mml, this.semantic);
        if (this.mml.getAttribute('data-semantic-id') ===
            this.mml.getAttribute('data-semantic-parent')) {
            this.mml.removeAttribute('data-semantic-parent');
        }
        return this.mml;
    }
}
//# sourceMappingURL=case_proof.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_table.js






class CaseTable extends AbstractEnrichCase {
    static test(semantic) {
        return (semantic.type === semantic_meaning_SemanticType.MATRIX ||
            semantic.type === semantic_meaning_SemanticType.VECTOR ||
            semantic.type === semantic_meaning_SemanticType.CASES);
    }
    constructor(semantic) {
        super(semantic);
        this.inner = [];
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        const lfence = cloneContentNode(this.semantic.contentNodes[0]);
        const rfence = this.semantic.contentNodes[1]
            ? cloneContentNode(this.semantic.contentNodes[1])
            : null;
        this.inner = this.semantic.childNodes.map(walkTree);
        if (!this.mml) {
            this.mml = introduceNewLayer([lfence].concat(this.inner, [rfence]), this.semantic);
        }
        else if (dom_util_tagName(this.mml) === MMLTAGS.MFENCED) {
            const children = this.mml.childNodes;
            this.mml.insertBefore(lfence, children[0] || null);
            if (rfence) {
                this.mml.appendChild(rfence);
            }
            this.mml = rewriteMfenced(this.mml);
        }
        else {
            const newChildren = [lfence, this.mml];
            if (rfence) {
                newChildren.push(rfence);
            }
            this.mml = introduceNewLayer(newChildren, this.semantic);
        }
        setAttributes(this.mml, this.semantic);
        return this.mml;
    }
}
//# sourceMappingURL=case_table.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/case_text.js




class CaseText extends AbstractEnrichCase {
    static test(semantic) {
        return (semantic.type === semantic_meaning_SemanticType.PUNCTUATED &&
            (semantic.role === semantic_meaning_SemanticRole.TEXT ||
                semantic.contentNodes.every((x) => x.role === semantic_meaning_SemanticRole.DUMMY)));
    }
    constructor(semantic) {
        super(semantic);
        this.mml = semantic.mathmlTree;
    }
    getMathml() {
        const children = [];
        const collapsed = collapsePunctuated(this.semantic, children);
        this.mml = introduceNewLayer(children, this.semantic);
        setAttributes(this.mml, this.semantic);
        this.mml.removeAttribute(enrich_attr_Attribute.CONTENT);
        addCollapsedAttribute(this.mml, collapsed);
        return this.mml;
    }
}
//# sourceMappingURL=case_text.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/enrich_case_factory.js












factory.push(...[
    {
        test: CaseLimit.test,
        constr: (node) => new CaseLimit(node)
    },
    {
        test: CaseEmbellished.test,
        constr: (node) => new CaseEmbellished(node)
    },
    {
        test: CaseDoubleScript.test,
        constr: (node) => new CaseDoubleScript(node)
    },
    {
        test: CaseTensor.test,
        constr: (node) => new CaseTensor(node)
    },
    {
        test: CaseMultiscripts.test,
        constr: (node) => new CaseMultiscripts(node)
    },
    { test: CaseLine.test, constr: (node) => new CaseLine(node) },
    {
        test: CaseBinomial.test,
        constr: (node) => new CaseBinomial(node)
    },
    {
        test: CaseProof.test,
        constr: (node) => new CaseProof(node)
    },
    {
        test: CaseEmpheq.test,
        constr: (node) => new CaseEmpheq(node)
    },
    {
        test: CaseTable.test,
        constr: (node) => new CaseTable(node)
    },
    { test: CaseText.test, constr: (node) => new CaseText(node) }
]);
//# sourceMappingURL=enrich_case_factory.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/enrich_mathml/enrich.js





function semanticMathmlNode(mml, options) {
    const clone = cloneNode(mml);
    const tree = getTree(clone, options);
    return enrich(clone, tree, options);
}
function semanticMathmlSync(expr, options) {
    const mml = parseInput(expr);
    try {
        return semanticMathmlNode(mml, options);
    }
    catch (err) {
        console.error(err);
        return mml;
    }
}
function semanticMathml(expr, options, callback) {
    EnginePromise.getall().then(() => {
        const mml = DomUtil.parseInput(expr);
        callback(semanticMathmlNode(mml, options));
    });
}
function prepareMmlString(expr) {
    if (!expr.match(/^<math/)) {
        expr = '<math>' + expr;
    }
    if (!expr.match(/\/math>$/)) {
        expr += '</math>';
    }
    return expr;
}
//# sourceMappingURL=enrich.js.map
;// ./node_modules/.pnpm/speech-rule-engine@5.0.0-beta.1/node_modules/speech-rule-engine/js/speech_rules/clearspeak_preference_string.js

const PREFERENCES = new DynamicProperties({
    AbsoluteValue: ['Auto', 'AbsEnd', 'Cardinality', 'Determinant'],
    Bar: ['Auto', 'Conjugate'],
    Caps: ['Auto', 'SayCaps'],
    CombinationPermutation: ['Auto', 'ChoosePermute'],
    Currency: ['Auto', 'Position', 'Prefix'],
    Ellipses: ['Auto', 'AndSoOn'],
    Enclosed: ['Auto', 'EndEnclose'],
    Exponent: [
        'Auto',
        'AfterPower',
        'Ordinal',
        'OrdinalPower',
        'Exponent'
    ],
    Fraction: [
        'Auto',
        'EndFrac',
        'FracOver',
        'General',
        'GeneralEndFrac',
        'Ordinal',
        'Over',
        'OverEndFrac',
        'Per'
    ],
    Functions: [
        'Auto',
        'None',
        'Reciprocal'
    ],
    Inference: ['Auto', 'Long'],
    ImpliedTimes: ['Auto', 'MoreImpliedTimes', 'None'],
    Log: ['Auto', 'LnAsNaturalLog'],
    Matrix: [
        'Auto',
        'Combinatoric',
        'EndMatrix',
        'EndVector',
        'SilentColNum',
        'SpeakColNum',
        'Vector'
    ],
    MultiLineLabel: [
        'Auto',
        'Case',
        'Constraint',
        'Equation',
        'Line',
        'None',
        'Row',
        'Step'
    ],
    MultiLineOverview: ['Auto', 'None'],
    MultiLinePausesBetweenColumns: ['Auto', 'Long', 'Short'],
    MultsymbolDot: ['Auto', 'Dot'],
    MultsymbolX: ['Auto', 'By', 'Cross'],
    Paren: [
        'Auto',
        'CoordPoint',
        'Interval',
        'Silent',
        'Speak',
        'SpeakNestingLevel'
    ],
    Prime: ['Auto', 'Angle', 'Length'],
    Roots: ['Auto', 'PosNegSqRoot', 'PosNegSqRootEnd', 'RootEnd'],
    SetMemberSymbol: ['Auto', 'Belongs', 'Element', 'Member', 'In'],
    Sets: ['Auto', 'SilentBracket', 'woAll'],
    TriangleSymbol: ['Auto', 'Delta'],
    Trig: [
        'Auto',
        'ArcTrig',
        'TrigInverse',
        'Reciprocal'
    ],
    VerticalLine: ['Auto', 'Divides', 'Given', 'SuchThat']
});
const AUTO = 'Auto';
function fromPreference(pref) {
    const pairs = pref.split(':');
    const preferences = {};
    const properties = PREFERENCES.getProperties();
    const validKeys = Object.keys(properties);
    for (let i = 0, key; (key = pairs[i]); i++) {
        const pair = key.split('_');
        if (validKeys.indexOf(pair[0]) === -1) {
            continue;
        }
        const value = pair[1];
        if (value &&
            value !== AUTO &&
            properties[pair[0]].indexOf(value) !== -1) {
            preferences[pair[0]] = pair[1];
        }
    }
    return preferences;
}
function toPreference(pref) {
    const keys = Object.keys(pref);
    const str = [];
    for (let i = 0; i < keys.length; i++) {
        str.push(keys[i] + '_' + pref[keys[i]]);
    }
    return str.length ? str.join(':') : DynamicCstr.DEFAULT_VALUE;
}
function findPreference(prefs, kind) {
    if (prefs === 'default') {
        return AUTO;
    }
    const parsed = fromPreference(prefs);
    return parsed[kind] || AUTO;
}
function addPreference(prefs, kind, value) {
    if (prefs === 'default') {
        return kind + '_' + value;
    }
    const parsed = fromPreference(prefs);
    parsed[kind] = value;
    return toPreference(parsed);
}
//# sourceMappingURL=clearspeak_preference_string.js.map
;// ./mjs/a11y/sre.js





const locales = variables/* Variables */.u.LOCALES;
const setupEngine = (x) => {
    return Engine.getInstance().setup(x);
};
const engineSetup = () => {
    return Engine.getInstance().json();
};
const toEnriched = (mml) => {
    return semanticMathmlSync(mml, Engine.getInstance().options);
};
const parseDOM = parseInput;
const sre_addPreference = addPreference;
const sre_fromPreference = fromPreference;
const sre_toPreference = toPreference;
//# sourceMappingURL=sre.js.map
;// ./mjs/a11y/speech/SpeechMenu.js
var SpeechMenu_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


let csPrefsSetting = {};
let previousPrefs = null;
function currentPreference(settings) {
    var _a, _b;
    const matcher = settings === null || settings === void 0 ? void 0 : settings.match(/^clearspeak-(.*)/);
    previousPrefs = (_b = (_a = (matcher && matcher[1])) !== null && _a !== void 0 ? _a : previousPrefs) !== null && _b !== void 0 ? _b : 'default';
    return previousPrefs;
}
function csPrefsVariables(menu, prefs) {
    const srVariable = menu.pool.lookup('speechRules');
    const previous = currentPreference(menu.settings.speechRules);
    csPrefsSetting = sre_fromPreference(previous);
    for (const pref of prefs) {
        menu.factory.get('variable')(menu.factory, {
            name: 'csprf_' + pref,
            setter: (value) => {
                csPrefsSetting[pref] = value;
                srVariable.setValue('clearspeak-' + sre_toPreference(csPrefsSetting));
            },
            getter: () => {
                return csPrefsSetting[pref] || 'Auto';
            },
        }, menu.pool);
    }
}
const localePreferences = new Map();
function getLocalePreferences(menu, locale) {
    return SpeechMenu_awaiter(this, void 0, void 0, function* () {
        if (!localePreferences.has(locale)) {
            yield menu.mathItem.generatorPool.getLocalePreferences(localePreferences);
        }
    });
}
const relevantPreferences = new Map();
let SpeechMenu_counter = 0;
function csSelectionBox(menu, locale) {
    const props = localePreferences.get(locale);
    csPrefsVariables(menu, Object.keys(props));
    const items = [];
    for (const prop of Object.getOwnPropertyNames(props)) {
        items.push({
            title: prop,
            values: props[prop].map((x) => x.replace(RegExp('^' + prop + '_'), '')),
            variable: 'csprf_' + prop,
        });
    }
    const sb = menu.factory.get('selectionBox')(menu.factory, {
        title: 'Clearspeak Preferences',
        signature: '',
        order: 'alphabetic',
        grid: 'square',
        selections: items,
    }, menu);
    return {
        type: 'command',
        id: 'ClearspeakPreferences',
        content: 'Select Preferences',
        action: () => sb.post(0, 0),
    };
}
function basePreferences(previous) {
    const items = [
        {
            type: 'radio',
            content: 'No Preferences',
            id: 'clearspeak-default',
            variable: 'speechRules',
        },
        {
            type: 'radio',
            content: 'Current Preferences',
            id: 'clearspeak-' + previous,
            variable: 'speechRules',
        },
        {
            type: 'rule',
        },
    ];
    return items;
}
function smartPreferences(previous, smart, locale) {
    const loc = localePreferences.get(locale);
    const items = [
        { type: 'label', content: 'Preferences for ' + smart },
        { type: 'rule' },
    ];
    return items.concat(loc[smart].map(function (x) {
        const [key, value] = x.split('_');
        return {
            type: 'radioCompare',
            content: value,
            id: 'clearspeak-' + sre_addPreference(previous, key, value),
            variable: 'speechRules',
            comparator: (x, y) => {
                if (x === y) {
                    return true;
                }
                if (value !== 'Auto') {
                    return false;
                }
                const [dom1, pref] = x.split('-');
                const [dom2] = y.split('-');
                return (dom1 === dom2 && !sre_fromPreference(pref)[key]);
            },
        };
    }));
}
function clearspeakMenu(menu, sub, callback) {
    return SpeechMenu_awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const exit = (items) => {
            callback(menu.factory.get('subMenu')(menu.factory, {
                items: items,
                id: 'Clearspeak',
            }, sub));
        };
        if (!menu.settings.speech || !menu.settings.enrich) {
            exit([]);
            return;
        }
        const locale = menu.pool.lookup('locale').getValue();
        yield getLocalePreferences(menu, locale);
        if (!localePreferences.get(locale)) {
            exit([]);
            return;
        }
        const box = csSelectionBox(menu, locale);
        let items = [];
        if (menu.settings.speech) {
            const item = menu.mathItem;
            const explorer = (_a = item === null || item === void 0 ? void 0 : item.explorers) === null || _a === void 0 ? void 0 : _a.speech;
            const previous = currentPreference(menu.settings.speechRules);
            items = items.concat(basePreferences(previous));
            const focus = explorer === null || explorer === void 0 ? void 0 : explorer.refocus;
            const semantic = (_b = focus === null || focus === void 0 ? void 0 : focus.getAttribute('data-semantic-id')) !== null && _b !== void 0 ? _b : null;
            const count = SpeechMenu_counter++;
            yield item.generatorPool.getRelevantPreferences(item, semantic, relevantPreferences, count);
            const smart = relevantPreferences.get(count);
            relevantPreferences.delete(count);
            if (smart) {
                const smartItems = smartPreferences(previous, smart, locale);
                items = items.concat(smartItems);
            }
        }
        items.splice(2, 0, box);
        exit(items);
    });
}
MJContextMenu.DynamicSubmenus.set('Clearspeak', [clearspeakMenu, 'speech']);
let LOCALE_MENU = null;
function localeMenu(menu, sub, callback) {
    if (LOCALE_MENU) {
        callback(LOCALE_MENU);
        return;
    }
    const radios = [];
    for (const lang of locales.keys()) {
        if (lang === 'nemeth' || lang === 'euro')
            continue;
        radios.push({
            type: 'radio',
            id: lang,
            content: locales.get(lang) || lang,
            variable: 'locale',
        });
    }
    radios.sort((x, y) => x.content.localeCompare(y.content, 'en'));
    LOCALE_MENU = menu.factory.get('subMenu')(menu.factory, {
        items: radios,
        id: 'Language',
    }, sub);
    callback(LOCALE_MENU);
}
MJContextMenu.DynamicSubmenus.set('A11yLanguage', [localeMenu, 'speech']);
//# sourceMappingURL=SpeechMenu.js.map
;// ./mjs/ui/menu/MenuUtil.js

const isMac = context.os === 'MacOS';
function copyToClipboard(text) {
    const document = context.document;
    const input = document.createElement('textarea');
    input.value = text;
    input.setAttribute('readonly', '');
    input.style.cssText =
        'height: 1px; width: 1px; padding: 1px; position: absolute; left: -10px';
    document.body.appendChild(input);
    input.select();
    try {
        document.execCommand('copy');
    }
    catch (error) {
        alert(`Can't copy to clipboard: ${error.message}`);
    }
    document.body.removeChild(input);
}
//# sourceMappingURL=MenuUtil.js.map
;// ./mjs/ui/menu/AnnotationMenu.js

function showAnnotations(box, types, cache) {
    return (menu, sub) => {
        getAnnotation(getSemanticNode(menu), types, cache);
        box.attachMenu(menu);
        return createAnnotationMenu(menu, sub, cache, () => box.post());
    };
}
function copyAnnotations(cache) {
    return (menu, sub) => {
        const annotations = cache.slice();
        cache.length = 0;
        return createAnnotationMenu(menu, sub, annotations, () => copyToClipboard(annotation.trim()));
    };
}
function getSemanticNode(menu) {
    var _a;
    let node = (_a = menu.mathItem) === null || _a === void 0 ? void 0 : _a.root;
    while (node && !node.isKind('semantics')) {
        if (node.isToken || node.childNodes.length !== 1)
            return null;
        node = node.childNodes[0];
    }
    return node;
}
function getAnnotation(node, types, annotations) {
    if (!node)
        return;
    for (const child of node.childNodes) {
        if (child.isKind('annotation')) {
            const match = annotationMatch(child, types);
            if (match) {
                const value = child.childNodes.reduce((text, chars) => text + chars.toString(), '');
                annotations.push([match, value]);
            }
        }
    }
}
function annotationMatch(child, types) {
    const encoding = child.attributes.get('encoding');
    for (const type of Object.keys(types)) {
        if (types[type].includes(encoding)) {
            return type;
        }
    }
    return null;
}
let annotation = '';
function createAnnotationMenu(menu, submenu, annotations, action) {
    return menu.factory.get('subMenu')(menu.factory, {
        items: annotations.map(([type, value]) => {
            return {
                type: 'command',
                id: type,
                content: type,
                action: () => {
                    annotation = value;
                    action();
                },
            };
        }),
        id: 'annotations',
    }, submenu);
}
//# sourceMappingURL=AnnotationMenu.js.map
;// ./mjs/ui/menu/RadioCompare.js

class RadioCompare extends Radio {
    static fromJson(_factory, { content: content, variable: variable, id: id, comparator: comparator, }, menu) {
        return new this(menu, content, variable, id, comparator);
    }
    constructor(menu, content, variable, id, comparator) {
        super(menu, content, variable, id);
        this.comparator = comparator;
        this.role = 'menuitemradiocompare';
    }
    updateAria() {
        this.html.setAttribute('aria-checked', this.comparator(this.variable.getValue(), this.id) ? 'true' : 'false');
    }
    updateSpan() {
        this.span.style.display = this.comparator(this.variable.getValue(), this.id)
            ? ''
            : 'none';
    }
}
//# sourceMappingURL=RadioCompare.js.map
;// ./mjs/ui/menu/MmlVisitor.js


class MmlVisitor_MmlVisitor extends SerializedMmlVisitor {
    constructor() {
        super(...arguments);
        this.options = {
            filterSRE: true,
            filterTex: true,
            texHints: true,
            semantics: false,
        };
        this.mathItem = null;
    }
    visitTree(node, math = null, options = {}) {
        this.mathItem = math;
        userOptions(this.options, options);
        return this.visitNode(node, '');
    }
    visitTeXAtomNode(node, space) {
        if (this.options.texHints) {
            return super.visitDefault(node, space);
        }
        if (node.childNodes[0] && node.childNodes[0].childNodes.length === 1) {
            return this.visitNode(node.childNodes[0], space);
        }
        return (`${space}<mrow${this.getAttributes(node)}>\n` +
            this.childNodeMml(node, space + '  ', '\n') +
            `${space}</mrow>`);
    }
    visitMathNode(node, space) {
        if (!this.options.semantics || this.mathItem.inputJax.name !== 'TeX') {
            return super.visitDefault(node, space);
        }
        const addRow = node.childNodes.length && node.childNodes[0].childNodes.length > 1;
        return (`${space}<math${this.getAttributes(node)}>\n${space}  <semantics>\n` +
            (addRow ? space + '    <mrow>\n' : '') +
            this.childNodeMml(node, space + (addRow ? '      ' : '    '), '\n') +
            (addRow ? space + '    </mrow>\n' : '') +
            `${space}    <annotation encoding="application/x-tex">` +
            this.mathItem.math +
            `</annotation>\n${space}  </semantics>\n${space}</math>`);
    }
    getAttributeList(node) {
        const list = super.getAttributeList(node);
        if (this.options.filterTex) {
            delete list['data-latex'];
            delete list['data-latex-item'];
        }
        if (this.options.filterSRE) {
            const keys = Object.keys(list).filter((id) => id.match(/^(?:data-semantic-.*?|data-speech-node|role|aria-(?:level|posinset|setsize|owns))$/));
            for (const key of keys) {
                delete list[key];
            }
        }
        return list;
    }
}
//# sourceMappingURL=MmlVisitor.js.map
;// ./mjs/ui/menu/SelectableInfo.js

class SelectableInfo extends Info {
    keydown(event) {
        if (event.key === 'a' && (event.ctrlKey || event.metaKey)) {
            this.selectAll();
            this.stop(event);
            return;
        }
        super.keydown(event);
    }
    selectAll() {
        const selection = document.getSelection();
        selection.selectAllChildren(this.html.querySelector('.CtxtMenu_InfoContent').firstChild);
    }
    copyToClipboard() {
        this.selectAll();
        try {
            document.execCommand('copy');
        }
        catch (err) {
            alert(`Can't copy to clipboard: ${err.message}`);
        }
        document.getSelection().removeAllRanges();
    }
    generateHtml() {
        super.generateHtml();
        const footer = this.html.querySelector('span.' + HtmlClasses['INFOSIGNATURE']);
        const button = footer.appendChild(document.createElement('input'));
        button.type = 'button';
        button.value = 'Copy to Clipboard';
        button.addEventListener('click', (_event) => this.copyToClipboard());
    }
}
//# sourceMappingURL=SelectableInfo.js.map
;// ./mjs/ui/menu/Menu.js
var Menu_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











const Menu_MathJax = global_MathJax;
const XMLDECLARATION = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>';
class Menu {
    get isLoading() {
        return Menu.loading > 0;
    }
    get loadingPromise() {
        if (!this.isLoading) {
            return Promise.resolve();
        }
        if (!Menu._loadingPromise) {
            Menu._loadingPromise = new Promise((ok, failed) => {
                Menu._loadingOK = ok;
                Menu._loadingFailed = failed;
            });
        }
        return Menu._loadingPromise;
    }
    postInfo(dialog) {
        if (this.menu.mathItem) {
            this.menu.nofocus = !!this.menu.mathItem.outputData.nofocus;
        }
        dialog.post();
    }
    constructor(document, options = {}) {
        this.settings = null;
        this.defaultSettings = null;
        this.menu = null;
        this.current = null;
        this.MmlVisitor = new MmlVisitor_MmlVisitor();
        this.jax = {
            CHTML: null,
            SVG: null,
        };
        this.rerenderStart = STATE.LAST;
        this.requiredExtensions = [];
        this.about = new Info('<b style="font-size:120%;">MathJax</b> v' + mathjax.version, () => {
            const lines = [];
            lines.push('Input Jax: ' + this.document.inputJax.map((jax) => jax.name).join(', '));
            lines.push('Output Jax: ' + this.document.outputJax.name);
            lines.push('Document Type: ' + this.document.kind);
            return lines.join('<br/>');
        }, '<a href="https://www.mathjax.org">www.mathjax.org</a>');
        this.help = new Info('<b>MathJax Help</b>', () => {
            return [
                '<p><b>MathJax</b> is a JavaScript library that allows page',
                ' authors to include mathematics within their web pages.',
                " As a reader, you don't need to do anything to make that happen.</p>",
                '<p><b>Browsers</b>: MathJax works with all modern browsers including',
                ' Edge, Firefox, Chrome, Safari, Opera, and most mobile browsers.</p>',
                '<p><b>Math Menu</b>: MathJax adds a contextual menu to equations.',
                ' Right-click or CTRL-click on any mathematics to access the menu.</p>',
                '<div style="margin-left: 1em;">',
                "<p><b>Show Math As:</b> These options allow you to view the formula's",
                ' source markup (as MathML or in its original format).</p>',
                "<p><b>Copy to Clipboard:</b> These options copy the formula's source markup,",
                ' as MathML or in its original format, to the clipboard',
                ' (in browsers that support that).</p>',
                '<p><b>Math Settings:</b> These give you control over features of MathJax,',
                ' such the size of the mathematics, the mechanism used to display equations,',
                ' how to handle equations that are too wide, and the language to use for',
                " MathJax's menus and error messages (not yet implemented in v4).",
                '</p>',
                '<p><b>Accessibility</b>: MathJax can work with screen',
                ' readers to make mathematics accessible to the visually impaired.',
                ' Turn on speech or braille generation to enable creation of speech strings',
                ' and the ability to investigate expressions interactively.  You can control',
                ' the style of the explorer in its menu.</p>',
                '</div>',
                '<p><b>Math Zoom</b>: If you are having difficulty reading an',
                ' equation, MathJax can enlarge it to help you see it better, or',
                ' you can scale all the math on the page to make it larger.',
                ' Turn these features on in the <b>Math Settings</b> menu.</p>',
                "<p><b>Preferences</b>: MathJax uses your browser's localStorage database",
                ' to save the preferences set via this menu locally in your browser.  These',
                ' are not used to track you, and are not transferred or used remotely by',
                ' MathJax in any way.</p>',
            ].join('\n');
        }, '<a href="https://www.mathjax.org">www.mathjax.org</a>');
        this.mathmlCode = new SelectableInfo('MathJax MathML Expression', () => {
            if (!this.menu.mathItem)
                return '';
            const text = this.toMML(this.menu.mathItem);
            return '<pre>' + this.formatSource(text) + '</pre>';
        }, '');
        this.originalText = new SelectableInfo('MathJax Original Source', () => {
            if (!this.menu.mathItem)
                return '';
            const text = this.menu.mathItem.math;
            return ('<pre style="font-size:125%; margin:0">' +
                this.formatSource(text) +
                '</pre>');
        }, '');
        this.annotationBox = new SelectableInfo('MathJax Annotation Text', () => {
            const text = annotation;
            return ('<pre style="font-size:125%; margin:0">' +
                this.formatSource(text) +
                '</pre>');
        }, '');
        this.svgImage = new SelectableInfo('MathJax SVG Image', () => {
            return ('<div id="svg-image" style="font-family: monospace; font-size:125%; margin:0">' +
                'Generative SVG Image...</div>');
        }, '');
        this.speechText = new SelectableInfo('MathJax Speech Text', () => {
            if (!this.menu.mathItem)
                return '';
            return ('<div style="font-size:125%; margin:0">' +
                this.formatSource(this.menu.mathItem.outputData.speech) +
                '</div>');
        }, '');
        this.brailleText = new SelectableInfo('MathJax Braille Code', () => {
            if (!this.menu.mathItem)
                return '';
            return ('<div style="font-size:125%; margin:0">' +
                this.formatSource(this.menu.mathItem.outputData.braille) +
                '</div>');
        }, '');
        this.errorMessage = new SelectableInfo('MathJax Error Message', () => {
            if (!this.menu.mathItem)
                return '';
            return ('<pre style="font-size:125%; margin:0">' +
                this.formatSource(this.menu.errorMsg) +
                '</pre>');
        }, '');
        this.zoomBox = new Info('MathJax Zoomed Expression', () => {
            if (!this.menu.mathItem)
                return '';
            const element = this.menu.mathItem.typesetRoot.cloneNode(true);
            element.style.margin = '0';
            const scale = 1.25 * parseFloat(this.settings.zscale);
            return ('<div style="font-size: ' + scale + '%">' + element.outerHTML + '</div>');
        }, '');
        this.document = document;
        this.options = userOptions(defaultOptions({}, this.constructor.OPTIONS), options);
        this.initSettings();
        this.mergeUserSettings();
        this.initMenu();
        this.applySettings();
    }
    initSettings() {
        var _a;
        this.settings = this.options.settings;
        this.jax = this.options.jax;
        const jax = this.document.outputJax;
        this.jax[jax.name] = jax;
        this.settings.renderer = jax.name;
        this.settings.scale = jax.options.scale;
        if (jax.options.displayOverflow) {
            this.settings.overflow =
                jax.options.displayOverflow.substring(0, 1).toUpperCase() +
                    jax.options.displayOverflow.substring(1).toLowerCase();
        }
        this.settings.breakInline = (_a = jax.options.linebreaks) === null || _a === void 0 ? void 0 : _a.inline;
        this.defaultSettings = Object.assign({}, this.document.options.a11y, this.settings);
        this.setA11y({ roleDescription: this.settings.roleDescription });
    }
    initMenu() {
        const parser = new Parser([
            ['contextMenu', MJContextMenu.fromJson.bind(MJContextMenu)],
            ['radioCompare', RadioCompare.fromJson.bind(RadioCompare)],
        ]);
        this.menu = parser.parse({
            type: 'contextMenu',
            id: 'MathJax_Menu',
            pool: [
                this.variable('showSRE'),
                this.variable('showTex'),
                this.variable('texHints'),
                this.variable('semantics'),
                this.variable('zoom'),
                this.variable('zscale'),
                this.variable('renderer', (jax) => this.setRenderer(jax)),
                this.variable('overflow', (overflow) => this.setOverflow(overflow)),
                this.variable('breakInline', (breaks) => this.setInlineBreaks(breaks)),
                this.variable('alt'),
                this.variable('cmd'),
                this.variable('ctrl'),
                this.variable('shift'),
                this.variable('scale', (scale) => this.setScale(scale)),
                this.a11yVar('speech', (speech) => this.setSpeech(speech)),
                this.a11yVar('braille', (braille) => this.setBraille(braille)),
                this.variable('brailleCode', (code) => this.setBrailleCode(code)),
                this.a11yVar('highlight', (value) => this.setHighlight(value)),
                this.a11yVar('backgroundColor'),
                this.a11yVar('backgroundOpacity'),
                this.a11yVar('foregroundColor'),
                this.a11yVar('foregroundOpacity'),
                this.a11yVar('subtitles'),
                this.a11yVar('viewBraille'),
                this.a11yVar('voicing'),
                this.a11yVar('roleDescription', () => this.setRoleDescription()),
                this.a11yVar('help'),
                this.a11yVar('locale', (locale) => this.setLocale(locale)),
                this.variable('speechRules', (value) => {
                    const [domain, style] = value.split('-');
                    this.document.options.sre.domain = domain;
                    this.document.options.sre.style = style;
                    this.rerender(STATE.COMPILED);
                }),
                this.a11yVar('magnification'),
                this.a11yVar('magnify'),
                this.a11yVar('treeColoring'),
                this.a11yVar('infoType'),
                this.a11yVar('infoRole'),
                this.a11yVar('infoPrefix'),
                this.variable('autocollapse'),
                this.variable('collapsible', (collapse) => this.setCollapsible(collapse)),
                this.variable('enrich', (enrich) => this.setEnrichment(enrich)),
                this.variable('inTabOrder', (tab) => this.setTabOrder(tab)),
                this.a11yVar('tabSelects'),
                this.variable('assistiveMml', (mml) => this.setAssistiveMml(mml)),
            ],
            items: [
                this.submenu('Show', 'Show Math As', [
                    this.command('MathMLcode', 'MathML Code', () => this.postInfo(this.mathmlCode)),
                    this.command('Original', 'Original Form', () => this.postInfo(this.originalText)),
                    this.rule(),
                    this.command('Speech', 'Speech Text', () => this.postInfo(this.speechText), {
                        disabled: true,
                    }),
                    this.command('Braille', 'Braille Code', () => this.postInfo(this.brailleText), { disabled: true }),
                    this.command('SVG', 'SVG Image', () => this.postSvgImage(), {
                        disabled: true,
                    }),
                    this.submenu('ShowAnnotation', 'Annotation'),
                    this.rule(),
                    this.command('Error', 'Error Message', () => this.postInfo(this.errorMessage), { disabled: true }),
                ]),
                this.submenu('Copy', 'Copy to Clipboard', [
                    this.command('MathMLcode', 'MathML Code', () => this.copyMathML()),
                    this.command('Original', 'Original Form', () => this.copyOriginal()),
                    this.rule(),
                    this.command('Speech', 'Speech Text', () => this.copySpeechText(), {
                        disabled: true,
                    }),
                    this.command('Braille', 'Braille Code', () => this.copyBrailleText(), { disabled: true }),
                    this.command('SVG', 'SVG Image', () => this.copySvgImage(), {
                        disabled: true,
                    }),
                    this.submenu('CopyAnnotation', 'Annotation'),
                    this.rule(),
                    this.command('Error', 'Error Message', () => this.copyErrorMessage(), { disabled: true }),
                ]),
                this.rule(),
                this.submenu('Settings', 'Math Settings', [
                    this.submenu('Renderer', 'Math Renderer', this.radioGroup('renderer', [['CHTML'], ['SVG']])),
                    this.submenu('Overflow', 'Wide Expressions', [
                        this.radioGroup('overflow', [
                            ['Overflow'],
                            ['Scroll'],
                            ['Linebreak'],
                            ['Scale'],
                            ['Truncate'],
                            ['Elide'],
                        ]),
                        this.rule(),
                        this.checkbox('BreakInline', 'Allow In-line Breaks', 'breakInline'),
                    ]),
                    this.rule(),
                    this.submenu('MathmlIncludes', 'MathML/SVG has', [
                        this.checkbox('showSRE', 'Semantic attributes', 'showSRE'),
                        this.checkbox('showTex', 'LaTeX attributes', 'showTex'),
                        this.checkbox('texHints', 'TeX hints', 'texHints'),
                        this.checkbox('semantics', 'Original as annotation', 'semantics'),
                    ]),
                    this.submenu('Language', 'Language'),
                    this.rule(),
                    this.submenu('ZoomTrigger', 'Zoom Trigger', [
                        this.command('ZoomNow', 'Zoom Once Now', () => this.zoom(null, '', this.menu.mathItem)),
                        this.rule(),
                        this.radioGroup('zoom', [
                            ['Click'],
                            ['DoubleClick', 'Double-Click'],
                            ['NoZoom', 'No Zoom'],
                        ]),
                        this.rule(),
                        this.label('TriggerRequires', 'Trigger Requires:'),
                        this.checkbox(isMac ? 'Option' : 'Alt', isMac ? 'Option' : 'Alt', 'alt'),
                        this.checkbox('Command', 'Command', 'cmd', {
                            hidden: !isMac,
                        }),
                        this.checkbox('Control', 'Control', 'ctrl', {
                            hiddne: isMac,
                        }),
                        this.checkbox('Shift', 'Shift', 'shift'),
                    ]),
                    this.submenu('ZoomFactor', 'Zoom Factor', this.radioGroup('zscale', [
                        ['150%'],
                        ['175%'],
                        ['200%'],
                        ['250%'],
                        ['300%'],
                        ['400%'],
                    ])),
                    this.rule(),
                    this.command('Scale', 'Scale All Math...', () => this.scaleAllMath()),
                    this.rule(),
                    this.command('Reset', 'Reset to defaults', () => this.resetDefaults()),
                ]),
                this.rule(),
                this.label('Accessibility', '\xA0\xA0 Accessibility:'),
                this.submenu('Speech', '\xA0 \xA0 Speech', [
                    this.checkbox('Generate', 'Generate', 'speech'),
                    this.checkbox('Subtitles', 'Show Subtitles', 'subtitles'),
                    this.checkbox('Auto Voicing', 'Auto Voicing', 'voicing'),
                    this.rule(),
                    this.label('Rules', 'Rules:'),
                    this.submenu('Mathspeak', 'Mathspeak', this.radioGroup('speechRules', [
                        ['mathspeak-default', 'Verbose'],
                        ['mathspeak-brief', 'Brief'],
                        ['mathspeak-sbrief', 'Superbrief'],
                    ])),
                    this.submenu('Clearspeak', 'Clearspeak', this.radioGroup('speechRules', [['clearspeak-default', 'Auto']])),
                    this.rule(),
                    this.submenu('A11yLanguage', 'Language'),
                ]),
                this.submenu('Braille', '\xA0 \xA0 Braille', [
                    this.checkbox('Generate', 'Generate', 'braille'),
                    this.checkbox('Subtitles', 'Show Subtitles', 'viewBraille'),
                    this.rule(),
                    this.label('Code', 'Code Format:'),
                    this.radioGroup('brailleCode', [
                        ['nemeth', 'Nemeth'],
                        ['ueb', 'UEB'],
                        ['euro', 'Euro'],
                    ]),
                ]),
                this.submenu('Explorer', '\xA0 \xA0 Explorer', [
                    this.submenu('Highlight', 'Highlight', [
                        this.submenu('Background', 'Background', this.radioGroup('backgroundColor', [
                            ['Blue'],
                            ['Red'],
                            ['Green'],
                            ['Yellow'],
                            ['Cyan'],
                            ['Magenta'],
                            ['White'],
                            ['Black'],
                        ])),
                        { type: 'slider', variable: 'backgroundOpacity', content: ' ' },
                        this.submenu('Foreground', 'Foreground', this.radioGroup('foregroundColor', [
                            ['Black'],
                            ['White'],
                            ['Magenta'],
                            ['Cyan'],
                            ['Yellow'],
                            ['Green'],
                            ['Red'],
                            ['Blue'],
                        ])),
                        { type: 'slider', variable: 'foregroundOpacity', content: ' ' },
                        this.rule(),
                        this.radioGroup('highlight', [['None'], ['Hover'], ['Flame']]),
                        this.rule(),
                        this.checkbox('TreeColoring', 'Tree Coloring', 'treeColoring'),
                    ]),
                    this.submenu('Magnification', 'Magnification', [
                        this.radioGroup('magnification', [
                            ['None'],
                            ['Keyboard'],
                            ['Mouse'],
                        ]),
                        this.rule(),
                        this.radioGroup('magnify', [
                            ['200%'],
                            ['300%'],
                            ['400%'],
                            ['500%'],
                        ]),
                    ]),
                    this.submenu('Semantic Info', 'Semantic Info', [
                        this.checkbox('Type', 'Type', 'infoType'),
                        this.checkbox('Role', 'Role', 'infoRole'),
                        this.checkbox('Prefix', 'Prefix', 'infoPrefix'),
                    ]),
                    this.rule(),
                    this.submenu('Role Description', 'Describe math as', [
                        this.radioGroup('roleDescription', [
                            ['MathJax expression'],
                            ['MathJax'],
                            ['math'],
                            ['clickable math'],
                            ['explorable math'],
                            ['none'],
                        ]),
                    ]),
                    this.checkbox('Math Help', 'Help message on focus', 'help'),
                ]),
                this.submenu('Options', '\xA0 \xA0 Options', [
                    this.checkbox('Enrich', 'Semantic Enrichment', 'enrich'),
                    this.checkbox('Collapsible', 'Collapsible Math', 'collapsible'),
                    this.checkbox('AutoCollapse', 'Auto Collapse', 'autocollapse', {
                        disabled: true,
                    }),
                    this.rule(),
                    this.checkbox('InTabOrder', 'Include in Tab Order', 'inTabOrder'),
                    this.submenu('TabSelects', 'Tabbing Focuses on', [
                        this.radioGroup('tabSelects', [
                            ['all', 'Whole Expression'],
                            ['last', 'Last Explored Node'],
                        ]),
                    ]),
                    this.rule(),
                    this.checkbox('AssistiveMml', 'Include Hidden MathML', 'assistiveMml'),
                ]),
                this.rule(),
                this.command('About', 'About MathJax', () => this.postInfo(this.about)),
                this.command('Help', 'MathJax Help', () => this.postInfo(this.help)),
            ],
        });
        const menu = this.menu;
        menu.settings = this.settings;
        menu.findID('Settings', 'Overflow', 'Elide').disable();
        menu.findID('Braille', 'ueb').hide();
        menu.setJax(this.jax);
        this.attachDialogMenus(menu);
        this.checkLoadableItems();
        const cache = [];
        MJContextMenu.DynamicSubmenus.set('ShowAnnotation', [
            showAnnotations(this.annotationBox, this.options.annotationTypes, cache),
            '',
        ]);
        MJContextMenu.DynamicSubmenus.set('CopyAnnotation', [
            copyAnnotations(cache),
            '',
        ]);
        addInfoStyles(this.document.document);
        addMenuStyles(this.document.document);
    }
    attachDialogMenus(menu) {
        this.about.attachMenu(menu);
        this.help.attachMenu(menu);
        this.originalText.attachMenu(menu);
        this.mathmlCode.attachMenu(menu);
        this.originalText.attachMenu(menu);
        this.svgImage.attachMenu(menu);
        this.speechText.attachMenu(menu);
        this.brailleText.attachMenu(menu);
        this.errorMessage.attachMenu(menu);
        this.zoomBox.attachMenu(menu);
    }
    checkLoadableItems() {
        var _a, _b, _c, _d, _e, _f;
        if (Menu_MathJax && Menu_MathJax._ && Menu_MathJax.loader && Menu_MathJax.startup) {
            const settings = this.settings;
            const options = this.document.options;
            if ((settings.enrich ||
                (settings.speech && options.enableSpeech) ||
                (settings.braille && options.enableBraille)) &&
                !((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.explorer)) {
                this.loadA11y('explorer');
            }
            if (settings.collapsible && !((_d = (_c = Menu_MathJax._) === null || _c === void 0 ? void 0 : _c.a11y) === null || _d === void 0 ? void 0 : _d.complexity)) {
                this.loadA11y('complexity');
            }
            if (settings.assistiveMml && !((_f = (_e = Menu_MathJax._) === null || _e === void 0 ? void 0 : _e.a11y) === null || _f === void 0 ? void 0 : _f['assistive-mml'])) {
                this.loadA11y('assistive-mml');
            }
        }
        else {
            const menu = this.menu;
            for (const name of Object.keys(this.jax)) {
                if (!this.jax[name]) {
                    menu.findID('Settings', 'Renderer', name).disable();
                }
            }
            menu.findID('Speech').disable();
            menu.findID('Braille').disable();
            menu.findID('Explorer').disable();
            menu.findID('Options', 'AutoCollapse').disable();
            menu.findID('Options', 'Collapsible').disable();
            menu.findID('Options', 'Enrich').disable();
            menu.findID('Options', 'AssistiveMml').disable();
        }
    }
    enableAccessibilityItems(name, enable) {
        const menu = this.menu.findID(name).submenu;
        for (const item of menu.items.slice(1)) {
            if (item instanceof Rule)
                continue;
            enable && (!(item instanceof Submenu) || item.submenu.items.length)
                ? item.enable()
                : item.disable();
        }
    }
    mergeUserSettings() {
        try {
            const settings = localStorage.getItem(Menu.MENU_STORAGE);
            if (!settings)
                return;
            Object.assign(this.settings, JSON.parse(settings));
            this.setA11y(this.settings);
        }
        catch (err) {
            console.log('MathJax localStorage error: ' + err.message);
        }
    }
    saveUserSettings() {
        const settings = {};
        for (const name of Object.keys(this.settings)) {
            if (this.settings[name] !== this.defaultSettings[name]) {
                settings[name] = this.settings[name];
            }
        }
        try {
            if (Object.keys(settings).length) {
                localStorage.setItem(Menu.MENU_STORAGE, JSON.stringify(settings));
            }
            else {
                localStorage.removeItem(Menu.MENU_STORAGE);
            }
        }
        catch (err) {
            console.log('MathJax localStorage error: ' + err.message);
        }
    }
    setA11y(options) {
        var _a, _b;
        if ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.explorer) {
            Menu_MathJax._.a11y.explorer_ts.setA11yOptions(this.document, options);
        }
    }
    getA11y(option) {
        var _a, _b;
        if ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.explorer) {
            if (this.document.options.a11y[option] !== undefined) {
                return this.document.options.a11y[option];
            }
            return this.document.options.sre[option];
        }
    }
    applySettings() {
        this.setTabOrder(this.settings.inTabOrder);
        const options = this.document.options;
        options.enableAssistiveMml = this.settings.assistiveMml;
        this.enableAccessibilityItems('Speech', this.settings.speech);
        this.enableAccessibilityItems('Braille', this.settings.braille);
        this.setAccessibilityMenus();
        const renderer = this.settings.renderer.replace(/[^a-zA-Z0-9]/g, '') || 'CHTML';
        (Menu._loadingPromise || Promise.resolve()).then(() => {
            const settings = this.settings;
            const options = this.document.outputJax.options;
            options.scale = parseFloat(settings.scale);
            options.displayOverflow = settings.overflow.toLowerCase();
            if (options.linebreaks) {
                options.linebreaks.inline = settings.breakInline;
            }
            if (!settings.speechRules) {
                const sre = this.document.options.sre;
                settings.speechRules = `${sre.domain || 'clearspeak'}-${sre.style || 'default'}`;
            }
            if (renderer !== this.defaultSettings.renderer) {
                this.document.whenReady(() => this.setRenderer(renderer, false));
            }
        });
    }
    setOverflow(overflow) {
        this.document.outputJax.options.displayOverflow = overflow.toLowerCase();
        if (!Menu.loading) {
            this.document.rerenderPromise();
        }
    }
    setInlineBreaks(breaks) {
        this.document.outputJax.options.linebreaks.inline = breaks;
        if (!Menu.loading) {
            this.document.rerenderPromise();
        }
    }
    setScale(scale) {
        this.document.outputJax.options.scale = parseFloat(scale);
        if (!Menu.loading) {
            this.document.rerenderPromise();
        }
    }
    setRenderer(jax, rerender = true) {
        if (Object.hasOwn(this.jax, jax) && this.jax[jax]) {
            return this.setOutputJax(jax, rerender);
        }
        const name = jax.toLowerCase();
        return new Promise((ok, fail) => {
            this.loadComponent('output/' + name, () => {
                const startup = Menu_MathJax.startup;
                if (!(name in startup.constructors)) {
                    return fail(new Error(`Component ${name} not loaded`));
                }
                startup.useOutput(name, true);
                startup.output = startup.getOutputJax();
                startup.output.setAdaptor(this.document.adaptor);
                startup.output.initialize();
                this.jax[jax] = startup.output;
                this.setOutputJax(jax, rerender)
                    .then(() => ok())
                    .catch((err) => fail(err));
            });
        });
    }
    setOutputJax(jax, rerender = true) {
        this.jax[jax].setAdaptor(this.document.adaptor);
        this.document.outputJax = this.jax[jax];
        const promise = this.loadRequiredExtensions();
        return rerender
            ? promise.then(() => mathjax.handleRetriesFor(() => this.rerender()))
            : promise.then(() => { });
    }
    loadRequiredExtensions() {
        const jax = this.document.outputJax.name.toLowerCase();
        const promises = [];
        for (const path of this.requiredExtensions) {
            promises.push(Menu_MathJax.loader.load(`[${path}]/${jax}`));
        }
        this.requiredExtensions = [];
        return Promise.all(promises);
    }
    addRequiredExtensions(extensions) {
        if (extensions) {
            const set = new Set([...this.requiredExtensions, ...extensions]);
            this.requiredExtensions = [...set];
        }
    }
    setTabOrder(tab) {
        const menu = this.menu.findID('Options', 'TabSelects');
        tab ? menu.enable() : menu.disable();
        this.menu.store.inTaborder(tab);
    }
    setAssistiveMml(mml) {
        var _a, _b;
        this.document.options.enableAssistiveMml = mml;
        if (!mml || ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b['assistive-mml'])) {
            this.rerender();
        }
        else {
            this.loadA11y('assistive-mml');
        }
    }
    setAccessibilityMenus() {
        const enable = this.settings.enrich;
        const method = enable ? 'enable' : 'disable';
        ['Speech', 'Braille', 'Explorer'].forEach((id) => this.menu.findID(id)[method]());
        const options = this.document.options;
        options.enableSpeech =
            options.enableBraille =
                options.enableExplorer =
                    enable;
        if (!enable) {
            this.settings.collapsible = false;
            this.document.options.enableCollapsible = false;
        }
    }
    setSpeech(speech) {
        var _a, _b;
        this.enableAccessibilityItems('Speech', speech);
        this.document.options.enableSpeech = speech;
        if (!speech || ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.explorer)) {
            this.rerender(STATE.COMPILED);
        }
        else {
            this.loadA11y('explorer');
        }
    }
    setBraille(braille) {
        var _a, _b;
        this.enableAccessibilityItems('Braille', braille);
        this.document.options.enableBraille = braille;
        if (!braille || ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.explorer)) {
            this.rerender(STATE.COMPILED);
        }
        else {
            this.loadA11y('explorer');
        }
    }
    setBrailleCode(code) {
        this.document.options.sre.braille = code;
        this.rerender(STATE.COMPILED);
    }
    setLocale(locale) {
        this.document.options.sre.locale = locale;
        this.rerender(STATE.COMPILED);
    }
    setRoleDescription() {
        this.rerender(STATE.COMPILED);
    }
    setEnrichment(enrich) {
        var _a, _b;
        this.document.options.enableEnrichment = enrich;
        this.setAccessibilityMenus();
        if (!enrich || ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.explorer)) {
            this.rerender(STATE.COMPILED);
        }
        else {
            this.loadA11y('explorer');
        }
    }
    setCollapsible(collapse) {
        var _a, _b, _c, _d;
        this.document.options.enableComplexity = collapse;
        if (collapse && !this.settings.enrich) {
            this.settings.enrich = this.document.options.enableEnrichment = true;
            this.setAccessibilityMenus();
        }
        if (!collapse) {
            this.menu.pool.lookup('highlight').setValue('None');
        }
        if (!collapse || ((_b = (_a = Menu_MathJax._) === null || _a === void 0 ? void 0 : _a.a11y) === null || _b === void 0 ? void 0 : _b.complexity)) {
            this.rerender(STATE.COMPILED);
        }
        else {
            this.loadA11y('complexity');
            if (!((_d = (_c = Menu_MathJax._) === null || _c === void 0 ? void 0 : _c.a11y) === null || _d === void 0 ? void 0 : _d.explorer)) {
                this.loadA11y('explorer');
            }
        }
    }
    setHighlight(value) {
        var _a, _b;
        if (value === 'None')
            return;
        if (!this.settings.collapsible) {
            const variable = this.menu.pool.lookup('collapsible');
            variable.setValue(true);
            (_b = (_a = variable.items[0]) === null || _a === void 0 ? void 0 : _a.executeCallbacks_) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        if (!Menu.loadingPromises.has('a11y/complexity')) {
            this.rerender(STATE.COMPILED);
        }
    }
    scaleAllMath() {
        const scale = (parseFloat(this.settings.scale) * 100)
            .toFixed(1)
            .replace(/.0$/, '');
        const percent = prompt('Scale all mathematics (compared to surrounding text) by', scale + '%');
        if (this.current) {
            const speech = this.menu.mathItem.explorers.speech;
            speech.refocus = this.current;
            speech.focus();
        }
        if (percent) {
            if (percent.match(/^\s*\d+(\.\d*)?\s*%?\s*$/)) {
                const scale = parseFloat(percent) / 100;
                if (scale) {
                    this.menu.pool.lookup('scale').setValue(String(scale));
                }
                else {
                    alert('The scale should not be zero');
                }
            }
            else {
                alert('The scale should be a percentage (e.g., 120%)');
            }
        }
    }
    resetDefaults() {
        Menu.loading++;
        const pool = this.menu.pool;
        const settings = this.defaultSettings;
        for (const name of Object.keys(settings)) {
            const variable = pool.lookup(name);
            if (variable) {
                if (variable.getValue() !== settings[name]) {
                    variable.setValue(settings[name]);
                    const item = variable.items[0];
                    if (item) {
                        item.executeCallbacks_();
                    }
                }
            }
            else if (Object.hasOwn(this.settings, name)) {
                this.settings[name] = settings[name];
            }
        }
        Menu.loading--;
        this.rerender(STATE.COMPILED);
    }
    checkComponent(name) {
        const promise = Menu.loadingPromises.get(name);
        if (promise) {
            mathjax.retryAfter(promise);
        }
    }
    loadComponent(name, callback) {
        if (Menu.loadingPromises.has(name))
            return;
        const loader = Menu_MathJax.loader;
        if (!loader)
            return;
        Menu.loading++;
        const promise = loader
            .load(name)
            .then(() => {
            Menu.loading--;
            Menu.loadingPromises.delete(name);
            if (Menu.loading === 0 && Menu._loadingPromise) {
                Menu._loadingPromise = null;
                Menu._loadingOK();
            }
            callback();
        })
            .catch((err) => {
            if (Menu._loadingPromise) {
                Menu._loadingPromise = null;
                Menu._loadingFailed(err);
            }
            else {
                console.log(err);
            }
        });
        Menu.loadingPromises.set(name, promise);
    }
    loadA11y(component) {
        const noEnrich = !STATE.ENRICHED;
        this.loadComponent('a11y/' + component, () => {
            var _a, _b;
            const startup = Menu_MathJax.startup;
            mathjax.handlers.unregister(startup.handler);
            startup.handler = startup.getHandler();
            mathjax.handlers.register(startup.handler);
            const document = this.document;
            this.document = startup.document = startup.getDocument();
            this.document.processed = document.processed;
            this.document.menu = this;
            if (document.webworker) {
                this.document.webworker = document.webworker;
            }
            this.setA11y(this.settings);
            this.defaultSettings = Object.assign({}, this.document.options.a11y, ((_b = (_a = Menu_MathJax.config) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.a11y) || {}, this.defaultSettings);
            this.document.outputJax.reset();
            this.transferMathList(document);
            this.document.processed = document.processed;
            if (!Menu._loadingPromise) {
                this.document.outputJax.reset();
                mathjax.handleRetriesFor(() => {
                    this.rerender(component === 'complexity' || noEnrich
                        ? STATE.COMPILED
                        : STATE.TYPESET);
                });
            }
        });
    }
    transferMathList(document) {
        const MathItem = this.document.options.MathItem;
        for (const item of document.math) {
            const math = new MathItem();
            Object.assign(math, item);
            this.document.math.push(math);
        }
    }
    formatSource(text) {
        return text
            .trim()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
    toMML(math) {
        return this.MmlVisitor.visitTree(math.root, math, {
            filterSRE: !this.settings.showSRE,
            filterTex: !this.settings.showTex,
            texHints: this.settings.texHints,
            semantics: this.settings.semantics && math.inputJax.name !== 'MathML',
        });
    }
    toSVG(math) {
        const jax = this.jax.SVG;
        if (!jax)
            return Promise.resolve("SVG can't be produced.<br>Try switching to SVG output first.");
        const adaptor = jax.adaptor;
        const cache = jax.options.fontCache;
        const breaks = !!math.root.getProperty('process-breaks');
        if (cache !== 'global' &&
            (math.display || !breaks) &&
            adaptor.getAttribute(math.typesetRoot, 'jax') === 'SVG') {
            for (const child of adaptor.childNodes(math.typesetRoot)) {
                if (adaptor.kind(child) === 'svg') {
                    return Promise.resolve(this.formatSvg(adaptor.serializeXML(child)));
                }
            }
        }
        return this.typesetSVG(math, cache, breaks);
    }
    typesetSVG(math, cache, breaks) {
        return Menu_awaiter(this, void 0, void 0, function* () {
            const jax = this.jax.SVG;
            const div = jax.html('div');
            if (cache === 'global') {
                jax.options.fontCache = 'local';
            }
            const root = math.root;
            math.root = root.copy(true);
            math.root.setInheritedAttributes({}, math.display, 0, false);
            if (breaks) {
                jax.unmarkInlineBreaks(math.root);
                math.root.setProperty('inlineMarked', false);
            }
            const promise = mathjax.handleRetriesFor(() => {
                jax.toDOM(math, div, jax.document);
            });
            return promise.then(() => {
                math.root = root;
                jax.options.fontCache = cache;
                return this.formatSvg(jax.adaptor.innerHTML(div));
            });
        });
    }
    formatSvg(svg) {
        const css = this.constructor.SvgCss;
        svg = svg.match(/^<svg.*?><defs>/)
            ? svg.replace(/<defs>/, `<defs><style>${css}</style>`)
            : svg.replace(/^(<svg.*?>)/, `$1<defs><style>${css}</style></defs>`);
        svg = svg
            .replace(/ (?:role|focusable)=".*?"/g, '')
            .replace(/"currentColor"/g, '"black"');
        if (!this.settings.showSRE) {
            svg = svg.replace(/ (?:data-semantic-.*?|data-speech-node|role|aria-(?:level|posinset|setsize|owns))=".*?"/g, '');
        }
        if (!this.settings.showTex) {
            svg = svg.replace(/ data-latex(?:-item)?=".*?"/g, '');
        }
        if (!this.settings.texHints) {
            svg = svg
                .replace(/ data-mjx-(?:texclass|alternate|variant|pseudoscript|smallmatrix|mathaccent|auto-op|script-align|vbox)=".*?"/g, '')
                .replace(/ data-mml-node="TeXAtom"/g, '');
        }
        return `${XMLDECLARATION}\n${svg}`;
    }
    postSvgImage() {
        this.postInfo(this.svgImage);
        this.toSVG(this.menu.mathItem).then((svg) => {
            const html = this.svgImage.html.querySelector('#svg-image');
            html.innerHTML = this.formatSource(svg).replace(/\n/g, '<br>');
        });
    }
    zoom(event, type, math) {
        if (!event || this.isZoomEvent(event, type)) {
            this.menu.mathItem = math;
            if (event) {
                this.menu.post(event);
            }
            this.postInfo(this.zoomBox);
        }
    }
    isZoomEvent(event, zoom) {
        return (this.settings.zoom === zoom &&
            (!this.settings.alt || event.altKey) &&
            (!this.settings.ctrl || event.ctrlKey) &&
            (!this.settings.cmd || event.metaKey) &&
            (!this.settings.shift || event.shiftKey));
    }
    rerender(start = STATE.TYPESET) {
        this.rerenderStart = Math.min(start, this.rerenderStart);
        const startup = Menu_MathJax.startup;
        if (!Menu.loading && startup.hasTypeset) {
            startup.document.whenReady(() => Menu_awaiter(this, void 0, void 0, function* () {
                if (this.rerenderStart <= STATE.COMPILED) {
                    this.document.reset({ inputJax: [] });
                }
                yield this.document.rerenderPromise(this.rerenderStart);
                this.rerenderStart = STATE.LAST;
            }));
        }
    }
    copyMathML() {
        copyToClipboard(this.toMML(this.menu.mathItem));
    }
    copyOriginal() {
        copyToClipboard(this.menu.mathItem.math.trim());
    }
    copySvgImage() {
        this.toSVG(this.menu.mathItem).then((svg) => {
            copyToClipboard(svg);
        });
    }
    copySpeechText() {
        copyToClipboard(this.menu.mathItem.outputData.speech);
    }
    copyBrailleText() {
        copyToClipboard(this.menu.mathItem.outputData.braille);
    }
    copyErrorMessage() {
        copyToClipboard(this.menu.errorMsg.trim());
    }
    addMenu(math) {
        this.addEvents(math);
        this.menu.store.insert(math.typesetRoot);
        math.typesetRoot.tabIndex = this.settings.inTabOrder ? 0 : -1;
    }
    addEvents(math) {
        const node = math.typesetRoot;
        node.addEventListener('mousedown', () => {
            var _a, _b;
            this.menu.mathItem = math;
            this.current = (_b = (_a = math.explorers) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.current;
        }, true);
        node.addEventListener('contextmenu', () => {
            var _a;
            this.menu.mathItem = math;
            const speech = (_a = math.explorers) === null || _a === void 0 ? void 0 : _a.speech;
            if (speech) {
                math.outputData.nofocus = !this.current;
                speech.refocus = this.current;
            }
        }, true);
        node.addEventListener('keydown', () => (this.menu.mathItem = math), true);
        node.addEventListener('click', (event) => this.zoom(event, 'Click', math), true);
        node.addEventListener('dblclick', (event) => this.zoom(event, 'DoubleClick', math), true);
    }
    clear() {
        this.menu.store.clear();
    }
    variable(name, action) {
        return {
            name: name,
            getter: () => this.settings[name],
            setter: (value) => {
                this.settings[name] = value;
                if (action) {
                    action(value);
                }
                this.saveUserSettings();
            },
        };
    }
    a11yVar(name, action) {
        return {
            name: name,
            getter: () => this.getA11y(name),
            setter: (value) => {
                this.settings[name] = value;
                this.setA11y({ [name]: value });
                if (action) {
                    action(value);
                }
                this.saveUserSettings();
            },
        };
    }
    submenu(id, content, entries = [], disabled = false) {
        let items = [];
        for (const entry of entries) {
            if (Array.isArray(entry)) {
                items = items.concat(entry);
            }
            else {
                items.push(entry);
            }
        }
        return {
            type: 'submenu',
            id,
            content,
            menu: { items },
            disabled: items.length === 0 || disabled,
        };
    }
    command(id, content, action, other = {}) {
        return Object.assign({ type: 'command', id, content, action }, other);
    }
    checkbox(id, content, variable, other = {}) {
        return Object.assign({ type: 'checkbox', id, content, variable }, other);
    }
    radioGroup(variable, radios) {
        return radios.map((def) => this.radio(def[0], def[1] || def[0], variable));
    }
    radio(id, content, variable, other = {}) {
        return Object.assign({ type: 'radio', id, content, variable }, other);
    }
    label(id, content) {
        return { type: 'label', id, content };
    }
    rule() {
        return { type: 'rule' };
    }
}
Menu.MENU_STORAGE = 'MathJax-Menu-Settings';
Menu.OPTIONS = {
    settings: {
        showSRE: false,
        showTex: false,
        texHints: true,
        semantics: false,
        zoom: 'NoZoom',
        zscale: '200%',
        renderer: 'CHTML',
        alt: false,
        cmd: false,
        ctrl: false,
        shift: false,
        scale: 1,
        overflow: 'Scroll',
        breakInline: true,
        autocollapse: false,
        collapsible: false,
        enrich: true,
        inTabOrder: true,
        assistiveMml: false,
        speech: true,
        braille: true,
        brailleCode: 'nemeth',
        speechRules: 'clearspeak-default',
        roleDescription: 'math',
        tabSelects: 'all',
    },
    jax: {
        CHTML: null,
        SVG: null,
    },
    annotationTypes: expandable({
        TeX: ['TeX', 'LaTeX', 'application/x-tex'],
        StarMath: ['StarMath 5.0'],
        Maple: ['Maple'],
        ContentMathML: ['MathML-Content', 'application/mathml-content+xml'],
        OpenMath: ['OpenMath'],
    }),
};
Menu.SvgCss = [
    'svg a{fill:blue;stroke:blue}',
    '[data-mml-node="merror"]>g{fill:red;stroke:red}',
    '[data-mml-node="merror"]>rect[data-background]{fill:yellow;stroke:none}',
    '[data-frame],[data-line]{stroke-width:70px;fill:none}',
    '.mjx-dashed{stroke-dasharray:140}',
    '.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}',
    'use[data-c]{stroke-width:3px}',
].join('');
Menu.loading = 0;
Menu.loadingPromises = new Map();
Menu._loadingPromise = null;
Menu._loadingOK = null;
Menu._loadingFailed = null;
//# sourceMappingURL=Menu.js.map
;// ./mjs/ui/menu/MenuHandler.js





newState('CONTEXT_MENU', 170);
function MenuMathItemMixin(BaseMathItem) {
    return class extends BaseMathItem {
        addMenu(document, force = false) {
            if (this.state() >= STATE.CONTEXT_MENU)
                return;
            if (!this.isEscaped && (document.options.enableMenu || force)) {
                document.menu.addMenu(this);
            }
            this.state(STATE.CONTEXT_MENU);
        }
        getMenus(document) {
            document.menu.menu.store.sort();
        }
        checkLoading(document) {
            document.checkLoading();
        }
    };
}
function MenuMathDocumentMixin(BaseDocument) {
    var _a;
    return _a = class extends BaseDocument {
            constructor(...args) {
                super(...args);
                this.menu = new this.options.MenuClass(this, this.options.menuOptions);
                const ProcessBits = this.constructor.ProcessBits;
                if (!ProcessBits.has('context-menu')) {
                    ProcessBits.allocate('context-menu');
                }
                this.options.MathItem = MenuMathItemMixin(this.options.MathItem);
                const settings = this.menu.settings;
                const options = this.options;
                const enrich = (options.enableEnrichment = settings.enrich);
                options.enableSpeech = settings.speech && enrich;
                options.enableBraille = settings.braille && enrich;
                options.enableComplexity = settings.collapsible && enrich;
                options.enableExplorer = enrich;
            }
            addMenu() {
                if (!this.processed.isSet('context-menu')) {
                    for (const math of this.math) {
                        math.addMenu(this);
                    }
                    this.processed.set('context-menu');
                }
                return this;
            }
            getMenus() {
                this.menu.menu.store.sort();
            }
            checkLoading() {
                let result = true;
                try {
                    this._checkLoading();
                    result = false;
                }
                catch (err) {
                    if (!err.retry) {
                        throw err;
                    }
                }
                return result;
            }
            _checkLoading() {
                if (this.menu.isLoading) {
                    mathjax.retryAfter(this.menu.loadingPromise.catch((err) => console.log(err)));
                }
                if (this.options.enableComplexity) {
                    this.menu.checkComponent('a11y/complexity');
                }
                if (this.options.enableExplorer) {
                    this.menu.checkComponent('a11y/explorer');
                }
                return this;
            }
            state(state, restore = false) {
                super.state(state, restore);
                if (state < STATE.CONTEXT_MENU) {
                    this.processed.clear('context-menu');
                }
                return this;
            }
        },
        _a.OPTIONS = Object.assign(Object.assign({ enableEnrichment: true, enableComplexity: true, enableSpeech: true, enableBraille: true, enableExplorer: true, enrichSpeech: 'none', enrichError: (_doc, _math, err) => console.warn('Enrichment Error:', err) }, BaseDocument.OPTIONS), { MenuClass: Menu, menuOptions: Menu.OPTIONS, enableMenu: true, sre: BaseDocument.OPTIONS.sre || expandable({}), a11y: BaseDocument.OPTIONS.a11y || expandable({}), renderActions: expandable(Object.assign(Object.assign({}, BaseDocument.OPTIONS.renderActions), { addMenu: [STATE.CONTEXT_MENU], getMenus: [STATE.INSERTED + 5, false], checkLoading: [
                    STATE.UNPROCESSED + 1,
                    (doc) => doc.checkLoading(),
                    '',
                    false,
                ] })) }),
        _a;
}
function MenuHandler(handler) {
    handler.documentClass = MenuMathDocumentMixin(handler.documentClass);
    return handler;
}
//# sourceMappingURL=MenuHandler.js.map
;// ./components/mjs/ui/menu/lib/menu.js













if (MathJax.loader) {
  MathJax.loader.checkVersion('ui/menu', VERSION, 'ui');
}

combineWithMathJax({_: {
  a11y: {
    speech: {
      SpeechMenu: SpeechMenu_namespaceObject
    }
  },
  ui: {
    menu: {
      AnnotationMenu: AnnotationMenu_namespaceObject,
      MJContextMenu: MJContextMenu_namespaceObject,
      Menu: Menu_namespaceObject,
      MenuHandler: MenuHandler_namespaceObject,
      MenuUtil: MenuUtil_namespaceObject,
      MmlVisitor: menu_MmlVisitor_namespaceObject,
      RadioCompare: RadioCompare_namespaceObject,
      SelectableInfo: SelectableInfo_namespaceObject
    }
  }
}});

;// ./components/mjs/ui/menu/menu.js






if (MathJax.startup && hasWindow) {
  MathJax.startup.extendHandler(handler => MenuHandler(handler), 20);
}

;// ./mjs/input/mathml/FindMathML.js

const NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
class FindMathML extends AbstractFindMath {
    findMath(node) {
        const set = new Set();
        this.findMathNodes(node, set);
        this.findMathPrefixed(node, set);
        const html = this.adaptor.root(this.adaptor.document);
        if (this.adaptor.kind(html) === 'html' && set.size === 0) {
            this.findMathNS(node, set);
        }
        return this.processMath(set);
    }
    findMathNodes(node, set) {
        for (const math of this.adaptor.tags(node, 'math')) {
            set.add(math);
        }
    }
    findMathPrefixed(node, set) {
        const html = this.adaptor.root(this.adaptor.document);
        for (const attr of this.adaptor.allAttributes(html)) {
            if (attr.name.substring(0, 6) === 'xmlns:' && attr.value === NAMESPACE) {
                const prefix = attr.name.substring(6);
                for (const math of this.adaptor.tags(node, prefix + ':math')) {
                    set.add(math);
                }
            }
        }
    }
    findMathNS(node, set) {
        for (const math of this.adaptor.tags(node, 'math', NAMESPACE)) {
            set.add(math);
        }
    }
    processMath(set) {
        const adaptor = this.adaptor;
        const math = [];
        for (const mml of set.values()) {
            if (adaptor.kind(adaptor.parent(mml)) === 'mjx-assistive-mml')
                continue;
            const display = adaptor.getAttribute(mml, 'display') === 'block' ||
                adaptor.getAttribute(mml, 'mode') === 'display';
            const start = { node: mml, n: 0, delim: '' };
            const end = { node: mml, n: 0, delim: '' };
            math.push({ math: adaptor.outerHTML(mml), start, end, display });
        }
        return math;
    }
}
FindMathML.OPTIONS = {};
//# sourceMappingURL=FindMathML.js.map
;// ./mjs/input/mathml/MathMLCompile.js



class MathMLCompile {
    constructor(options = {}) {
        const Class = this.constructor;
        this.options = userOptions(defaultOptions({}, Class.OPTIONS), options);
    }
    setMmlFactory(mmlFactory) {
        this.factory = mmlFactory;
    }
    compile(node) {
        const mml = this.makeNode(node);
        mml.verifyTree(this.options['verify']);
        mml.setInheritedAttributes({}, false, 0, false);
        mml.walkTree(this.markMrows);
        return mml;
    }
    makeNode(node) {
        const adaptor = this.adaptor;
        let limits = false;
        const kind = adaptor.kind(node).replace(/^.*:/, '');
        let texClass = adaptor.getAttribute(node, 'data-mjx-texclass') || '';
        if (texClass) {
            texClass = this.filterAttribute('data-mjx-texclass', texClass) || '';
        }
        let type = texClass && kind === 'mrow' ? 'TeXAtom' : kind;
        for (const name of this.filterClassList(adaptor.allClasses(node))) {
            if (name.match(/^MJX-TeXAtom-/) && kind === 'mrow') {
                texClass = name.substring(12);
                type = 'TeXAtom';
            }
            else if (name === 'MJX-fixedlimits') {
                limits = true;
            }
        }
        if (!this.factory.getNodeClass(type)) {
            return this.unknownNode(type, node);
        }
        return this.createMml(type, node, texClass, limits);
    }
    createMml(type, node, texClass, limits) {
        const mml = this.factory.create(type);
        if (type === 'TeXAtom' && texClass === 'OP' && !limits) {
            mml.setProperty('movesupsub', true);
            mml.attributes.setInherited('movablelimits', true);
        }
        if (texClass) {
            mml.texClass = TEXCLASS[texClass];
            mml.setProperty('texClass', mml.texClass);
        }
        this.addAttributes(mml, node);
        this.checkClass(mml, node);
        this.addChildren(mml, node);
        return mml;
    }
    unknownNode(type, node) {
        if (this.factory.getNodeClass('html') &&
            this.options.allowHtmlInTokenNodes) {
            return this.factory.create('html').setHTML(node, this.adaptor);
        }
        this.error('Unknown node type "' + type + '"');
        return null;
    }
    addAttributes(mml, node) {
        let ignoreVariant = false;
        for (const attr of this.adaptor.allAttributes(node)) {
            const name = attr.name;
            const value = this.filterAttribute(name, attr.value);
            if (value === null || name === 'xmlns') {
                continue;
            }
            if (name.substring(0, 9) === 'data-mjx-') {
                switch (name.substring(9)) {
                    case 'alternate':
                        mml.setProperty('variantForm', true);
                        break;
                    case 'variant':
                        mml.attributes.set('mathvariant', value);
                        mml.setProperty('ignore-variant', true);
                        ignoreVariant = true;
                        break;
                    case 'smallmatrix':
                        mml.setProperty('smallmatrix', true);
                        mml.setProperty('useHeight', false);
                        break;
                    case 'mathaccent':
                        mml.setProperty('mathaccent', value === 'true');
                        break;
                    case 'auto-op':
                        mml.setProperty('autoOP', value === 'true');
                        break;
                    case 'script-align':
                        mml.setProperty('scriptalign', value);
                        break;
                    case 'vbox':
                        mml.setProperty('vbox', value);
                        break;
                    default:
                        mml.attributes.set(name, value);
                        break;
                }
            }
            else if (name !== 'class') {
                const val = value.toLowerCase();
                if (val === 'true' || val === 'false') {
                    mml.attributes.set(name, val === 'true');
                }
                else if (!ignoreVariant || name !== 'mathvariant') {
                    mml.attributes.set(name, value);
                }
            }
        }
    }
    filterAttribute(_name, value) {
        return value;
    }
    filterClassList(list) {
        return list;
    }
    addChildren(mml, node) {
        if (mml.arity === 0) {
            return;
        }
        const adaptor = this.adaptor;
        for (const child of adaptor.childNodes(node)) {
            const name = adaptor.kind(child);
            if (name === '#comment') {
                continue;
            }
            if (name === '#text') {
                this.addText(mml, child);
            }
            else if (mml.isKind('annotation-xml')) {
                mml.appendChild(this.factory.create('XML').setXML(child, adaptor));
            }
            else {
                const childMml = mml.appendChild(this.makeNode(child));
                if (childMml.arity === 0 &&
                    adaptor.childNodes(child).length &&
                    !childMml.isKind('html')) {
                    if (this.options['fixMisplacedChildren']) {
                        this.addChildren(mml, child);
                    }
                    else {
                        childMml.mError('There should not be children for ' + childMml.kind + ' nodes', this.options['verify'], true);
                    }
                }
            }
        }
        if (mml.isToken) {
            this.trimSpace(mml);
        }
    }
    addText(mml, child) {
        let text = this.adaptor.value(child);
        if ((mml.isToken || mml.getProperty('isChars')) && mml.arity) {
            if (mml.isToken) {
                text = translate(text);
                text = this.normalizeSpace(text);
            }
            mml.appendChild(this.factory.create('text').setText(text));
        }
        else if (text.match(/\S/)) {
            this.error('Unexpected text node "' + text + '"');
        }
    }
    checkClass(mml, node) {
        const classList = [];
        for (const name of this.filterClassList(this.adaptor.allClasses(node))) {
            if (name.substring(0, 4) === 'MJX-') {
                if (name === 'MJX-variant') {
                    mml.setProperty('variantForm', true);
                }
                else if (name.substring(0, 11) !== 'MJX-TeXAtom') {
                    mml.attributes.set('mathvariant', this.fixCalligraphic(name.substring(3)));
                }
            }
            else {
                classList.push(name);
            }
        }
        if (classList.length) {
            mml.attributes.set('class', classList.join(' '));
        }
    }
    fixCalligraphic(variant) {
        return variant.replace(/caligraphic/, 'calligraphic');
    }
    markMrows(mml) {
        if (mml.isKind('mrow') && !mml.isInferred && mml.childNodes.length >= 2) {
            const first = mml.childNodes[0];
            const last = mml.childNodes[mml.childNodes.length - 1];
            if (first.isKind('mo') &&
                first.attributes.get('fence') &&
                first.attributes.get('stretchy') &&
                last.isKind('mo') &&
                last.attributes.get('fence') &&
                last.attributes.get('stretchy')) {
                if (first.childNodes.length) {
                    mml.setProperty('open', first.getText());
                }
                if (last.childNodes.length) {
                    mml.setProperty('close', last.getText());
                }
            }
        }
    }
    normalizeSpace(text) {
        return text
            .replace(/[\t\n\r]/g, ' ')
            .replace(/  +/g, ' ');
    }
    trimSpace(mml) {
        let child = mml.childNodes[0];
        if (!child)
            return;
        if (child.isKind('text')) {
            child.setText(child.getText().replace(/^ +/, ''));
        }
        child = mml.childNodes[mml.childNodes.length - 1];
        if (child.isKind('text')) {
            child.setText(child.getText().replace(/ +$/, ''));
        }
    }
    error(message) {
        throw new Error(message);
    }
}
MathMLCompile.OPTIONS = {
    MmlFactory: null,
    allowHtmlInTokenNodes: false,
    fixMisplacedChildren: true,
    verify: Object.assign({}, AbstractMmlNode.verifyDefaults),
    translateEntities: true
};
//# sourceMappingURL=MathMLCompile.js.map
;// ./mjs/input/mathml.js





class MathML extends AbstractInputJax {
    constructor(options = {}) {
        const [mml, find, compile] = separateOptions(options, FindMathML.OPTIONS, MathMLCompile.OPTIONS);
        super(mml);
        this.findMathML = this.options.FindMathML || new FindMathML(find);
        this.mathml =
            this.options.MathMLCompile || new MathMLCompile(compile);
        this.mmlFilters = new FunctionList(this.options.mmlFilters);
    }
    setAdaptor(adaptor) {
        super.setAdaptor(adaptor);
        this.findMathML.adaptor = adaptor;
        this.mathml.adaptor = adaptor;
    }
    setMmlFactory(mmlFactory) {
        super.setMmlFactory(mmlFactory);
        this.mathml.setMmlFactory(mmlFactory);
    }
    get processStrings() {
        return false;
    }
    compile(math, document) {
        let mml = math.start.node;
        if (!mml ||
            !math.end.node ||
            this.options['forceReparse'] ||
            this.adaptor.kind(mml) === '#text') {
            let mathml = this.executeFilters(this.preFilters, math, document, (math.math || '<math></math>').trim());
            if (this.options['parseAs'] === 'html') {
                mathml = `<html><head></head><body>${mathml}</body></html>`;
            }
            const doc = this.checkForErrors(this.adaptor.parse(mathml, 'text/' + this.options['parseAs']));
            const body = this.adaptor.body(doc);
            if (this.adaptor.childNodes(body).length !== 1) {
                this.error('MathML must consist of a single element');
            }
            mml = this.adaptor.remove(this.adaptor.firstChild(body));
            if (this.adaptor.kind(mml).replace(/^[a-z]+:/, '') !== 'math') {
                this.error('MathML must be formed by a <math> element, not <' +
                    this.adaptor.kind(mml) +
                    '>');
            }
        }
        mml = this.executeFilters(this.mmlFilters, math, document, mml);
        let root = this.mathml.compile(mml);
        root = this.executeFilters(this.postFilters, math, document, root);
        math.display = root.attributes.get('display') === 'block';
        return root;
    }
    checkForErrors(doc) {
        const err = this.adaptor.tags(this.adaptor.body(doc), 'parsererror')[0];
        if (err) {
            if (this.adaptor.textContent(err) === '') {
                this.error('Error processing MathML');
            }
            this.options['parseError'].call(this, err);
        }
        return doc;
    }
    error(message) {
        throw new Error(message);
    }
    findMath(node) {
        return this.findMathML.findMath(node);
    }
}
MathML.NAME = 'MathML';
MathML.OPTIONS = defaultOptions({
    parseAs: 'html',
    forceReparse: false,
    mmlFilters: [],
    FindMathML: null,
    MathMLCompile: null,
    parseError: function (node) {
        this.error(this.adaptor.textContent(node).replace(/\n.*/g, ''));
    }
}, AbstractInputJax.OPTIONS);
//# sourceMappingURL=mathml.js.map
;// ./components/mjs/input/mml/lib/mml.js







if (MathJax.loader) {
  MathJax.loader.checkVersion('input/mml', VERSION, 'input');
}

combineWithMathJax({_: {
  input: {
    mathml_ts: mathml_namespaceObject,
    mathml: {
      FindMathML: FindMathML_namespaceObject,
      MathMLCompile: MathMLCompile_namespaceObject
    }
  }
}});

;// ./components/mjs/input/mml/init.js





if (MathJax.loader) {
  //
  // Install a path-filter to cause loading of an entity file to load all entities,
  //   since the individual files don't have individual components.
  //
  MathJax.loader.pathFilters.add((data) => {
    data.name = data.name.replace(/\/util\/entities\/.*?\.js/, '/input/mml/entities.js');
    return true;
  });
}

;// ./components/mjs/a11y/sre/lib/sre.js





if (MathJax.loader) {
  MathJax.loader.checkVersion('a11y/sre', VERSION, 'a11y');
}

combineWithMathJax({_: {
  a11y: {
    sre_ts: sre_namespaceObject
  }
}});

;// ./components/mjs/a11y/sre/sre.js





;// ./mjs/a11y/semantic-enrich.js




newState('ENRICHED', STATE.COMPILED + 10);
class enrichVisitor extends SerializedMmlVisitor {
    visitTree(node, math) {
        this.mactionId = 0;
        const mml = super.visitTree(node);
        if (this.mactionId) {
            math.inputData.hasMaction = true;
        }
        return mml;
    }
    visitHtmlNode(node, _space) {
        return node.getSerializedXML();
    }
    visitMactionNode(node, space) {
        const [nl, endspace] = node.childNodes.length === 0 ? ['', ''] : ['\n', space];
        const children = this.childNodeMml(node, space + '  ', nl);
        let attributes = this.getAttributes(node);
        if (node.attributes.get('actiontype') === 'toggle') {
            const id = ++this.mactionId;
            node.setProperty('mactionId', id);
            attributes =
                ` data-maction-id="${id}" selection="${node.attributes.get('selection')}"` +
                    attributes
                        .replace(/ selection="\d+"/, '')
                        .replace(/ data-maction-id="\d+"/, '');
        }
        return (`${space}<maction${attributes}>` +
            (children.match(/\S/) ? nl + children + endspace : '') +
            '</maction>');
    }
}
function EnrichedMathItemMixin(BaseMathItem, MmlJax, toMathML) {
    return class extends BaseMathItem {
        constructor() {
            super(...arguments);
            this.toMathML = toMathML;
        }
        serializeMml(node) {
            if ('outerHTML' in node) {
                return node.outerHTML;
            }
            if (typeof Element !== 'undefined' &&
                typeof window !== 'undefined' &&
                node instanceof Element) {
                const div = window.document.createElement('div');
                div.appendChild(node);
                return div.innerHTML;
            }
            return node.toString();
        }
        enrich(document, force = false) {
            if (this.state() >= STATE.ENRICHED)
                return;
            if (!this.isEscaped && (document.options.enableEnrichment || force)) {
                const math = new document.options.MathItem('', MmlJax);
                try {
                    let mml;
                    if (!this.inputData.originalMml) {
                        mml = this.inputData.originalMml = this.toMathML(this.root, this);
                    }
                    else {
                        mml = this.adjustSelections();
                    }
                    const enriched = toEnriched(mml);
                    this.inputData.enrichedMml = math.math = this.serializeMml(enriched);
                    math.math = math.math
                        .replace(/ role="treeitem"/g, ' data-speech-node="true"')
                        .replace(/ aria-(?:posinset|owns|setsize)=".*?"/g, '');
                    math.display = this.display;
                    math.compile(document);
                    this.root = math.root;
                }
                catch (err) {
                    document.options.enrichError(document, this, err);
                }
            }
            this.state(STATE.ENRICHED);
        }
        toEnriched(mml) {
            return this.serializeMml(toEnriched(mml));
        }
        unEnrich(document) {
            const mml = this.inputData.originalMml;
            if (!mml)
                return;
            const math = new document.options.MathItem('', MmlJax);
            math.math = mml;
            math.display = this.display;
            math.compile(document);
            this.root = math.root;
        }
        adjustSelections() {
            const mml = this.inputData.originalMml;
            if (!this.inputData.hasMaction)
                return mml;
            const maction = [];
            this.root.walkTree((node) => {
                if (node.isKind('maction')) {
                    maction[node.attributes.get('data-maction-id')] = node;
                }
            });
            return mml.replace(/(data-maction-id="(\d+)" selection=)"\d+"/g, (_match, prefix, id) => `${prefix}"${maction[id].attributes.get('selection')}"`);
        }
    };
}
function EnrichedMathDocumentMixin(BaseDocument, MmlJax) {
    var _a;
    return _a = class extends BaseDocument {
            constructor(...args) {
                super(...args);
                MmlJax.setMmlFactory(this.mmlFactory);
                const ProcessBits = this.constructor
                    .ProcessBits;
                if (!ProcessBits.has('enriched')) {
                    ProcessBits.allocate('enriched');
                }
                const visitor = new enrichVisitor(this.mmlFactory);
                const toMathML = (node, math) => visitor.visitTree(node, math);
                this.options.MathItem = EnrichedMathItemMixin(this.options.MathItem, MmlJax, toMathML);
            }
            enrich() {
                if (!this.processed.isSet('enriched')) {
                    if (this.options.enableEnrichment) {
                        setupEngine(this.options.sre);
                        for (const math of this.math) {
                            math.enrich(this);
                        }
                    }
                    this.processed.set('enriched');
                }
                return this;
            }
            enrichError(_doc, _math, err) {
                console.warn('Enrichment error:', err);
            }
            state(state, restore = false) {
                super.state(state, restore);
                if (state < STATE.ENRICHED) {
                    this.processed.clear('enriched');
                    if (state >= STATE.COMPILED) {
                        for (const item of this.math) {
                            item.unEnrich(this);
                        }
                    }
                }
                return this;
            }
        },
        _a.OPTIONS = Object.assign(Object.assign({}, BaseDocument.OPTIONS), { enableEnrichment: true, enrichError: (doc, math, err) => doc.enrichError(doc, math, err), renderActions: expandable(Object.assign(Object.assign({}, BaseDocument.OPTIONS.renderActions), { enrich: [STATE.ENRICHED] })), sre: expandable({
                speech: 'none',
                locale: 'en',
                domain: 'clearspeak',
                style: 'default',
                braille: 'nemeth',
                structure: true,
                aria: true,
            }) }),
        _a;
}
function EnrichHandler(handler, MmlJax) {
    MmlJax.setAdaptor(handler.adaptor);
    handler.documentClass = EnrichedMathDocumentMixin(handler.documentClass, MmlJax);
    return handler;
}
//# sourceMappingURL=semantic-enrich.js.map
;// ./components/mjs/a11y/semantic-enrich/lib/semantic-enrich.js





if (MathJax.loader) {
  MathJax.loader.checkVersion('a11y/semantic-enrich', VERSION, 'a11y');
}

combineWithMathJax({_: {
  a11y: {
    "semantic-enrich": semantic_enrich_namespaceObject
  }
}});

;// ./components/mjs/a11y/semantic-enrich/semantic-enrich.js






if (MathJax.startup) {
  MathJax.startup.extendHandler(
    handler => EnrichHandler(handler, new MathML({allowHtmlInTokenNodes: true}))
  );
}

;// ./mjs/a11y/speech/SpeechUtil.js

const ProsodyKeys = ['pitch', 'rate', 'volume'];
function ssmlParsing(speech) {
    const xml = parseDOM(speech);
    const instr = [];
    const text = [];
    recurseSsml(Array.from(xml.childNodes), instr, text);
    return [text.join(' '), instr];
}
function recurseSsml(nodes, instr, text, prosody = {}) {
    for (const node of nodes) {
        if (node.nodeType === 3) {
            const content = node.textContent.trim();
            if (content) {
                text.push(content);
                instr.push(Object.assign({ text: content }, prosody));
            }
            continue;
        }
        if (node.nodeType === 1) {
            const element = node;
            const tag = element.tagName;
            if (tag === 'speak') {
                continue;
            }
            if (tag === 'prosody') {
                recurseSsml(Array.from(node.childNodes), instr, text, getProsody(element, prosody));
                continue;
            }
            switch (tag) {
                case 'break':
                    instr.push({ pause: element.getAttribute('time') });
                    break;
                case 'mark':
                    instr.push({ mark: element.getAttribute('name') });
                    break;
                case 'say-as': {
                    const txt = element.textContent;
                    instr.push(Object.assign({ text: txt, character: true }, prosody));
                    text.push(txt);
                    break;
                }
            }
        }
    }
}
const combinePros = {
    pitch: (x, _sign) => 1 * (x / 100),
    volume: (x, _sign) => 0.5 * (x / 100),
    rate: (x, _sign) => 1 * (x / 100),
};
function getProsody(element, prosody) {
    const combine = {};
    for (const pros of ProsodyKeys) {
        if (element.hasAttribute(pros)) {
            const [sign, value] = extractProsody(element.getAttribute(pros));
            if (!sign) {
                combine[pros] = pros === 'volume' ? 0.5 : 1;
                continue;
            }
            let orig = prosody[pros];
            orig = orig ? orig : pros === 'volume' ? 0.5 : 1;
            const relative = combinePros[pros](parseInt(value, 10), sign);
            combine[pros] = sign === '-' ? orig - relative : orig + relative;
        }
    }
    return combine;
}
const prosodyRegexp = /([+-]?)([0-9]+)%/;
function extractProsody(attr) {
    const match = attr.match(prosodyRegexp);
    if (!match) {
        console.warn('Something went wrong with the prosody matching.');
        return ['', '100'];
    }
    return [match[1], match[2]];
}
function buildLabel(speech, prefix, postfix, sep = ' ') {
    if (!speech) {
        return '';
    }
    const label = [speech];
    if (prefix) {
        label.unshift(prefix);
    }
    if (postfix) {
        label.push(postfix);
    }
    return label.join(sep);
}
function buildSpeech(speech, locale = 'en', rate = '100') {
    return ssmlParsing('<?xml version="1.0"?><speak version="1.1"' +
        ' xmlns="http://www.w3.org/2001/10/synthesis"' +
        ` xml:lang="${locale}">` +
        `<prosody rate="${rate}%">${speech}` +
        '</prosody></speak>');
}
function honk() {
    const ac = new AudioContext();
    const os = ac.createOscillator();
    os.frequency.value = 300;
    os.connect(ac.destination);
    os.start(ac.currentTime);
    os.stop(ac.currentTime + 0.05);
}
var InPlace;
(function (InPlace) {
    InPlace[InPlace["NONE"] = 0] = "NONE";
    InPlace[InPlace["DEPTH"] = 1] = "DEPTH";
    InPlace[InPlace["SUMMARY"] = 2] = "SUMMARY";
})(InPlace || (InPlace = {}));
var SemAttr;
(function (SemAttr) {
    SemAttr["SPEECH"] = "data-semantic-speech-none";
    SemAttr["SPEECH_SSML"] = "data-semantic-speech";
    SemAttr["SUMMARY"] = "data-semantic-summary-none";
    SemAttr["SUMMARY_SSML"] = "data-semantic-summary";
    SemAttr["PREFIX"] = "data-semantic-prefix-none";
    SemAttr["PREFIX_SSML"] = "data-semantic-prefix";
    SemAttr["POSTFIX"] = "data-semantic-postfix-none";
    SemAttr["POSTFIX_SSML"] = "data-semantic-postfix";
    SemAttr["BRAILLE"] = "data-semantic-braille";
})(SemAttr || (SemAttr = {}));
//# sourceMappingURL=SpeechUtil.js.map
;// ./mjs/a11y/speech/GeneratorPool.js

class GeneratorPool {
    constructor() {
        this.promise = Promise.resolve();
        this.adaptor = null;
        this._options = {};
        this._init = false;
    }
    set element(element) {
        this._element = element;
    }
    get element() {
        return this._element;
    }
    set options(options) {
        this._options = Object.assign({}, (options === null || options === void 0 ? void 0 : options.sre) || {}, {
            enableSpeech: options.enableSpeech,
            enableBraille: options.enableBraille,
        });
        delete this._options.custom;
    }
    get options() {
        return this._options;
    }
    init(options, adaptor, webworker) {
        this.options = options;
        if (this._init)
            return;
        this.adaptor = adaptor;
        this.webworker = webworker;
        this._init = true;
    }
    update(options) {
        Object.assign(this.options, options);
    }
    Speech(item) {
        const mml = item.outputData.mml;
        const options = Object.assign({}, this.options, { modality: 'speech' });
        return (this.promise = this.webworker.Speech(mml, options, item));
    }
    SpeechFor(item, mml) {
        const options = Object.assign({}, this.options, { modality: 'speech' });
        return this.webworker.speechFor(mml, options, item);
    }
    cancel(item) {
        var _a;
        (_a = this.webworker) === null || _a === void 0 ? void 0 : _a.Cancel(item);
    }
    updateRegions(node, speechRegion, brailleRegion) {
        speechRegion.Update(this.getLabel(node));
        brailleRegion.Update(this.getBraille(node));
    }
    getOptions(node) {
        var _a, _b, _c, _d;
        return {
            locale: (_a = this.adaptor.getAttribute(node, 'data-semantic-locale')) !== null && _a !== void 0 ? _a : '',
            domain: (_b = this.adaptor.getAttribute(node, 'data-semantic-domain')) !== null && _b !== void 0 ? _b : '',
            style: (_c = this.adaptor.getAttribute(node, 'data-semantic-style')) !== null && _c !== void 0 ? _c : '',
            domain2style: (_d = this.adaptor.getAttribute(node, 'data-semantic-domain2style')) !== null && _d !== void 0 ? _d : '',
        };
    }
    nextRules(item) {
        const options = this.getOptions(item.typesetRoot);
        this.update(options);
        return (this.promise = this.webworker.nextRules(item.outputData.mml, Object.assign({}, this.options, { modality: 'speech' }), item));
    }
    nextStyle(node, item) {
        const options = this.getOptions(item.typesetRoot);
        this.update(options);
        return (this.promise = this.webworker.nextStyle(item.outputData.mml, Object.assign({}, this.options, { modality: 'speech' }), this.adaptor.getAttribute(node, 'data-semantic-id'), item));
    }
    getLabel(node, _center = '', sep = ' ') {
        const adaptor = this.adaptor;
        return (buildLabel(adaptor.getAttribute(node, SemAttr.SPEECH_SSML), adaptor.getAttribute(node, SemAttr.PREFIX_SSML), adaptor.getAttribute(node, SemAttr.POSTFIX_SSML), sep) || adaptor.getAttribute(node, 'aria-label'));
    }
    getBraille(node) {
        const adaptor = this.adaptor;
        return (adaptor.getAttribute(node, 'aria-braillelabel') ||
            adaptor.getAttribute(node, SemAttr.BRAILLE));
    }
    getLocalePreferences(prefs) {
        return (this.promise = this.webworker.clearspeakLocalePreferences(this.options, prefs));
    }
    getRelevantPreferences(item, semantic, prefs, counter) {
        const mml = item.outputData.mml;
        return (this.promise = this.webworker.clearspeakRelevantPreferences(mml, semantic, prefs, counter));
    }
}
//# sourceMappingURL=GeneratorPool.js.map
;// ./mjs/a11y/speech/WebWorker.js
var WebWorker_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class Task {
    constructor(cmd, item, resolve, reject) {
        this.cmd = cmd;
        this.item = item;
        this.resolve = resolve;
        this.reject = reject;
    }
}
class WorkerHandler {
    constructor(adaptor, options) {
        this.adaptor = adaptor;
        this.options = options;
        this.ready = false;
        this.tasks = [];
        this.Commands = {
            Ready(handler, _data) {
                handler.ready = true;
                handler.postNext();
            },
            Finished(handler, data) {
                const task = handler.tasks.shift();
                if (data.success) {
                    task.resolve(data.result);
                }
                else {
                    task.reject(data.error);
                }
                handler.postNext();
            },
            Log(handler, data) {
                if (handler.options.debug) {
                    console.log('Log:', data);
                }
            },
        };
    }
    Start() {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            if (this.ready)
                throw Error('Worker already started');
            this.worker = yield this.adaptor.createWorker(this.Listener.bind(this), this.options);
        });
    }
    debug(msg, ...rest) {
        if (this.options.debug) {
            console.info(msg, ...rest);
        }
    }
    Listener(event) {
        this.debug('Worker  >>>  Client:', event.data);
        if (Object.hasOwn(this.Commands, event.data.cmd)) {
            this.Commands[event.data.cmd](this, event.data.data);
        }
        else {
            this.debug('Invalid command from worker: ' + event.data.cmd);
        }
    }
    Post(msg, item) {
        const promise = new Promise((resolve, reject) => {
            this.tasks.push(new Task(msg, item, resolve, reject));
        });
        if (this.ready && this.tasks.length === 1) {
            this.postNext();
        }
        return promise;
    }
    postNext() {
        if (this.tasks.length) {
            const msg = Object.assign({}, this.tasks[0].cmd, {
                debug: this.options.debug,
            });
            this.worker.postMessage(msg);
        }
    }
    Cancel(item) {
        const i = this.tasks.findIndex((task) => task.item === item);
        if (i > 0) {
            this.tasks[i].reject(`Task ${this.tasks[i].cmd.cmd} cancelled`);
            this.tasks.splice(i, 1);
        }
    }
    Setup(options) {
        return this.Post({
            cmd: 'setup',
            data: {
                domain: options.domain,
                style: options.style,
                locale: options.locale,
                modality: options.modality,
            },
        });
    }
    Speech(math, options, item) {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            this.Attach(item, options.enableSpeech, options.enableBraille, yield this.Post({
                cmd: 'speech',
                data: { mml: math, options: options },
            }, item));
        });
    }
    nextRules(math, options, item) {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            this.Attach(item, options.enableSpeech, options.enableBraille, yield this.Post({
                cmd: 'nextRules',
                data: { mml: math, options: options },
            }, item));
        });
    }
    nextStyle(math, options, nodeId, item) {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            this.Attach(item, options.enableSpeech, options.enableBraille, yield this.Post({
                cmd: 'nextStyle',
                data: {
                    mml: math,
                    options: options,
                    nodeId: nodeId,
                },
            }, item));
        });
    }
    speechFor(math, options, item) {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            const data = yield this.Post({
                cmd: 'speech',
                data: { mml: math, options: options },
            }, item);
            return JSON.parse(data);
        });
    }
    Attach(item, speech, braille, structure) {
        const data = JSON.parse(structure);
        const container = item.typesetRoot;
        if (!container)
            return;
        this.setSpecialAttributes(container, data.options, 'data-semantic-', [
            'locale',
            'domain',
            'style',
            'domain2style',
        ]);
        const adaptor = this.adaptor;
        this.setSpecialAttributes(container, data.translations, 'data-semantic-');
        for (const [id, sid] of Object.entries(data.mactions)) {
            let node = adaptor.getElement('#' + id, container);
            if (!node || !adaptor.childNodes(node)[0]) {
                continue;
            }
            node = adaptor.childNodes(node)[0];
            adaptor.setAttribute(node, 'data-semantic-type', 'dummy');
            this.setSpecialAttributes(node, sid, '');
        }
        this.setSpeechAttributes(adaptor.childNodes(container)[0], '', data, speech, braille);
        if (speech) {
            if (data.label) {
                adaptor.setAttribute(container, SemAttr.SPEECH, data.label);
                adaptor.setAttribute(container, SemAttr.SPEECH_SSML, data.ssml);
                item.outputData.speech = data.label;
            }
            adaptor.setAttribute(container, 'data-speech-attached', 'true');
        }
        if (braille) {
            if (data.braillelabel) {
                adaptor.setAttribute(container, SemAttr.BRAILLE, data.braillelabel);
                item.outputData.braille = data.braillelabel;
            }
            if (data.braille) {
                adaptor.setAttribute(container, 'data-braille-attached', 'true');
            }
        }
    }
    setSpeechAttribute(node, data, speech, braille) {
        var _a, _b;
        const adaptor = this.adaptor;
        const id = adaptor.getAttribute(node, 'data-semantic-id');
        adaptor.removeAttribute(node, 'data-speech-node');
        if (speech && data.speech[id]['speech-none']) {
            adaptor.setAttribute(node, 'data-speech-node', 'true');
            for (let [key, value] of Object.entries(data.speech[id])) {
                key = key.replace(/-ssml$/, '');
                if (value) {
                    adaptor.setAttribute(node, `data-semantic-${key}`, value);
                }
            }
        }
        if (braille && ((_b = (_a = data.braille) === null || _a === void 0 ? void 0 : _a[id]) === null || _b === void 0 ? void 0 : _b['braille-none'])) {
            adaptor.setAttribute(node, 'data-speech-node', 'true');
            const value = data.braille[id]['braille-none'];
            adaptor.setAttribute(node, SemAttr.BRAILLE, value);
        }
    }
    setSpeechAttributes(root, rootId, data, speech, braille) {
        const adaptor = this.adaptor;
        if (!root ||
            adaptor.kind(root) === '#text' ||
            adaptor.kind(root) === '#comment') {
            return rootId;
        }
        root = root;
        if (adaptor.hasAttribute(root, 'data-semantic-id')) {
            this.setSpeechAttribute(root, data, speech, braille);
            if (!rootId && !adaptor.hasAttribute(root, 'data-semantic-parent')) {
                rootId = adaptor.getAttribute(root, 'data-semantic-id');
            }
        }
        for (const child of Array.from(adaptor.childNodes(root))) {
            rootId = this.setSpeechAttributes(child, rootId, data, speech, braille);
        }
        return rootId;
    }
    setSpecialAttributes(node, map, prefix, keys) {
        if (!map)
            return;
        keys = keys || Object.keys(map);
        for (const key of keys) {
            const value = map[key];
            if (value) {
                this.adaptor.setAttribute(node, `${prefix}${key.toLowerCase()}`, value);
            }
        }
    }
    Detach(item) {
        const container = item.typesetRoot;
        this.adaptor.removeAttribute(container, 'data-speech-attached');
        this.adaptor.removeAttribute(container, 'data-braille-attached');
        this.detachSpeech(container);
    }
    detachSpeech(node) {
        const adaptor = this.adaptor;
        const children = adaptor.childNodes(node);
        if (!children)
            return;
        if (adaptor.kind(node) !== '#text') {
            for (const key of [
                'none',
                'summary-none',
                'speech',
                'speech-none',
                'summary',
                'braille',
            ]) {
                adaptor.removeAttribute(node, `data-semantic-${key}`);
            }
        }
        for (const child of children) {
            this.detachSpeech(child);
        }
    }
    Terminate() {
        this.debug('Terminating pending tasks');
        for (const task of this.tasks) {
            task.reject(`${task.cmd.data.cmd} cancelled by WorkerHandler termination`);
        }
        this.tasks = [];
        this.debug('Terminating worker');
        return this.worker.terminate();
    }
    Stop() {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            if (!this.worker) {
                throw Error('Worker has not been started');
            }
            yield this.Terminate();
            this.worker = null;
            this.ready = false;
        });
    }
    clearspeakLocalePreferences(options, prefs) {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            yield this.Post({
                cmd: 'localePreferences',
                data: {
                    options: options,
                },
            }).then((data) => {
                prefs.set(options.locale, JSON.parse(data));
            });
        });
    }
    clearspeakRelevantPreferences(math, nodeId, prefs, counter) {
        return WebWorker_awaiter(this, void 0, void 0, function* () {
            yield this.Post({
                cmd: 'relevantPreferences',
                data: {
                    mml: math,
                    id: nodeId,
                },
            }).then((e) => {
                prefs.set(counter, e);
            });
        });
    }
}
//# sourceMappingURL=WebWorker.js.map
;// ./components/root-pack.js
//
//  Replacement for __dirname for root directory
//



const root_pack_config = global_MathJax.config || {};
const root_pack_mjxRoot = () => root_pack_config?.loader?.paths?.mathjax || root_pack_config?.__dirname || '/';

;// ./mjs/components/mjs/sre-root.js
//
//  Replacement for __dirname for sre-root directory
//



const sreRoot = () => root_pack_mjxRoot() + '/sre';

;// ./mjs/a11y/speech.js
var speech_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






newState('ATTACHSPEECH', STATE.INSERTED + 10);
function SpeechMathItemMixin(EnrichedMathItem) {
    return class extends EnrichedMathItem {
        constructor() {
            super(...arguments);
            this.generatorPool = new GeneratorPool();
        }
        attachSpeech(document) {
            this.outputData.speechPromise = null;
            if (this.state() >= STATE.ATTACHSPEECH)
                return;
            this.state(STATE.ATTACHSPEECH);
            if (this.isEscaped ||
                !(document.options.enableSpeech || document.options.enableBraille) ||
                !document.options.enableEnrichment) {
                return;
            }
            document.getWebworker();
            this.generatorPool.init(document.options, document.adaptor, document.webworker);
            this.outputData.mml = this.toMathML(this.root, this);
            const promise = this.generatorPool
                .Speech(this)
                .catch((err) => document.options.speechError(document, this, err));
            document.savePromise(promise);
            this.outputData.speechPromise = promise;
        }
        detachSpeech(document) {
            document.webworker.Detach(this);
        }
        speechFor(mml) {
            return speech_awaiter(this, void 0, void 0, function* () {
                mml = this.toEnriched(mml);
                const data = yield this.generatorPool.SpeechFor(this, mml);
                return [data.label, data.braillelabel];
            });
        }
        clear() {
            this.generatorPool.cancel(this);
        }
    };
}
function SpeechMathDocumentMixin(EnrichedMathDocument) {
    var _a;
    return _a = class extends EnrichedMathDocument {
            constructor(...args) {
                super(...args);
                this.webworker = null;
                const ProcessBits = this.constructor
                    .ProcessBits;
                if (!ProcessBits.has('attach-speech')) {
                    ProcessBits.allocate('attach-speech');
                }
                this.options.MathItem = SpeechMathItemMixin(this.options.MathItem);
            }
            getWebworker() {
                if (this.webworker)
                    return;
                this.webworker = new WorkerHandler(this.adaptor, this.options.worker);
                this.webworker.Start();
            }
            attachSpeech() {
                if (!this.processed.isSet('attach-speech')) {
                    const options = this.options;
                    if (options.enableEnrichment &&
                        (options.enableSpeech || options.enableBraille)) {
                        this.getWebworker();
                        for (const math of this.math) {
                            math.attachSpeech(this);
                        }
                    }
                    this.processed.set('attach-speech');
                }
                return this;
            }
            speechError(_doc, _math, err) {
                console.warn('Speech generation error:', err);
            }
            state(state, restore = false) {
                super.state(state, restore);
                if (state < STATE.ATTACHSPEECH) {
                    this.processed.clear('attach-speech');
                    if (state >= STATE.TYPESET) {
                        for (const math of this.math) {
                            math.detachSpeech(this);
                        }
                    }
                }
                return this;
            }
            done() {
                const _super = Object.create(null, {
                    done: { get: () => super.done }
                });
                return speech_awaiter(this, void 0, void 0, function* () {
                    var _b;
                    yield ((_b = this.webworker) === null || _b === void 0 ? void 0 : _b.Stop());
                    return _super.done.call(this);
                });
            }
        },
        _a.OPTIONS = Object.assign(Object.assign({}, EnrichedMathDocument.OPTIONS), { enableSpeech: true, enableBraille: true, speechError: (doc, math, err) => doc.speechError(doc, math, err), renderActions: expandable(Object.assign(Object.assign({}, EnrichedMathDocument.OPTIONS.renderActions), { attachSpeech: [STATE.ATTACHSPEECH] })), worker: {
                path: sreRoot(),
                maps: sreRoot().replace(/[cm]js\/a11y\/sre$/, 'bundle/sre/mathmaps'),
                worker: 'speech-worker.js',
                debug: false,
            }, a11y: expandable({
                speech: true,
                braille: true,
            }) }),
        _a;
}
function SpeechHandler(handler, MmlJax) {
    if (!handler.documentClass.prototype.enrich && MmlJax) {
        handler = EnrichHandler(handler, MmlJax);
    }
    handler.documentClass = SpeechMathDocumentMixin(handler.documentClass);
    return handler;
}
//# sourceMappingURL=speech.js.map
;// ./components/mjs/a11y/speech/lib/speech.js








if (MathJax.loader) {
  MathJax.loader.checkVersion('a11y/speech', VERSION, 'a11y');
}

combineWithMathJax({_: {
  a11y: {
    speech_ts: speech_namespaceObject,
    speech: {
      GeneratorPool: GeneratorPool_namespaceObject,
      SpeechUtil: SpeechUtil_namespaceObject,
      WebWorker: WebWorker_namespaceObject
    }
  }
}});

;// ./components/mjs/a11y/speech/speech.js







if (MathJax.loader) {
  let path = Package.resolvePath('[sre]', false);
  let maps = Package.resolvePath('[mathmaps]', false);
  if (hasWindow) {
    path = new URL(path, location).href;
    maps = new URL(maps, location).href;
  } else {
    const REQUIRE = typeof require !== 'undefined' ? require : MathJax.config.loader.require;
    if (REQUIRE?.resolve) {
      path = REQUIRE.resolve(`${path}/require.mjs`).replace(/\/[^\/]*$/, '');
      maps = REQUIRE.resolve(`${maps}/base.json`).replace(/\/[^\/]*$/, '');
    } else {
      path = maps = '';
    }
  }
  if (path) {
    combineDefaults(MathJax.config, 'options', { worker: { path, maps } });
  }
}

if (MathJax.startup) {
  MathJax.startup.extendHandler(handler => SpeechHandler(handler));
}

;// ./mjs/a11y/explorer/Highlighter.js
const namedColors = {
    red: { red: 255, green: 0, blue: 0 },
    green: { red: 0, green: 255, blue: 0 },
    blue: { red: 0, green: 0, blue: 255 },
    yellow: { red: 255, green: 255, blue: 0 },
    cyan: { red: 0, green: 255, blue: 255 },
    magenta: { red: 255, green: 0, blue: 255 },
    white: { red: 255, green: 255, blue: 255 },
    black: { red: 0, green: 0, blue: 0 },
};
function getColorString(color, deflt) {
    var _a;
    const channel = namedColors[color.color] || namedColors[deflt.color];
    channel.alpha = (_a = color.alpha) !== null && _a !== void 0 ? _a : deflt.alpha;
    return rgba(channel);
}
function rgba(color) {
    var _a;
    return `rgba(${color.red},${color.green},${color.blue},${(_a = color.alpha) !== null && _a !== void 0 ? _a : 1})`;
}
const DEFAULT_BACKGROUND = { color: 'blue', alpha: 1 };
const DEFAULT_FOREGROUND = { color: 'black', alpha: 1 };
let Highlighter_counter = 0;
class AbstractHighlighter {
    constructor() {
        this.counter = Highlighter_counter++;
        this.ATTR = 'sre-highlight-' + this.counter.toString();
        this.mactionName = '';
        this.currentHighlights = [];
    }
    highlight(nodes) {
        this.currentHighlights.push(nodes.map((node) => {
            const info = this.highlightNode(node);
            this.setHighlighted(node);
            return info;
        }));
    }
    highlightAll(node) {
        const mactions = this.getMactionNodes(node);
        for (let i = 0, maction; (maction = mactions[i]); i++) {
            this.highlight([maction]);
        }
    }
    unhighlight() {
        const nodes = this.currentHighlights.pop();
        if (!nodes) {
            return;
        }
        nodes.forEach((highlight) => {
            if (this.isHighlighted(highlight.node)) {
                this.unhighlightNode(highlight);
                this.unsetHighlighted(highlight.node);
            }
        });
    }
    unhighlightAll() {
        while (this.currentHighlights.length > 0) {
            this.unhighlight();
        }
    }
    setColor(background, foreground) {
        this._foreground = getColorString(foreground, DEFAULT_FOREGROUND);
        this._background = getColorString(background, DEFAULT_BACKGROUND);
    }
    get foreground() {
        return this._foreground;
    }
    get background() {
        return this._background;
    }
    getMactionNodes(node) {
        return Array.from(node.getElementsByClassName(this.mactionName));
    }
    isMactionNode(node) {
        const className = node.className || node.getAttribute('class');
        return className ? !!className.match(new RegExp(this.mactionName)) : false;
    }
    isHighlighted(node) {
        return node.hasAttribute(this.ATTR);
    }
    setHighlighted(node) {
        node.setAttribute(this.ATTR, 'true');
    }
    unsetHighlighted(node) {
        node.removeAttribute(this.ATTR);
    }
}
class SvgHighlighter extends AbstractHighlighter {
    constructor() {
        super();
        this.mactionName = 'maction';
    }
    highlightNode(node) {
        let info;
        if (this.isHighlighted(node)) {
            info = {
                node: node,
                background: this.background,
                foreground: this.foreground,
            };
            return info;
        }
        if (node.tagName === 'svg' || node.tagName === 'MJX-CONTAINER') {
            info = {
                node: node,
                background: node.style.backgroundColor,
                foreground: node.style.color,
            };
            node.style.backgroundColor = this.background;
            node.style.color = this.foreground;
            return info;
        }
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('sre-highlighter-added', 'true');
        const padding = 40;
        const bbox = node.getBBox();
        rect.setAttribute('x', (bbox.x - padding).toString());
        rect.setAttribute('y', (bbox.y - padding).toString());
        rect.setAttribute('width', (bbox.width + 2 * padding).toString());
        rect.setAttribute('height', (bbox.height + 2 * padding).toString());
        const transform = node.getAttribute('transform');
        if (transform) {
            rect.setAttribute('transform', transform);
        }
        rect.setAttribute('fill', this.background);
        node.setAttribute(this.ATTR, 'true');
        node.parentNode.insertBefore(rect, node);
        info = { node: node, foreground: node.getAttribute('fill') };
        if (node.nodeName !== 'rect') {
            node.setAttribute('fill', this.foreground);
        }
        return info;
    }
    setHighlighted(node) {
        if (node.tagName === 'svg') {
            super.setHighlighted(node);
        }
    }
    unhighlightNode(info) {
        const previous = info.node.previousSibling;
        if (previous && previous.hasAttribute('sre-highlighter-added')) {
            info.foreground
                ? info.node.setAttribute('fill', info.foreground)
                : info.node.removeAttribute('fill');
            info.node.parentNode.removeChild(previous);
            return;
        }
        info.node.style.backgroundColor = info.background;
        info.node.style.color = info.foreground;
    }
    isMactionNode(node) {
        return node.getAttribute('data-mml-node') === this.mactionName;
    }
    getMactionNodes(node) {
        return Array.from(node.querySelectorAll(`[data-mml-node="${this.mactionName}"]`));
    }
}
class ChtmlHighlighter extends AbstractHighlighter {
    constructor() {
        super();
        this.mactionName = 'mjx-maction';
    }
    highlightNode(node) {
        const info = {
            node: node,
            background: node.style.backgroundColor,
            foreground: node.style.color,
        };
        if (!this.isHighlighted(node)) {
            node.style.backgroundColor = this.background;
            node.style.color = this.foreground;
        }
        return info;
    }
    unhighlightNode(info) {
        info.node.style.backgroundColor = info.background;
        info.node.style.color = info.foreground;
    }
    isMactionNode(node) {
        var _a;
        return ((_a = node.tagName) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === this.mactionName.toUpperCase();
    }
    getMactionNodes(node) {
        return Array.from(node.getElementsByTagName(this.mactionName));
    }
}
function getHighlighter(back, fore, renderer) {
    const highlighter = new highlighterMapping[renderer]();
    highlighter.setColor(back, fore);
    return highlighter;
}
const highlighterMapping = {
    SVG: SvgHighlighter,
    CHTML: ChtmlHighlighter,
    generic: ChtmlHighlighter,
};
//# sourceMappingURL=Highlighter.js.map
;// ./mjs/a11y/explorer/Region.js



class AbstractRegion {
    constructor(document) {
        this.document = document;
        this.CLASS = this.constructor;
        this.AddStyles();
    }
    AddStyles() {
        if (this.CLASS.styleAdded) {
            return;
        }
        const node = this.document.adaptor.node('style');
        node.innerHTML = this.CLASS.style.cssText;
        this.document.adaptor
            .head(this.document.adaptor.document)
            .appendChild(node);
        this.CLASS.styleAdded = true;
    }
    AddElement() {
        if (this.div)
            return;
        const element = this.document.adaptor.node('div');
        element.classList.add(this.CLASS.className);
        this.div = element;
        this.inner = this.document.adaptor.node('div');
        this.div.appendChild(this.inner);
        this.document.adaptor
            .body(this.document.adaptor.document)
            .appendChild(this.div);
    }
    Show(node, highlighter) {
        this.AddElement();
        this.position(node);
        this.highlight(highlighter);
        this.div.classList.add(this.CLASS.className + '_Show');
    }
    Hide() {
        if (!this.div)
            return;
        this.div.parentNode.removeChild(this.div);
        this.div = null;
        this.inner = null;
    }
    stackRegions(node) {
        const rect = node.getBoundingClientRect();
        let baseBottom = 0;
        let baseLeft = Number.POSITIVE_INFINITY;
        const regions = this.document.adaptor.document.getElementsByClassName(this.CLASS.className + '_Show');
        for (let i = 0, region; (region = regions[i]); i++) {
            if (region !== this.div) {
                baseBottom = Math.max(region.getBoundingClientRect().bottom, baseBottom);
                baseLeft = Math.min(region.getBoundingClientRect().left, baseLeft);
            }
        }
        const bot = (baseBottom ? baseBottom : rect.bottom + 10) + window.scrollY;
        const left = (baseLeft < Number.POSITIVE_INFINITY ? baseLeft : rect.left) +
            window.scrollX;
        this.div.style.top = bot + 'px';
        this.div.style.left = left + 'px';
    }
}
AbstractRegion.styleAdded = false;
class DummyRegion extends AbstractRegion {
    Clear() { }
    Update() { }
    Hide() { }
    Show() { }
    AddElement() { }
    AddStyles() { }
    position() { }
    highlight(_highlighter) { }
}
class StringRegion extends AbstractRegion {
    Clear() {
        if (!this.div)
            return;
        this.Update('');
        this.inner.style.top = '';
        this.inner.style.backgroundColor = '';
    }
    Update(speech) {
        if (speech) {
            this.AddElement();
        }
        if (this.inner) {
            this.inner.textContent = '';
            this.inner.textContent = speech || '\u00a0';
        }
    }
    position(node) {
        this.stackRegions(node);
    }
    highlight(highlighter) {
        if (!this.div)
            return;
        this.inner.style.backgroundColor = highlighter.background;
        this.inner.style.color = highlighter.foreground;
    }
}
class ToolTip extends StringRegion {
}
ToolTip.className = 'MJX_ToolTip';
ToolTip.style = new StyleJsonSheet({
    ['.' + ToolTip.className]: {
        width: 'auto',
        height: 'auto',
        opacity: 1,
        'text-align': 'center',
        'border-radius': '4px',
        padding: 0,
        'border-bottom': '1px dotted black',
        position: 'absolute',
        display: 'inline-block',
        'background-color': 'white',
        'z-index': 202,
    },
    ['.' + ToolTip.className + ' > div']: {
        'border-radius': 'inherit',
        padding: '0 2px',
    },
});
class LiveRegion extends StringRegion {
}
LiveRegion.className = 'MJX_LiveRegion';
LiveRegion.style = new StyleJsonSheet({
    ['.' + LiveRegion.className]: {
        position: 'absolute',
        top: 0,
        display: 'none',
        width: 'auto',
        height: 'auto',
        padding: 0,
        opacity: 1,
        'z-index': '202',
        left: 0,
        right: 0,
        margin: '0 auto',
        'background-color': 'white',
        'box-shadow': '0px 5px 20px #888',
        border: '2px solid #CCCCCC',
    },
    ['.' + LiveRegion.className + '_Show']: {
        display: 'block',
    },
});
class SpeechRegion extends LiveRegion {
    constructor() {
        super(...arguments);
        this.active = false;
        this.node = null;
        this.clear = false;
        this.highlighter = getHighlighter({ color: 'red' }, { color: 'black' }, this.document.outputJax.name);
        this.voiceRequest = false;
        this.voiceCancelled = false;
    }
    Show(node, highlighter) {
        super.Update('\u00a0');
        this.node = node;
        super.Show(node, highlighter);
    }
    Update(speech) {
        if (this.voiceRequest) {
            this.makeVoice(speech);
            return;
        }
        speechSynthesis.onvoiceschanged = (() => (this.voiceRequest = true)).bind(this);
        const promise = new Promise((resolve) => {
            setTimeout(() => {
                if (this.voiceRequest) {
                    resolve(true);
                }
                else {
                    setTimeout(() => {
                        this.voiceRequest = true;
                        resolve(true);
                    }, 100);
                }
            }, 100);
        });
        promise.then(() => this.makeVoice(speech));
    }
    makeVoice(speech) {
        this.active =
            this.document.options.a11y.voicing &&
                !!speechSynthesis.getVoices().length;
        speechSynthesis.cancel();
        this.clear = true;
        const [text, ssml] = buildSpeech(speech, this.document.options.sre.locale, this.document.options.sre.rate);
        super.Update(text);
        if (this.active && text) {
            this.makeUtterances(ssml, this.document.options.sre.locale);
        }
    }
    makeUtterances(ssml, locale) {
        this.voiceCancelled = false;
        let utterance = null;
        for (const utter of ssml) {
            if (utter.mark) {
                if (!utterance) {
                    this.highlightNode(utter.mark, true);
                    continue;
                }
                utterance.addEventListener('end', (_event) => {
                    if (!this.voiceCancelled) {
                        this.highlightNode(utter.mark);
                    }
                });
                continue;
            }
            if (utter.pause) {
                const time = parseInt(utter.pause.match(/^[0-9]+/)[0]);
                if (isNaN(time) || !utterance) {
                    continue;
                }
                utterance.addEventListener('end', (_event) => {
                    speechSynthesis.pause();
                    setTimeout(() => {
                        speechSynthesis.resume();
                    }, time);
                });
                continue;
            }
            utterance = new SpeechSynthesisUtterance(utter.text);
            if (utter.rate) {
                utterance.rate = utter.rate;
            }
            if (utter.pitch) {
                utterance.pitch = utter.pitch;
            }
            utterance.lang = locale;
            speechSynthesis.speak(utterance);
        }
        if (utterance) {
            utterance.addEventListener('end', (_event) => {
                this.highlighter.unhighlight();
            });
        }
    }
    Hide() {
        this.cancelVoice();
        super.Hide();
    }
    cancelVoice() {
        this.voiceCancelled = true;
        speechSynthesis.cancel();
        this.highlighter.unhighlight();
    }
    highlightNode(id, init = false) {
        this.highlighter.unhighlight();
        const nodes = Array.from(this.node.querySelectorAll(`[data-semantic-id="${id}"]`));
        if (!this.clear || init) {
            this.highlighter.highlight(nodes);
        }
        this.clear = false;
    }
}
class HoverRegion extends AbstractRegion {
    position(node) {
        const nodeRect = node.getBoundingClientRect();
        const divRect = this.div.getBoundingClientRect();
        const xCenter = nodeRect.left + nodeRect.width / 2;
        let left = xCenter - divRect.width / 2;
        left = left < 0 ? 0 : left;
        left = left + window.scrollX;
        let top;
        switch (this.document.options.a11y.align) {
            case 'top':
                top = nodeRect.top - divRect.height - 10;
                break;
            case 'bottom':
                top = nodeRect.bottom + 10;
                break;
            case 'center':
            default: {
                const yCenter = nodeRect.top + nodeRect.height / 2;
                top = yCenter - divRect.height / 2;
            }
        }
        top = top + window.scrollY;
        top = top < 0 ? 0 : top;
        this.div.style.top = top + 'px';
        this.div.style.left = left + 'px';
    }
    highlight(highlighter) {
        if (!this.div)
            return;
        if (this.inner.firstChild &&
            !this.inner.firstChild.hasAttribute('sre-highlight')) {
            return;
        }
        this.inner.style.backgroundColor = highlighter.background;
        this.inner.style.color = highlighter.foreground;
    }
    Show(node, highlighter) {
        this.AddElement();
        this.div.style.fontSize = this.document.options.a11y.magnify;
        this.Update(node);
        super.Show(node, highlighter);
    }
    Clear() {
        if (!this.div)
            return;
        this.inner.textContent = '';
        this.inner.style.top = '';
        this.inner.style.backgroundColor = '';
    }
    Update(node) {
        if (!this.div)
            return;
        this.Clear();
        const mjx = this.cloneNode(node);
        const selected = mjx.querySelector('[data-mjx-clone]');
        this.inner.style.backgroundColor = node.style.backgroundColor;
        selected.style.backgroundColor = '';
        selected.classList.remove('mjx-selected');
        this.inner.appendChild(mjx);
        this.position(node);
    }
    cloneNode(node) {
        let mjx = node.cloneNode(true);
        mjx.setAttribute('data-mjx-clone', 'true');
        if (mjx.nodeName !== 'MJX-CONTAINER') {
            if (mjx.nodeName !== 'g') {
                mjx.style.marginLeft = mjx.style.marginRight = '0';
            }
            let container = node;
            while (container && container.nodeName !== 'MJX-CONTAINER') {
                container = container.parentNode;
            }
            if (mjx.nodeName !== 'MJX-MATH' && mjx.nodeName !== 'svg') {
                const child = container.firstChild;
                mjx = child.cloneNode(false).appendChild(mjx).parentNode;
                if (mjx.nodeName === 'svg') {
                    mjx.firstChild.setAttribute('transform', 'matrix(1 0 0 -1 0 0)');
                    const W = parseFloat(mjx.getAttribute('viewBox').split(/ /)[2]);
                    const w = parseFloat(mjx.getAttribute('width'));
                    const { x, y, width, height } = node.getBBox();
                    mjx.setAttribute('viewBox', [x, -(y + height), width, height].join(' '));
                    mjx.removeAttribute('style');
                    mjx.setAttribute('width', (w / W) * width + 'ex');
                    mjx.setAttribute('height', (w / W) * height + 'ex');
                    container.setAttribute('sre-highlight', 'false');
                }
            }
            mjx = container.cloneNode(false).appendChild(mjx)
                .parentNode;
            mjx.style.margin = '0';
        }
        return mjx;
    }
}
HoverRegion.className = 'MJX_HoverRegion';
HoverRegion.style = new StyleJsonSheet({
    ['.' + HoverRegion.className]: {
        display: 'block',
        position: 'absolute',
        width: 'max-content',
        height: 'auto',
        padding: 0,
        opacity: 1,
        'z-index': '202',
        margin: '0 auto',
        'background-color': 'white',
        'line-height': 0,
        'box-shadow': '0px 10px 20px #888',
        border: '2px solid #CCCCCC',
    },
    ['.' + HoverRegion.className + ' > div']: {
        overflow: 'hidden',
    },
});
//# sourceMappingURL=Region.js.map
;// ./mjs/a11y/explorer/Explorer.js
class AbstractExplorer {
    get highlighter() {
        return this.pool.highlighter;
    }
    static stopEvent(event) {
        if (event.preventDefault) {
            event.preventDefault();
        }
        else {
            event.returnValue = false;
        }
        if (event.stopImmediatePropagation) {
            event.stopImmediatePropagation();
        }
        else if (event.stopPropagation) {
            event.stopPropagation();
        }
        event.cancelBubble = true;
    }
    static create(document, pool, region, node, ...rest) {
        const explorer = new this(document, pool, region, node, ...rest);
        return explorer;
    }
    constructor(document, pool, region, node, ..._rest) {
        this.document = document;
        this.pool = pool;
        this.region = region;
        this.node = node;
        this.stoppable = true;
        this.events = [];
        this._active = false;
    }
    Events() {
        return this.events;
    }
    get active() {
        return this._active;
    }
    set active(flag) {
        this._active = flag;
    }
    Attach() {
        this.AddEvents();
    }
    Detach() {
        this.RemoveEvents();
    }
    Start() {
        this.active = true;
    }
    Stop() {
        if (this.active) {
            this.region.Clear();
            this.region.Hide();
            this.active = false;
        }
    }
    AddEvents() {
        for (const [eventkind, eventfunc] of this.events) {
            this.node.addEventListener(eventkind, eventfunc);
        }
    }
    RemoveEvents() {
        for (const [eventkind, eventfunc] of this.events) {
            this.node.removeEventListener(eventkind, eventfunc);
        }
    }
    Update(_force = false) { }
    stopEvent(event) {
        if (this.stoppable) {
            AbstractExplorer.stopEvent(event);
        }
    }
}
//# sourceMappingURL=Explorer.js.map
;// ./mjs/a11y/explorer/KeyExplorer.js
var KeyExplorer_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




const nav = '[data-speech-node]';
function isContainer(el) {
    return el.matches('mjx-container');
}
function hasModifiers(event, shift = true) {
    return ((event.shiftKey && shift) || event.metaKey || event.altKey || event.ctrlKey);
}
function helpMessage(title, select) {
    return `
<H2>Exploring expressions ${title}</h2>

<p>The mathematics on this page is being rendered by <a
href="https://www.mathjax.org/" target="_blank">MathJax</a>, which
generates both the text spoken by screen readers, as well as the
visual layout for sighted users.</p>

<p>Expressions typeset by MathJax can be explored interactively, and
are focusable.  You can use the <kbd>Tab</kbd> key to move to a typeset
expression${select}.  Initially, the expression will be read in full,
but you can use the following keys to explore the expression
further:<p>

<ul>

<li><kbd>Down Arrow</kbd> moves one level deeper into the expression to
allow you to explore the current subexpression term by term.</li>

<li><kbd>Up Arrow</kbd> moves back up a level within the expression.</li>

<li><kbd>Right Arrow</kbd> moves to the next term in the current
subexpression.</li>

<li><kbd>Left Arrow</kbd> moves to the next term in the current
subexpression.</li>

<li><kbd>Shift</kbd>+<kbd>Arrow</kbd> moves to a neighboring cell within a table.

<li><kbd>0-9</kbd>+<kbd>0-9</kbd> jumps to a cell by its index in the table, where 0 = 10.

<li><kbd>Home</kbd> takes you to the top of the expression.</li>

<li><kbd>Enter</kbd> or <kbd>Return</kbd> clicks a link or activates an active
subexpression.</li>

<li><kbd>Space</kbd> opens the MathJax contextual menu where you can view
or copy the source format of the expression, or modify MathJax's
settings.</li>

<li><kbd>Escape</kbd> exits the expression explorer.</li>

<li><kbd>x</kbd> gives a summary of the current subexpression.</li>

<li><kbd>z</kbd> gives the full text of a collapsed expression.</li>

<li><kbd>d</kbd> gives the current depth within the expression.</li>

<li><kbd>s</kbd> starts or stops auto-voicing with synchronized highlighting.</li>

<li><kbd>v</kbd> marks the current position in the expression.</li>

<li><kbd>p</kbd> cycles through the marked positions in the expression.</li>

<li><kbd>u</kbd> clears all marked positions and returns to the starting position.</li>

<li><kbd>&gt;</kbd> cycles through the available speech rule sets
(MathSpeak, ClearSpeak).</li>

<li><kbd>&lt;</kbd> cycles through the verbosity levels for the current
rule set.</li>

<li><kbd>h</kbd> produces this help listing.</li>
</ul>

<p>The MathJax contextual menu allows you to enable or disable speech
or Braille generation for mathematical expressions, the language to
use for the spoken mathematics, and other features of MathJax.  In
particular, the Explorer submenu allows you to specify how the
mathematics should be identified in the page (e.g., by saying "math"
when the expression is spoken), and whether or not to include a
message about the letter "h" bringing up this dialog box.</p>

<p>The contextual menu also provides options for viewing or copying a
MathML version of the expression or its original source format,
creating an SVG version of the expression, and viewing various other
information.</p>

<p>For more help, see the <a
href="https://docs.mathjax.org/en/latest/basic/accessibility.html"
targe="_blank">MathJax accessibility documentation.</a></p>
`;
}
const helpData = new Map([
    [
        'MacOS',
        [
            'on MacOS and iOS using VoiceOver',
            ', or the VoiceOver arrow keys to select an expression',
        ],
    ],
    [
        'Windows',
        [
            'in Windows using NVDA or JAWS',
            `. The screen reader should enter focus or forms mode automatically
when the expression gets the browser focus, but if not, you can toggle
focus mode using NVDA+space in NVDA; for JAWS, Enter should start
forms mode while Numpad Plus leaves it.  Also note that you can use
the NVDA or JAWS key plus the arrow keys to explore the expression
even in browse mode, and you can use NVDA+shift+arrow keys to
navigate out of an expression that has the focus in NVDA`,
        ],
    ],
    [
        'Unix',
        [
            'in Unix using Orca',
            `, and Orca should enter focus mode automatically.  If not, use the
Orca+a key to toggle focus mode on or off.  Also note that you can use
Orca+arrow keys to explore expressions even in browse mode`,
        ],
    ],
    ['unknown', ['with a Screen Reader.', '']],
]);
class SpeechExplorer extends AbstractExplorer {
    get generators() {
        var _a;
        return (_a = this.item) === null || _a === void 0 ? void 0 : _a.generatorPool;
    }
    get role() {
        return this.item.ariaRole;
    }
    get description() {
        return this.item.roleDescription;
    }
    get none() {
        return this.item.none;
    }
    FocusIn(_event) {
        if (this.item.outputData.nofocus) {
            this.item.outputData.nofocus = false;
            return;
        }
        if (!this.clicked) {
            this.Start();
        }
        this.clicked = null;
    }
    FocusOut(_event) {
        if (this.current && !this.focusSpeech) {
            this.setCurrent(null);
            this.Stop();
            if (!document.hasFocus()) {
                this.focusTop();
            }
        }
    }
    KeyDown(event) {
        this.pendingIndex.shift();
        this.region.cancelVoice();
        if (hasModifiers(event, false))
            return;
        const CLASS = this.constructor;
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const [action, value] = CLASS.keyMap.get(key) || [];
        const result = action
            ? value === undefined || this.active
                ? action(this, event)
                : value
            : this.undefinedKey(event);
        if (result)
            return;
        this.stopEvent(event);
        if (result === false && this.sound) {
            this.NoMove();
        }
    }
    MouseDown(event) {
        var _a;
        this.pendingIndex = [];
        this.region.cancelVoice();
        if (hasModifiers(event) || event.buttons === 2) {
            this.item.outputData.nofocus = true;
            return;
        }
        const clicked = this.findClicked(event.target, event.x, event.y);
        if (clicked === this.document.infoIcon) {
            this.stopEvent(event);
            return;
        }
        (_a = document.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
        if (event.target.getAttribute('sre-highlighter-added')) {
            this.refocus = clicked;
        }
        else {
            this.clicked = clicked;
        }
    }
    Click(event) {
        if (hasModifiers(event) ||
            event.buttons === 2 ||
            document.getSelection().type === 'Range') {
            this.FocusOut(null);
            return;
        }
        const clicked = this.findClicked(event.target, event.x, event.y);
        if (clicked === this.document.infoIcon) {
            this.stopEvent(event);
            this.help();
            return;
        }
        if (!clicked || this.node.contains(clicked)) {
            this.stopEvent(event);
            this.refocus = clicked;
            if (!this.triggerLinkMouse()) {
                this.Start();
            }
        }
    }
    DblClick(event) {
        var _a;
        const direction = (_a = document.getSelection().direction) !== null && _a !== void 0 ? _a : 'none';
        if (hasModifiers(event) || event.buttons === 2 || direction !== 'none') {
            this.FocusOut(null);
        }
        else {
            this.stopEvent(event);
            this.refocus = this.rootNode();
            this.Start();
        }
    }
    spaceKey() {
        this.refocus = this.current;
        return true;
    }
    hKey() {
        this.refocus = this.current;
        this.help();
    }
    escapeKey() {
        this.Stop();
        this.focusTop();
        return true;
    }
    enterKey(event) {
        if (this.active) {
            if (this.triggerLinkKeyboard(event)) {
                this.Stop();
            }
            else {
                const expandable = this.actionable(this.current);
                if (!expandable) {
                    return false;
                }
                this.refocus = expandable;
                expandable.dispatchEvent(new Event('click'));
            }
        }
        else {
            this.Start();
        }
    }
    homeKey() {
        this.setCurrent(this.rootNode());
    }
    moveDown(shift) {
        return shift
            ? this.moveToNeighborCell(1, 0)
            : this.moveTo(this.firstNode(this.current));
    }
    moveUp(shift) {
        return shift
            ? this.moveToNeighborCell(-1, 0)
            : this.moveTo(this.getParent(this.current));
    }
    moveRight(shift) {
        return shift
            ? this.moveToNeighborCell(0, 1)
            : this.moveTo(this.nextSibling(this.current));
    }
    moveLeft(shift) {
        return shift
            ? this.moveToNeighborCell(0, -1)
            : this.moveTo(this.prevSibling(this.current));
    }
    moveTo(node) {
        if (!node)
            return false;
        this.setCurrent(node);
    }
    moveToNeighborCell(di, dj) {
        const cell = this.tableCell(this.current);
        if (!cell)
            return false;
        const [i, j] = this.cellPosition(cell);
        if (i == null)
            return false;
        const move = this.cellAt(this.cellTable(cell), i + di, j + dj);
        if (!move)
            return false;
        this.setCurrent(move);
    }
    undefinedKey(event) {
        return !this.active || hasModifiers(event);
    }
    addMark() {
        if (this.current === this.marks[this.marks.length - 1]) {
            this.setCurrent(this.current);
        }
        else {
            this.currentMark = this.marks.length - 1;
            this.marks.push(this.current);
            this.speak('Position marked');
        }
    }
    prevMark() {
        if (this.currentMark < 0) {
            if (this.marks.length === 0) {
                this.setCurrent(this.lastMark || this.rootNode());
                return;
            }
            this.currentMark = this.marks.length - 1;
        }
        const current = this.currentMark;
        this.setCurrent(this.marks[current]);
        this.currentMark = current - 1;
    }
    clearMarks() {
        this.marks = [];
        this.currentMark = -1;
        this.prevMark();
    }
    autoVoice() {
        const value = !this.document.options.a11y.voicing;
        if (this.document.menu) {
            this.document.menu.menu.pool.lookup('voicing').setValue(value);
        }
        else {
            this.document.options.a11y.voicing = value;
        }
        this.Update();
    }
    numberKey(n) {
        if (!this.tableCell(this.current))
            return false;
        if (n === 0) {
            n = 10;
        }
        if (this.pendingIndex.length) {
            const table = this.cellTable(this.tableCell(this.current));
            const cell = this.cellAt(table, this.pendingIndex[0] - 1, n - 1);
            this.pendingIndex = [];
            this.speak(String(n));
            if (!cell)
                return false;
            setTimeout(() => this.setCurrent(cell), 500);
        }
        else {
            this.pendingIndex = [null, n];
            this.speak(`Jump to row ${n} and column`);
        }
    }
    depth() {
        var _a, _b, _c;
        if (this.speechType === 'd') {
            this.setCurrent(this.current);
            return;
        }
        this.speechType = 'd';
        const parts = [
            [
                (_a = this.node.getAttribute('data-semantic-level')) !== null && _a !== void 0 ? _a : 'Level',
                (_b = this.current.getAttribute('aria-level')) !== null && _b !== void 0 ? _b : '0',
            ]
                .join(' ')
                .trim(),
        ];
        const action = this.actionable(this.current);
        if (action) {
            parts.unshift((_c = this.node.getAttribute(action.getAttribute('toggle') === '1'
                ? 'data-semantic-expandable'
                : 'data-semantic-collapsible')) !== null && _c !== void 0 ? _c : '');
        }
        this.speak(parts.join(' '), this.current.getAttribute(SemAttr.BRAILLE));
    }
    summary() {
        if (this.speechType === 'x') {
            this.setCurrent(this.current);
            return;
        }
        this.speechType = 'x';
        const summary = this.current.getAttribute(SemAttr.SUMMARY);
        this.speak(summary, this.current.getAttribute(SemAttr.BRAILLE), this.SsmlAttributes(this.current, SemAttr.SUMMARY_SSML));
    }
    nextRules() {
        this.node.removeAttribute('data-speech-attached');
        this.restartAfter(this.generators.nextRules(this.item));
    }
    nextStyle() {
        this.node.removeAttribute('data-speech-attached');
        this.restartAfter(this.generators.nextStyle(this.current, this.item));
    }
    details() {
        const action = this.actionable(this.current);
        if (!action ||
            !action.getAttribute('data-collapsible') ||
            action.getAttribute('toggle') !== '1' ||
            this.speechType === 'z') {
            this.setCurrent(this.current);
            return;
        }
        this.speechType = 'z';
        const id = this.nodeId(this.current);
        let current;
        this.item.root.walkTree((node) => {
            if (node.attributes.get('data-semantic-id') === id) {
                current = node;
            }
        });
        let mml = this.item.toMathML(current, this.item);
        if (!current.isKind('math')) {
            mml = `<math>${mml}</math>`;
        }
        mml = mml.replace(/ (?:data-semantic-|aria-|data-speech-|data-latex).*?=".*?"/g, '');
        this.item
            .speechFor(mml)
            .then(([speech, braille]) => this.speak(speech, braille));
    }
    help() {
        const adaptor = this.document.adaptor;
        const helpBackground = adaptor.node('mjx-help-background');
        const close = (event) => {
            helpBackground.remove();
            this.node.focus();
            this.stopEvent(event);
        };
        helpBackground.addEventListener('click', close);
        const helpSizer = adaptor.node('mjx-help-sizer', {}, [
            adaptor.node('mjx-help-dialog', { tabindex: 0, role: 'dialog', 'aria-labeledby': 'mjx-help-label' }, [
                adaptor.node('h1', { id: 'mjx-help-label' }, [
                    adaptor.text('MathJax Expression Explorer Help'),
                ]),
                adaptor.node('div'),
                adaptor.node('input', { type: 'button', value: 'Close' }),
            ]),
        ]);
        helpBackground.append(helpSizer);
        const help = helpSizer.firstChild;
        help.addEventListener('click', (event) => this.stopEvent(event));
        help.lastChild.addEventListener('click', close);
        help.addEventListener('keydown', (event) => {
            if (event.code === 'Escape') {
                close(event);
            }
        });
        const [title, select] = helpData.get(context.os);
        help.childNodes[1].innerHTML = helpMessage(title, select);
        document.body.append(helpBackground);
        help.focus();
    }
    setCurrent(node, addDescription = false) {
        this.speechType = '';
        if (!document.hasFocus()) {
            this.refocus = this.current;
        }
        this.node.setAttribute('aria-busy', 'true');
        if (this.current) {
            for (const part of this.getSplitNodes(this.current)) {
                part.classList.remove('mjx-selected');
            }
            this.pool.unhighlight();
            if (this.document.options.a11y.tabSelects === 'last') {
                this.refocus = this.current;
            }
            if (!node) {
                this.lastMark = this.current;
                this.removeSpeech();
            }
            this.current = null;
        }
        this.current = node;
        this.currentMark = -1;
        if (this.current) {
            const parts = this.getSplitNodes(this.current);
            for (const part of parts) {
                part.classList.add('mjx-selected');
            }
            this.pool.highlight(parts);
            this.addSpeech(node, addDescription);
        }
        this.node.removeAttribute('aria-busy');
    }
    getSplitNodes(node) {
        const id = this.nodeId(node);
        if (!id) {
            return [node];
        }
        return Array.from(this.node.querySelectorAll(`[data-semantic-id="${id}"]`));
    }
    addSpeech(node, describe) {
        var _a;
        (_a = this.img) === null || _a === void 0 ? void 0 : _a.remove();
        let speech = [
            node.getAttribute(SemAttr.PREFIX),
            node.getAttribute(SemAttr.SPEECH),
            node.getAttribute(SemAttr.POSTFIX),
        ]
            .join(' ')
            .trim();
        if (describe) {
            let description = this.description === this.none ? '' : ', ' + this.description;
            if (this.document.options.a11y.help) {
                description += ', press h for help';
            }
            speech += description;
        }
        this.speak(speech, node.getAttribute(SemAttr.BRAILLE), this.SsmlAttributes(node, SemAttr.SPEECH_SSML));
        this.node.setAttribute('tabindex', '-1');
    }
    removeSpeech() {
        if (this.speech) {
            this.speech.remove();
            this.speech = null;
            if (this.img) {
                this.node.append(this.img);
            }
            this.node.setAttribute('tabindex', '0');
        }
    }
    speak(speech, braille = '', ssml = null, description = this.none) {
        const oldspeech = this.speech;
        this.speech = document.createElement('mjx-speech');
        this.speech.setAttribute('role', this.role);
        this.speech.setAttribute('aria-label', speech);
        this.speech.setAttribute(SemAttr.SPEECH, speech);
        if (ssml) {
            this.speech.setAttribute(SemAttr.PREFIX_SSML, ssml[0] || '');
            this.speech.setAttribute(SemAttr.SPEECH_SSML, ssml[1] || '');
            this.speech.setAttribute(SemAttr.POSTFIX_SSML, ssml[2] || '');
        }
        if (braille) {
            this.speech.setAttribute('aria-braillelabel', braille);
        }
        this.speech.setAttribute('aria-roledescription', description);
        this.speech.setAttribute('tabindex', '0');
        this.node.append(this.speech);
        this.focusSpeech = true;
        this.speech.focus();
        this.focusSpeech = false;
        this.Update();
        if (oldspeech) {
            setTimeout(() => oldspeech.remove(), 100);
        }
    }
    attachSpeech() {
        var _a;
        const item = this.item;
        const container = this.node;
        if (!container.hasAttribute('has-speech')) {
            for (const child of Array.from(container.childNodes)) {
                child.setAttribute('aria-hidden', 'true');
            }
            container.setAttribute('has-speech', 'true');
        }
        const description = item.roleDescription;
        const speech = (container.getAttribute(SemAttr.SPEECH) || '') +
            (description ? ', ' + description : '');
        (_a = this.img) === null || _a === void 0 ? void 0 : _a.remove();
        this.img = this.document.adaptor.node('mjx-speech', {
            'aria-label': speech,
            role: 'img',
            'aria-roledescription': item.none,
        });
        container.appendChild(this.img);
    }
    detachSpeech() {
        var _a;
        const container = this.node;
        (_a = this.img) === null || _a === void 0 ? void 0 : _a.remove();
        container.removeAttribute('has-speech');
        for (const child of Array.from(container.childNodes)) {
            child.removeAttribute('aria-hidden');
        }
    }
    focus() {
        this.node.focus();
    }
    nodeId(node) {
        return node.getAttribute('data-semantic-id');
    }
    parentId(node) {
        return node.getAttribute('data-semantic-parent');
    }
    getNode(id) {
        return id ? this.node.querySelector(`[data-semantic-id="${id}"]`) : null;
    }
    getParent(node) {
        return this.getNode(this.parentId(node));
    }
    childArray(node) {
        return node ? node.getAttribute('data-semantic-children').split(/,/) : [];
    }
    isCell(node) {
        return (!!node && this.cellTypes.includes(node.getAttribute('data-semantic-type')));
    }
    isRow(node) {
        return !!node && node.getAttribute('data-semantic-type') === 'row';
    }
    tableCell(node) {
        while (node && node !== this.node) {
            if (this.isCell(node)) {
                return node;
            }
            node = node.parentNode;
        }
        return null;
    }
    cellTable(cell) {
        const row = this.getParent(cell);
        return this.isRow(row) ? this.getParent(row) : row;
    }
    cellPosition(cell) {
        const row = this.getParent(cell);
        const j = this.childArray(row).indexOf(this.nodeId(cell));
        if (!this.isRow(row)) {
            return [j, 1];
        }
        const table = this.getParent(row);
        const i = this.childArray(table).indexOf(this.nodeId(row));
        return [i, j];
    }
    cellAt(table, i, j) {
        const row = this.getNode(this.childArray(table)[i]);
        if (!this.isRow(row)) {
            return j === 1 ? row : null;
        }
        const cell = this.getNode(this.childArray(row)[j]);
        return cell;
    }
    firstNode(node) {
        const owns = node.getAttribute('data-semantic-owns');
        if (!owns) {
            return node.querySelector(nav);
        }
        const ownsList = owns.split(/ /);
        for (const id of ownsList) {
            const node = this.getNode(id);
            if (node === null || node === void 0 ? void 0 : node.hasAttribute('data-speech-node')) {
                return node;
            }
        }
        return node.querySelector(nav);
    }
    rootNode() {
        const base = this.node.querySelector('[data-semantic-structure]');
        if (!base) {
            return this.node.querySelector(nav);
        }
        const id = base
            .getAttribute('data-semantic-structure')
            .split(/ /)[0]
            .replace('(', '');
        return this.getNode(id);
    }
    nextSibling(node) {
        var _a;
        const id = this.parentId(node);
        if (!id)
            return null;
        const owns = (_a = this.getNode(id)
            .getAttribute('data-semantic-owns')) === null || _a === void 0 ? void 0 : _a.split(/ /);
        if (!owns)
            return null;
        let i = owns.indexOf(this.nodeId(node));
        let next;
        do {
            next = this.getNode(owns[++i]);
        } while (next && !next.hasAttribute('data-speech-node'));
        return next;
    }
    prevSibling(node) {
        var _a;
        const id = this.parentId(node);
        if (!id)
            return null;
        const owns = (_a = this.getNode(id)
            .getAttribute('data-semantic-owns')) === null || _a === void 0 ? void 0 : _a.split(/ /);
        if (!owns)
            return null;
        let i = owns.indexOf(this.nodeId(node));
        let prev;
        do {
            prev = this.getNode(owns[--i]);
        } while (prev && !prev.hasAttribute('data-speech-node'));
        return prev;
    }
    findClicked(node, x, y) {
        const icon = this.document.infoIcon;
        if (icon === node || icon.contains(node)) {
            return icon;
        }
        if (this.node.getAttribute('jax') !== 'SVG') {
            return node.closest(nav);
        }
        let found = null;
        let clicked = this.node;
        while (clicked) {
            if (clicked.matches(nav)) {
                found = clicked;
            }
            const nodes = Array.from(clicked.childNodes);
            clicked = null;
            for (const child of nodes) {
                if (child !== this.speech &&
                    child !== this.img &&
                    child.tagName.toLowerCase() !== 'rect') {
                    const { left, right, top, bottom } = child.getBoundingClientRect();
                    if (left <= x && x <= right && top <= y && y <= bottom) {
                        clicked = child;
                        break;
                    }
                }
            }
        }
        return found;
    }
    focusTop() {
        this.focusSpeech = true;
        this.node.focus();
        this.focusSpeech = false;
    }
    SsmlAttributes(node, center) {
        return [
            node.getAttribute(SemAttr.PREFIX_SSML),
            node.getAttribute(center),
            node.getAttribute(SemAttr.POSTFIX_SSML),
        ];
    }
    restartAfter(promise) {
        return KeyExplorer_awaiter(this, void 0, void 0, function* () {
            yield promise;
            this.attachSpeech();
            const current = this.current;
            this.current = null;
            this.pool.unhighlight();
            this.setCurrent(current);
        });
    }
    constructor(document, pool, region, node, brailleRegion, magnifyRegion, _mml, item) {
        super(document, pool, null, node);
        this.document = document;
        this.pool = pool;
        this.region = region;
        this.node = node;
        this.brailleRegion = brailleRegion;
        this.magnifyRegion = magnifyRegion;
        this.item = item;
        this.sound = false;
        this.current = null;
        this.clicked = null;
        this.refocus = null;
        this.focusSpeech = false;
        this.restarted = null;
        this.speech = null;
        this.speechType = '';
        this.img = null;
        this.attached = false;
        this.eventsAttached = false;
        this.marks = [];
        this.currentMark = -1;
        this.lastMark = null;
        this.pendingIndex = [];
        this.cellTypes = ['cell', 'line'];
        this.events = super.Events().concat([
            ['focusin', this.FocusIn.bind(this)],
            ['focusout', this.FocusOut.bind(this)],
            ['keydown', this.KeyDown.bind(this)],
            ['mousedown', this.MouseDown.bind(this)],
            ['click', this.Click.bind(this)],
            ['dblclick', this.DblClick.bind(this)],
        ]);
    }
    findStartNode() {
        let node = this.refocus || this.current;
        if (!node && this.restarted) {
            node = this.node.querySelector(this.restarted);
        }
        this.refocus = this.restarted = null;
        return node;
    }
    Start() {
        const _super = Object.create(null, {
            Start: { get: () => super.Start }
        });
        return KeyExplorer_awaiter(this, void 0, void 0, function* () {
            if (!this.attached || this.active)
                return;
            this.document.activeItem = this.item;
            if (this.item.state() < STATE.ATTACHSPEECH) {
                this.item.attachSpeech(this.document);
                yield this.generators.promise;
            }
            if (this.focusSpeech)
                return;
            this.node.classList.add('mjx-explorer-active');
            this.node.append(this.document.infoIcon);
            const node = this.findStartNode();
            this.setCurrent(node || this.rootNode(), !node);
            _super.Start.call(this);
            const options = this.document.options;
            const a11y = options.a11y;
            if (a11y.subtitles && a11y.speech && options.enableSpeech) {
                this.region.Show(this.node, this.highlighter);
            }
            if (a11y.viewBraille && a11y.braille && options.enableBraille) {
                this.brailleRegion.Show(this.node, this.highlighter);
            }
            if (a11y.keyMagnifier) {
                this.magnifyRegion.Show(this.current, this.highlighter);
            }
            this.Update();
        });
    }
    Stop() {
        if (this.active) {
            const description = this.description;
            if (this.node.getAttribute('aria-roledescription') !== description) {
                this.node.setAttribute('aria-roledescription', description);
            }
            this.node.classList.remove('mjx-explorer-active');
            this.document.infoIcon.remove();
            this.pool.unhighlight();
            this.magnifyRegion.Hide();
            this.region.Hide();
            this.brailleRegion.Hide();
        }
        super.Stop();
    }
    Update() {
        if (!this.active)
            return;
        this.region.node = this.node;
        this.generators.updateRegions(this.speech || this.node, this.region, this.brailleRegion);
        this.magnifyRegion.Update(this.current);
    }
    Attach() {
        if (this.attached)
            return;
        super.Attach();
        this.node.setAttribute('tabindex', '0');
        this.attached = true;
    }
    Detach() {
        var _a;
        super.RemoveEvents();
        this.node.removeAttribute('role');
        this.node.removeAttribute('aria-roledescription');
        this.node.removeAttribute('aria-label');
        (_a = this.img) === null || _a === void 0 ? void 0 : _a.remove();
        if (this.active) {
            this.node.setAttribute('tabindex', '0');
        }
        this.attached = false;
    }
    NoMove() {
        honk();
    }
    AddEvents() {
        if (!this.eventsAttached) {
            super.AddEvents();
            this.eventsAttached = true;
        }
    }
    actionable(node) {
        const parent = node === null || node === void 0 ? void 0 : node.parentNode;
        return parent && this.highlighter.isMactionNode(parent) ? parent : null;
    }
    triggerLinkKeyboard(event) {
        if (!this.current) {
            if (event.target instanceof HTMLAnchorElement) {
                event.target.dispatchEvent(new MouseEvent('click'));
                return true;
            }
            return false;
        }
        return this.triggerLink(this.current);
    }
    triggerLink(node) {
        var _a;
        const focus = (_a = node === null || node === void 0 ? void 0 : node.getAttribute('data-semantic-postfix')) === null || _a === void 0 ? void 0 : _a.match(/(^| )link($| )/);
        if (focus) {
            while (node && node !== this.node) {
                if (node instanceof HTMLAnchorElement) {
                    node.dispatchEvent(new MouseEvent('click'));
                    setTimeout(() => this.FocusOut(null), 50);
                    return true;
                }
                node = node.parentNode;
            }
        }
        return false;
    }
    triggerLinkMouse() {
        let node = this.refocus;
        while (node && node !== this.node) {
            if (this.triggerLink(node)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    semanticFocus() {
        const focus = [];
        let name = 'data-semantic-id';
        let node = this.current || this.refocus || this.node;
        const action = this.actionable(node);
        if (action) {
            name = action.hasAttribute('data-maction-id') ? 'data-maction-id' : 'id';
            node = action;
            focus.push(nav);
        }
        const attr = node.getAttribute(name);
        if (attr) {
            focus.unshift(`[${name}="${attr}"]`);
        }
        return focus.join(' ');
    }
}
SpeechExplorer.keyMap = new Map([
    ['Tab', [() => true]],
    ['Escape', [(explorer) => explorer.escapeKey()]],
    ['Enter', [(explorer, event) => explorer.enterKey(event)]],
    ['Home', [(explorer) => explorer.homeKey()]],
    [
        'ArrowDown',
        [(explorer, event) => explorer.moveDown(event.shiftKey), true],
    ],
    ['ArrowUp', [(explorer, event) => explorer.moveUp(event.shiftKey), true]],
    [
        'ArrowLeft',
        [(explorer, event) => explorer.moveLeft(event.shiftKey), true],
    ],
    [
        'ArrowRight',
        [(explorer, event) => explorer.moveRight(event.shiftKey), true],
    ],
    [' ', [(explorer) => explorer.spaceKey()]],
    ['h', [(explorer) => explorer.hKey()]],
    ['>', [(explorer) => explorer.nextRules(), false]],
    ['<', [(explorer) => explorer.nextStyle(), false]],
    ['x', [(explorer) => explorer.summary(), false]],
    ['z', [(explorer) => explorer.details(), false]],
    ['d', [(explorer) => explorer.depth(), false]],
    ['v', [(explorer) => explorer.addMark(), false]],
    ['p', [(explorer) => explorer.prevMark(), false]],
    ['u', [(explorer) => explorer.clearMarks(), false]],
    ['s', [(explorer) => explorer.autoVoice(), false]],
    ...[...'0123456789'].map((n) => [
        n,
        [(explorer) => explorer.numberKey(parseInt(n)), false],
    ]),
]);
//# sourceMappingURL=KeyExplorer.js.map
;// ./mjs/a11y/explorer/MouseExplorer.js



class AbstractMouseExplorer extends AbstractExplorer {
    constructor() {
        super(...arguments);
        this.events = super.Events().concat([
            ['mouseover', this.MouseOver.bind(this)],
            ['mouseout', this.MouseOut.bind(this)],
        ]);
    }
    MouseOver(_event) {
        this.Start();
    }
    MouseOut(_event) {
        this.Stop();
    }
}
class Hoverer extends AbstractMouseExplorer {
    constructor(document, pool, region, node, nodeQuery, nodeAccess) {
        super(document, pool, region, node);
        this.document = document;
        this.pool = pool;
        this.region = region;
        this.node = node;
        this.nodeQuery = nodeQuery;
        this.nodeAccess = nodeAccess;
    }
    MouseOut(event) {
        this.highlighter.unhighlight();
        this.region.Hide();
        super.MouseOut(event);
    }
    MouseOver(event) {
        super.MouseOver(event);
        const target = event.target;
        const [node, kind] = this.getNode(target);
        if (!node) {
            return;
        }
        this.highlighter.unhighlight();
        this.highlighter.highlight([node]);
        this.region.Update(kind);
        this.region.Show(node, this.highlighter);
    }
    getNode(node) {
        const original = node;
        while (node && node !== this.node) {
            if (this.nodeQuery(node)) {
                return [node, this.nodeAccess(node)];
            }
            node = node.parentNode;
        }
        node = original;
        while (node) {
            if (this.nodeQuery(node)) {
                return [node, this.nodeAccess(node)];
            }
            const child = node.childNodes[0];
            node =
                child && child.tagName === 'defs'
                    ? node.childNodes[1]
                    : child;
        }
        return [null, null];
    }
}
class ValueHoverer extends Hoverer {
}
class ContentHoverer extends Hoverer {
}
class FlameHoverer extends Hoverer {
    constructor(document, pool, _ignore, node) {
        super(document, pool, new DummyRegion(document), node, (x) => this.highlighter.isMactionNode(x), () => { });
        this.document = document;
        this.pool = pool;
        this.node = node;
    }
}
//# sourceMappingURL=MouseExplorer.js.map
;// ./mjs/a11y/explorer/TreeExplorer.js

class AbstractTreeExplorer extends AbstractExplorer {
    constructor(document, pool, region, node, mml) {
        super(document, pool, null, node);
        this.document = document;
        this.pool = pool;
        this.region = region;
        this.node = node;
        this.mml = mml;
        this.stoppable = false;
    }
    Attach() {
        super.Attach();
        this.Start();
    }
    Detach() {
        this.Stop();
        super.Detach();
    }
}
class FlameColorer extends AbstractTreeExplorer {
    Start() {
        if (this.active)
            return;
        this.active = true;
        this.highlighter.highlightAll(this.node);
    }
    Stop() {
        if (this.active) {
            this.highlighter.unhighlightAll();
        }
        this.active = false;
    }
}
class TreeColorer extends AbstractTreeExplorer {
    constructor() {
        super(...arguments);
        this.contrast = new ContrastPicker();
        this.leaves = [];
        this.modality = 'data-semantic-foreground';
    }
    Start() {
        if (this.active)
            return;
        this.active = true;
        if (!this.node.hasAttribute('hasforegroundcolor')) {
            this.colorLeaves();
            this.node.setAttribute('hasforegroundcolor', 'true');
        }
        this.leaves.forEach((leaf) => this.colorize(leaf));
    }
    Stop() {
        if (this.active) {
            this.leaves.forEach((leaf) => this.uncolorize(leaf));
        }
        this.active = false;
    }
    colorLeaves() {
        this.leaves = Array.from(this.node.querySelectorAll('[data-semantic-id]:not([data-semantic-children])'));
        for (const leaf of this.leaves) {
            leaf.setAttribute(this.modality, this.contrast.generate());
            this.contrast.increment();
        }
    }
    colorize(node) {
        if (node.hasAttribute(this.modality)) {
            node.setAttribute(this.modality + '-old', node.style.color);
            node.style.color = node.getAttribute(this.modality);
        }
    }
    uncolorize(node) {
        const fore = this.modality + '-old';
        if (node.hasAttribute(fore)) {
            node.style.color = node.getAttribute(fore);
        }
    }
}
class ContrastPicker {
    constructor() {
        this.hue = 10;
        this.sat = 100;
        this.light = 50;
        this.incr = 53;
    }
    generate() {
        return ContrastPicker.hsl2rgb(this.hue, this.sat, this.light);
    }
    increment() {
        this.hue = (this.hue + this.incr) % 360;
    }
    static hsl2rgb(h, s, l) {
        s = s > 1 ? s / 100 : s;
        l = l > 1 ? l / 100 : l;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = l - c / 2;
        let r = 0, g = 0, b = 0;
        if (0 <= h && h < 60) {
            [r, g, b] = [c, x, 0];
        }
        else if (60 <= h && h < 120) {
            [r, g, b] = [x, c, 0];
        }
        else if (120 <= h && h < 180) {
            [r, g, b] = [0, c, x];
        }
        else if (180 <= h && h < 240) {
            [r, g, b] = [0, x, c];
        }
        else if (240 <= h && h < 300) {
            [r, g, b] = [x, 0, c];
        }
        else if (300 <= h && h < 360) {
            [r, g, b] = [c, 0, x];
        }
        return `rgb(${(r + m) * 255}, ${(g + m) * 255}, ${(b + m) * 255})`;
    }
}
//# sourceMappingURL=TreeExplorer.js.map
;// ./mjs/a11y/explorer/ExplorerPool.js





class RegionPool {
    constructor(document) {
        this.document = document;
        this.speechRegion = new SpeechRegion(this.document);
        this.brailleRegion = new LiveRegion(this.document);
        this.magnifier = new HoverRegion(this.document);
        this.tooltip1 = new ToolTip(this.document);
        this.tooltip2 = new ToolTip(this.document);
        this.tooltip3 = new ToolTip(this.document);
    }
}
const allExplorers = {
    speech: (doc, pool, node, ...rest) => {
        const explorer = SpeechExplorer.create(doc, pool, doc.explorerRegions.speechRegion, node, doc.explorerRegions.brailleRegion, doc.explorerRegions.magnifier, rest[0], rest[1]);
        explorer.sound = true;
        return explorer;
    },
    mouseMagnifier: (doc, pool, node, ..._rest) => ContentHoverer.create(doc, pool, doc.explorerRegions.magnifier, node, (x) => x.hasAttribute('data-semantic-type'), (x) => x),
    hover: (doc, pool, node, ..._rest) => FlameHoverer.create(doc, pool, null, node),
    infoType: (doc, pool, node, ..._rest) => ValueHoverer.create(doc, pool, doc.explorerRegions.tooltip1, node, (x) => x.hasAttribute('data-semantic-type'), (x) => x.getAttribute('data-semantic-type')),
    infoRole: (doc, pool, node, ..._rest) => ValueHoverer.create(doc, pool, doc.explorerRegions.tooltip2, node, (x) => x.hasAttribute('data-semantic-role'), (x) => x.getAttribute('data-semantic-role')),
    infoPrefix: (doc, pool, node, ..._rest) => ValueHoverer.create(doc, pool, doc.explorerRegions.tooltip3, node, (x) => { var _a; return (_a = x.hasAttribute) === null || _a === void 0 ? void 0 : _a.call(x, 'data-semantic-prefix-none'); }, (x) => { var _a; return (_a = x.getAttribute) === null || _a === void 0 ? void 0 : _a.call(x, 'data-semantic-prefix-none'); }),
    flame: (doc, pool, node, ..._rest) => FlameColorer.create(doc, pool, null, node),
    treeColoring: (doc, pool, node, ...rest) => TreeColorer.create(doc, pool, null, node, ...rest),
};
class ExplorerPool {
    constructor() {
        this.explorers = {};
        this.attached = [];
        this._restart = [];
        this.speechExplorerKeys = ['speech', 'braille', 'keyMagnifier'];
    }
    get highlighter() {
        if (this._renderer !== this.document.outputJax.name) {
            this._renderer = this.document.outputJax.name;
            this.setPrimaryHighlighter();
            return this._highlighter;
        }
        const [foreground, background] = this.colorOptions();
        this._highlighter.setColor(background, foreground);
        return this._highlighter;
    }
    init(document, node, mml, item) {
        this.document = document;
        this.mml = mml;
        this.node = node;
        this.setPrimaryHighlighter();
        for (const key of Object.keys(allExplorers)) {
            this.explorers[key] = allExplorers[key](this.document, this, this.node, this.mml, item);
        }
        this.setSecondaryHighlighter();
        this.attach();
    }
    attach() {
        this.attached = [];
        const keyExplorers = [];
        const a11y = this.document.options.a11y;
        for (const [key, explorer] of Object.entries(this.explorers)) {
            if (explorer instanceof SpeechExplorer) {
                explorer.stoppable = false;
                keyExplorers.unshift(explorer);
                if (this.speechExplorerKeys.some((exKey) => this.document.options.a11y[exKey])) {
                    explorer.Attach();
                    this.attached.push(key);
                }
                else {
                    explorer.Detach();
                }
                continue;
            }
            if (a11y[key] ||
                (key === 'speech' && (a11y.braille || a11y.keyMagnifier))) {
                explorer.Attach();
                this.attached.push(key);
            }
            else {
                explorer.Detach();
            }
        }
        for (const explorer of keyExplorers) {
            if (explorer.attached) {
                explorer.stoppable = true;
                break;
            }
        }
    }
    reattach() {
        for (const key of this.attached) {
            const explorer = this.explorers[key];
            if (explorer.active) {
                this._restart.push(key);
                explorer.Stop();
            }
        }
    }
    restart() {
        this._restart.forEach((x) => {
            this.explorers[x].Start();
        });
        this._restart = [];
    }
    setPrimaryHighlighter() {
        const [foreground, background] = this.colorOptions();
        this._highlighter = getHighlighter(background, foreground, this.document.outputJax.name);
    }
    setSecondaryHighlighter() {
        this.secondaryHighlighter = getHighlighter({ color: 'red' }, { color: 'black' }, this.document.outputJax.name);
        this.speech.region.highlighter =
            this.secondaryHighlighter;
    }
    highlight(nodes) {
        this.highlighter.highlight(nodes);
    }
    unhighlight() {
        this.secondaryHighlighter.unhighlight();
        this.highlighter.unhighlight();
    }
    get speech() {
        return this.explorers['speech'];
    }
    colorOptions() {
        const opts = this.document.options.a11y;
        const foreground = {
            color: opts.foregroundColor.toLowerCase(),
            alpha: opts.foregroundOpacity / 100,
        };
        const background = {
            color: opts.backgroundColor.toLowerCase(),
            alpha: opts.backgroundOpacity / 100,
        };
        return [foreground, background];
    }
}
//# sourceMappingURL=ExplorerPool.js.map
;// ./mjs/a11y/explorer.js








const isUnix = context.os === 'Unix';
newState('EXPLORER', STATE.INSERTED + 30);
function ExplorerMathItemMixin(BaseMathItem, toMathML) {
    var _a;
    return _a = class BaseClass extends BaseMathItem {
            constructor() {
                super(...arguments);
                this.refocus = null;
            }
            get ariaRole() {
                return this.constructor.ariaRole;
            }
            get roleDescription() {
                const CLASS = this.constructor;
                return CLASS.roleDescription === 'none'
                    ? CLASS.none
                    : CLASS.roleDescription;
            }
            get none() {
                return this.constructor.none;
            }
            attachSpeech(document) {
                var _b, _c;
                super.attachSpeech(document);
                (_c = (_b = this.outputData.speechPromise) === null || _b === void 0 ? void 0 : _b.then(() => this.explorers.speech.attachSpeech())) === null || _c === void 0 ? void 0 : _c.then(() => {
                    var _b;
                    if ((_b = this.explorers) === null || _b === void 0 ? void 0 : _b.speech) {
                        this.explorers.speech.restarted = this.refocus;
                    }
                    this.refocus = null;
                    if (this.explorers) {
                        this.explorers.restart();
                    }
                });
            }
            detachSpeech(document) {
                super.detachSpeech(document);
                this.explorers.speech.detachSpeech();
            }
            explorable(document, force = false) {
                if (this.state() >= STATE.EXPLORER)
                    return;
                if (!this.isEscaped && (document.options.enableExplorer || force)) {
                    const node = this.typesetRoot;
                    const mml = toMathML(this.root);
                    if (!this.explorers) {
                        this.explorers = new ExplorerPool();
                    }
                    this.explorers.init(document, node, mml, this);
                }
                this.state(STATE.EXPLORER);
            }
            state(state = null, restore = false) {
                if (state < STATE.EXPLORER && this.explorers) {
                    for (const explorer of Object.values(this.explorers.explorers)) {
                        if (explorer.active) {
                            explorer.Stop();
                        }
                    }
                }
                return super.state(state, restore);
            }
            rerender(document, start = STATE.RERENDER) {
                const focus = this.setTemporaryFocus(document);
                super.rerender(document, start);
                this.clearTemporaryFocus(focus);
            }
            setTemporaryFocus(document) {
                var _b;
                let focus = null;
                if (this.explorers) {
                    const speech = this.explorers.speech;
                    focus = (speech === null || speech === void 0 ? void 0 : speech.attached) ? document.tmpFocus : null;
                    if (focus) {
                        this.refocus = (_b = speech.semanticFocus()) !== null && _b !== void 0 ? _b : null;
                        const adaptor = document.adaptor;
                        adaptor.append(adaptor.body(), focus);
                    }
                    this.explorers.reattach();
                    focus === null || focus === void 0 ? void 0 : focus.focus();
                }
                return focus;
            }
            clearTemporaryFocus(focus) {
                var _b;
                if (focus) {
                    const promise = (_b = this.outputData.speechPromise) !== null && _b !== void 0 ? _b : Promise.resolve();
                    promise.then(() => setTimeout(() => focus.remove(), 100));
                }
            }
        },
        _a.ariaRole = isUnix ? 'tree' : 'application',
        _a.roleDescription = 'math',
        _a.none = '\u0091',
        _a;
}
function ExplorerMathDocumentMixin(BaseDocument) {
    var _a;
    return _a = class BaseClass extends BaseDocument {
            constructor(...args) {
                super(...args);
                this.explorerRegions = null;
                this.activeItem = null;
                const ProcessBits = this.constructor.ProcessBits;
                if (!ProcessBits.has('explorer')) {
                    ProcessBits.allocate('explorer');
                }
                const visitor = new SerializedMmlVisitor(this.mmlFactory);
                const toMathML = (node) => visitor.visitTree(node);
                const options = this.options;
                if (!options.a11y.speechRules) {
                    options.a11y.speechRules = `${options.sre.domain}-${options.sre.style}`;
                }
                const mathItem = (options.MathItem = ExplorerMathItemMixin(options.MathItem, toMathML));
                mathItem.roleDescription = options.roleDescription;
                this.explorerRegions = new RegionPool(this);
                if ('addStyles' in this) {
                    this.addStyles(this.constructor.speechStyles);
                }
                const adaptor = this.adaptor;
                const SVGNS = 'http://www.w3.org/2000/svg';
                this.infoIcon = adaptor.node('mjx-help', {}, [
                    adaptor.node('svg', { viewBox: '0 0 18 18', xmlns: SVGNS, 'aria-hidden': 'true' }, [
                        adaptor.node('circle', { stroke: 'none' }, [], SVGNS),
                        adaptor.node('circle', {}, [], SVGNS),
                        adaptor.node('line', { x1: 9, y1: 9, x2: 9, y2: 13 }, [], SVGNS),
                        adaptor.node('line', { x1: 9, y1: 5.5, x2: 9, y2: 5.5 }, [], SVGNS),
                    ], SVGNS),
                ]);
                this.tmpFocus = this.adaptor.node('mjx-focus', {
                    tabIndex: 0,
                    style: {
                        outline: 'none',
                        display: 'block',
                        position: 'absolute',
                        top: 0,
                        left: '-10px',
                        width: '1px',
                        height: '1px',
                        overflow: 'hidden',
                    },
                    role: mathItem.ariaRole,
                    'aria-label': mathItem.none,
                    'aria-roledescription': mathItem.none,
                });
            }
            explorable() {
                if (!this.processed.isSet('explorer')) {
                    if (this.options.enableExplorer) {
                        for (const math of this.math) {
                            math.explorable(this);
                        }
                    }
                    this.processed.set('explorer');
                }
                return this;
            }
            rerender(start) {
                const active = this.activeItem;
                const focus = active === null || active === void 0 ? void 0 : active.setTemporaryFocus(this);
                super.rerender(start);
                active === null || active === void 0 ? void 0 : active.clearTemporaryFocus(focus);
                return this;
            }
            state(state, restore = false) {
                super.state(state, restore);
                if (state < STATE.EXPLORER) {
                    this.processed.clear('explorer');
                }
                return this;
            }
        },
        _a.OPTIONS = Object.assign(Object.assign({}, BaseDocument.OPTIONS), { enableExplorer: hasWindow, renderActions: expandable(Object.assign(Object.assign({}, BaseDocument.OPTIONS.renderActions), { explorable: [STATE.EXPLORER] })), sre: expandable(Object.assign(Object.assign({}, BaseDocument.OPTIONS.sre), { speech: 'none' })), a11y: Object.assign(Object.assign({}, BaseDocument.OPTIONS.a11y), { align: 'top', backgroundColor: 'Blue', backgroundOpacity: 20, flame: false, foregroundColor: 'Black', foregroundOpacity: 100, highlight: 'None', hover: false, infoPrefix: false, infoRole: false, infoType: false, keyMagnifier: false, magnification: 'None', magnify: '400%', mouseMagnifier: false, subtitles: false, treeColoring: false, viewBraille: false, voicing: false, help: true, roleDescription: 'math', tabSelects: 'all' }) }),
        _a.speechStyles = {
            'mjx-container[has-speech="true"]': {
                position: 'relative',
                cursor: 'default',
            },
            'mjx-speech': {
                position: 'absolute',
                'z-index': -1,
                left: 0,
                top: 0,
                bottom: 0,
                right: 0,
            },
            'mjx-speech:focus': {
                outline: 'none',
            },
            'mjx-container .mjx-selected': {
                outline: '2px solid black',
            },
            'mjx-container > mjx-help': {
                display: 'none',
                position: 'absolute',
                top: '-.33em',
                right: '-.5em',
                width: '.6em',
                height: '.6em',
                cursor: 'pointer',
            },
            'mjx-container[display="true"] > mjx-help': {
                right: 0,
            },
            'mjx-help > svg': {
                stroke: 'black',
                width: '100%',
                height: '100%',
            },
            'mjx-help > svg > circle': {
                'stroke-width': '1.5px',
                cx: '9px',
                cy: '9px',
                r: '9px',
                fill: 'white',
            },
            'mjx-help > svg > circle:nth-child(2)': {
                fill: 'rgba(0, 0, 255, 0.2)',
                r: '7px',
            },
            'mjx-help > svg > line': {
                'stroke-width': '2.5px',
                'stroke-linecap': 'round',
            },
            'mjx-help:hover > svg > circle:nth-child(2)': {
                fill: 'white',
            },
            'mjx-container.mjx-explorer-active > mjx-help': {
                display: 'inline-flex',
                'align-items': 'center',
            },
            'mjx-help-sizer': {
                position: 'fixed',
                width: '40%',
                'max-width': '30em',
                top: '3em',
                left: '50%',
            },
            'mjx-help-dialog': {
                position: 'absolute',
                width: '200%',
                left: '-100%',
                border: '3px outset',
                'border-radius': '15px',
                color: 'black',
                'background-color': '#DDDDDD',
                'z-index': '301',
                'text-align': 'right',
                'font-style': 'normal',
                'text-indent': 0,
                'text-transform': 'none',
                'line-height': 'normal',
                'letter-spacing': 'normal',
                'word-spacing': 'normal',
                'word-wrap': 'normal',
                float: 'none',
                'box-shadow': '0px 10px 20px #808080',
                outline: 'none',
            },
            'mjx-help-dialog > h1': {
                'font-size': '24px',
                'text-align': 'center',
                margin: '.5em 0',
            },
            'mjx-help-dialog > div': {
                margin: '0 1em',
                padding: '3px',
                overflow: 'auto',
                height: '20em',
                border: '2px inset black',
                'background-color': 'white',
                'text-align': 'left',
            },
            'mjx-help-dialog > input': {
                margin: '.5em 2em',
            },
            'mjx-help-dialog kbd': {
                display: 'inline-block',
                padding: '3px 5px',
                'font-size': '11px',
                'line-height': '10px',
                color: '#444d56',
                'vertical-align': 'middle',
                'background-color': '#fafbfc',
                border: 'solid 1.5px #c6cbd1',
                'border-bottom-color': '#959da5',
                'border-radius': '3px',
                'box-shadow': 'inset -.5px -1px 0 #959da5',
            },
            'mjx-help-dialog ul': {
                'list-style-type': 'none',
            },
            'mjx-help-dialog li': {
                'margin-bottom': '.5em',
            },
            'mjx-help-background': {
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
            },
        },
        _a;
}
function ExplorerHandler(handler, MmlJax = null) {
    if (!handler.documentClass.prototype.attachSpeech) {
        handler = SpeechHandler(handler, MmlJax);
    }
    handler.documentClass = ExplorerMathDocumentMixin(handler.documentClass);
    return handler;
}
function setA11yOptions(document, options) {
    var _a;
    const sreOptions = engineSetup();
    for (const key in options) {
        if (document.options.a11y[key] !== undefined) {
            setA11yOption(document, key, options[key]);
        }
        else if (sreOptions[key] !== undefined) {
            document.options.sre[key] = options[key];
        }
    }
    if (options.roleDescription) {
        document.options.MathItem.roleDescription = options.roleDescription;
    }
    for (const item of document.math) {
        (_a = item === null || item === void 0 ? void 0 : item.explorers) === null || _a === void 0 ? void 0 : _a.attach();
    }
}
function setA11yOption(document, option, value) {
    switch (option) {
        case 'speechRules': {
            const [domain, style] = value.split('-');
            document.options.sre.domain = domain;
            document.options.sre.style = style;
            break;
        }
        case 'magnification':
            switch (value) {
                case 'None':
                    document.options.a11y.magnification = value;
                    document.options.a11y.keyMagnifier = false;
                    document.options.a11y.mouseMagnifier = false;
                    break;
                case 'Keyboard':
                    document.options.a11y.magnification = value;
                    document.options.a11y.keyMagnifier = true;
                    document.options.a11y.mouseMagnifier = false;
                    break;
                case 'Mouse':
                    document.options.a11y.magnification = value;
                    document.options.a11y.keyMagnifier = false;
                    document.options.a11y.mouseMagnifier = true;
                    break;
            }
            break;
        case 'highlight':
            switch (value) {
                case 'None':
                    document.options.a11y.highlight = value;
                    document.options.a11y.hover = false;
                    document.options.a11y.flame = false;
                    break;
                case 'Hover':
                    document.options.a11y.highlight = value;
                    document.options.a11y.hover = true;
                    document.options.a11y.flame = false;
                    break;
                case 'Flame':
                    document.options.a11y.highlight = value;
                    document.options.a11y.hover = false;
                    document.options.a11y.flame = true;
                    break;
            }
            break;
        case 'locale':
            document.options.sre.locale = value;
            break;
        default:
            document.options.a11y[option] = value;
    }
}
//# sourceMappingURL=explorer.js.map
;// ./components/mjs/a11y/explorer/lib/explorer.js












if (MathJax.loader) {
  MathJax.loader.checkVersion('a11y/explorer', VERSION, 'a11y');
}

combineWithMathJax({_: {
  a11y: {
    explorer_ts: explorer_namespaceObject,
    explorer: {
      Explorer: Explorer_namespaceObject,
      ExplorerPool: ExplorerPool_namespaceObject,
      Highlighter: Highlighter_namespaceObject,
      KeyExplorer: KeyExplorer_namespaceObject,
      MouseExplorer: MouseExplorer_namespaceObject,
      Region: Region_namespaceObject,
      TreeExplorer: TreeExplorer_namespaceObject
    }
  }
}});

;// ./components/mjs/a11y/explorer/explorer.js





if (MathJax.startup && hasWindow) {
  MathJax.startup.extendHandler(handler => ExplorerHandler(handler));
}

;// ./components/mjs/a11y/util.js







Loader.preLoaded(
  'a11y/sre',
  'a11y/semantic-enrich',
  'a11y/speech',
  'a11y/explorer'
);

;// ./components/mjs/tex-chtml/tex-chtml.js








Loader.preLoaded(
  'loader', 'startup',
  'core',
  'input/tex',
  'output/chtml',
  'ui/menu'
);
Loader.saveVersion('tex-chtml');

loadFont(startup, true);

})();

/******/ })()
;