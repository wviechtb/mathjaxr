/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/

// UNUSED EXPORTS: loadFont

// NAMESPACE OBJECT: ./mjs/output/common/Direction.js
var Direction_namespaceObject = {};
__webpack_require__.r(Direction_namespaceObject);
__webpack_require__.d(Direction_namespaceObject, {
  DIRECTION: () => (DIRECTION),
  H: () => (H),
  V: () => (V)
});

// NAMESPACE OBJECT: ./mjs/output/common/FontData.js
var FontData_namespaceObject = {};
__webpack_require__.r(FontData_namespaceObject);
__webpack_require__.d(FontData_namespaceObject, {
  DIRECTION: () => (DIRECTION),
  FontData: () => (FontData),
  NOSTRETCH: () => (NOSTRETCH),
  mergeOptions: () => (mergeOptions)
});

// NAMESPACE OBJECT: ./mjs/output/common/LineBBox.js
var LineBBox_namespaceObject = {};
__webpack_require__.r(LineBBox_namespaceObject);
__webpack_require__.d(LineBBox_namespaceObject, {
  LineBBox: () => (LineBBox)
});

// NAMESPACE OBJECT: ./mjs/output/common/LinebreakVisitor.js
var LinebreakVisitor_namespaceObject = {};
__webpack_require__.r(LinebreakVisitor_namespaceObject);
__webpack_require__.d(LinebreakVisitor_namespaceObject, {
  LinebreakVisitor: () => (LinebreakVisitor),
  Linebreaks: () => (Linebreaks),
  NOBREAK: () => (NOBREAK)
});

// NAMESPACE OBJECT: ./mjs/output/common.js
var common_namespaceObject = {};
__webpack_require__.r(common_namespaceObject);
__webpack_require__.d(common_namespaceObject, {
  CommonOutputJax: () => (CommonOutputJax),
  FONTPATH: () => (FONTPATH)
});

// NAMESPACE OBJECT: ./mjs/output/common/WrapperFactory.js
var common_WrapperFactory_namespaceObject = {};
__webpack_require__.r(common_WrapperFactory_namespaceObject);
__webpack_require__.d(common_WrapperFactory_namespaceObject, {
  CommonWrapperFactory: () => (CommonWrapperFactory)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrapper.js
var common_Wrapper_namespaceObject = {};
__webpack_require__.r(common_Wrapper_namespaceObject);
__webpack_require__.d(common_Wrapper_namespaceObject, {
  CommonWrapper: () => (CommonWrapper),
  SPACE: () => (SPACE)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrapper.js
var chtml_Wrapper_namespaceObject = {};
__webpack_require__.r(chtml_Wrapper_namespaceObject);
__webpack_require__.d(chtml_Wrapper_namespaceObject, {
  ChtmlWrapper: () => (ChtmlWrapper),
  FONTSIZE: () => (FONTSIZE)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/math.js
var math_namespaceObject = {};
__webpack_require__.r(math_namespaceObject);
__webpack_require__.d(math_namespaceObject, {
  CommonMathMixin: () => (CommonMathMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/math.js
var Wrappers_math_namespaceObject = {};
__webpack_require__.r(Wrappers_math_namespaceObject);
__webpack_require__.d(Wrappers_math_namespaceObject, {
  ChtmlMath: () => (ChtmlMath)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mi.js
var mi_namespaceObject = {};
__webpack_require__.r(mi_namespaceObject);
__webpack_require__.d(mi_namespaceObject, {
  CommonMiMixin: () => (CommonMiMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mi.js
var Wrappers_mi_namespaceObject = {};
__webpack_require__.r(Wrappers_mi_namespaceObject);
__webpack_require__.d(Wrappers_mi_namespaceObject, {
  ChtmlMi: () => (ChtmlMi)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mo.js
var mo_namespaceObject = {};
__webpack_require__.r(mo_namespaceObject);
__webpack_require__.d(mo_namespaceObject, {
  CommonMoMixin: () => (CommonMoMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Usage.js
var Usage_namespaceObject = {};
__webpack_require__.r(Usage_namespaceObject);
__webpack_require__.d(Usage_namespaceObject, {
  Usage: () => (Usage)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/FontData.js
var chtml_FontData_namespaceObject = {};
__webpack_require__.r(chtml_FontData_namespaceObject);
__webpack_require__.d(chtml_FontData_namespaceObject, {
  AddCSS: () => (AddCSS),
  ChtmlFontData: () => (ChtmlFontData),
  DIRECTION: () => (DIRECTION),
  FontData: () => (FontData),
  NOSTRETCH: () => (NOSTRETCH),
  mergeOptions: () => (mergeOptions)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mo.js
var Wrappers_mo_namespaceObject = {};
__webpack_require__.r(Wrappers_mo_namespaceObject);
__webpack_require__.d(Wrappers_mo_namespaceObject, {
  ChtmlMo: () => (ChtmlMo)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mn.js
var mn_namespaceObject = {};
__webpack_require__.r(mn_namespaceObject);
__webpack_require__.d(mn_namespaceObject, {
  CommonMnMixin: () => (CommonMnMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mn.js
var Wrappers_mn_namespaceObject = {};
__webpack_require__.r(Wrappers_mn_namespaceObject);
__webpack_require__.d(Wrappers_mn_namespaceObject, {
  ChtmlMn: () => (ChtmlMn)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/ms.js
var ms_namespaceObject = {};
__webpack_require__.r(ms_namespaceObject);
__webpack_require__.d(ms_namespaceObject, {
  CommonMsMixin: () => (CommonMsMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/ms.js
var Wrappers_ms_namespaceObject = {};
__webpack_require__.r(Wrappers_ms_namespaceObject);
__webpack_require__.d(Wrappers_ms_namespaceObject, {
  ChtmlMs: () => (ChtmlMs)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtext.js
var mtext_namespaceObject = {};
__webpack_require__.r(mtext_namespaceObject);
__webpack_require__.d(mtext_namespaceObject, {
  CommonMtextMixin: () => (CommonMtextMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtext.js
var Wrappers_mtext_namespaceObject = {};
__webpack_require__.r(Wrappers_mtext_namespaceObject);
__webpack_require__.d(Wrappers_mtext_namespaceObject, {
  ChtmlMtext: () => (ChtmlMtext)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mspace.js
var mspace_namespaceObject = {};
__webpack_require__.r(mspace_namespaceObject);
__webpack_require__.d(mspace_namespaceObject, {
  CommonMspaceMixin: () => (CommonMspaceMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mspace.js
var Wrappers_mspace_namespaceObject = {};
__webpack_require__.r(Wrappers_mspace_namespaceObject);
__webpack_require__.d(Wrappers_mspace_namespaceObject, {
  ChtmlMspace: () => (ChtmlMspace)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mpadded.js
var mpadded_namespaceObject = {};
__webpack_require__.r(mpadded_namespaceObject);
__webpack_require__.d(mpadded_namespaceObject, {
  CommonMpaddedMixin: () => (CommonMpaddedMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mpadded.js
var Wrappers_mpadded_namespaceObject = {};
__webpack_require__.r(Wrappers_mpadded_namespaceObject);
__webpack_require__.d(Wrappers_mpadded_namespaceObject, {
  ChtmlMpadded: () => (ChtmlMpadded)
});

// NAMESPACE OBJECT: ./mjs/output/common/Notation.js
var Notation_namespaceObject = {};
__webpack_require__.r(Notation_namespaceObject);
__webpack_require__.d(Notation_namespaceObject, {
  ARROWDX: () => (ARROWDX),
  ARROWX: () => (ARROWX),
  ARROWY: () => (ARROWY),
  CommonArrow: () => (CommonArrow),
  CommonBorder: () => (CommonBorder),
  CommonBorder2: () => (CommonBorder2),
  CommonDiagonalArrow: () => (CommonDiagonalArrow),
  CommonDiagonalStrike: () => (CommonDiagonalStrike),
  PADDING: () => (PADDING),
  SOLID: () => (SOLID),
  THICKNESS: () => (THICKNESS),
  arrowBBox: () => (arrowBBox),
  arrowBBoxHD: () => (arrowBBoxHD),
  arrowBBoxW: () => (arrowBBoxW),
  arrowDef: () => (arrowDef),
  arrowHead: () => (arrowHead),
  diagonalArrowDef: () => (diagonalArrowDef),
  fullBBox: () => (fullBBox),
  fullBorder: () => (fullBorder),
  fullPadding: () => (fullPadding),
  sideIndex: () => (sideIndex),
  sideNames: () => (sideNames)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/menclose.js
var menclose_namespaceObject = {};
__webpack_require__.r(menclose_namespaceObject);
__webpack_require__.d(menclose_namespaceObject, {
  CommonMencloseMixin: () => (CommonMencloseMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Notation.js
var chtml_Notation_namespaceObject = {};
__webpack_require__.r(chtml_Notation_namespaceObject);
__webpack_require__.d(chtml_Notation_namespaceObject, {
  ARROWDX: () => (ARROWDX),
  ARROWX: () => (ARROWX),
  ARROWY: () => (ARROWY),
  Arrow: () => (Arrow),
  Border: () => (Border),
  Border2: () => (Border2),
  CommonArrow: () => (CommonArrow),
  CommonBorder: () => (CommonBorder),
  CommonBorder2: () => (CommonBorder2),
  CommonDiagonalArrow: () => (CommonDiagonalArrow),
  CommonDiagonalStrike: () => (CommonDiagonalStrike),
  DiagonalArrow: () => (DiagonalArrow),
  DiagonalStrike: () => (DiagonalStrike),
  PADDING: () => (PADDING),
  RenderElement: () => (RenderElement),
  SOLID: () => (SOLID),
  THICKNESS: () => (THICKNESS),
  arrowBBox: () => (arrowBBox),
  arrowBBoxHD: () => (arrowBBoxHD),
  arrowBBoxW: () => (arrowBBoxW),
  arrowDef: () => (arrowDef),
  arrowHead: () => (arrowHead),
  diagonalArrowDef: () => (diagonalArrowDef),
  fullBBox: () => (fullBBox),
  fullBorder: () => (fullBorder),
  fullPadding: () => (fullPadding),
  sideIndex: () => (sideIndex),
  sideNames: () => (sideNames)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/menclose.js
var Wrappers_menclose_namespaceObject = {};
__webpack_require__.r(Wrappers_menclose_namespaceObject);
__webpack_require__.d(Wrappers_menclose_namespaceObject, {
  ChtmlMenclose: () => (ChtmlMenclose)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mrow.js
var mrow_namespaceObject = {};
__webpack_require__.r(mrow_namespaceObject);
__webpack_require__.d(mrow_namespaceObject, {
  CommonInferredMrowMixin: () => (CommonInferredMrowMixin),
  CommonMrowMixin: () => (CommonMrowMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mrow.js
var Wrappers_mrow_namespaceObject = {};
__webpack_require__.r(Wrappers_mrow_namespaceObject);
__webpack_require__.d(Wrappers_mrow_namespaceObject, {
  ChtmlInferredMrow: () => (ChtmlInferredMrow),
  ChtmlMrow: () => (ChtmlMrow)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mfenced.js
var mfenced_namespaceObject = {};
__webpack_require__.r(mfenced_namespaceObject);
__webpack_require__.d(mfenced_namespaceObject, {
  CommonMfencedMixin: () => (CommonMfencedMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mfenced.js
var Wrappers_mfenced_namespaceObject = {};
__webpack_require__.r(Wrappers_mfenced_namespaceObject);
__webpack_require__.d(Wrappers_mfenced_namespaceObject, {
  ChtmlMfenced: () => (ChtmlMfenced)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mfrac.js
var mfrac_namespaceObject = {};
__webpack_require__.r(mfrac_namespaceObject);
__webpack_require__.d(mfrac_namespaceObject, {
  CommonMfracMixin: () => (CommonMfracMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mfrac.js
var Wrappers_mfrac_namespaceObject = {};
__webpack_require__.r(Wrappers_mfrac_namespaceObject);
__webpack_require__.d(Wrappers_mfrac_namespaceObject, {
  ChtmlMfrac: () => (ChtmlMfrac)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/msqrt.js
var msqrt_namespaceObject = {};
__webpack_require__.r(msqrt_namespaceObject);
__webpack_require__.d(msqrt_namespaceObject, {
  CommonMsqrtMixin: () => (CommonMsqrtMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/msqrt.js
var Wrappers_msqrt_namespaceObject = {};
__webpack_require__.r(Wrappers_msqrt_namespaceObject);
__webpack_require__.d(Wrappers_msqrt_namespaceObject, {
  ChtmlMsqrt: () => (ChtmlMsqrt)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mroot.js
var mroot_namespaceObject = {};
__webpack_require__.r(mroot_namespaceObject);
__webpack_require__.d(mroot_namespaceObject, {
  CommonMrootMixin: () => (CommonMrootMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mroot.js
var Wrappers_mroot_namespaceObject = {};
__webpack_require__.r(Wrappers_mroot_namespaceObject);
__webpack_require__.d(Wrappers_mroot_namespaceObject, {
  ChtmlMroot: () => (ChtmlMroot)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/msubsup.js
var msubsup_namespaceObject = {};
__webpack_require__.r(msubsup_namespaceObject);
__webpack_require__.d(msubsup_namespaceObject, {
  CommonMsubMixin: () => (CommonMsubMixin),
  CommonMsubsupMixin: () => (CommonMsubsupMixin),
  CommonMsupMixin: () => (CommonMsupMixin)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/scriptbase.js
var scriptbase_namespaceObject = {};
__webpack_require__.r(scriptbase_namespaceObject);
__webpack_require__.d(scriptbase_namespaceObject, {
  CommonScriptbaseMixin: () => (CommonScriptbaseMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/scriptbase.js
var Wrappers_scriptbase_namespaceObject = {};
__webpack_require__.r(Wrappers_scriptbase_namespaceObject);
__webpack_require__.d(Wrappers_scriptbase_namespaceObject, {
  ChtmlScriptbase: () => (ChtmlScriptbase)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/msubsup.js
var Wrappers_msubsup_namespaceObject = {};
__webpack_require__.r(Wrappers_msubsup_namespaceObject);
__webpack_require__.d(Wrappers_msubsup_namespaceObject, {
  ChtmlMsub: () => (ChtmlMsub),
  ChtmlMsubsup: () => (ChtmlMsubsup),
  ChtmlMsup: () => (ChtmlMsup)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/munderover.js
var munderover_namespaceObject = {};
__webpack_require__.r(munderover_namespaceObject);
__webpack_require__.d(munderover_namespaceObject, {
  CommonMoverMixin: () => (CommonMoverMixin),
  CommonMunderMixin: () => (CommonMunderMixin),
  CommonMunderoverMixin: () => (CommonMunderoverMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/munderover.js
var Wrappers_munderover_namespaceObject = {};
__webpack_require__.r(Wrappers_munderover_namespaceObject);
__webpack_require__.d(Wrappers_munderover_namespaceObject, {
  ChtmlMover: () => (ChtmlMover),
  ChtmlMunder: () => (ChtmlMunder),
  ChtmlMunderover: () => (ChtmlMunderover)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mmultiscripts.js
var mmultiscripts_namespaceObject = {};
__webpack_require__.r(mmultiscripts_namespaceObject);
__webpack_require__.d(mmultiscripts_namespaceObject, {
  CommonMmultiscriptsMixin: () => (CommonMmultiscriptsMixin),
  NextScript: () => (NextScript),
  ScriptNames: () => (ScriptNames)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mmultiscripts.js
var Wrappers_mmultiscripts_namespaceObject = {};
__webpack_require__.r(Wrappers_mmultiscripts_namespaceObject);
__webpack_require__.d(Wrappers_mmultiscripts_namespaceObject, {
  ChtmlMmultiscripts: () => (ChtmlMmultiscripts)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtable.js
var mtable_namespaceObject = {};
__webpack_require__.r(mtable_namespaceObject);
__webpack_require__.d(mtable_namespaceObject, {
  BREAK_BELOW: () => (BREAK_BELOW),
  CommonMtableMixin: () => (CommonMtableMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtable.js
var Wrappers_mtable_namespaceObject = {};
__webpack_require__.r(Wrappers_mtable_namespaceObject);
__webpack_require__.d(Wrappers_mtable_namespaceObject, {
  ChtmlMtable: () => (ChtmlMtable)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtr.js
var mtr_namespaceObject = {};
__webpack_require__.r(mtr_namespaceObject);
__webpack_require__.d(mtr_namespaceObject, {
  CommonMlabeledtrMixin: () => (CommonMlabeledtrMixin),
  CommonMtrMixin: () => (CommonMtrMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtr.js
var Wrappers_mtr_namespaceObject = {};
__webpack_require__.r(Wrappers_mtr_namespaceObject);
__webpack_require__.d(Wrappers_mtr_namespaceObject, {
  ChtmlMlabeledtr: () => (ChtmlMlabeledtr),
  ChtmlMtr: () => (ChtmlMtr)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mtd.js
var mtd_namespaceObject = {};
__webpack_require__.r(mtd_namespaceObject);
__webpack_require__.d(mtd_namespaceObject, {
  CommonMtdMixin: () => (CommonMtdMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mtd.js
var Wrappers_mtd_namespaceObject = {};
__webpack_require__.r(Wrappers_mtd_namespaceObject);
__webpack_require__.d(Wrappers_mtd_namespaceObject, {
  ChtmlMtd: () => (ChtmlMtd)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/maction.js
var maction_namespaceObject = {};
__webpack_require__.r(maction_namespaceObject);
__webpack_require__.d(maction_namespaceObject, {
  CommonMactionMixin: () => (CommonMactionMixin),
  TooltipData: () => (TooltipData)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/maction.js
var Wrappers_maction_namespaceObject = {};
__webpack_require__.r(Wrappers_maction_namespaceObject);
__webpack_require__.d(Wrappers_maction_namespaceObject, {
  ChtmlMaction: () => (ChtmlMaction)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/mglyph.js
var mglyph_namespaceObject = {};
__webpack_require__.r(mglyph_namespaceObject);
__webpack_require__.d(mglyph_namespaceObject, {
  CommonMglyphMixin: () => (CommonMglyphMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/mglyph.js
var Wrappers_mglyph_namespaceObject = {};
__webpack_require__.r(Wrappers_mglyph_namespaceObject);
__webpack_require__.d(Wrappers_mglyph_namespaceObject, {
  ChtmlMglyph: () => (ChtmlMglyph)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/semantics.js
var semantics_namespaceObject = {};
__webpack_require__.r(semantics_namespaceObject);
__webpack_require__.d(semantics_namespaceObject, {
  CommonSemanticsMixin: () => (CommonSemanticsMixin)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/XmlNode.js
var XmlNode_namespaceObject = {};
__webpack_require__.r(XmlNode_namespaceObject);
__webpack_require__.d(XmlNode_namespaceObject, {
  CommonXmlNodeMixin: () => (CommonXmlNodeMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/semantics.js
var Wrappers_semantics_namespaceObject = {};
__webpack_require__.r(Wrappers_semantics_namespaceObject);
__webpack_require__.d(Wrappers_semantics_namespaceObject, {
  ChtmlAnnotation: () => (ChtmlAnnotation),
  ChtmlAnnotationXML: () => (ChtmlAnnotationXML),
  ChtmlSemantics: () => (ChtmlSemantics),
  ChtmlXmlNode: () => (ChtmlXmlNode)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/TeXAtom.js
var TeXAtom_namespaceObject = {};
__webpack_require__.r(TeXAtom_namespaceObject);
__webpack_require__.d(TeXAtom_namespaceObject, {
  CommonTeXAtomMixin: () => (CommonTeXAtomMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/TeXAtom.js
var Wrappers_TeXAtom_namespaceObject = {};
__webpack_require__.r(Wrappers_TeXAtom_namespaceObject);
__webpack_require__.d(Wrappers_TeXAtom_namespaceObject, {
  ChtmlTeXAtom: () => (ChtmlTeXAtom)
});

// NAMESPACE OBJECT: ./mjs/output/common/Wrappers/TextNode.js
var TextNode_namespaceObject = {};
__webpack_require__.r(TextNode_namespaceObject);
__webpack_require__.d(TextNode_namespaceObject, {
  CommonTextNodeMixin: () => (CommonTextNodeMixin)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/TextNode.js
var Wrappers_TextNode_namespaceObject = {};
__webpack_require__.r(Wrappers_TextNode_namespaceObject);
__webpack_require__.d(Wrappers_TextNode_namespaceObject, {
  ChtmlTextNode: () => (ChtmlTextNode)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers/HtmlNode.js
var Wrappers_HtmlNode_namespaceObject = {};
__webpack_require__.r(Wrappers_HtmlNode_namespaceObject);
__webpack_require__.d(Wrappers_HtmlNode_namespaceObject, {
  ChtmlHtmlNode: () => (ChtmlHtmlNode)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/Wrappers.js
var Wrappers_namespaceObject = {};
__webpack_require__.r(Wrappers_namespaceObject);
__webpack_require__.d(Wrappers_namespaceObject, {
  ChtmlWrappers: () => (ChtmlWrappers)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/WrapperFactory.js
var chtml_WrapperFactory_namespaceObject = {};
__webpack_require__.r(chtml_WrapperFactory_namespaceObject);
__webpack_require__.d(chtml_WrapperFactory_namespaceObject, {
  ChtmlWrapperFactory: () => (ChtmlWrapperFactory)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/DefaultFont.js
var DefaultFont_namespaceObject = {};
__webpack_require__.r(DefaultFont_namespaceObject);
__webpack_require__.d(DefaultFont_namespaceObject, {
  DefaultFont: () => (DefaultFont),
  fontName: () => (DefaultFont_fontName)
});

// NAMESPACE OBJECT: ./mjs/output/chtml.js
var chtml_namespaceObject = {};
__webpack_require__.r(chtml_namespaceObject);
__webpack_require__.d(chtml_namespaceObject, {
  CHTML: () => (CHTML)
});

// NAMESPACE OBJECT: ./mjs/output/chtml/DynamicFonts.js
var DynamicFonts_namespaceObject = {};
__webpack_require__.r(DynamicFonts_namespaceObject);
__webpack_require__.d(DynamicFonts_namespaceObject, {
  AddFontIds: () => (AddFontIds)
});

;// ./components/mjs/core/lib/components/global.js
const g = (typeof window !== 'undefined' ? window : global);
const def = g.MathJax._.components.global;
const GLOBAL = def.GLOBAL;
const isObject = def.isObject;
const combineConfig = def.combineConfig;
const combineDefaults = def.combineDefaults;
const combineWithMathJax = def.combineWithMathJax;
const global_MathJax = def.MathJax;

;// ./mjs/components/version.js
const VERSION = '4.0.0';
//# sourceMappingURL=version.js.map
;// ./components/mjs/core/lib/core/OutputJax.js
const OutputJax_def = MathJax._.core.OutputJax;
const AbstractOutputJax = OutputJax_def.AbstractOutputJax;

;// ./components/mjs/core/lib/core/MathItem.js
const MathItem_def = MathJax._.core.MathItem;
const protoItem = MathItem_def.protoItem;
const AbstractMathItem = MathItem_def.AbstractMathItem;
const STATE = MathItem_def.STATE;
const newState = MathItem_def.newState;

;// ./components/mjs/core/lib/core/MmlTree/MmlNode.js
const MmlNode_def = MathJax._.core.MmlTree.MmlNode;
const TEXCLASS = MmlNode_def.TEXCLASS;
const TEXCLASSNAMES = MmlNode_def.TEXCLASSNAMES;
const MATHVARIANTS = MmlNode_def.MATHVARIANTS;
const indentAttributes = MmlNode_def.indentAttributes;
const AbstractMmlNode = MmlNode_def.AbstractMmlNode;
const AbstractMmlTokenNode = MmlNode_def.AbstractMmlTokenNode;
const AbstractMmlLayoutNode = MmlNode_def.AbstractMmlLayoutNode;
const AbstractMmlBaseNode = MmlNode_def.AbstractMmlBaseNode;
const AbstractMmlEmptyNode = MmlNode_def.AbstractMmlEmptyNode;
const TextNode = MmlNode_def.TextNode;
const XMLNode = MmlNode_def.XMLNode;

;// ./components/mjs/core/lib/mathjax.js
const mathjax_def = MathJax._.mathjax;
const mathjax = mathjax_def.mathjax;

;// ./components/mjs/core/lib/util/Options.js
const Options_def = MathJax._.util.Options;
const Options_isObject = Options_def.isObject;
const APPEND = Options_def.APPEND;
const REMOVE = Options_def.REMOVE;
const OPTIONS = Options_def.OPTIONS;
const Expandable = Options_def.Expandable;
const expandable = Options_def.expandable;
const makeArray = Options_def.makeArray;
const keys = Options_def.keys;
const copy = Options_def.copy;
const insert = Options_def.insert;
const defaultOptions = Options_def.defaultOptions;
const userOptions = Options_def.userOptions;
const selectOptions = Options_def.selectOptions;
const selectOptionsFromKeys = Options_def.selectOptionsFromKeys;
const separateOptions = Options_def.separateOptions;
const lookup = Options_def.lookup;

;// ./components/mjs/core/lib/util/AsyncLoad.js
const AsyncLoad_def = MathJax._.util.AsyncLoad;
const asyncLoad = AsyncLoad_def.asyncLoad;

;// ./components/mjs/core/lib/util/Retries.js
const Retries_def = MathJax._.util.Retries;
const handleRetriesFor = Retries_def.handleRetriesFor;
const retryAfter = Retries_def.retryAfter;

;// ./mjs/output/common/Direction.js
const DIRECTION = { None: '', Vertical: 'v', Horizontal: 'h' };
const V = DIRECTION.Vertical;
const H = DIRECTION.Horizontal;
//# sourceMappingURL=Direction.js.map
;// ./mjs/output/common/FontData.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const NOSTRETCH = { dir: DIRECTION.None };
function mergeOptions(obj, dst, src) {
    return src ? defaultOptions(obj, { [dst]: src })[dst] : obj[dst];
}
class FontData {
    get CLASS() {
        return this.constructor;
    }
    static charOptions(font, n) {
        const char = font[n];
        if (!Array.isArray(char)) {
            throw Error(`Character data hasn't been loaded for 0x${n.toString(16).toUpperCase()}`);
        }
        if (char.length === 3) {
            char[3] = {};
        }
        return char[3];
    }
    static defineDynamicFiles(dynamicFiles, extension = '') {
        const list = {};
        (dynamicFiles || []).forEach(([file, variants, delimiters]) => {
            list[file] = {
                extension,
                file,
                variants,
                delimiters: delimiters || [],
                promise: null,
                failed: false,
                setup: (_font) => {
                    list[file].failed = true;
                },
            };
        });
        return list;
    }
    static dynamicSetup(extension, file, variants, delimiters = {}, fonts = null) {
        const data = extension ? this.dynamicExtensions.get(extension) : null;
        const files = extension ? data.files : this.dynamicFiles;
        files[file].setup = (font) => {
            Object.keys(variants).forEach((name) => font.defineChars(name, variants[name]));
            font.defineDelimiters(delimiters);
            if (extension) {
                this.adjustDelimiters(font.delimiters, Object.keys(delimiters), data.sizeN, data.stretchN);
            }
            if (fonts) {
                font.addDynamicFontCss(fonts);
            }
        };
    }
    static adjustDelimiters(delimiters, keys, sizeN, stretchN) {
        keys.forEach((id) => {
            const delim = delimiters[parseInt(id)];
            if ('dir' in delim) {
                if (delim.variants) {
                    delim.variants = this.adjustArrayIndices(delim.variants, sizeN);
                }
                if (delim.stretchv) {
                    delim.stretchv = this.adjustArrayIndices(delim.stretchv, stretchN);
                }
            }
        });
    }
    static adjustArrayIndices(list, N) {
        return list.map((n) => (n < 0 ? N - 1 - n : n));
    }
    static addExtension(data, prefix = '') {
        const extension = {
            name: data.name,
            prefix: prefix || `[${data.name}-extension]/${this.JAX.toLowerCase()}/dynamic`,
            files: this.defineDynamicFiles(data.ranges, data.name),
            sizeN: this.defaultSizeVariants.length,
            stretchN: this.defaultStretchVariants.length,
        };
        this.dynamicExtensions.set(data.name, extension);
        for (const [src, dst] of [
            ['options', 'OPTIONS'],
            ['variants', 'defaultVariants'],
            ['variantSmp', 'VariantSmp'],
            ['cssFonts', 'defaultCssFonts'],
            ['accentMap', 'defaultAccentMap'],
            ['moMap', 'defaultMoMap'],
            ['mnMap', 'defaultMnMap'],
            ['parameters', 'defaultParams'],
            ['chars', 'defaultChars'],
            ['sizeVariants', 'defaultSizeVariants'],
            ['stretchVariants', 'defaultStretchVariants'],
        ]) {
            mergeOptions(this, dst, data[src]);
        }
        if (data.delimiters) {
            Object.assign(this.defaultDelimiters, data.delimiters);
            this.adjustDelimiters(this.defaultDelimiters, Object.keys(data.delimiters), extension.sizeN, extension.stretchN);
        }
    }
    constructor(options = null) {
        this.variant = {};
        this.delimiters = {};
        this.cssFontMap = {};
        this.cssFontPrefix = '';
        this.remapChars = {};
        this.skewIcFactor = 0.75;
        const CLASS = this.CLASS;
        this.options = userOptions(defaultOptions({}, CLASS.OPTIONS), options);
        this.params = Object.assign({}, CLASS.defaultParams);
        this.sizeVariants = [...CLASS.defaultSizeVariants];
        this.stretchVariants = [...CLASS.defaultStretchVariants];
        this.defineCssFonts(CLASS.defaultCssFonts);
        this.cssFamilyPrefix = CLASS.defaultCssFamilyPrefix;
        this.createVariants(CLASS.defaultVariants);
        this.defineDelimiters(CLASS.defaultDelimiters);
        Object.keys(CLASS.defaultChars).forEach((name) => this.defineChars(name, CLASS.defaultChars[name]));
        this.defineRemap('accent', CLASS.defaultAccentMap);
        this.defineRemap('mo', CLASS.defaultMoMap);
        this.defineRemap('mn', CLASS.defaultMnMap);
        this.defineDynamicCharacters(CLASS.dynamicFiles);
        CLASS.dynamicExtensions.forEach((data) => this.defineDynamicCharacters(data.files));
    }
    setOptions(options) {
        defaultOptions(this.options, options);
    }
    addExtension(data, prefix = '') {
        const jax = this.constructor.JAX.toLowerCase();
        const dynamicFont = {
            name: data.name,
            prefix: prefix || `[${data.name}-extension]/${jax}/dynamic`,
            files: this.CLASS.defineDynamicFiles(data.ranges, prefix),
            sizeN: this.sizeVariants.length,
            stretchN: this.stretchVariants.length,
        };
        this.CLASS.dynamicExtensions.set(data.name, dynamicFont);
        defaultOptions(this.options, data.options || {});
        defaultOptions(this.params, data.parameters || {});
        mergeOptions(this, 'sizeVariants', data.sizeVariants);
        mergeOptions(this, 'stretchVariants', data.stretchVariants);
        mergeOptions(this.constructor, 'VariantSmp', data.variantSmp);
        this.defineCssFonts(mergeOptions({ cssFonts: {} }, 'cssFonts', data.cssFonts));
        this.createVariants(mergeOptions({ variants: [] }, 'variants', data.variants));
        if (data.delimiters) {
            this.defineDelimiters(mergeOptions({ delimiters: {} }, 'delimiters', data.delimiters));
            this.CLASS.adjustDelimiters(this.delimiters, Object.keys(data.delimiters), dynamicFont.sizeN, dynamicFont.stretchN);
        }
        for (const name of Object.keys(data.chars || {})) {
            this.defineChars(name, data.chars[name]);
        }
        this.defineRemap('accent', data.accentMap);
        this.defineRemap('mo', data.moMap);
        this.defineRemap('mn', data.mnMap);
        if (data.ranges) {
            this.defineDynamicCharacters(dynamicFont.files);
        }
        return [];
    }
    get styles() {
        return this._styles;
    }
    set styles(style) {
        this._styles = style;
    }
    createVariant(name, inherit = null, link = null) {
        const variant = {
            linked: [],
            chars: Object.create(inherit ? this.variant[inherit].chars : {}),
        };
        if (this.variant[link]) {
            Object.assign(variant.chars, this.variant[link].chars);
            this.variant[link].linked.push(variant.chars);
            variant.chars = Object.create(variant.chars);
        }
        this.remapSmpChars(variant.chars, name);
        this.variant[name] = variant;
    }
    remapSmpChars(chars, name) {
        const CLASS = this.CLASS;
        let remap = CLASS.VariantSmp[name];
        if (typeof remap === 'string') {
            remap = CLASS.VariantSmp[remap];
        }
        if (!remap)
            return;
        const SmpRemap = CLASS.SmpRemap;
        const SmpGreek = [null, null, CLASS.SmpRemapGreekU, CLASS.SmpRemapGreekL];
        for (const [i, lo, hi] of CLASS.SmpRanges) {
            const base = remap[i];
            if (!base)
                continue;
            for (let n = lo; n <= hi; n++) {
                if (n === 0x3a2)
                    continue;
                const smp = base + n - lo;
                chars[n] = this.smpChar(SmpRemap[smp] || smp);
            }
            if (SmpGreek[i]) {
                for (const n of Object.keys(SmpGreek[i]).map((x) => parseInt(x))) {
                    chars[n] = this.smpChar(base + SmpGreek[i][n]);
                }
            }
        }
        const extra = remap[5] || {};
        for (const n of Object.keys(extra)) {
            chars[n] = this.smpChar(remap[5][n]);
        }
    }
    smpChar(n) {
        return [, , , { smp: n }];
    }
    createVariants(variants) {
        for (const variant of variants) {
            this.createVariant(variant[0], variant[1], variant[2]);
        }
    }
    defineChars(name, chars) {
        const variant = this.variant[name];
        Object.assign(variant.chars, chars);
        for (const link of variant.linked) {
            Object.assign(link, chars);
        }
    }
    defineCssFonts(fonts) {
        Object.assign(this.cssFontMap, fonts);
        for (const name of Object.keys(fonts)) {
            if (this.cssFontMap[name][0] === 'unknown') {
                this.cssFontMap[name][0] = this.options.unknownFamily;
            }
        }
    }
    defineDelimiters(delims) {
        Object.assign(this.delimiters, delims);
    }
    defineRemap(name, remap) {
        if (remap) {
            if (!Object.hasOwn(this.remapChars, name)) {
                this.remapChars[name] = {};
            }
            Object.assign(this.remapChars[name], remap);
        }
    }
    defineDynamicCharacters(dynamicFiles) {
        for (const file of Object.keys(dynamicFiles)) {
            const dynamic = dynamicFiles[file];
            for (const name of Object.keys(dynamic.variants)) {
                this.defineChars(name, this.flattenRanges(dynamic.variants[name], dynamic));
            }
            this.defineDelimiters(this.flattenRanges(dynamic.delimiters, dynamic));
        }
    }
    flattenRanges(ranges, dynamic) {
        const chars = {};
        for (const n of ranges) {
            if (Array.isArray(n)) {
                for (let j = n[0]; j <= n[1]; j++) {
                    chars[j] = dynamic;
                }
            }
            else {
                chars[n] = dynamic;
            }
        }
        return chars;
    }
    dynamicFileName(dynamic) {
        const prefix = !dynamic.extension
            ? this.options.dynamicPrefix
            : this.CLASS.dynamicExtensions.get(dynamic.extension).prefix;
        return dynamic.file.match(/^(?:[/[]|[a-z]+:\/\/|[a-z]:)/i)
            ? dynamic.file
            : prefix + '/' + dynamic.file.replace(/(\.js)?$/, '.js');
    }
    loadDynamicFile(dynamic) {
        return __awaiter(this, void 0, void 0, function* () {
            if (dynamic.failed)
                return Promise.reject(new Error(`dynamic file '${dynamic.file}' failed to load`));
            if (!dynamic.promise) {
                dynamic.promise = asyncLoad(this.dynamicFileName(dynamic)).catch((err) => {
                    dynamic.failed = true;
                    console.warn(err);
                });
            }
            return dynamic.promise.then(() => dynamic.setup(this));
        });
    }
    loadDynamicFiles() {
        const dynamicFiles = this.CLASS.dynamicFiles;
        const promises = Object.keys(dynamicFiles).map((name) => this.loadDynamicFile(dynamicFiles[name]));
        for (const data of this.CLASS.dynamicExtensions.values()) {
            promises.push(...Object.keys(data.files).map((name) => this.loadDynamicFile(data.files[name])));
        }
        return Promise.all(promises);
    }
    loadDynamicFilesSync() {
        if (!mathjax.asyncIsSynchronous) {
            throw Error('MathJax(loadDynamicFilesSync): mathjax.asyncLoad must be specified and synchronous\n' +
                '    Try importing #js/../components/require.mjs and #js/util/asyncLoad/node.js');
        }
        const dynamicFiles = this.CLASS.dynamicFiles;
        Object.keys(dynamicFiles).forEach((name) => this.loadDynamicFileSync(dynamicFiles[name]));
        for (const data of this.CLASS.dynamicExtensions.values()) {
            Object.keys(data.files).forEach((name) => this.loadDynamicFileSync(data.files[name]));
        }
    }
    loadDynamicFileSync(dynamic) {
        if (!dynamic.promise) {
            dynamic.promise = Promise.resolve();
            try {
                mathjax.asyncLoad(this.dynamicFileName(dynamic));
            }
            catch (err) {
                dynamic.failed = true;
                console.warn(err);
            }
            dynamic.setup(this);
        }
    }
    addDynamicFontCss(_fonts, _root) { }
    getDelimiter(n) {
        const delim = this.delimiters[n];
        if (delim && !('dir' in delim)) {
            this.delimiters[n] = null;
            retryAfter(this.loadDynamicFile(delim));
            return null;
        }
        return delim;
    }
    getSizeVariant(n, i) {
        const delim = this.getDelimiter(n);
        if (delim && delim.variants) {
            i = delim.variants[i];
        }
        return this.sizeVariants[i];
    }
    getStretchVariant(n, i) {
        const delim = this.getDelimiter(n);
        return this.stretchVariants[delim.stretchv ? delim.stretchv[i] : 0];
    }
    getStretchVariants(n) {
        return [0, 1, 2, 3].map((i) => this.getStretchVariant(n, i));
    }
    getChar(name, n) {
        const char = this.variant[name].chars[n];
        if (char && !Array.isArray(char)) {
            const variant = this.variant[name];
            delete variant.chars[n];
            variant.linked.forEach((link) => delete link[n]);
            retryAfter(this.loadDynamicFile(char));
            return null;
        }
        return char;
    }
    getVariant(name) {
        return this.variant[name];
    }
    getCssFont(variant) {
        return this.cssFontMap[variant] || ['serif', false, false];
    }
    getFamily(family) {
        return this.cssFamilyPrefix ? this.cssFamilyPrefix + ', ' + family : family;
    }
    getRemappedChar(name, c) {
        const map = this.remapChars[name] || {};
        return map[c];
    }
}
FontData.OPTIONS = {
    unknownFamily: 'serif',
    dynamicPrefix: '.',
};
FontData.JAX = 'common';
FontData.NAME = '';
FontData.defaultVariants = [
    ['normal'],
    ['bold', 'normal'],
    ['italic', 'normal'],
    ['bold-italic', 'italic', 'bold'],
    ['double-struck', 'bold'],
    ['fraktur', 'normal'],
    ['bold-fraktur', 'bold', 'fraktur'],
    ['script', 'italic'],
    ['bold-script', 'bold-italic', 'script'],
    ['sans-serif', 'normal'],
    ['bold-sans-serif', 'bold', 'sans-serif'],
    ['sans-serif-italic', 'italic', 'sans-serif'],
    ['sans-serif-bold-italic', 'bold-italic', 'bold-sans-serif'],
    ['monospace', 'normal'],
    ['-smallop', 'normal'],
    ['-largeop', 'normal'],
    ['-tex-calligraphic', 'italic'],
    ['-tex-bold-calligraphic', 'bold-italic'],
    ['-tex-oldstyle', 'normal'],
    ['-tex-bold-oldstyle', 'bold'],
    ['-tex-mathit', 'italic'],
    ['-tex-variant', 'normal'],
];
FontData.defaultCssFonts = {
    normal: ['unknown', false, false],
    bold: ['unknown', false, true],
    italic: ['unknown', true, false],
    'bold-italic': ['unknown', true, true],
    'double-struck': ['unknown', false, true],
    fraktur: ['unknown', false, false],
    'bold-fraktur': ['unknown', false, true],
    script: ['cursive', false, false],
    'bold-script': ['cursive', false, true],
    'sans-serif': ['sans-serif', false, false],
    'bold-sans-serif': ['sans-serif', false, true],
    'sans-serif-italic': ['sans-serif', true, false],
    'sans-serif-bold-italic': ['sans-serif', true, true],
    monospace: ['monospace', false, false],
    '-smallop': ['unknown', false, false],
    '-largeop': ['unknown', false, false],
    '-tex-calligraphic': ['cursive', true, false],
    '-tex-bold-calligraphic': ['cursive', true, true],
    '-tex-oldstyle': ['unknown', false, false],
    '-tex-bold-oldstyle': ['unknown', false, true],
    '-tex-mathit': ['unknown', true, false],
    '-tex-variant': ['unknown', false, false],
};
FontData.defaultCssFamilyPrefix = '';
FontData.VariantSmp = {
    bold: [
        0x1d400,
        0x1d41a,
        0x1d6a8,
        0x1d6c2,
        0x1d7ce,
        { 0x3dc: 0x1d7ca, 0x3dd: 0x1d7cb },
    ],
    italic: [0x1d434, 0x1d44e, 0x1d6e2, 0x1d6fc],
    'bold-italic': [0x1d468, 0x1d482, 0x1d71c, 0x1d736],
    script: [0x1d49c, 0x1d4b6],
    'bold-script': [0x1d4d0, 0x1d4ea],
    fraktur: [0x1d504, 0x1d51e],
    'double-struck': [0x1d538, 0x1d552, , , 0x1d7d8],
    'bold-fraktur': [0x1d56c, 0x1d586],
    'sans-serif': [0x1d5a0, 0x1d5ba, , , 0x1d7e2],
    'bold-sans-serif': [0x1d5d4, 0x1d5ee, 0x1d756, 0x1d770, 0x1d7ec],
    'sans-serif-italic': [0x1d608, 0x1d622],
    'sans-serif-bold-italic': [0x1d63c, 0x1d656, 0x1d790, 0x1d7aa],
    monospace: [0x1d670, 0x1d68a, , , 0x1d7f6],
};
FontData.SmpRanges = [
    [0, 0x41, 0x5A],
    [1, 0x61, 0x7A],
    [2, 0x391, 0x3A9],
    [3, 0x3B1, 0x3C9],
    [4, 0x30, 0x39]
];
FontData.SmpRemap = {
    0x1D455: 0x210E,
    0x1D49D: 0x212C,
    0x1D4A0: 0x2130,
    0x1D4A1: 0x2131,
    0x1D4A3: 0x210B,
    0x1D4A4: 0x2110,
    0x1D4A7: 0x2112,
    0x1D4A8: 0x2133,
    0x1D4AD: 0x211B,
    0x1D4BA: 0x212F,
    0x1D4BC: 0x210A,
    0x1D4C4: 0x2134,
    0x1D506: 0x212D,
    0x1D50B: 0x210C,
    0x1D50C: 0x2111,
    0x1D515: 0x211C,
    0x1D51D: 0x2128,
    0x1D53A: 0x2102,
    0x1D53F: 0x210D,
    0x1D545: 0x2115,
    0x1D547: 0x2119,
    0x1D548: 0x211A,
    0x1D549: 0x211D,
    0x1D551: 0x2124,
};
FontData.SmpRemapGreekU = {
    0x2207: 0x19,
    0x03F4: 0x11
};
FontData.SmpRemapGreekL = {
    0x3D1: 0x1B,
    0x3D5: 0x1D,
    0x3D6: 0x1F,
    0x3F0: 0x1C,
    0x3F1: 0x1E,
    0x3F5: 0x1A,
    0x2202: 0x19
};
FontData.defaultAccentMap = {
    0x005E: '\u02C6',
    0x007E: '\u02DC',
    0x0300: '\u02CB',
    0x0301: '\u02CA',
    0x0302: '\u02C6',
    0x0303: '\u02DC',
    0x0304: '\u02C9',
    0x0306: '\u02D8',
    0x0307: '\u02D9',
    0x0308: '\u00A8',
    0x030A: '\u02DA',
    0x030C: '\u02C7',
    0x2192: '\u20D7'
};
FontData.defaultMoMap = {
    0x002d: '\u2212',
};
FontData.defaultMnMap = {
    0x002d: '\u2212',
};
FontData.defaultParams = {
    x_height: .442,
    quad: 1,
    num1: .676,
    num2: .394,
    num3: .444,
    denom1: .686,
    denom2: .345,
    sup1: .413,
    sup2: .363,
    sup3: .289,
    sub1: .15,
    sub2: .247,
    sup_drop: .386,
    sub_drop: .05,
    delim1: 2.39,
    delim2: 1.0,
    axis_height: .25,
    rule_thickness: .06,
    big_op_spacing1: .111,
    big_op_spacing2: .167,
    big_op_spacing3: .2,
    big_op_spacing4: .6,
    big_op_spacing5: .1,
    surd_height: .06,
    scriptspace: .05,
    nulldelimiterspace: .12,
    delimiterfactor: 901,
    delimitershortfall: .3,
    rule_factor: 1.25,
    min_rule_thickness: 1.25,
    separation_factor: 1.75,
    extra_ic: .033,
    extender_factor: .333
};
FontData.defaultDelimiters = {};
FontData.defaultChars = {};
FontData.defaultSizeVariants = [];
FontData.defaultStretchVariants = [];
FontData.dynamicFiles = {};
FontData.dynamicExtensions = new Map();
//# sourceMappingURL=FontData.js.map
;// ./components/mjs/core/lib/core/Tree/Visitor.js
const Visitor_def = MathJax._.core.Tree.Visitor;
const AbstractVisitor = Visitor_def.AbstractVisitor;

;// ./components/mjs/core/lib/util/BBox.js
const BBox_def = MathJax._.util.BBox;
const BBox = BBox_def.BBox;

;// ./mjs/output/common/LineBBox.js

class LineBBox extends BBox {
    static from(bbox, leading, indent = null) {
        const nbox = new this();
        Object.assign(nbox, bbox);
        nbox.lineLeading = leading;
        if (indent) {
            nbox.indentData = indent;
        }
        return nbox;
    }
    constructor(def, start = null) {
        super(def);
        this.indentData = null;
        this.isFirst = false;
        this.originalL = this.L;
        if (start) {
            this.start = start;
        }
    }
    append(cbox) {
        if (this.isFirst) {
            cbox.originalL += cbox.L;
            cbox.L = 0;
        }
        if (cbox.indentData) {
            this.indentData = cbox.indentData;
        }
        this.lineLeading = cbox.lineLeading;
        super.append(cbox);
        this.isFirst = cbox.isFirst;
    }
    copy() {
        const bbox = LineBBox.from(this, this.lineLeading);
        bbox.indentData = this.indentData;
        bbox.lineLeading = this.lineLeading;
        return bbox;
    }
    getIndentData(node) {
        let { indentalign, indentshift, indentalignfirst, indentshiftfirst, indentalignlast, indentshiftlast, } = node.attributes.getAllAttributes();
        if (indentalignfirst === 'indentalign') {
            indentalignfirst = node.attributes.getInherited('indentalign');
        }
        if (indentshiftfirst === 'indentshift') {
            indentshiftfirst = node.attributes.getInherited('indentshift');
        }
        if (indentalignlast === 'indentalign') {
            indentalignlast = indentalign;
        }
        if (indentshiftlast === 'indentshift') {
            indentshiftlast = indentshift;
        }
        this.indentData = [
            [indentalignfirst, indentshiftfirst],
            [indentalign, indentshift],
            [indentalignlast, indentshiftlast],
        ];
    }
    copyIndentData(bbox) {
        return bbox.indentData.map(([align, indent]) => [align, indent]);
    }
}
//# sourceMappingURL=LineBBox.js.map
;// ./components/mjs/core/lib/core/MmlTree/OperatorDictionary.js
const OperatorDictionary_def = MathJax._.core.MmlTree.OperatorDictionary;
const OPDEF = OperatorDictionary_def.OPDEF;
const MO = OperatorDictionary_def.MO;
const RANGES = OperatorDictionary_def.RANGES;
const getRange = OperatorDictionary_def.getRange;
const MMLSPACING = OperatorDictionary_def.MMLSPACING;
const OPTABLE = OperatorDictionary_def.OPTABLE;

;// ./mjs/output/common/LinebreakVisitor.js




const NOBREAK = 1000000;
class Linebreaks extends AbstractVisitor {
    breakToWidth(_wrapper, _W) { }
}
class LinebreakVisitor extends Linebreaks {
    constructor() {
        super(...arguments);
        this.PENALTY = {
            newline: (_p) => 0,
            nobreak: (_p) => NOBREAK,
            goodbreak: (p) => p - 200 * this.state.depth,
            badbreak: (p) => p + 200 * this.state.depth,
            auto: (p) => p,
        };
        this.FACTORS = {
            depth: (p) => p + 800 * this.state.depth,
            width: (p) => p +
                Math.floor(((this.state.width - this.state.w) / this.state.width) * 2500),
            tail: (p) => p +
                Math.floor((this.state.width /
                    Math.max(0.0001, this.state.mathLeft - this.state.w)) *
                    500),
            open: (p, mo) => {
                const prevClass = mo.node.prevClass;
                if (prevClass === TEXCLASS.BIN ||
                    prevClass === TEXCLASS.REL ||
                    prevClass === TEXCLASS.OP) {
                    return p + 5000;
                }
                const prev = this.getPrevious(mo);
                if (prev &&
                    (prev.attributes.get('form') !== 'postfix' ||
                        prev.attributes.get('linebreak') === 'nobreak')) {
                    return p + 5000;
                }
                const parent = mo.node.Parent;
                if ((parent === null || parent === void 0 ? void 0 : parent.isKind('mmultiscripts')) &&
                    mo.node === this.getFirstToken(parent)) {
                    const prescripts = !!parent.childNodes.filter((node) => node.isKind('mprescripts')).length;
                    if (prescripts)
                        return NOBREAK;
                }
                return p - 500;
            },
            close: (p, mo) => {
                var _a;
                const parent = mo.node.Parent;
                if ((parent === null || parent === void 0 ? void 0 : parent.isKind('msubsup')) &&
                    !(parent.isKind('mmultiscripts') &&
                        ((_a = parent.childNodes[1]) === null || _a === void 0 ? void 0 : _a.isKind('mprescripts'))) &&
                    mo.node === this.getLastToken(parent.childNodes[0])) {
                    return NOBREAK;
                }
                return p + 500;
            },
            space: (p, node) => {
                const mspace = node;
                if (!mspace.canBreak)
                    return NOBREAK;
                const w = mspace.getBBox().w;
                return w < 0 ? NOBREAK : w < 1 ? p : p - 100 * (w + 4);
            },
            separator: (p) => p + 500,
            fuzz: (p) => p * 0.99,
        };
        this.TEXCLASS = {
            [TEXCLASS.BIN]: (p) => p - 250,
            [TEXCLASS.REL]: (p) => p - 500,
        };
    }
    breakToWidth(wrapper, W) {
        const state = this.state;
        this.state = this.createState(wrapper);
        this.state.width = W;
        const n = wrapper.breakCount;
        for (let i = 0; i <= n; i++) {
            const line = wrapper.lineBBox[i] || wrapper.getLineBBox(i);
            if (line.w > W) {
                this.breakLineToWidth(wrapper, i);
            }
        }
        for (const [ww, ij] of this.state.breaks) {
            if (ij === null) {
                const mo = ww.coreMO();
                mo.setBreakStyle(mo.node.attributes.get('linebreakstyle') || 'before');
            }
            else {
                ww.setBreakAt(ij);
            }
            ww.invalidateBBox();
        }
        this.state = state;
    }
    createState(wrapper) {
        const mathWidth = wrapper.getBBox().w;
        return {
            breaks: new Set(),
            potential: [],
            width: 0,
            w: 0,
            prevWidth: 0,
            prevBreak: null,
            depth: 0,
            mathWidth: mathWidth,
            mathLeft: mathWidth,
        };
    }
    breakLineToWidth(wrapper, i) {
        const state = this.state;
        state.potential = [];
        state.w = 0;
        state.prevWidth = 0;
        state.prevBreak = null;
        state.depth = 0;
        this.visitNode(wrapper, i);
    }
    addWidth(bbox, w = null) {
        if (w === null) {
            w = bbox.L + bbox.w + bbox.R;
        }
        if (!w)
            return;
        w *= bbox.rscale;
        this.state.w += w;
        if (this.state.potential.length) {
            this.state.potential[0][4] += w;
        }
        this.processBreak();
    }
    processBreak() {
        const state = this.state;
        while (state.potential.length && state.w > this.state.width) {
            const br = state.potential.pop();
            const [ww, , pw, dw, w] = br;
            state.breaks.add(ww);
            state.w = state.potential.reduce((w, brk) => w + brk[4], dw + w);
            if (state.prevBreak && state.prevWidth + pw <= state.width) {
                state.breaks.delete(state.prevBreak[0]);
                state.prevWidth += pw;
            }
            else {
                state.prevWidth = pw + dw;
            }
            state.potential.forEach((data) => (data[2] -= pw));
            state.prevBreak = br;
            state.mathLeft -= pw;
        }
    }
    pushBreak(wrapper, penalty, w, ij) {
        var _a;
        const state = this.state;
        if (penalty >= NOBREAK || (state.w === 0 && state.prevWidth === 0))
            return;
        while (state.potential.length &&
            state.potential[0][1] > this.FACTORS.fuzz(penalty)) {
            const data = state.potential.shift();
            if (state.potential.length) {
                state.potential[0][4] += data[4];
            }
        }
        state.potential.unshift([
            [wrapper, ij],
            penalty,
            state.w - (((_a = state.prevBreak) === null || _a === void 0 ? void 0 : _a[3]) || 0),
            w,
            0,
        ]);
    }
    getBorderLR(wrapper) {
        var _a;
        const data = wrapper.styleData;
        if (!data)
            return [0, 0];
        const border = ((_a = data === null || data === void 0 ? void 0 : data.border) === null || _a === void 0 ? void 0 : _a.width) || [0, 0, 0, 0];
        const padding = (data === null || data === void 0 ? void 0 : data.padding) || [0, 0, 0, 0];
        return [border[3] + padding[3], border[1] + padding[1]];
    }
    getFirstToken(node) {
        return node.isToken ? node : this.getFirstToken(node.childNodes[0]);
    }
    getLastToken(node) {
        return node.isToken
            ? node
            : this.getLastToken(node.childNodes[node.childNodes.length - 1]);
    }
    visitNode(wrapper, i) {
        if (!wrapper)
            return;
        this.state.depth++;
        if (wrapper.node.isEmbellished && !wrapper.node.isKind('mo')) {
            this.visitEmbellishedOperator(wrapper, i);
        }
        else {
            super.visitNode(wrapper, i);
        }
        this.state.depth--;
    }
    visitDefault(wrapper, i) {
        var _a;
        const bbox = wrapper.getLineBBox(i);
        if (wrapper.node.isToken ||
            wrapper.node.linebreakContainer ||
            !((_a = wrapper.childNodes) === null || _a === void 0 ? void 0 : _a[0])) {
            this.addWidth(bbox);
        }
        else {
            const [L, R] = this.getBorderLR(wrapper);
            if (i === 0) {
                this.addWidth(bbox, bbox.L + L);
            }
            this.visitNode(wrapper.childNodes[0], i);
            if (i === wrapper.breakCount) {
                this.addWidth(bbox, bbox.R + R);
            }
        }
    }
    visitEmbellishedOperator(wrapper, _i) {
        const mo = wrapper.coreMO();
        const bbox = LineBBox.from(wrapper.getOuterBBox(), wrapper.linebreakOptions.lineleading);
        bbox.getIndentData(mo.node);
        const style = mo.getBreakStyle(mo.node.attributes.get('linebreakstyle'));
        const dw = mo.processIndent('', bbox.indentData[1][1], '', bbox.indentData[0][1], this.state.width)[1];
        const penalty = this.moPenalty(mo);
        if (style === 'before') {
            this.pushBreak(wrapper, penalty, dw - bbox.L, null);
            this.addWidth(bbox);
        }
        else {
            this.addWidth(bbox);
            const w = (style === 'after'
                ? 0
                : mo.multChar
                    ? mo.multChar.getBBox().w
                    : bbox.w) + dw;
            this.pushBreak(wrapper, penalty, w, null);
        }
    }
    visitMoNode(wrapper, _i) {
        const mo = wrapper;
        const bbox = LineBBox.from(mo.getOuterBBox(), mo.linebreakOptions.lineleading);
        bbox.getIndentData(mo.node);
        const style = mo.getBreakStyle(mo.node.attributes.get('linebreakstyle'));
        const dw = mo.processIndent('', bbox.indentData[1][1], '', bbox.indentData[0][1], this.state.width)[1];
        const penalty = this.moPenalty(mo);
        if (style === 'before') {
            this.pushBreak(wrapper, penalty, dw - bbox.L, null);
            this.addWidth(bbox);
        }
        else {
            this.addWidth(bbox);
            const w = (style === 'after'
                ? 0
                : mo.multChar
                    ? mo.multChar.getBBox().w
                    : bbox.w) + dw;
            this.pushBreak(wrapper, penalty, w, null);
        }
    }
    moPenalty(mo) {
        const { linebreak, fence, form } = mo.node.attributes.getList('linebreak', 'fence', 'form');
        const FACTORS = this.FACTORS;
        let penalty = FACTORS.tail(FACTORS.width(0));
        const isOpen = (fence && form === 'prefix') || mo.node.texClass === TEXCLASS.OPEN;
        const isClose = (fence && form === 'postfix') || mo.node.texClass === TEXCLASS.CLOSE;
        if (isOpen) {
            penalty = FACTORS.open(penalty, mo);
            this.state.depth++;
        }
        if (isClose) {
            penalty = FACTORS.close(penalty, mo);
            this.state.depth--;
        }
        penalty = (this.TEXCLASS[mo.node.texClass] || ((p) => p))(penalty);
        return (this.PENALTY[linebreak] || ((p) => p))(FACTORS.depth(penalty));
    }
    getPrevious(mo) {
        let child = mo.node;
        let parent = child.parent;
        let i = parent.childIndex(child);
        while (parent && (parent.notParent || parent.isKind('mrow')) && i === 0) {
            child = parent;
            parent = child.parent;
            i = parent.childIndex(child);
        }
        if (!parent || !i)
            return null;
        const prev = parent.childNodes[i - 1];
        return prev.isEmbellished ? prev.coreMO() : null;
    }
    visitMspaceNode(wrapper, i) {
        const bbox = wrapper.getLineBBox(i);
        const mspace = wrapper;
        if (mspace.canBreak) {
            const penalty = this.mspacePenalty(mspace);
            bbox.getIndentData(wrapper.node);
            const dw = wrapper.processIndent('', bbox.indentData[1][1], '', bbox.indentData[0][1], this.state.width)[1];
            this.pushBreak(wrapper, penalty, dw - bbox.w, null);
        }
        this.addWidth(bbox);
    }
    mspacePenalty(mspace) {
        const linebreak = mspace.node.attributes.get('linebreak');
        const FACTORS = this.FACTORS;
        const penalty = FACTORS.space(FACTORS.tail(FACTORS.width(0)), mspace);
        return (this.PENALTY[linebreak] || ((p) => p))(FACTORS.depth(penalty));
    }
    visitMtextNode(wrapper, i) {
        if (!wrapper.getText().match(/ /)) {
            this.visitDefault(wrapper, i);
            return;
        }
        const mtext = wrapper;
        mtext.clearBreakPoints();
        const space = mtext.textWidth(' ');
        const bbox = wrapper.getBBox();
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(bbox, bbox.L + L);
        const children = mtext.childNodes;
        for (const j of children.keys()) {
            const child = children[j];
            if (child.node.isKind('text')) {
                const words = child.node.getText().split(/ /);
                const last = words.pop();
                for (const k of words.keys()) {
                    this.addWidth(bbox, mtext.textWidth(words[k]));
                    this.pushBreak(wrapper, this.mtextPenalty(), -space, [j, k + 1]);
                    this.addWidth(bbox, space);
                }
                this.addWidth(bbox, mtext.textWidth(last));
            }
            else {
                this.addWidth(child.getBBox());
            }
        }
        this.addWidth(bbox, bbox.R + R);
    }
    mtextPenalty() {
        const FACTORS = this.FACTORS;
        return FACTORS.depth(FACTORS.tail(FACTORS.width(0)));
    }
    visitMrowNode(wrapper, i) {
        const line = wrapper.lineBBox[i] || wrapper.getLineBBox(i);
        const [start, startL] = line.start || [0, 0];
        const [end, endL] = line.end || [wrapper.childNodes.length - 1, 0];
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(line, line.L + L);
        for (let i = start; i <= end; i++) {
            this.visitNode(wrapper.childNodes[i], i === start ? startL : i === end ? endL : 0);
        }
        this.addWidth(line, line.R + R);
    }
    visitInferredMrowNode(wrapper, i) {
        this.state.depth--;
        this.visitMrowNode(wrapper, i);
        this.state.depth++;
    }
    visitMfracNode(wrapper, i) {
        const mfrac = wrapper;
        if (!mfrac.node.attributes.get('bevelled') &&
            mfrac.getOuterBBox().w > this.state.width) {
            this.breakToWidth(mfrac.childNodes[0], this.state.width);
            this.breakToWidth(mfrac.childNodes[1], this.state.width);
        }
        this.visitDefault(wrapper, i);
    }
    visitMsqrtNode(wrapper, i) {
        if (wrapper.getOuterBBox().w > this.state.width) {
            const msqrt = wrapper;
            const base = msqrt.childNodes[msqrt.base];
            this.breakToWidth(base, this.state.width - msqrt.rootWidth());
            msqrt.getStretchedSurd();
        }
        this.visitDefault(wrapper, i);
    }
    visitMrootNode(wrapper, i) {
        this.visitMsqrtNode(wrapper, i);
    }
    visitMsubNode(wrapper, i) {
        this.visitDefault(wrapper, i);
        const msub = wrapper;
        const x = msub.getOffset()[0];
        const sbox = msub.scriptChild.getOuterBBox();
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(msub.getLineBBox(i), x + L + sbox.rscale * sbox.w + msub.font.params.scriptspace + R);
    }
    visitMsupNode(wrapper, i) {
        this.visitDefault(wrapper, i);
        const msup = wrapper;
        const x = msup.getOffset()[0];
        const sbox = msup.scriptChild.getOuterBBox();
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(msup.getLineBBox(i), x + L + sbox.rscale * sbox.w + msup.font.params.scriptspace + R);
    }
    visitMsubsupNode(wrapper, i) {
        this.visitDefault(wrapper, i);
        const msubsup = wrapper;
        const subbox = msubsup.subChild.getOuterBBox();
        const supbox = msubsup.supChild.getOuterBBox();
        const x = msubsup.getAdjustedIc();
        const w = Math.max(subbox.rscale * subbox.w, x + supbox.rscale * supbox.w) +
            msubsup.font.params.scriptspace;
        const [L, R] = this.getBorderLR(wrapper);
        this.addWidth(wrapper.getLineBBox(i), L + w + R);
    }
    visitMmultiscriptsNode(wrapper, i) {
        const mmultiscripts = wrapper;
        const data = mmultiscripts.scriptData;
        if (data.numPrescripts) {
            const w = Math.max(data.psup.rscale * data.psup.w, data.psub.rscale * data.psub.w);
            this.addWidth(wrapper.getLineBBox(i), w + mmultiscripts.font.params.scriptspace);
        }
        this.visitDefault(wrapper, i);
        if (data.numScripts) {
            const w = Math.max(data.sup.rscale * data.sup.w, data.sub.rscale * data.sub.w);
            this.addWidth(wrapper.getLineBBox(i), w + mmultiscripts.font.params.scriptspace);
        }
    }
    visitMfencedNode(wrapper, i) {
        const mfenced = wrapper;
        const bbox = wrapper.getLineBBox(i);
        const [L, R] = this.getBorderLR(wrapper);
        if (i === 0) {
            this.addWidth(bbox, bbox.L + L);
        }
        this.visitNode(mfenced.mrow, i);
        if (i === wrapper.breakCount) {
            this.addWidth(bbox, bbox.R + R);
        }
    }
    visitMactionNode(wrapper, i) {
        const maction = wrapper;
        const bbox = wrapper.getLineBBox(i);
        const [L, R] = this.getBorderLR(wrapper);
        if (i === 0) {
            this.addWidth(bbox, bbox.L + L);
        }
        this.visitNode(maction.selected, i);
        if (i === wrapper.breakCount) {
            this.addWidth(bbox, bbox.R + R);
        }
    }
}
(function () {
    for (const op of Object.keys(OPTABLE.postfix)) {
        const data = OPTABLE.postfix[op][3];
        if (data && data.fence) {
            data.linebreakstyle = 'after';
        }
    }
    OPTABLE.infix['\u2061'] = [...OPTABLE.infix['\u2061']];
    OPTABLE.infix['\u2061'][3] = { linebreak: 'nobreak' };
})();
//# sourceMappingURL=LinebreakVisitor.js.map
;// ./components/mjs/core/lib/util/lengths.js
const lengths_def = MathJax._.util.lengths;
const BIGDIMEN = lengths_def.BIGDIMEN;
const UNITS = lengths_def.UNITS;
const RELUNITS = lengths_def.RELUNITS;
const MATHSPACE = lengths_def.MATHSPACE;
const length2em = lengths_def.length2em;
const percent = lengths_def.percent;
const em = lengths_def.em;
const px = lengths_def.px;

;// ./components/mjs/core/lib/util/Styles.js
const Styles_def = MathJax._.util.Styles;
const TRBL = Styles_def.TRBL;
const WSC = Styles_def.WSC;
const Styles = Styles_def.Styles;

;// ./components/mjs/core/lib/util/StyleJson.js
const StyleJson_def = MathJax._.util.StyleJson;
const StyleJsonSheet = StyleJson_def.StyleJsonSheet;

;// ./mjs/output/common.js










const FONTPATH = '@mathjax/%%FONT%%-font';
class CommonOutputJax extends AbstractOutputJax {
    get forceInlineBreaks() {
        return false;
    }
    constructor(options = {}, defaultFactory = null, defaultFont = null) {
        const [fontClass, font] = options.fontData instanceof FontData
            ? [options.fontData.constructor, options.fontData]
            : [options.fontData || defaultFont, null];
        const [jaxOptions, fontOptions] = separateOptions(options, fontClass.OPTIONS);
        super(jaxOptions);
        this.factory =
            this.options.wrapperFactory ||
                new defaultFactory();
        this.factory.jax = this;
        this.styleJson = this.options.styleJson || new StyleJsonSheet();
        this.font = font || new fontClass(fontOptions);
        this.font.setOptions({ mathmlSpacing: this.options.mathmlSpacing });
        this.unknownCache = new Map();
        const linebreaks = (this.options.linebreaks.LinebreakVisitor ||
            LinebreakVisitor);
        this.linebreaks = new linebreaks(this.factory);
    }
    setAdaptor(adaptor) {
        super.setAdaptor(adaptor);
        if (this.options.htmlHDW === 'auto') {
            this.options.htmlHDW = adaptor.canMeasureNodes ? 'ignore' : 'force';
        }
    }
    addExtension(font, prefix = '') {
        return this.font.addExtension(font, prefix);
    }
    typeset(math, html) {
        this.setDocument(html);
        const node = this.createNode();
        this.toDOM(math, node, html);
        return node;
    }
    createNode() {
        const jax = this.constructor.NAME;
        return this.html('mjx-container', { class: 'MathJax', jax: jax });
    }
    setScale(node, wrapper) {
        let scale = this.getInitialScale() * this.options.scale;
        if (wrapper.node.attributes.get('overflow') === 'scale' &&
            this.math.display) {
            const w = wrapper.getOuterBBox().w;
            const W = this.math.metrics.containerWidth / this.pxPerEm;
            if (w > W && w) {
                scale *= W / w;
            }
        }
        if (scale !== 1) {
            this.adaptor.setStyle(node, 'fontSize', percent(scale));
        }
    }
    getInitialScale() {
        return this.math.metrics.scale;
    }
    toDOM(math, node, html = null) {
        var _a;
        this.setDocument(html);
        this.math = math;
        this.container = node;
        this.pxPerEm = math.metrics.ex / this.font.params.x_height;
        this.executeFilters(this.preFilters, math, html, node);
        this.nodeMap = new Map();
        math.root.attributes.getAllInherited().overflow =
            this.options.displayOverflow;
        const overflow = math.root.attributes.get('overflow');
        this.adaptor.setAttribute(node, 'overflow', overflow);
        const linebreak = overflow === 'linebreak';
        if (linebreak) {
            this.getLinebreakWidth();
        }
        const makeBreaks = this.options.linebreaks.inline && !math.display;
        let inlineMarked = !!math.root.getProperty('inlineMarked');
        if (inlineMarked &&
            (!makeBreaks ||
                this.forceInlineBreaks !== math.root.getProperty('inlineForced'))) {
            this.unmarkInlineBreaks(math.root);
            math.root.removeProperty('inlineMarked');
            math.root.removeProperty('inlineForced');
            inlineMarked = false;
        }
        if (makeBreaks && !inlineMarked) {
            this.markInlineBreaks((_a = math.root.childNodes) === null || _a === void 0 ? void 0 : _a[0]);
            math.root.setProperty('inlineMarked', true);
            math.root.setProperty('inlineForced', this.forceInlineBreaks);
        }
        math.root.setTeXclass(null);
        const wrapper = this.factory.wrap(math.root);
        this.setScale(node, wrapper);
        this.processMath(wrapper, node);
        this.nodeMap = null;
        this.executeFilters(this.postFilters, math, html, node);
    }
    getBBox(math, html) {
        this.setDocument(html);
        this.math = math;
        math.root.setTeXclass(null);
        this.nodeMap = new Map();
        const bbox = this.factory.wrap(math.root).getOuterBBox();
        this.nodeMap = null;
        return bbox;
    }
    getLinebreakWidth() {
        const W = this.math.metrics.containerWidth / this.pxPerEm;
        const width = this.math.root.attributes.get('maxwidth') ||
            this.options.linebreaks.width;
        this.containerWidth = length2em(width, W, 1, this.pxPerEm);
    }
    markInlineBreaks(node) {
        if (!node)
            return;
        const forcebreak = this.forceInlineBreaks;
        let postbreak = false;
        let marked = false;
        let markNext = '';
        for (const child of node.childNodes) {
            if (markNext) {
                marked = this.markInlineBreak(marked, forcebreak, markNext, node, child);
                markNext = '';
                postbreak = false;
            }
            else if (child.isEmbellished) {
                if (child === node.childNodes[0]) {
                    continue;
                }
                const mo = child.coreMO();
                const texClass = mo.texClass;
                const linebreak = mo.attributes.get('linebreak');
                const linebreakstyle = mo.attributes.get('linebreakstyle');
                if ((texClass === TEXCLASS.BIN ||
                    texClass === TEXCLASS.REL ||
                    (texClass === TEXCLASS.ORD && mo.hasSpacingAttributes()) ||
                    linebreak !== 'auto') &&
                    linebreak !== 'nobreak') {
                    if (linebreakstyle === 'before') {
                        if (!postbreak || linebreak !== 'auto') {
                            marked = this.markInlineBreak(marked, forcebreak, linebreak, node, child, mo);
                        }
                    }
                    else {
                        markNext = linebreak;
                    }
                }
                postbreak = linebreak === 'newline' && linebreakstyle === 'after';
            }
            else if (child.isKind('mspace')) {
                const linebreak = child.attributes.get('linebreak');
                if (linebreak !== 'nobreak' && child.canBreak) {
                    marked = this.markInlineBreak(marked, forcebreak, linebreak, node, child);
                }
                postbreak = linebreak === 'newline';
            }
            else {
                postbreak = false;
                if ((child.isKind('mstyle') &&
                    !child.attributes.get('style') &&
                    !child.attributes.hasExplicit('mathbackground')) ||
                    child.isKind('semantics')) {
                    this.markInlineBreaks(child.childNodes[0]);
                    if (child.getProperty('process-breaks')) {
                        child.setProperty('inline-breaks', true);
                        child.childNodes[0].setProperty('inline-breaks', true);
                        node.parent.setProperty('process-breaks', 'true');
                    }
                }
                else if (child.isKind('mrow') &&
                    child.attributes.get('data-semantic-added')) {
                    this.markInlineBreaks(child);
                    if (child.getProperty('process-breaks')) {
                        child.setProperty('inline-breaks', true);
                        node.parent.setProperty('process-breaks', 'true');
                    }
                }
            }
        }
    }
    markInlineBreak(marked, forcebreak, linebreak, node, child, mo = null) {
        child.setProperty('breakable', true);
        if (forcebreak && linebreak !== 'newline') {
            child.setProperty('forcebreak', true);
            mo === null || mo === void 0 ? void 0 : mo.setProperty('forcebreak', true);
        }
        else {
            child.removeProperty('forcebreak');
            mo === null || mo === void 0 ? void 0 : mo.removeProperty('forcebreak');
            if (linebreak === 'newline') {
                child.setProperty('newline', true);
            }
        }
        if (!marked) {
            node.setProperty('process-breaks', true);
            node.parent.setProperty('process-breaks', true);
            marked = true;
        }
        return marked;
    }
    unmarkInlineBreaks(node) {
        if (!node)
            return;
        node.removeProperty('forcebreak');
        node.removeProperty('breakable');
        if (node.getProperty('process-breaks')) {
            node.removeProperty('process-breaks');
            for (const child of node.childNodes) {
                this.unmarkInlineBreaks(child);
            }
        }
    }
    getMetrics(html) {
        this.setDocument(html);
        const adaptor = this.adaptor;
        const maps = this.getMetricMaps(html);
        for (const math of html.math) {
            const parent = adaptor.parent(math.start.node);
            if (math.state() < STATE.METRICS && parent) {
                const map = maps[math.display ? 1 : 0];
                const { em, ex, containerWidth, scale, family } = map.get(parent);
                math.setMetrics(em, ex, containerWidth, scale);
                if (this.options.mtextInheritFont) {
                    math.outputData.mtextFamily = family;
                }
                if (this.options.merrorInheritFont) {
                    math.outputData.merrorFamily = family;
                }
                math.state(STATE.METRICS);
            }
        }
    }
    getMetricsFor(node, display) {
        const getFamily = this.options.mtextInheritFont || this.options.merrorInheritFont;
        const test = this.getTestElement(node, display);
        const metrics = Object.assign(Object.assign({}, this.measureMetrics(test, getFamily)), { display });
        this.adaptor.remove(test);
        return metrics;
    }
    getMetricMaps(html) {
        const adaptor = this.adaptor;
        const domMaps = [
            new Map(),
            new Map(),
        ];
        for (const math of html.math) {
            const node = adaptor.parent(math.start.node);
            if (node && math.state() < STATE.METRICS) {
                const map = domMaps[math.display ? 1 : 0];
                if (!map.has(node)) {
                    map.set(node, this.getTestElement(node, math.display));
                }
            }
        }
        const getFamily = this.options.mtextInheritFont || this.options.merrorInheritFont;
        const maps = [new Map(), new Map()];
        for (const i of maps.keys()) {
            for (const node of domMaps[i].keys()) {
                maps[i].set(node, this.measureMetrics(domMaps[i].get(node), getFamily));
            }
        }
        for (const i of maps.keys()) {
            for (const node of domMaps[i].values()) {
                adaptor.remove(node);
            }
        }
        return maps;
    }
    getTestElement(node, display) {
        const adaptor = this.adaptor;
        if (!this.testInline) {
            this.testInline = this.html('mjx-test', {
                style: {
                    display: 'inline-block',
                    width: '100%',
                    'font-style': 'normal',
                    'font-weight': 'normal',
                    'font-size': '100%',
                    'font-size-adjust': 'none',
                    'text-indent': 0,
                    'text-transform': 'none',
                    'letter-spacing': 'normal',
                    'word-spacing': 'normal',
                    overflow: 'hidden',
                    height: '1px',
                    'margin-right': '-1px',
                },
            }, [
                this.html('mjx-left-box', {
                    style: {
                        display: 'inline-block',
                        width: 0,
                        float: 'left',
                    },
                }),
                this.html('mjx-ex-box', {
                    style: {
                        position: 'absolute',
                        overflow: 'hidden',
                        width: '1px',
                        height: '60ex',
                    },
                }),
                this.html('mjx-right-box', {
                    style: {
                        display: 'inline-block',
                        width: 0,
                        float: 'right',
                    },
                }),
            ]);
            this.testDisplay = adaptor.clone(this.testInline);
            adaptor.setStyle(this.testDisplay, 'display', 'table');
            adaptor.setStyle(this.testDisplay, 'margin-right', '');
            adaptor.setStyle(adaptor.firstChild(this.testDisplay), 'display', 'none');
            const right = adaptor.lastChild(this.testDisplay);
            adaptor.setStyle(right, 'display', 'table-cell');
            adaptor.setStyle(right, 'width', '10000em');
            adaptor.setStyle(right, 'float', '');
        }
        return adaptor.append(node, adaptor.clone(display ? this.testDisplay : this.testInline));
    }
    measureMetrics(node, getFamily) {
        const adaptor = this.adaptor;
        const family = getFamily ? adaptor.fontFamily(node) : '';
        const em = adaptor.fontSize(node);
        const [w, h] = adaptor.nodeSize(adaptor.childNode(node, 1));
        const ex = w ? h / 60 : em * this.options.exFactor;
        const containerWidth = !w
            ? 1000000
            : adaptor.getStyle(node, 'display') === 'table'
                ? adaptor.nodeSize(adaptor.lastChild(node))[0] - 1
                : adaptor.nodeBBox(adaptor.lastChild(node)).left -
                    adaptor.nodeBBox(adaptor.firstChild(node)).left -
                    2;
        const scale = Math.max(this.options.minScale, this.options.matchFontHeight ? ex / this.font.params.x_height / em : 1);
        return { em, ex, containerWidth, scale, family };
    }
    styleSheet(html) {
        this.setDocument(html);
        this.styleJson.clear();
        this.styleJson.addStyles(this.constructor.commonStyles);
        if ('getStyles' in html) {
            for (const styles of html.getStyles()) {
                this.styleJson.addStyles(styles);
            }
        }
        this.addWrapperStyles(this.styleJson);
        this.addFontStyles(this.styleJson);
        const sheet = this.html('style', { id: 'MJX-styles' }, [
            this.text('\n' + this.styleJson.cssText + '\n'),
        ]);
        return sheet;
    }
    addFontStyles(styles) {
        styles.addStyles(this.font.styles);
    }
    addWrapperStyles(styles) {
        for (const kind of this.factory.getKinds()) {
            this.addClassStyles(this.factory.getNodeClass(kind), styles);
        }
    }
    addClassStyles(CLASS, styles) {
        CLASS.addStyles(styles, this);
    }
    insertStyles(_styles) { }
    setDocument(html) {
        if (html) {
            this.document = html;
            this.adaptor.document = html.document;
        }
    }
    html(type, def = {}, content = [], ns) {
        return this.adaptor.node(type, def, content, ns);
    }
    text(text) {
        return this.adaptor.text(text);
    }
    fixed(m, n = 3) {
        if (Math.abs(m) < 0.0006) {
            return '0';
        }
        return m.toFixed(n).replace(/\.?0+$/, '');
    }
    measureText(text, variant, font = ['', false, false]) {
        const node = this.unknownText(text, variant);
        if (variant === '-explicitFont') {
            const styles = this.cssFontStyles(font);
            this.adaptor.setAttributes(node, { style: styles });
        }
        return this.measureTextNodeWithCache(node, text, variant, font);
    }
    measureTextNodeWithCache(text, chars, variant, font = ['', false, false]) {
        if (variant === '-explicitFont') {
            variant = [font[0], font[1] ? 'T' : 'F', font[2] ? 'T' : 'F', ''].join('-');
        }
        if (!this.unknownCache.has(variant)) {
            this.unknownCache.set(variant, new Map());
        }
        const map = this.unknownCache.get(variant);
        const cached = map.get(chars);
        if (cached)
            return cached;
        const bbox = this.measureTextNode(text);
        map.set(chars, bbox);
        return bbox;
    }
    cssFontStyles(font, styles = {}) {
        const [family, italic, bold] = font;
        styles['font-family'] = this.font.getFamily(family);
        if (italic)
            styles['font-style'] = 'italic';
        if (bold)
            styles['font-weight'] = 'bold';
        return styles;
    }
    getFontData(styles) {
        if (!styles) {
            styles = new Styles();
        }
        return [
            this.font.getFamily(styles.get('font-family')),
            styles.get('font-style') === 'italic',
            styles.get('font-weight') === 'bold',
        ];
    }
}
CommonOutputJax.NAME = 'Common';
CommonOutputJax.OPTIONS = Object.assign(Object.assign({}, AbstractOutputJax.OPTIONS), { scale: 1, minScale: .5, mtextInheritFont: false, merrorInheritFont: false, mtextFont: '', merrorFont: 'serif', mathmlSpacing: false, skipAttributes: {}, exFactor: .5, displayAlign: 'center', displayIndent: '0', displayOverflow: 'overflow', linebreaks: {
        inline: true,
        width: '100%',
        lineleading: .2,
        LinebreakVisitor: null,
    }, font: '', htmlHDW: 'auto', wrapperFactory: null, fontData: null, fontPath: FONTPATH, styleJson: null });
CommonOutputJax.commonStyles = {
    'mjx-container[overflow="scroll"][display]': {
        overflow: 'auto clip',
        'min-width': 'initial !important',
    },
    'mjx-container[overflow="truncate"][display]': {
        overflow: 'hidden clip',
        'min-width': 'initial !important',
    },
    'mjx-container[display]': {
        display: 'block',
        'text-align': 'center',
        'justify-content': 'center',
        margin: 'calc(1em - 2px) 0',
        padding: '2px 0',
    },
    'mjx-container[display][width="full"]': {
        display: 'flex',
    },
    'mjx-container[justify="left"]': {
        'text-align': 'left',
        'justify-content': 'left',
    },
    'mjx-container[justify="right"]': {
        'text-align': 'right',
        'justify-content': 'right',
    },
};
//# sourceMappingURL=common.js.map
;// ./components/mjs/core/lib/core/Tree/WrapperFactory.js
const WrapperFactory_def = MathJax._.core.Tree.WrapperFactory;
const AbstractWrapperFactory = WrapperFactory_def.AbstractWrapperFactory;

;// ./mjs/output/common/WrapperFactory.js

class CommonWrapperFactory extends AbstractWrapperFactory {
    constructor() {
        super(...arguments);
        this.jax = null;
    }
    get Wrappers() {
        return this.node;
    }
}
CommonWrapperFactory.defaultNodes = {};
//# sourceMappingURL=WrapperFactory.js.map
;// ./components/mjs/core/lib/core/Tree/Wrapper.js
const Wrapper_def = MathJax._.core.Tree.Wrapper;
const AbstractWrapper = Wrapper_def.AbstractWrapper;

;// ./components/mjs/core/lib/util/string.js
const string_def = MathJax._.util.string;
const sortLength = string_def.sortLength;
const quotePattern = string_def.quotePattern;
const unicodeChars = string_def.unicodeChars;
const unicodeString = string_def.unicodeString;
const isPercent = string_def.isPercent;
const split = string_def.split;
const replaceUnicode = string_def.replaceUnicode;
const toEntity = string_def.toEntity;

;// ./mjs/output/common/Wrapper.js









const SMALLSIZE = 2 / 18;
const MOSPACE = 5 / 18;
function MathMLSpace(script, nodict, size) {
    return nodict
        ? script
            ? SMALLSIZE
            : MOSPACE
        : script
            ? size < SMALLSIZE
                ? 0
                : SMALLSIZE
            : size;
}
const SPACE = {
    [em(0)]: '0',
    [em(2 / 18)]: '1',
    [em(3 / 18)]: '2',
    [em(4 / 18)]: '3',
    [em(5 / 18)]: '4',
    [em(6 / 18)]: '5'
};
class CommonWrapper extends AbstractWrapper {
    static addStyles(styles, _jax) {
        styles.addStyles(this.styles);
    }
    get jax() {
        return this.factory.jax;
    }
    get adaptor() {
        return this.factory.jax.adaptor;
    }
    get metrics() {
        return this.factory.jax.math.metrics;
    }
    get containerWidth() {
        return this.jax.containerWidth;
    }
    get linebreaks() {
        return this.jax.linebreaks;
    }
    get linebreakOptions() {
        return this.jax.options.linebreaks;
    }
    get fixesPWidth() {
        return !this.node.notParent && !this.node.isToken;
    }
    get breakCount() {
        if (this._breakCount < 0) {
            const node = this.node;
            this._breakCount = node.isEmbellished
                ? this.coreMO().embellishedBreakCount
                : node.arity < 0 &&
                    !node.linebreakContainer &&
                    this.childNodes[0]
                        .isStack
                    ? this.childNodes[0].breakCount
                    : 0;
        }
        return this._breakCount;
    }
    breakTop(mrow, _child) {
        return this.node.linebreakContainer || !this.parent
            ? mrow
            : this.parent.breakTop(mrow, this);
    }
    constructor(factory, node, parent = null) {
        super(factory, node);
        this.parent = null;
        this.dom = null;
        this.removedStyles = null;
        this.styles = null;
        this.styleData = null;
        this.variant = '';
        this.bboxComputed = false;
        this._breakCount = -1;
        this.lineBBox = [];
        this.stretch = NOSTRETCH;
        this.font = null;
        this.parent = parent;
        this.font = factory.jax.font;
        this.bbox = BBox.zero();
        this.getStyles();
        this.getStyleData();
        this.getVariant();
        this.getScale();
        this.getSpace();
        this.childNodes = node.childNodes.map((child) => {
            const wrapped = this.wrap(child);
            if (wrapped.bbox.pwidth && (node.notParent || node.isKind('math'))) {
                this.bbox.pwidth = BBox.fullWidth;
            }
            return wrapped;
        });
    }
    wrap(node, parent = null) {
        const wrapped = this.factory.wrap(node, parent || this);
        if (parent) {
            parent.childNodes.push(wrapped);
        }
        this.jax.nodeMap.set(node, wrapped);
        return wrapped;
    }
    getBBox(save = true) {
        if (this.bboxComputed) {
            return this.bbox;
        }
        const bbox = save ? this.bbox : BBox.zero();
        this.computeBBox(bbox);
        this.bboxComputed = save;
        return bbox;
    }
    getOuterBBox(save = true) {
        var _a;
        const bbox = this.getBBox(save);
        if (!this.styleData)
            return bbox;
        const padding = this.styleData.padding;
        const border = ((_a = this.styleData.border) === null || _a === void 0 ? void 0 : _a.width) || [0, 0, 0, 0];
        const obox = bbox.copy();
        for (const [, i, side] of BBox.boxSides) {
            obox[side] += padding[i] + border[i];
        }
        return obox;
    }
    getUnbrokenHD() {
        const n = this.breakCount + 1;
        let H = 0;
        let D = 0;
        for (let i = 0; i < n; i++) {
            const { h, d } = this.getLineBBox(i);
            if (h > H) {
                H = h;
            }
            if (d > D) {
                D = d;
            }
        }
        return [H, D];
    }
    computeBBox(bbox, recompute = false) {
        bbox.empty();
        for (const child of this.childNodes) {
            bbox.append(child.getOuterBBox());
        }
        bbox.clean();
        if (this.fixesPWidth && this.setChildPWidths(recompute)) {
            this.computeBBox(bbox, true);
        }
    }
    getLineBBox(i) {
        if (!this.lineBBox[i]) {
            const n = this.breakCount;
            if (n) {
                const line = this.embellishedBBox(i) || this.computeLineBBox(i);
                this.lineBBox[i] = line;
                if (i === 0) {
                    if (!this.node.isKind('mo') && this.node.isEmbellished) {
                        line.originalL = this.getBBox().L;
                    }
                    else {
                        line.L = this.getBBox().L;
                    }
                }
                if (i === n) {
                    line.R = this.getBBox().R;
                }
            }
            else {
                const obox = this.getOuterBBox();
                this.lineBBox[i] = LineBBox.from(obox, this.linebreakOptions.lineleading);
            }
        }
        return this.lineBBox[i];
    }
    embellishedBBox(i) {
        if (!this.node.isEmbellished || this.node.isKind('mo'))
            return null;
        const mo = this.coreMO();
        return mo.moLineBBox(i, mo.embellishedBreakStyle, this.getOuterBBox());
    }
    computeLineBBox(i) {
        return this.getChildLineBBox(this.childNodes[0], i);
    }
    getBreakNode(bbox) {
        var _a, _b;
        if (!bbox.start) {
            return [this, null];
        }
        const [i, j] = bbox.start;
        if (this.node.isEmbellished) {
            return [this, this.coreMO()];
        }
        const childNodes = ((_b = (_a = this.childNodes[0]) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.isInferred)
            ? this.childNodes[0].childNodes
            : this.childNodes;
        if (this.node.isToken || !childNodes[i]) {
            return [this, null];
        }
        return childNodes[i].getBreakNode(childNodes[i].getLineBBox(j));
    }
    getChildLineBBox(child, i) {
        const n = this.breakCount;
        let cbox = child.getLineBBox(i);
        if (this.styleData || this.bbox.L || this.bbox.R) {
            cbox = cbox.copy();
        }
        this.addMiddleBorders(cbox);
        if (i === 0) {
            cbox.L += this.bbox.L;
            this.addLeftBorders(cbox);
        }
        else if (i === n) {
            cbox.R += this.bbox.R;
            this.addRightBorders(cbox);
        }
        return cbox;
    }
    addLeftBorders(bbox) {
        var _a;
        if (!this.styleData)
            return;
        const border = this.styleData.border;
        const padding = this.styleData.padding;
        bbox.w += (((_a = border === null || border === void 0 ? void 0 : border.width) === null || _a === void 0 ? void 0 : _a[3]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[3]) || 0);
    }
    addMiddleBorders(bbox) {
        var _a, _b;
        if (!this.styleData)
            return;
        const border = this.styleData.border;
        const padding = this.styleData.padding;
        bbox.h += (((_a = border === null || border === void 0 ? void 0 : border.width) === null || _a === void 0 ? void 0 : _a[0]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[0]) || 0);
        bbox.d += (((_b = border === null || border === void 0 ? void 0 : border.width) === null || _b === void 0 ? void 0 : _b[2]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[2]) || 0);
    }
    addRightBorders(bbox) {
        var _a;
        if (!this.styleData)
            return;
        const border = this.styleData.border;
        const padding = this.styleData.padding;
        bbox.w += (((_a = border === null || border === void 0 ? void 0 : border.width) === null || _a === void 0 ? void 0 : _a[1]) || 0) + ((padding === null || padding === void 0 ? void 0 : padding[1]) || 0);
    }
    setChildPWidths(recompute, w = null, clear = true) {
        if (recompute) {
            return false;
        }
        if (clear) {
            this.bbox.pwidth = '';
        }
        let changed = false;
        for (const child of this.childNodes) {
            const cbox = child.getBBox();
            if (cbox.pwidth &&
                child.setChildPWidths(recompute, w === null ? cbox.w : w, clear)) {
                changed = true;
            }
        }
        return changed;
    }
    breakToWidth(_W) {
    }
    invalidateBBox(bubble = true) {
        if (this.bboxComputed || this._breakCount >= 0) {
            this.bboxComputed = false;
            this.lineBBox = [];
            this._breakCount = -1;
            if (this.parent && bubble) {
                this.parent.invalidateBBox();
            }
        }
    }
    copySkewIC(bbox) {
        var _a, _b, _c;
        const first = this.childNodes[0];
        if ((_a = first === null || first === void 0 ? void 0 : first.bbox) === null || _a === void 0 ? void 0 : _a.sk) {
            bbox.sk = first.bbox.sk;
        }
        if ((_b = first === null || first === void 0 ? void 0 : first.bbox) === null || _b === void 0 ? void 0 : _b.dx) {
            bbox.dx = first.bbox.dx;
        }
        const last = this.childNodes[this.childNodes.length - 1];
        if ((_c = last === null || last === void 0 ? void 0 : last.bbox) === null || _c === void 0 ? void 0 : _c.ic) {
            bbox.ic = last.bbox.ic;
            bbox.w += bbox.ic;
        }
    }
    getStyles() {
        const styleString = this.node.attributes.getExplicit('style');
        if (!styleString)
            return;
        const style = (this.styles = new Styles(styleString));
        for (let i = 0, m = CommonWrapper.removeStyles.length; i < m; i++) {
            const id = CommonWrapper.removeStyles[i];
            if (style.get(id)) {
                if (!this.removedStyles)
                    this.removedStyles = {};
                this.removedStyles[id] = style.get(id);
                style.set(id, '');
            }
        }
    }
    getStyleData() {
        if (!this.styles)
            return;
        const padding = Array(4).fill(0);
        const width = Array(4).fill(0);
        const style = Array(4);
        const color = Array(4);
        let hasPadding = false;
        let hasBorder = false;
        for (const [name, i] of BBox.boxSides) {
            const key = 'border' + name;
            const w = this.styles.get(key + 'Width');
            if (w) {
                hasBorder = true;
                width[i] = Math.max(0, this.length2em(w, 1));
                style[i] = this.styles.get(key + 'Style') || 'solid';
                color[i] = this.styles.get(key + 'Color');
            }
            const p = this.styles.get('padding' + name);
            if (p) {
                hasPadding = true;
                padding[i] = Math.max(0, this.length2em(p, 1));
            }
        }
        this.styleData =
            hasPadding || hasBorder
                ? {
                    padding,
                    border: hasBorder ? { width, style, color } : null,
                }
                : null;
    }
    getVariant() {
        if (!this.node.isToken)
            return;
        const attributes = this.node.attributes;
        let variant = attributes.get('mathvariant');
        if (attributes.hasExplicit('mathvariant')) {
            if (!this.font.getVariant(variant)) {
                console.warn(`Invalid variant: ${variant}`);
                variant = 'normal';
            }
        }
        else {
            const values = attributes.getList('fontfamily', 'fontweight', 'fontstyle');
            if (this.removedStyles) {
                const style = this.removedStyles;
                if (style.fontFamily)
                    values.family = style.fontFamily;
                if (style.fontWeight)
                    values.weight = style.fontWeight;
                if (style.fontStyle)
                    values.style = style.fontStyle;
            }
            if (values.fontfamily)
                values.family = values.fontfamily;
            if (values.fontweight)
                values.weight = values.fontweight;
            if (values.fontstyle)
                values.style = values.fontstyle;
            if (values.weight && values.weight.match(/^\d+$/)) {
                values.weight = parseInt(values.weight) > 600 ? 'bold' : 'normal';
            }
            if (values.family) {
                variant = this.explicitVariant(values.family, values.weight, values.style);
            }
            else {
                if (this.node.getProperty('variantForm'))
                    variant = '-tex-variant';
                variant =
                    (CommonWrapper.BOLDVARIANTS[values.weight] || {})[variant] || variant;
                variant =
                    (CommonWrapper.ITALICVARIANTS[values.style] || {})[variant] ||
                        variant;
            }
        }
        this.variant = variant;
    }
    explicitVariant(fontFamily, fontWeight, fontStyle) {
        let style = this.styles;
        if (!style)
            style = this.styles = new Styles();
        style.set('fontFamily', fontFamily);
        if (fontWeight)
            style.set('fontWeight', fontWeight);
        if (fontStyle)
            style.set('fontStyle', fontStyle);
        return '-explicitFont';
    }
    getScale() {
        let scale = 1;
        const parent = this.parent;
        const pscale = parent ? parent.bbox.scale : 1;
        const attributes = this.node.attributes;
        const scriptlevel = Math.min(attributes.get('scriptlevel'), 2);
        let fontsize = attributes.get('fontsize');
        let mathsize = this.node.isToken || this.node.isKind('mstyle')
            ? attributes.get('mathsize')
            : attributes.getInherited('mathsize');
        if (scriptlevel !== 0) {
            scale = Math.pow(attributes.get('scriptsizemultiplier'), scriptlevel);
        }
        if (this.removedStyles && this.removedStyles.fontSize && !fontsize) {
            fontsize = this.removedStyles.fontSize;
        }
        if (fontsize && !attributes.hasExplicit('mathsize')) {
            mathsize = fontsize;
        }
        if (mathsize !== '1') {
            scale *= this.length2em(mathsize, 1, 1);
        }
        if (scriptlevel !== 0) {
            const scriptminsize = this.length2em(attributes.get('scriptminsize'), 0.4, 1);
            if (scale < scriptminsize)
                scale = scriptminsize;
        }
        this.bbox.scale = scale;
        this.bbox.rscale = scale / pscale;
    }
    getSpace() {
        const isTop = this.isTopEmbellished();
        const hasSpacing = this.node.hasSpacingAttributes();
        if (this.jax.options.mathmlSpacing || hasSpacing) {
            if (isTop) {
                this.getMathMLSpacing();
            }
        }
        else {
            this.getTeXSpacing(isTop, hasSpacing);
        }
    }
    getMathMLSpacing() {
        const node = this.node.coreMO();
        const child = node.coreParent();
        const parent = child.parent;
        if (!parent || !parent.isKind('mrow') || parent.childNodes.length === 1) {
            return;
        }
        const n = parent.childIndex(child);
        if (n === null)
            return;
        const noDictDef = node.getProperty('noDictDef');
        const attributes = node.attributes;
        const isScript = attributes.get('scriptlevel') > 0;
        this.bbox.L = attributes.isSet('lspace')
            ? Math.max(0, this.length2em(attributes.get('lspace')))
            : MathMLSpace(isScript, noDictDef, node.lspace);
        this.bbox.R = attributes.isSet('rspace')
            ? Math.max(0, this.length2em(attributes.get('rspace')))
            : MathMLSpace(isScript, noDictDef, node.rspace);
        if (!n)
            return;
        const prev = parent.childNodes[n - 1];
        if (!prev.isEmbellished)
            return;
        const bbox = this.jax.nodeMap.get(prev).getBBox();
        if (bbox.R) {
            this.bbox.L = Math.max(0, this.bbox.L - bbox.R);
        }
    }
    getTeXSpacing(isTop, hasSpacing) {
        if (!hasSpacing) {
            const space = this.node.texSpacing();
            if (space) {
                this.bbox.L = this.length2em(space);
            }
        }
        if (isTop || hasSpacing) {
            const attributes = this.node.coreMO().attributes;
            if (attributes.isSet('lspace')) {
                this.bbox.L = Math.max(0, this.length2em(attributes.get('lspace')));
            }
            if (attributes.isSet('rspace')) {
                this.bbox.R = Math.max(0, this.length2em(attributes.get('rspace')));
            }
        }
    }
    isTopEmbellished() {
        return (this.node.isEmbellished &&
            !(this.node.parent && this.node.parent.isEmbellished));
    }
    core() {
        return this.jax.nodeMap.get(this.node.core());
    }
    coreMO() {
        return this.jax.nodeMap.get(this.node.coreMO());
    }
    coreRScale() {
        let rscale = this.bbox.rscale;
        let node = this.coreMO();
        while (node !== this && node) {
            rscale *= node.bbox.rscale;
            node = node.parent;
        }
        return rscale;
    }
    getRScale() {
        let rscale = 1;
        let node = this;
        while (node) {
            rscale *= node.bbox.rscale;
            node = node.parent;
        }
        return rscale;
    }
    getText() {
        let text = '';
        if (this.node.isToken) {
            for (const child of this.node.childNodes) {
                if (child instanceof TextNode) {
                    text += child.getText();
                }
            }
        }
        return text;
    }
    canStretch(direction) {
        this.stretch = NOSTRETCH;
        if (this.node.isEmbellished) {
            const core = this.core();
            if (core && core.node !== this.node) {
                if (core.canStretch(direction)) {
                    this.stretch = core.stretch;
                }
            }
        }
        return this.stretch.dir !== DIRECTION.None;
    }
    getAlignShift() {
        let { indentalign, indentshift, indentalignfirst, indentshiftfirst } = this.node.attributes.getAllAttributes();
        if (indentalignfirst !== 'indentalign') {
            indentalign = indentalignfirst;
        }
        if (indentshiftfirst !== 'indentshift') {
            indentshift = indentshiftfirst;
        }
        return this.processIndent(indentalign, indentshift);
    }
    processIndent(indentalign, indentshift, align = '', shift = '', width = this.metrics.containerWidth) {
        if (!this.jax.math.display) {
            return ['left', 0];
        }
        if (!align || align === 'auto') {
            align = this.jax.math.root.getProperty('inlineMarked')
                ? 'left'
                : this.jax.options.displayAlign;
        }
        if (!shift || shift === 'auto') {
            shift = this.jax.math.root.getProperty('inlineMarked')
                ? '0'
                : this.jax.options.displayIndent;
        }
        if (indentalign === 'auto') {
            indentalign = align;
        }
        if (indentshift === 'auto') {
            indentshift = shift;
            if (indentalign === 'right' && !indentshift.match(/^\s*0[a-z]*\s*$/)) {
                indentshift = ('-' + indentshift.trim()).replace(/^--/, '');
            }
        }
        const indent = this.length2em(indentshift, width);
        return [indentalign, indent];
    }
    getAlignX(W, bbox, align) {
        return align === 'right'
            ? W - (bbox.w + bbox.R) * bbox.rscale
            : align === 'left'
                ? bbox.L * bbox.rscale
                : (W - bbox.w * bbox.rscale) / 2;
    }
    getAlignY(H, D, h, d, align) {
        return align === 'top'
            ? H - h
            : align === 'bottom'
                ? d - D
                : align === 'center'
                    ? (H - h - (D - d)) / 2
                    : 0;
    }
    getWrapWidth(i) {
        return this.childNodes[i].getBBox().w;
    }
    getChildAlign(_i) {
        return 'left';
    }
    percent(m) {
        return percent(m);
    }
    em(m) {
        return em(m);
    }
    px(m, M = -BIGDIMEN) {
        return px(m, M, this.metrics.em);
    }
    length2em(length, size = 1, scale = null) {
        if (scale === null) {
            scale = this.bbox.scale;
        }
        const t = this.font.params.rule_thickness;
        const factor = lookup(length, { medium: 1, thin: 2 / 3, thick: 5 / 3 }, 0);
        return factor
            ? factor * t
            : length2em(length, size, scale, this.jax.pxPerEm);
    }
    unicodeChars(text, name = this.variant) {
        let chars = unicodeChars(text);
        const variant = this.font.getVariant(name);
        if (variant && variant.chars) {
            const map = variant.chars;
            chars = chars.map((n) => { var _a, _b; return ((_b = (_a = map[n]) === null || _a === void 0 ? void 0 : _a[3]) === null || _b === void 0 ? void 0 : _b.smp) || n; });
        }
        return chars;
    }
    remapChars(chars) {
        return chars;
    }
    mmlText(text) {
        return this.node.factory.create('text').setText(text);
    }
    mmlNode(kind, properties = {}, children = []) {
        return this.node.factory.create(kind, properties, children);
    }
    createMo(text) {
        const mmlFactory = this.node.factory;
        const textNode = mmlFactory.create('text').setText(text);
        const mml = mmlFactory.create('mo', { stretchy: true }, [textNode]);
        mml.inheritAttributesFrom(this.node);
        mml.parent = this.node.parent;
        const node = this.wrap(mml);
        node.parent = this;
        return node;
    }
    getVariantChar(variant, n) {
        const char = this.font.getChar(variant, n) || [0, 0, 0, { unknown: true }];
        if (char.length === 3) {
            char[3] = {};
        }
        return char;
    }
    html(type, def = {}, content = []) {
        return this.jax.html(type, def, content);
    }
}
CommonWrapper.kind = 'unknown';
CommonWrapper.styles = {};
CommonWrapper.removeStyles = [
    'fontSize',
    'fontFamily',
    'fontWeight',
    'fontStyle',
    'fontVariant',
    'font',
];
CommonWrapper.skipAttributes = {
    fontfamily: true,
    fontsize: true,
    fontweight: true,
    fontstyle: true,
    color: true,
    background: true,
    class: true,
    href: true,
    style: true,
    xmlns: true,
};
CommonWrapper.BOLDVARIANTS = {
    bold: {
        normal: 'bold',
        italic: 'bold-italic',
        fraktur: 'bold-fraktur',
        script: 'bold-script',
        'sans-serif': 'bold-sans-serif',
        'sans-serif-italic': 'sans-serif-bold-italic',
    },
    normal: {
        bold: 'normal',
        'bold-italic': 'italic',
        'bold-fraktur': 'fraktur',
        'bold-script': 'script',
        'bold-sans-serif': 'sans-serif',
        'sans-serif-bold-italic': 'sans-serif-italic',
    },
};
CommonWrapper.ITALICVARIANTS = {
    italic: {
        normal: 'italic',
        bold: 'bold-italic',
        'sans-serif': 'sans-serif-italic',
        'bold-sans-serif': 'sans-serif-bold-italic',
    },
    normal: {
        italic: 'normal',
        'bold-italic': 'bold',
        'sans-serif-italic': 'sans-serif',
        'sans-serif-bold-italic': 'bold-sans-serif',
    },
};
//# sourceMappingURL=Wrapper.js.map
;// ./mjs/output/chtml/Wrapper.js


const FONTSIZE = {
    '70.7%': 's',
    '70%': 's',
    '50%': 'ss',
    '60%': 'Tn',
    '85%': 'sm',
    '120%': 'lg',
    '144%': 'Lg',
    '173%': 'LG',
    '207%': 'hg',
    '249%': 'HG',
};
class ChtmlWrapper extends CommonWrapper {
    toCHTML(parents) {
        if (this.toEmbellishedCHTML(parents))
            return;
        this.addChildren(this.standardChtmlNodes(parents));
    }
    toEmbellishedCHTML(parents) {
        if (parents.length <= 1 || !this.node.isEmbellished)
            return false;
        const adaptor = this.adaptor;
        parents.forEach((dom) => adaptor.append(dom, this.html('mjx-linestrut')));
        const style = this.coreMO().embellishedBreakStyle;
        const dom = [];
        for (const [parent, STYLE] of [
            [parents[0], 'before'],
            [parents[1], 'after'],
        ]) {
            if (style !== STYLE) {
                this.toCHTML([parent]);
                dom.push(this.dom[0]);
                if (STYLE === 'after') {
                    adaptor.removeAttribute(this.dom[0], 'space');
                }
            }
            else {
                dom.push(this.createChtmlNodes([parent])[0]);
            }
        }
        this.dom = dom;
        return true;
    }
    addChildren(parents) {
        for (const child of this.childNodes) {
            child.toCHTML(parents);
        }
    }
    standardChtmlNodes(parents) {
        this.markUsed();
        const chtml = this.createChtmlNodes(parents);
        this.handleStyles();
        this.handleScale();
        this.handleBorders();
        this.handleColor();
        this.handleSpace();
        this.handleAttributes();
        this.handlePWidth();
        return chtml;
    }
    markUsed() {
        this.jax.wrapperUsage.add(this.kind);
    }
    createChtmlNodes(parents) {
        this.dom = parents.map((_parent) => this.html('mjx-' + this.node.kind));
        parents = this.handleHref(parents);
        for (const i of parents.keys()) {
            this.adaptor.append(parents[i], this.dom[i]);
        }
        return this.dom;
    }
    handleHref(parents) {
        const href = this.node.attributes.get('href');
        if (!href)
            return parents;
        return parents.map((parent) => this.adaptor.append(parent, this.html('a', { href: href })));
    }
    handleStyles() {
        if (!this.styles)
            return;
        const styles = this.styles.cssText;
        if (styles) {
            const adaptor = this.adaptor;
            this.dom.forEach((dom) => adaptor.setAttribute(dom, 'style', styles));
            const family = this.styles.get('font-family');
            if (family) {
                this.dom.forEach((dom) => adaptor.setStyle(dom, 'font-family', this.font.cssFamilyPrefix + ', ' + family));
            }
        }
    }
    handleScale() {
        this.dom.forEach((dom) => this.setScale(dom, this.bbox.rscale));
    }
    setScale(chtml, rscale) {
        const scale = Math.abs(rscale - 1) < 0.001 ? 1 : rscale;
        if (chtml && scale !== 1) {
            const size = this.percent(scale);
            if (FONTSIZE[size]) {
                this.adaptor.setAttribute(chtml, 'size', FONTSIZE[size]);
            }
            else {
                this.adaptor.setStyle(chtml, 'fontSize', size);
            }
        }
        return chtml;
    }
    handleSpace() {
        const adaptor = this.adaptor;
        const breakable = !!this.node.getProperty('breakable') && !this.node.getProperty('newline');
        const n = this.dom.length - 1;
        for (const data of [
            [this.getLineBBox(0).L, 'space', 'marginLeft', 0],
            [this.getLineBBox(n).R, 'rspace', 'marginRight', n],
        ]) {
            const [dimen, name, margin, i] = data;
            const space = this.em(dimen);
            if (breakable && name === 'space') {
                const node = adaptor.node('mjx-break', SPACE[space]
                    ? { size: SPACE[space] }
                    : { style: `letter-spacing: ${this.em(dimen - 1)}` }, [adaptor.text(' ')]);
                adaptor.insert(node, this.dom[i]);
            }
            else if (dimen) {
                if (SPACE[space]) {
                    adaptor.setAttribute(this.dom[i], name, SPACE[space]);
                }
                else {
                    adaptor.setStyle(this.dom[i], margin, space);
                }
            }
        }
    }
    handleBorders() {
        var _a, _b;
        const border = (_a = this.styleData) === null || _a === void 0 ? void 0 : _a.border;
        const padding = (_b = this.styleData) === null || _b === void 0 ? void 0 : _b.padding;
        const n = this.dom.length - 1;
        if (!border || !n)
            return;
        const adaptor = this.adaptor;
        for (const k of this.dom.keys()) {
            const dom = this.dom[k];
            if (k) {
                if (border.width[3]) {
                    adaptor.setStyle(dom, 'border-left', ' none');
                }
                if (padding[3]) {
                    adaptor.setStyle(dom, 'padding-left', '0');
                }
            }
            if (k !== n) {
                if (border.width[1]) {
                    adaptor.setStyle(dom, 'border-right', 'none');
                }
                if (padding[1]) {
                    adaptor.setStyle(dom, 'padding-right', '0');
                }
            }
        }
    }
    handleColor() {
        var _a;
        const adaptor = this.adaptor;
        const attributes = this.node.attributes;
        const color = (attributes.getExplicit('mathcolor') ||
            attributes.getExplicit('color'));
        const background = (attributes.getExplicit('mathbackground') ||
            attributes.getExplicit('background') ||
            ((_a = this.styles) === null || _a === void 0 ? void 0 : _a.get('background-color')));
        if (color) {
            this.dom.forEach((dom) => adaptor.setStyle(dom, 'color', color));
        }
        if (background) {
            this.dom.forEach((dom) => adaptor.setStyle(dom, 'backgroundColor', background));
        }
    }
    handleAttributes() {
        const adaptor = this.adaptor;
        const attributes = this.node.attributes;
        const defaults = attributes.getAllDefaults();
        const skip = ChtmlWrapper.skipAttributes;
        for (const name of attributes.getExplicitNames()) {
            if (skip[name] === false ||
                (!(name in defaults) &&
                    !skip[name] &&
                    !adaptor.hasAttribute(this.dom[0], name))) {
                const value = attributes.getExplicit(name);
                this.dom.forEach((dom) => adaptor.setAttribute(dom, name, value));
            }
        }
        if (attributes.get('class')) {
            const names = attributes.get('class').trim().split(/ +/);
            for (const name of names) {
                this.dom.forEach((dom) => adaptor.addClass(dom, name));
            }
        }
        if (this.node.getProperty('inline-breaks')) {
            this.dom.forEach((dom) => adaptor.setAttribute(dom, 'inline-breaks', 'true'));
        }
    }
    handlePWidth() {
        if (this.bbox.pwidth) {
            const adaptor = this.adaptor;
            if (this.bbox.pwidth === BBox.fullWidth) {
                this.dom.forEach((dom) => adaptor.setAttribute(dom, 'width', 'full'));
            }
            else {
                this.dom.forEach((dom) => adaptor.setStyle(dom, 'width', this.bbox.pwidth));
            }
        }
    }
    setIndent(chtml, align, shift) {
        const adaptor = this.adaptor;
        if (align === 'center' || align === 'left') {
            const L = this.getBBox().L;
            adaptor.setStyle(chtml, 'margin-left', this.em(shift + L));
        }
        if (align === 'center' || align === 'right') {
            const R = this.getBBox().R;
            adaptor.setStyle(chtml, 'margin-right', this.em(-shift + R));
        }
    }
    drawBBox() {
        const { w, h, d, R } = this.getOuterBBox();
        const box = this.html('mjx-box', {
            style: {
                opacity: 0.25,
                'margin-left': this.em(-w - R),
            },
        }, [
            this.html('mjx-box', {
                style: {
                    height: this.em(h),
                    width: this.em(w),
                    'background-color': 'red',
                },
            }),
            this.html('mjx-box', {
                style: {
                    height: this.em(d),
                    width: this.em(w),
                    'margin-left': this.em(-w),
                    'vertical-align': this.em(-d),
                    'background-color': 'green',
                },
            }),
        ]);
        const node = this.dom[0] || this.parent.dom[0];
        const size = this.adaptor.getAttribute(node, 'size');
        if (size) {
            this.adaptor.setAttribute(box, 'size', size);
        }
        const fontsize = this.adaptor.getStyle(node, 'fontSize');
        if (fontsize) {
            this.adaptor.setStyle(box, 'fontSize', fontsize);
        }
        this.adaptor.append(this.adaptor.parent(node), box);
        this.adaptor.setStyle(node, 'backgroundColor', '#FFEE00');
    }
    html(type, def = {}, content = []) {
        return this.jax.html(type, def, content);
    }
    text(text) {
        return this.jax.text(text);
    }
    char(n) {
        return this.font.charSelector(n).substring(1);
    }
}
ChtmlWrapper.kind = 'unknown';
ChtmlWrapper.autoStyle = true;
//# sourceMappingURL=Wrapper.js.map
;// ./mjs/output/common/Wrappers/math.js
function CommonMathMixin(Base) {
    return class CommonMathMixin extends Base {
        getWrapWidth(_i) {
            return this.parent
                ? this.getBBox().w
                : this.metrics.containerWidth / this.jax.pxPerEm;
        }
        computeBBox(bbox, recompute = false) {
            super.computeBBox(bbox, recompute);
            const attributes = this.node.attributes;
            if (!this.parent &&
                this.jax.math.display &&
                attributes.get('overflow') === 'linebreak') {
                const W = this.containerWidth;
                if (bbox.w > W) {
                    this.childNodes[0].breakToWidth(W);
                }
                bbox.updateFrom(this.childNodes[0].getBBox());
            }
        }
    };
}
//# sourceMappingURL=math.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/math.js
const math_def = MathJax._.core.MmlTree.MmlNodes.math;
const MmlMath = math_def.MmlMath;

;// ./mjs/output/chtml/Wrappers/math.js




const ChtmlMath = (function () {
    var _a;
    const Base = CommonMathMixin(ChtmlWrapper);
    return _a = class ChtmlMath extends Base {
            handleDisplay(parent) {
                const adaptor = this.adaptor;
                const [align, shift] = this.getAlignShift();
                if (align !== 'center') {
                    adaptor.setAttribute(parent, 'justify', align);
                }
                if (this.bbox.pwidth === BBox.fullWidth) {
                    adaptor.setAttribute(parent, 'width', 'full');
                    if (this.jax.table) {
                        let { L, w, R } = this.jax.table.getOuterBBox();
                        if (align === 'right') {
                            R = Math.max(R || -shift, -shift);
                        }
                        else if (align === 'left') {
                            L = Math.max(L || shift, shift);
                        }
                        else if (align === 'center') {
                            w += 2 * Math.abs(shift);
                        }
                        const W = this.em(Math.max(0, L + w + R));
                        adaptor.setStyle(parent, 'min-width', W);
                        adaptor.setStyle(this.jax.table.dom[0], 'min-width', W);
                    }
                }
                else {
                    this.setIndent(this.dom[0], align, shift);
                }
            }
            handleInline(parent) {
                const adaptor = this.adaptor;
                const margin = adaptor.getStyle(this.dom[0], 'margin-right');
                if (margin) {
                    adaptor.setStyle(this.dom[0], 'margin-right', '');
                    adaptor.setStyle(parent, 'margin-right', margin);
                    adaptor.setStyle(parent, 'width', '0');
                }
            }
            toCHTML(parents) {
                super.toCHTML(parents);
                const adaptor = this.adaptor;
                const display = this.node.attributes.get('display') === 'block';
                if (display) {
                    adaptor.setAttribute(this.dom[0], 'display', 'true');
                    adaptor.setAttribute(parents[0], 'display', 'true');
                    this.handleDisplay(parents[0]);
                }
                else {
                    this.handleInline(parents[0]);
                }
                adaptor.addClass(this.dom[0], `${this.font.cssFontPrefix}-N`);
            }
            setChildPWidths(recompute, w = null, clear = true) {
                return this.parent ? super.setChildPWidths(recompute, w, clear) : false;
            }
            handleAttributes() {
                super.handleAttributes();
                const adaptor = this.adaptor;
                if (this.node.getProperty('process-breaks')) {
                    this.dom.forEach((dom) => adaptor.setAttribute(dom, 'breakable', 'true'));
                }
            }
        },
        _a.kind = MmlMath.prototype.kind,
        _a.styles = {
            'mjx-math': {
                'line-height': 0,
                'text-align': 'left',
                'text-indent': 0,
                'font-style': 'normal',
                'font-weight': 'normal',
                'font-size': '100%',
                'font-size-adjust': 'none',
                'letter-spacing': 'normal',
                'word-wrap': 'normal',
                'word-spacing': 'normal',
                direction: 'ltr',
                padding: '1px 0',
            },
            'mjx-container[jax="CHTML"][display="true"] mjx-math': {
                padding: 0,
            },
            'mjx-math[breakable]': {
                display: 'inline',
            },
            'mjx-container[jax="CHTML"] mjx-break': {
                'white-space': 'normal',
                'line-height': '0',
                'clip-path': 'rect(0 0 0 0)',
                'font-family': 'MJX-BRK !important',
            },
            'mjx-break[size="0"]': {
                'letter-spacing': 0.001 - 1 + 'em',
            },
            'mjx-break[size="1"]': {
                'letter-spacing': 0.111 - 1 + 'em',
            },
            'mjx-break[size="2"]': {
                'letter-spacing': 0.167 - 1 + 'em',
            },
            'mjx-break[size="3"]': {
                'letter-spacing': 0.222 - 1 + 'em',
            },
            'mjx-break[size="4"]': {
                'letter-spacing': 0.278 - 1 + 'em',
            },
            'mjx-break[size="5"]': {
                'letter-spacing': 0.333 - 1 + 'em',
            },
        },
        _a;
})();
//# sourceMappingURL=math.js.map
;// ./mjs/output/common/Wrappers/mi.js
function CommonMiMixin(Base) {
    return class CommonMiMixin extends Base {
        computeBBox(bbox, _recompute = false) {
            super.computeBBox(bbox);
            this.copySkewIC(bbox);
        }
    };
}
//# sourceMappingURL=mi.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mi.js
const mi_def = MathJax._.core.MmlTree.MmlNodes.mi;
const MmlMi = mi_def.MmlMi;

;// ./mjs/output/chtml/Wrappers/mi.js



const ChtmlMi = (function () {
    var _a;
    const Base = CommonMiMixin(ChtmlWrapper);
    return _a = class ChtmlMi extends Base {
        },
        _a.kind = MmlMi.prototype.kind,
        _a;
})();
//# sourceMappingURL=mi.js.map
;// ./mjs/output/common/Wrappers/mo.js





function CommonMoMixin(Base) {
    return class CommonMoMixin extends Base {
        get breakCount() {
            return this.breakStyle ? 1 : 0;
        }
        get embellishedBreakCount() {
            return this.embellishedBreakStyle ? 1 : 0;
        }
        get embellishedBreakStyle() {
            return this.breakStyle || this.getBreakStyle();
        }
        protoBBox(bbox) {
            const stretchy = this.stretch.dir !== DIRECTION.None;
            if (stretchy && this.size === null) {
                this.getStretchedVariant([0]);
            }
            if (stretchy && this.size < 0)
                return;
            super.computeBBox(bbox);
            if (bbox.w === 0 &&
                this.node.attributes.hasExplicit('fence') &&
                this.node.getText() === '' &&
                (this.node.texClass === TEXCLASS.OPEN ||
                    this.node.texClass === TEXCLASS.CLOSE) &&
                !this.jax.options.mathmlSpacing) {
                bbox.R = this.font.params.nulldelimiterspace;
            }
            this.copySkewIC(bbox);
        }
        getAccentOffset() {
            const bbox = BBox.empty();
            this.protoBBox(bbox);
            return -bbox.w / 2;
        }
        getCenterOffset(bbox = null) {
            if (!bbox) {
                bbox = BBox.empty();
                super.computeBBox(bbox);
            }
            return (bbox.h + bbox.d) / 2 + this.font.params.axis_height - bbox.h;
        }
        getStretchedVariant(WH, exact = false) {
            if (this.stretch.dir !== DIRECTION.None) {
                let D = this.getWH(WH);
                const min = this.getSize('minsize', 0);
                const max = this.getSize('maxsize', Infinity);
                const mathaccent = this.node.getProperty('mathaccent');
                D = Math.max(min, Math.min(max, D));
                const df = this.font.params.delimiterfactor / 1000;
                const ds = this.font.params.delimitershortfall;
                const m = min || exact
                    ? D
                    : mathaccent
                        ? Math.min(D / df, D + ds)
                        : Math.max(D * df, D - ds);
                const delim = this.stretch;
                const c = delim.c || this.getText().codePointAt(0);
                let i = 0;
                if (delim.sizes) {
                    for (const d of delim.sizes) {
                        if (d >= m) {
                            if (mathaccent && i) {
                                i--;
                            }
                            this.setDelimSize(c, i);
                            return;
                        }
                        i++;
                    }
                }
                if (delim.stretch) {
                    this.size = -1;
                    this.invalidateBBox();
                    this.getStretchBBox(WH, this.checkExtendedHeight(D, delim), delim);
                }
                else {
                    this.setDelimSize(c, i - 1);
                }
            }
        }
        setDelimSize(c, i) {
            const delim = this.stretch;
            this.variant = this.font.getSizeVariant(c, i);
            this.size = i;
            const schar = delim.schar
                ? delim.schar[Math.min(i, delim.schar.length - 1)] || c
                : c;
            this.stretch = Object.assign(Object.assign({}, delim), { c: schar });
            this.childNodes[0].invalidateBBox();
        }
        getSize(name, value) {
            const attributes = this.node.attributes;
            if (attributes.isSet(name)) {
                value = this.length2em(attributes.get(name), 1, 1);
            }
            return value;
        }
        getWH(WH) {
            if (WH.length === 0)
                return 0;
            if (WH.length === 1)
                return WH[0];
            const [H, D] = WH;
            const a = this.font.params.axis_height;
            return this.node.attributes.get('symmetric')
                ? 2 * Math.max(H - a, D + a)
                : H + D;
        }
        getStretchBBox(WHD, D, C) {
            if (Object.hasOwn(C, 'min') && C.min > D) {
                D = C.min;
            }
            let [h, d, w] = C.HDW;
            if (this.stretch.dir === DIRECTION.Vertical) {
                [h, d] = this.getBaseline(WHD, D, C);
            }
            else {
                w = D;
                if (this.stretch.hd && !this.jax.options.mathmlSpacing) {
                    const t = this.font.params.extender_factor;
                    h = h * (1 - t) + this.stretch.hd[0] * t;
                    d = d * (1 - t) + this.stretch.hd[1] * t;
                }
            }
            this.bbox.h = h;
            this.bbox.d = d;
            this.bbox.w = w;
        }
        getBaseline(WHD, HD, C) {
            const hasWHD = WHD.length === 2 && WHD[0] + WHD[1] === HD;
            const symmetric = this.node.attributes.get('symmetric');
            const [H, D] = hasWHD ? WHD : [HD, 0];
            let [h, d] = [H + D, 0];
            if (symmetric) {
                const a = this.font.params.axis_height;
                if (hasWHD) {
                    h = 2 * Math.max(H - a, D + a);
                }
                d = h / 2 - a;
            }
            else if (hasWHD) {
                d = D;
            }
            else {
                const [ch, cd] = C.HDW || [0.75, 0.25];
                d = cd * (h / (ch + cd));
            }
            return [h - d, d];
        }
        checkExtendedHeight(D, C) {
            if (C.fullExt) {
                const [extSize, endSize] = C.fullExt;
                const n = Math.ceil(Math.max(0, D - endSize) / extSize);
                D = endSize + n * extSize;
            }
            return D;
        }
        setBreakStyle(linebreak = '') {
            this.breakStyle =
                this.node.parent.isEmbellished && !linebreak
                    ? ''
                    : this.getBreakStyle(linebreak);
            if (!this.breakCount)
                return;
            if (this.multChar) {
                const i = this.parent.node.childIndex(this.node);
                const next = this.parent.node.childNodes[i + 1];
                if (next) {
                    next.setTeXclass(this.multChar.node);
                }
            }
        }
        getBreakStyle(linebreak = '') {
            const attributes = this.node.attributes;
            let style = linebreak ||
                (attributes.get('linebreak') === 'newline' ||
                    this.node.getProperty('forcebreak')
                    ? attributes.get('linebreakstyle')
                    : '');
            if (style === 'infixlinebreakstyle') {
                style = attributes.get(style);
            }
            return style;
        }
        getMultChar() {
            const multChar = this.node.attributes.get('linebreakmultchar');
            if (multChar && this.getText() === '\u2062' && multChar !== '\u2062') {
                this.multChar = this.createMo(multChar);
            }
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.size = null;
            this.isAccent = this.node.isAccent;
            this.getMultChar();
            this.setBreakStyle();
        }
        computeBBox(bbox, _recompute = false) {
            this.protoBBox(bbox);
            if (this.node.attributes.get('symmetric') &&
                this.stretch.dir !== DIRECTION.Horizontal) {
                const d = this.getCenterOffset(bbox);
                bbox.h += d;
                bbox.d -= d;
            }
            if (this.node.getProperty('mathaccent') &&
                (this.stretch.dir === DIRECTION.None || this.size >= 0)) {
                bbox.w = 0;
            }
        }
        computeLineBBox(i) {
            return this.moLineBBox(i, this.breakStyle);
        }
        moLineBBox(i, style, obox = null) {
            const leadingString = this.node.attributes.get('lineleading');
            const leading = this.length2em(leadingString, this.linebreakOptions.lineleading);
            if (i === 0 && style === 'before') {
                const bbox = LineBBox.from(BBox.zero(), leading);
                bbox.originalL = this.bbox.L;
                this.bbox.L = 0;
                return bbox;
            }
            let bbox = LineBBox.from(obox || this.getOuterBBox(), leading);
            if (i === 1) {
                if (style === 'after') {
                    bbox.w = bbox.h = bbox.d = 0;
                    bbox.isFirst = true;
                    this.bbox.R = 0;
                }
                else if (style === 'duplicate') {
                    bbox.L = 0;
                }
                else if (this.multChar) {
                    bbox = LineBBox.from(this.multChar.getOuterBBox(), leading);
                }
                bbox.getIndentData(this.node);
            }
            return bbox;
        }
        canStretch(direction) {
            if (this.stretch.dir !== DIRECTION.None) {
                return this.stretch.dir === direction;
            }
            const attributes = this.node.attributes;
            if (!attributes.get('stretchy'))
                return false;
            const c = this.getText();
            if (Array.from(c).length !== 1)
                return false;
            const delim = this.font.getDelimiter(c.codePointAt(0));
            this.stretch = (delim && delim.dir === direction ? delim : NOSTRETCH);
            return this.stretch.dir !== DIRECTION.None;
        }
        getVariant() {
            if (this.node.attributes.get('largeop')) {
                this.variant = this.node.attributes.get('displaystyle')
                    ? '-largeop'
                    : '-smallop';
                return;
            }
            if (!this.node.attributes.hasExplicit('mathvariant') &&
                this.node.getProperty('pseudoscript') === false) {
                this.variant = '-tex-variant';
                return;
            }
            super.getVariant();
        }
        remapChars(chars) {
            const primes = this.node.getProperty('primes');
            if (primes) {
                return unicodeChars(primes);
            }
            if (chars.length === 1) {
                const parent = this.node.coreParent().parent;
                const isAccent = this.isAccent && !parent.isKind('mrow');
                const map = isAccent ? 'accent' : 'mo';
                const text = this.font.getRemappedChar(map, chars[0]);
                if (text) {
                    chars = this.unicodeChars(text, this.variant);
                }
            }
            return chars;
        }
    };
}
//# sourceMappingURL=mo.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mo.js
const mo_def = MathJax._.core.MmlTree.MmlNodes.mo;
const MmlMo = mo_def.MmlMo;

;// ./mjs/output/chtml/Usage.js
class Usage {
    constructor() {
        this.used = new Set();
        this.needsUpdate = [];
    }
    add(item) {
        const name = JSON.stringify(item);
        if (!this.used.has(name)) {
            this.needsUpdate.push(item);
        }
        this.used.add(name);
    }
    has(item) {
        return this.used.has(JSON.stringify(item));
    }
    clear() {
        this.used.clear();
        this.needsUpdate = [];
    }
    update() {
        const update = this.needsUpdate;
        this.needsUpdate = [];
        return update;
    }
}
//# sourceMappingURL=Usage.js.map
;// ./mjs/output/chtml/FontData.js





class ChtmlFontData extends FontData {
    constructor() {
        super(...arguments);
        this.charUsage = new Usage();
        this.delimUsage = new Usage();
        this.fontUsage = {};
        this.newFonts = 0;
    }
    static charOptions(font, n) {
        return super.charOptions(font, n);
    }
    static addFontURLs(styles, fonts, url) {
        for (const name of Object.keys(fonts)) {
            const font = Object.assign({}, fonts[name]);
            font.src = font.src.replace(/%%URL%%/, url);
            styles[name] = font;
        }
    }
    static addDynamicFontCss(styles, fonts, root) {
        const fontStyles = {};
        for (const font of fonts) {
            const name = font.slice(4);
            fontStyles[`@font-face /* ${name} */`] = {
                'font-family': font,
                src: `url("%%URL%%/${font.toLowerCase()}.woff2") format("woff2")`,
            };
            styles[`.${name}`] = {
                'font-family': `${this.defaultCssFamilyPrefix}, ${font}`,
            };
        }
        this.addFontURLs(styles, fontStyles, root);
    }
    static addExtension(data, prefix = '') {
        super.addExtension(data, prefix);
        if (data.fonts) {
            this.addDynamicFontCss(this.defaultStyles, data.fonts, data.fontURL);
        }
    }
    addExtension(data, prefix = '') {
        super.addExtension(data, prefix);
        if (!data.fonts || !this.options.adaptiveCSS) {
            return [];
        }
        const css = {};
        const styles = new StyleJsonSheet();
        this.constructor.addDynamicFontCss(css, data.fonts, data.fontURL);
        styles.addStyles(css);
        return styles.getStyleRules();
    }
    adaptiveCSS(adapt) {
        this.options.adaptiveCSS = adapt;
    }
    clearCache() {
        if (this.options.adaptiveCSS) {
            this.charUsage.clear();
            this.delimUsage.clear();
        }
    }
    createVariant(name, inherit = null, link = null) {
        super.createVariant(name, inherit, link);
        this.variant[name].letter = this.constructor.defaultVariantLetters[name];
    }
    defineChars(name, chars) {
        super.defineChars(name, chars);
        const letter = this.variant[name].letter;
        const CLASS = this.constructor;
        for (const n of Object.keys(chars)) {
            const i = parseInt(n);
            if (!Array.isArray(chars[i]))
                continue;
            const options = CLASS.charOptions(chars, i);
            if (options.f === undefined) {
                options.f = letter;
            }
            for (const [m, M] of CLASS.combiningChars) {
                if (i >= m && i <= M) {
                    options.cmb = true;
                    break;
                }
            }
        }
    }
    addDynamicFontCss(fonts, root = this.options.fontURL) {
        this.constructor.addDynamicFontCss(this.fontUsage, fonts, root);
    }
    updateDynamicStyles() {
        const styles = this.fontUsage;
        this.fontUsage = {};
        if (!this.options.adaptiveCSS) {
            this.updateStyles(styles);
        }
        return styles;
    }
    get styles() {
        const CLASS = this.constructor;
        const styles = Object.assign(Object.assign({}, CLASS.defaultStyles), this.fontUsage);
        this.fontUsage = {};
        CLASS.addFontURLs(styles, CLASS.defaultFonts, this.options.fontURL);
        if (this.options.adaptiveCSS) {
            this.updateStyles(styles);
        }
        else {
            this.allStyles(styles);
        }
        return styles;
    }
    updateStyles(styles) {
        for (const N of this.delimUsage.update()) {
            this.addDelimiterStyles(styles, N, this.getDelimiter(N));
        }
        for (const [name, N] of this.charUsage.update()) {
            const variant = this.variant[name];
            this.addCharStyles(styles, variant.letter, N, variant.chars[N]);
        }
        return styles;
    }
    allStyles(styles) {
        var _a;
        for (const n of Object.keys(this.delimiters)) {
            const N = parseInt(n);
            this.addDelimiterStyles(styles, N, this.delimiters[N]);
        }
        for (const name of Object.keys(this.variant)) {
            const variant = this.variant[name];
            const vletter = variant.letter;
            for (const n of Object.keys(variant.chars)) {
                const N = parseInt(n);
                const char = variant.chars[N];
                if (((_a = char === null || char === void 0 ? void 0 : char[3]) === null || _a === void 0 ? void 0 : _a.smp) || !Array.isArray(char))
                    continue;
                if (char.length < 4) {
                    char[3] = {};
                }
                this.addCharStyles(styles, vletter, N, char);
            }
        }
    }
    addDelimiterStyles(styles, n, data) {
        if (!data.stretch)
            return;
        const c = data.c && data.c !== n ? this.charSelector(data.c) : this.charSelector(n);
        if (data.dir === DIRECTION.Vertical) {
            this.addDelimiterVStyles(styles, n, c, data);
        }
        else {
            this.addDelimiterHStyles(styles, n, c, data);
        }
    }
    addDelimiterVStyles(styles, n, c, data) {
        const HDW = data.HDW;
        const [beg, ext, end, mid] = data.stretch;
        const [begV, extV, endV, midV] = this.getStretchVariants(n);
        const Hb = this.addDelimiterVPart(styles, c, 'beg', beg, begV, HDW);
        this.addDelimiterVPart(styles, c, 'ext', ext, extV, HDW);
        const He = this.addDelimiterVPart(styles, c, 'end', end, endV, HDW);
        if (mid) {
            const Hm = this.addDelimiterVPart(styles, c, 'mid', mid, midV, HDW);
            const m = this.em(Hm / 2 - 0.03);
            styles[`mjx-stretchy-v${c} > mjx-ext:first-of-type`] = {
                height: '50%',
                'border-width': `${this.em1(Hb - 0.03)} 0 ${m}`,
            };
            styles[`mjx-stretchy-v${c} > mjx-ext:last-of-type`] = {
                height: '50%',
                'border-width': `${m} 0 ${this.em1(He - 0.03)}`,
            };
        }
        else if (He || Hb) {
            styles[`mjx-stretchy-v${c} > mjx-ext`]['border-width'] =
                `${this.em1(Hb - 0.03)} 0 ${this.em1(He - 0.03)}`;
        }
    }
    addDelimiterVPart(styles, c, part, n, v, HDW) {
        if (!n)
            return 0;
        const [h, d, w] = this.getChar(v, n);
        const css = { width: this.em0(w) };
        if (part !== 'ext') {
            const dw = w > HDW[2] ? this.em((HDW[2] - w) / 2) : 'auto';
            const y = part === 'beg' ? h : part === 'end' ? -d : (h - d) / 2;
            css.margin = `${this.em(y)} ${dw} ${this.em(-y)}`;
        }
        else {
            css['line-height'] = this.em0(h + d + 0.005);
            styles[`mjx-stretchy-v${c} > mjx-${part} > mjx-spacer`] = {
                'margin-top': this.em(-d),
            };
        }
        styles[`mjx-stretchy-v${c} > mjx-${part}`] = css;
        return h + d;
    }
    addDelimiterHStyles(styles, n, c, data) {
        const HDW = [...data.HDW];
        const [beg, ext, end, mid] = data.stretch;
        const [begV, extV, endV, midV] = this.getStretchVariants(n);
        if (data.hd && !this.options.mathmlSpacing) {
            const t = this.params.extender_factor;
            HDW[0] = HDW[0] * (1 - t) + data.hd[0] * t;
            HDW[1] = HDW[1] * (1 - t) + data.hd[1] * t;
        }
        const Wb = this.addDelimiterHPart(styles, c, 'beg', beg, begV, HDW);
        this.addDelimiterHPart(styles, c, 'ext', ext, extV, HDW);
        const We = this.addDelimiterHPart(styles, c, 'end', end, endV, HDW);
        if (mid) {
            const Wm = this.addDelimiterHPart(styles, c, 'mid', mid, midV, HDW);
            const m = this.em0(Wm / 2 - 0.03);
            styles[`mjx-stretchy-h${c} > mjx-ext:first-of-type`] = {
                width: '50%',
                'border-width': `0 ${m} 0 ${this.em0(Wb - 0.03)}`,
            };
            styles[`mjx-stretchy-h${c} > mjx-ext:last-of-type`] = {
                width: '50%',
                'border-width': `0 ${this.em0(We - 0.03)} 0 ${m}`,
            };
        }
        else if (Wb || We) {
            styles[`mjx-stretchy-h${c} > mjx-ext`]['border-width'] =
                `0 ${this.em0(We - 0.06)} 0 ${this.em0(Wb - 0.06)}`;
        }
        if (data.ext) {
            styles[`mjx-stretchy-h${c} > mjx-ext > mjx-spacer`]['letter-spacing'] =
                this.em(-data.ext);
        }
    }
    addDelimiterHPart(styles, c, part, n, v, HDW) {
        if (!n)
            return 0;
        let [, , w, options] = this.getChar(v, n);
        const css = {
            padding: this.padding(HDW, w - HDW[2]),
        };
        if (part === 'ext') {
            if (!w && options.dx) {
                w = 2 * options.dx - 0.06;
            }
            styles[`mjx-stretchy-h${c} > mjx-${part} > mjx-spacer`] = {
                'margin-left': this.em(-w / 2),
            };
            if (options.cmb) {
                styles[`mjx-stretchy-h${c} > mjx-${part} > mjx-c`] = {
                    width: this.em(w),
                    'text-align': 'right',
                };
            }
        }
        else {
            if (part === 'mid') {
                css['margin'] = `0 ${this.em(-w / 2)}`;
            }
            else {
                css[part == 'end' ? 'margin-left' : 'margin-right'] = this.em(-w);
            }
            this.checkCombiningChar(options, css);
        }
        styles[`mjx-stretchy-h${c} > mjx-${part}`] = css;
        return w;
    }
    addCharStyles(styles, vletter, n, data) {
        const options = data[3];
        const letter = options.f !== undefined ? options.f : vletter;
        const font = options.ff || (letter ? `${this.cssFontPrefix}-${letter}` : '');
        const selector = 'mjx-c' + this.charSelector(n) + (font ? '.' + font : '');
        const padding = options.oc || options.ic || 0;
        styles[selector] = {
            padding: this.padding(data, padding),
        };
        if (options.oc) {
            styles[selector + '[noic]'] = { 'padding-right': this.em(data[2]) };
        }
        this.checkCombiningChar(options, styles[selector]);
    }
    checkCombiningChar(options, css) {
        if (!options.cmb)
            return;
        const pad = css.padding.split(/ /);
        css.width = pad[1];
        pad[1] = '0';
        if (!pad[3]) {
            pad.pop();
        }
        css.padding = pad.join(' ');
    }
    em(n) {
        return em(n);
    }
    em0(n) {
        return em(Math.max(0, n));
    }
    em1(n) {
        const m = em(Math.max(0, n));
        return m === '0' ? '.1px' : m;
    }
    padding([h, d, w], ic = 0) {
        return [h, w + ic, d, 0].map(this.em0).join(' ');
    }
    charSelector(n) {
        return '.mjx-c' + n.toString(16).toUpperCase();
    }
}
ChtmlFontData.OPTIONS = Object.assign(Object.assign({}, FontData.OPTIONS), { dynamicPrefix: './chtml/dynamic', fontURL: './chtml/woff2' });
ChtmlFontData.JAX = 'CHTML';
ChtmlFontData.defaultVariantLetters = {};
ChtmlFontData.defaultStyles = {};
ChtmlFontData.defaultFonts = {};
ChtmlFontData.combiningChars = [
    [0x300, 0x36f],
    [0x20d0, 0x20ff],
];
function AddCSS(font, options) {
    for (const c of Object.keys(options)) {
        const n = parseInt(c);
        const data = options[n];
        if (data.c) {
            data.c = data.c.replace(/\\[0-9A-F]+/gi, (x) => String.fromCodePoint(parseInt(x.substring(1), 16)));
        }
        Object.assign(FontData.charOptions(font, n), data);
    }
    return font;
}
//# sourceMappingURL=FontData.js.map
;// ./mjs/output/chtml/Wrappers/mo.js




const ChtmlMo = (function () {
    var _a;
    const Base = CommonMoMixin(ChtmlWrapper);
    return _a = class ChtmlMo extends Base {
            toCHTML(parents) {
                const adaptor = this.adaptor;
                const attributes = this.node.attributes;
                const symmetric = attributes.get('symmetric') &&
                    this.stretch.dir !== DIRECTION.Horizontal;
                const stretchy = this.stretch.dir !== DIRECTION.None;
                if (stretchy && this.size === null) {
                    this.getStretchedVariant([]);
                }
                if (parents.length > 1) {
                    parents.forEach((dom) => adaptor.append(dom, this.html('mjx-linestrut')));
                }
                const chtml = this.standardChtmlNodes(parents);
                if (chtml.length > 1 && this.breakStyle !== 'duplicate') {
                    const i = this.breakStyle === 'after' ? 1 : 0;
                    adaptor.remove(chtml[i]);
                    chtml[i] = null;
                }
                if (stretchy && this.size < 0) {
                    this.stretchHTML(chtml);
                }
                else {
                    if (symmetric || attributes.get('largeop')) {
                        const u = this.em(this.getCenterOffset());
                        if (u !== '0') {
                            chtml.forEach((dom) => dom && adaptor.setStyle(dom, 'verticalAlign', u));
                        }
                    }
                    if (this.node.getProperty('mathaccent')) {
                        chtml.forEach((dom) => {
                            adaptor.setStyle(dom, 'width', '0');
                            adaptor.setStyle(dom, 'margin-left', this.em(this.getAccentOffset()));
                        });
                    }
                    if (chtml[0]) {
                        this.addChildren([chtml[0]]);
                    }
                    if (chtml[1]) {
                        (this.multChar || this).addChildren([chtml[1]]);
                    }
                }
            }
            stretchHTML(chtml) {
                const c = this.getText().codePointAt(0);
                this.font.delimUsage.add(c);
                this.childNodes[0].markUsed();
                const delim = this.stretch;
                const stretch = delim.stretch;
                const stretchv = this.font.getStretchVariants(c);
                const dom = [];
                const parts = [];
                for (let i = 0; i < stretch.length; i++) {
                    if (stretch[i]) {
                        parts[i] = this.font.getChar(stretchv[i], stretch[i]);
                    }
                }
                const { h, d, w } = this.bbox;
                const styles = {};
                if (delim.dir === DIRECTION.Vertical) {
                    this.createAssembly(parts, stretch, stretchv, dom, h + d, 0.05, '\n');
                    dom.push(this.html('mjx-mark'));
                    styles.height = this.em(h + d);
                    styles.verticalAlign = this.em(-d);
                }
                else {
                    this.createAssembly(parts, stretch, stretchv, dom, w, delim.ext || 0);
                    styles.width = this.em(w);
                }
                const properties = { class: this.char(delim.c || c), style: styles };
                const html = this.html('mjx-stretchy-' + delim.dir, properties, dom);
                const adaptor = this.adaptor;
                if (chtml[0]) {
                    adaptor.append(chtml[0], html);
                }
                if (chtml[1]) {
                    adaptor.append(chtml[1], chtml[0] ? adaptor.clone(html) : html);
                }
            }
            createAssembly(parts, sn, sv, dom, wh, ext, nl = '') {
                parts = [...parts, null, null, null].slice(0, 4);
                let [WHb, WHx, WHe, WHm] = parts.map((part) => part ? (nl ? part[0] + part[1] : part[2]) : 0);
                WHx = Math.max(0, WHx - ext);
                const [WH1, WH2] = parts[3]
                    ? [(wh - WHm) / 2 - WHb, (wh - WHm) / 2 - WHe]
                    : [wh - WHb - WHe, 0];
                this.createPart('mjx-beg', parts[0], sn[0], sv[0], dom);
                this.createPart('mjx-ext', parts[1], sn[1], sv[1], dom, WH1, WHx, nl);
                if (parts[3]) {
                    this.createPart('mjx-mid', parts[3], sn[3], sv[3], dom);
                    this.createPart('mjx-ext', parts[1], sn[1], sv[1], dom, WH2, WHx, nl);
                }
                this.createPart('mjx-end', parts[2], sn[2], sv[2], dom);
            }
            createPart(part, data, n, v, dom, W = 0, Wx = 0, nl = '') {
                if (n) {
                    const options = data[3];
                    const letter = options.f || (v === 'normal' ? '' : this.font.getVariant(v).letter);
                    const font = options.ff || (letter ? `${this.font.cssFontPrefix}-${letter}` : '');
                    const c = options.c || String.fromCodePoint(n);
                    let nodes = [];
                    if (part === 'mjx-ext' && (Wx || options.dx)) {
                        if (!Wx) {
                            Wx = Math.max(0.06, 2 * options.dx - 0.06);
                        }
                        const n = Math.min(Math.ceil(W / Wx) + 1, 500);
                        if (options.cmb) {
                            nodes.push(this.html('mjx-spacer'));
                            for (let i = 0; i < n; i++) {
                                nodes.push(this.html('mjx-c', {}, [this.text(c)]));
                            }
                        }
                        else {
                            nodes = [
                                this.html('mjx-spacer', {}, [
                                    this.text(Array(n).fill(c).join(nl)),
                                ]),
                            ];
                        }
                    }
                    else {
                        nodes = [this.text(c)];
                    }
                    dom.push(this.html(part, font ? { class: font } : {}, nodes));
                }
            }
        },
        _a.kind = MmlMo.prototype.kind,
        _a.styles = {
            'mjx-stretchy-h': {
                display: 'inline-block',
            },
            'mjx-stretchy-h > *': {
                display: 'inline-block',
                width: 0,
                'text-align': 'right',
            },
            'mjx-stretchy-h > mjx-ext': {
                'clip-path': 'padding-box xywh(0 -1em 100% calc(100% + 2em))',
                width: '100%',
                border: '0px solid transparent',
                'box-sizing': 'border-box',
                'text-align': 'left',
            },
            'mjx-stretchy-v': {
                display: 'inline-block',
                'text-align': 'center',
            },
            'mjx-stretchy-v > *': {
                display: 'block',
                height: 0,
                margin: '0 auto',
            },
            'mjx-stretchy-v > mjx-ext > mjx-spacer': {
                display: 'block',
            },
            'mjx-stretchy-v > mjx-ext': {
                'clip-path': 'padding-box xywh(-1em 0 calc(100% + 2em) 100%)',
                height: '100%',
                border: '0.1px solid transparent',
                'box-sizing': 'border-box',
                'white-space': 'wrap',
            },
            'mjx-mark': {
                display: 'inline-block',
                height: 0,
            },
        },
        _a;
})();
//# sourceMappingURL=mo.js.map
;// ./mjs/output/common/Wrappers/mn.js
function CommonMnMixin(Base) {
    return class CommonMnMixin extends Base {
        remapChars(chars) {
            if (chars.length) {
                const text = this.font.getRemappedChar('mn', chars[0]);
                if (text) {
                    const c = this.unicodeChars(text, this.variant);
                    if (c.length === 1) {
                        chars[0] = c[0];
                    }
                    else {
                        chars = c.concat(chars.slice(1));
                    }
                }
            }
            return chars;
        }
    };
}
//# sourceMappingURL=mn.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mn.js
const mn_def = MathJax._.core.MmlTree.MmlNodes.mn;
const MmlMn = mn_def.MmlMn;

;// ./mjs/output/chtml/Wrappers/mn.js



const ChtmlMn = (function () {
    var _a;
    const Base = CommonMnMixin(ChtmlWrapper);
    return _a = class ChtmlMn extends Base {
        },
        _a.kind = MmlMn.prototype.kind,
        _a;
})();
//# sourceMappingURL=mn.js.map
;// ./mjs/output/common/Wrappers/ms.js
function CommonMsMixin(Base) {
    return class CommonMsMixin extends Base {
        createText(text) {
            const node = this.wrap(this.mmlText(text));
            node.parent = this;
            return node;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            const attributes = this.node.attributes;
            const quotes = attributes.getList('lquote', 'rquote');
            if (this.variant !== 'monospace') {
                if (!attributes.isSet('lquote') && quotes.lquote === '"') {
                    quotes.lquote = '\u201C';
                }
                if (!attributes.isSet('rquote') && quotes.rquote === '"') {
                    quotes.rquote = '\u201D';
                }
            }
            this.childNodes.unshift(this.createText(quotes.lquote));
            this.childNodes.push(this.createText(quotes.rquote));
        }
    };
}
//# sourceMappingURL=ms.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/ms.js
const ms_def = MathJax._.core.MmlTree.MmlNodes.ms;
const MmlMs = ms_def.MmlMs;

;// ./mjs/output/chtml/Wrappers/ms.js



const ChtmlMs = (function () {
    var _a;
    const Base = CommonMsMixin(ChtmlWrapper);
    return _a = class ChtmlMs extends Base {
        },
        _a.kind = MmlMs.prototype.kind,
        _a;
})();
//# sourceMappingURL=ms.js.map
;// ./mjs/output/common/Wrappers/mtext.js

function CommonMtextMixin(Base) {
    var _a;
    return _a = class CommonMtextMixin extends Base {
            constructor() {
                super(...arguments);
                this.breakPoints = [];
            }
            textWidth(text) {
                let textNode = this.textNode;
                if (!textNode) {
                    const text = this.node.factory.create('text');
                    text.parent = this.node;
                    textNode = this.textNode = this.factory.wrap(text);
                    textNode.parent = this;
                }
                textNode.node.setText(text);
                textNode.invalidateBBox(false);
                return textNode.getBBox().w;
            }
            get breakCount() {
                return this.breakPoints.length;
            }
            getVariant() {
                const options = this.jax.options;
                const data = this.jax.math.outputData;
                const merror = (!!data.merrorFamily || !!options.merrorFont) &&
                    this.node.Parent.isKind('merror');
                if (!!data.mtextFamily || !!options.mtextFont || merror) {
                    const variant = this.node.attributes.get('mathvariant');
                    const font = this.constructor.INHERITFONTS[variant] ||
                        this.jax.font.getCssFont(variant);
                    const family = font[0] ||
                        (merror
                            ? data.merrorFamily || options.merrorFont
                            : data.mtextFamily || options.mtextFont);
                    this.variant = this.explicitVariant(family, font[2] ? 'bold' : '', font[1] ? 'italic' : '');
                    return;
                }
                super.getVariant();
            }
            setBreakAt(ij) {
                this.breakPoints.push(ij);
            }
            clearBreakPoints() {
                this.breakPoints = [];
            }
            computeLineBBox(i) {
                const bbox = LineBBox.from(this.getOuterBBox(), this.linebreakOptions.lineleading);
                if (!this.breakCount)
                    return bbox;
                bbox.w = this.getBreakWidth(i);
                if (i === 0) {
                    bbox.R = 0;
                    this.addLeftBorders(bbox);
                }
                else {
                    bbox.L = 0;
                    bbox.indentData = [
                        ['left', '0'],
                        ['left', '0'],
                        ['left', '0'],
                    ];
                    if (i === this.breakCount) {
                        this.addRightBorders(bbox);
                    }
                }
                return bbox;
            }
            getBreakWidth(i) {
                const childNodes = this.childNodes;
                let [si, sj] = this.breakPoints[i - 1] || [0, 0];
                const [ei, ej] = this.breakPoints[i] || [childNodes.length, 0];
                let words = childNodes[si].node.getText().split(/ /);
                if (si === ei) {
                    return this.textWidth(words.slice(sj, ej).join(' '));
                }
                let w = this.textWidth(words.slice(sj).join(' '));
                while (++si < ei && si < childNodes.length) {
                    w += childNodes[si].getBBox().w;
                }
                if (si < childNodes.length) {
                    words = childNodes[si].node.getText().split(/ /);
                    w += this.textWidth(words.slice(0, ej).join(' '));
                }
                return w;
            }
        },
        _a.INHERITFONTS = {
            normal: ['', false, false],
            bold: ['', false, true],
            italic: ['', true, false],
            'bold-italic': ['', true, true],
        },
        _a;
}
//# sourceMappingURL=mtext.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mtext.js
const mtext_def = MathJax._.core.MmlTree.MmlNodes.mtext;
const MmlMtext = mtext_def.MmlMtext;

;// ./mjs/output/chtml/Wrappers/mtext.js



const ChtmlMtext = (function () {
    var _a;
    const Base = CommonMtextMixin(ChtmlWrapper);
    return _a = class ChtmlMtext extends Base {
            toCHTML(parents) {
                if (!this.breakCount) {
                    super.toCHTML(parents);
                    return;
                }
                const chtml = this.standardChtmlNodes(parents);
                const textNode = this.textNode.node;
                const childNodes = this.childNodes;
                for (const i of chtml.keys()) {
                    const DOM = [chtml[i]];
                    this.adaptor.append(chtml[i], this.html('mjx-linestrut'));
                    let [si, sj] = this.breakPoints[i - 1] || [0, 0];
                    const [ei, ej] = this.breakPoints[i] || [childNodes.length, 0];
                    let words = childNodes[si].node.getText().split(/ /);
                    if (si === ei) {
                        textNode.setText(words.slice(sj, ej).join(' '));
                        this.textNode.toCHTML(DOM);
                        continue;
                    }
                    textNode.setText(words.slice(sj).join(' '));
                    this.textNode.toCHTML(DOM);
                    while (++si < ei && si < childNodes.length) {
                        childNodes[si].toCHTML(DOM);
                    }
                    if (si < childNodes.length) {
                        words = childNodes[si].node.getText().split(/ /);
                        textNode.setText(words.slice(0, ej).join(' '));
                        this.textNode.toCHTML(DOM);
                    }
                }
            }
        },
        _a.kind = MmlMtext.prototype.kind,
        _a;
})();
//# sourceMappingURL=mtext.js.map
;// ./mjs/output/common/Wrappers/mspace.js


function CommonMspaceMixin(Base) {
    return class CommonMspaceMixin extends Base {
        get canBreak() {
            return this.node.canBreak;
        }
        get breakCount() {
            return this.breakStyle ? 1 : 0;
        }
        setBreakStyle(linebreak = '') {
            this.breakStyle =
                linebreak ||
                    (this.node.hasNewline ||
                        this.node.getProperty('forcebreak')
                        ? 'before'
                        : '');
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.setBreakStyle();
        }
        computeBBox(bbox, _recompute = false) {
            const attributes = this.node.attributes;
            bbox.w = this.length2em(attributes.get('width'), 0);
            bbox.h = this.length2em(attributes.get('height'), 0);
            bbox.d = this.length2em(attributes.get('depth'), 0);
        }
        computeLineBBox(i) {
            const leadingString = this.node.attributes.get('data-lineleading');
            const leading = this.length2em(leadingString, this.linebreakOptions.lineleading);
            const bbox = LineBBox.from(BBox.zero(), leading);
            if (i === 1) {
                bbox.getIndentData(this.node);
                bbox.w = this.getBBox().w;
                bbox.isFirst = bbox.w === 0;
            }
            return bbox;
        }
    };
}
//# sourceMappingURL=mspace.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mspace.js
const mspace_def = MathJax._.core.MmlTree.MmlNodes.mspace;
const MmlMspace = mspace_def.MmlMspace;

;// ./mjs/output/chtml/Wrappers/mspace.js



const ChtmlMspace = (function () {
    var _a;
    const Base = CommonMspaceMixin(ChtmlWrapper);
    return _a = class ChtmlMspace extends Base {
            toCHTML(parents) {
                if (parents.length > 1) {
                    parents.forEach((dom) => this.adaptor.append(dom, this.html('mjx-linestrut')));
                }
                const chtml = this.standardChtmlNodes(parents);
                let { w, h, d } = this.getBBox();
                if (w < 0) {
                    this.adaptor.setStyle(chtml[0], 'marginRight', this.em(w));
                    w = 0;
                }
                if (w && !this.breakCount) {
                    this.adaptor.setStyle(chtml[0], 'width', this.em(w));
                }
                h = Math.max(0, h + d);
                if (h) {
                    this.adaptor.setStyle(chtml[0], 'height', this.em(Math.max(0, h)));
                }
                if (d) {
                    this.adaptor.setStyle(chtml[0], 'verticalAlign', this.em(-d));
                }
            }
        },
        _a.kind = MmlMspace.prototype.kind,
        _a;
})();
//# sourceMappingURL=mspace.js.map
;// ./mjs/output/common/Wrappers/mpadded.js
function CommonMpaddedMixin(Base) {
    return class CommonMpaddedMixin extends Base {
        getDimens() {
            const values = this.node.attributes.getList('width', 'height', 'depth', 'lspace', 'voffset');
            const bbox = this.childNodes[0].getOuterBBox();
            let { w, h, d } = bbox;
            const W = w;
            const H = h;
            const D = d;
            let x = 0;
            let y = 0;
            let dx = 0;
            if (values.width !== '')
                w = this.dimen(values.width, bbox, 'w', 0);
            if (values.height !== '')
                h = this.dimen(values.height, bbox, 'h', 0);
            if (values.depth !== '')
                d = this.dimen(values.depth, bbox, 'd', 0);
            if (values.voffset !== '')
                y = this.dimen(values.voffset, bbox);
            if (values.lspace !== '')
                x = this.dimen(values.lspace, bbox);
            const align = this.node.attributes.get('data-align');
            if (align) {
                dx = this.getAlignX(w, bbox, align);
            }
            return [H, D, W, h - H, d - D, w - W, x, y, dx];
        }
        dimen(length, bbox, d = '', m = null) {
            length = String(length);
            const match = length.match(/width|height|depth/);
            const size = (match
                ? bbox[match[0].charAt(0)]
                : d
                    ? bbox[d]
                    : 0);
            let dimen = this.length2em(length, size) || 0;
            if (length.match(/^[-+]/) && d) {
                dimen += size;
            }
            if (m != null) {
                dimen = Math.max(m, dimen);
            }
            return dimen;
        }
        setBBoxDimens(bbox) {
            const [H, D, W, dh, dd, dw] = this.getDimens();
            bbox.w = W + dw;
            bbox.h = H + dh;
            bbox.d = D + dd;
        }
        computeBBox(bbox, recompute = false) {
            this.setBBoxDimens(bbox);
            const w = this.childNodes[0].getOuterBBox().w;
            if (w > bbox.w) {
                const overflow = this.node.attributes.get('data-overflow');
                if (overflow === 'linebreak' ||
                    (overflow === 'auto' &&
                        this.jax.math.root.attributes.get('overflow') === 'linebreak')) {
                    this.childNodes[0].breakToWidth(bbox.w);
                    this.setBBoxDimens(bbox);
                }
            }
            this.setChildPWidths(recompute, bbox.w);
        }
        getWrapWidth(_i) {
            return this.getBBox().w;
        }
        getChildAlign(_i) {
            return this.node.attributes.get('data-align') || 'left';
        }
    };
}
//# sourceMappingURL=mpadded.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mpadded.js
const mpadded_def = MathJax._.core.MmlTree.MmlNodes.mpadded;
const MmlMpadded = mpadded_def.MmlMpadded;

;// ./mjs/output/chtml/Wrappers/mpadded.js



const ChtmlMpadded = (function () {
    var _a;
    const Base = CommonMpaddedMixin(ChtmlWrapper);
    return _a = class ChtmlMpadded extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                let chtml = this.standardChtmlNodes(parents);
                const content = [];
                const style = {};
                const [, , W, dh, dd, dw, x, y, dx] = this.getDimens();
                if (dw || this.childNodes[0].getBBox().pwidth) {
                    style.width = this.em(W + dw);
                }
                if (dh || dd) {
                    style.margin = this.em(dh) + ' 0 ' + this.em(dd);
                }
                if (x + dx || y) {
                    style.position = 'relative';
                    const rbox = this.html('mjx-rbox', {
                        style: {
                            left: this.em(x + dx),
                            top: this.em(-y),
                            'max-width': style.width,
                        },
                    });
                    if (x + dx && this.childNodes[0].getBBox().pwidth) {
                        this.adaptor.setAttribute(rbox, 'width', 'full');
                        this.adaptor.setStyle(rbox, 'left', this.em(x));
                    }
                    content.push(rbox);
                }
                chtml = [
                    this.adaptor.append(chtml[0], this.html('mjx-block', { style: style }, content)),
                ];
                if (this.childNodes[0].childNodes.length) {
                    this.childNodes[0].toCHTML([content[0] || chtml[0]]);
                }
                else if (dh || dd) {
                    this.adaptor.append(content[0] || chtml[0], this.html('mjx-box'));
                }
            }
        },
        _a.kind = MmlMpadded.prototype.kind,
        _a.styles = {
            'mjx-mpadded': {
                display: 'inline-block',
            },
            'mjx-rbox': {
                display: 'inline-block',
                position: 'relative',
            },
        },
        _a;
})();
//# sourceMappingURL=mpadded.js.map
;// ./mjs/output/common/Notation.js
const ARROWX = 4;
const ARROWDX = 1;
const ARROWY = 2;
const THICKNESS = 0.067;
const PADDING = 0.2;
const SOLID = THICKNESS + 'em solid';
const sideIndex = { top: 0, right: 1, bottom: 2, left: 3 };
const sideNames = Object.keys(sideIndex);
const fullBBox = ((node) => new Array(4).fill(node.thickness + node.padding));
const fullPadding = ((node) => new Array(4).fill(node.padding));
const fullBorder = ((node) => new Array(4).fill(node.thickness));
const arrowHead = (node) => {
    return Math.max(node.padding, node.thickness * (node.arrowhead.x + node.arrowhead.dx + 1));
};
const arrowBBoxHD = (node, TRBL) => {
    if (node.childNodes[0]) {
        const { h, d } = node.childNodes[0].getBBox();
        TRBL[0] = TRBL[2] = Math.max(0, node.thickness * node.arrowhead.y - (h + d) / 2);
    }
    return TRBL;
};
const arrowBBoxW = (node, TRBL) => {
    if (node.childNodes[0]) {
        const { w } = node.childNodes[0].getBBox();
        TRBL[1] = TRBL[3] = Math.max(0, node.thickness * node.arrowhead.y - w / 2);
    }
    return TRBL;
};
const arrowDef = {
    up: [-Math.PI / 2, false, true, 'verticalstrike'],
    down: [Math.PI / 2, false, true, 'verticakstrike'],
    right: [0, false, false, 'horizontalstrike'],
    left: [Math.PI, false, false, 'horizontalstrike'],
    updown: [Math.PI / 2, true, true, 'verticalstrike uparrow downarrow'],
    leftright: [0, true, false, 'horizontalstrike leftarrow rightarrow'],
};
const diagonalArrowDef = {
    updiagonal: [-1, 0, false, 'updiagonalstrike northeastarrow'],
    northeast: [-1, 0, false, 'updiagonalstrike updiagonalarrow'],
    southeast: [1, 0, false, 'downdiagonalstrike'],
    northwest: [1, Math.PI, false, 'downdiagonalstrike'],
    southwest: [-1, Math.PI, false, 'updiagonalstrike'],
    northeastsouthwest: [
        -1,
        0,
        true,
        'updiagonalstrike northeastarrow updiagonalarrow southwestarrow',
    ],
    northwestsoutheast: [
        1,
        0,
        true,
        'downdiagonalstrike northwestarrow southeastarrow',
    ],
};
const arrowBBox = {
    up: (node) => arrowBBoxW(node, [arrowHead(node), 0, node.padding, 0]),
    down: (node) => arrowBBoxW(node, [node.padding, 0, arrowHead(node), 0]),
    right: (node) => arrowBBoxHD(node, [0, arrowHead(node), 0, node.padding]),
    left: (node) => arrowBBoxHD(node, [0, node.padding, 0, arrowHead(node)]),
    updown: (node) => arrowBBoxW(node, [arrowHead(node), 0, arrowHead(node), 0]),
    leftright: (node) => arrowBBoxHD(node, [0, arrowHead(node), 0, arrowHead(node)]),
};
const CommonBorder = function (render) {
    return (side) => {
        const i = sideIndex[side];
        return [
            side,
            {
                renderer: render,
                bbox: (node) => {
                    const bbox = [0, 0, 0, 0];
                    bbox[i] = node.thickness + node.padding;
                    return bbox;
                },
                border: (node) => {
                    const bbox = [0, 0, 0, 0];
                    bbox[i] = node.thickness;
                    return bbox;
                },
            },
        ];
    };
};
const CommonBorder2 = function (render) {
    return (name, side1, side2) => {
        const i1 = sideIndex[side1];
        const i2 = sideIndex[side2];
        return [
            name,
            {
                renderer: render,
                bbox: (node) => {
                    const t = node.thickness + node.padding;
                    const bbox = [0, 0, 0, 0];
                    bbox[i1] = bbox[i2] = t;
                    return bbox;
                },
                border: (node) => {
                    const bbox = [0, 0, 0, 0];
                    bbox[i1] = bbox[i2] = node.thickness;
                    return bbox;
                },
                remove: side1 + ' ' + side2,
            },
        ];
    };
};
const CommonDiagonalStrike = function (render) {
    return (name) => {
        const cname = 'mjx-' + name.charAt(0) + 'strike';
        return [
            name + 'diagonalstrike',
            {
                renderer: render(cname),
                bbox: fullBBox,
            },
        ];
    };
};
const CommonDiagonalArrow = function (render) {
    return (name) => {
        const [c, pi, double, remove] = diagonalArrowDef[name];
        return [
            name + 'arrow',
            {
                renderer: (node, _child) => {
                    const [a, W] = node.arrowAW();
                    const arrow = node.arrow(W, c * (a - pi), double);
                    render(node, arrow);
                },
                bbox: (node) => {
                    const { a, x, y } = node.arrowData();
                    const [ax, ay, adx] = [
                        node.arrowhead.x,
                        node.arrowhead.y,
                        node.arrowhead.dx,
                    ];
                    const [b, ar] = node.getArgMod(ax + adx, ay);
                    const dy = y + (b > a ? node.thickness * ar * Math.sin(b - a) : 0);
                    const dx = x +
                        (b > Math.PI / 2 - a
                            ? node.thickness * ar * Math.sin(b + a - Math.PI / 2)
                            : 0);
                    return [dy, dx, dy, dx];
                },
                remove: remove,
            },
        ];
    };
};
const CommonArrow = function (render) {
    return (name) => {
        const [angle, double, isVertical, remove] = arrowDef[name];
        return [
            name + 'arrow',
            {
                renderer: (node, _child) => {
                    const { w, h, d } = node.getBBox();
                    const [W, offset] = isVertical ? [h + d, 'X'] : [w, 'Y'];
                    const dd = node.getOffset(offset);
                    const arrow = node.arrow(W, angle, double, offset, dd);
                    render(node, arrow);
                },
                bbox: arrowBBox[name],
                remove: remove,
            },
        ];
    };
};
//# sourceMappingURL=Notation.js.map
;// ./mjs/output/common/Wrappers/menclose.js


function CommonMencloseMixin(Base) {
    return class CommonMencloseMixin extends Base {
        getParameters() {
            const attributes = this.node.attributes;
            const padding = attributes.get('data-padding');
            if (padding !== undefined) {
                this.padding = this.length2em(padding, PADDING);
            }
            const thickness = attributes.get('data-thickness');
            if (thickness !== undefined) {
                this.thickness = this.length2em(thickness, THICKNESS);
            }
            const arrowhead = attributes.get('data-arrowhead');
            if (arrowhead !== undefined) {
                const [x, y, dx] = split(arrowhead);
                this.arrowhead = {
                    x: x ? parseFloat(x) : ARROWX,
                    y: y ? parseFloat(y) : ARROWY,
                    dx: dx ? parseFloat(dx) : ARROWDX,
                };
            }
        }
        getNotations() {
            const Notations = this.constructor.notations;
            for (const name of split(this.node.attributes.get('notation'))) {
                const notation = Notations.get(name);
                if (notation) {
                    this.notations[name] = notation;
                    if (notation.renderChild) {
                        this.renderChild = notation.renderer;
                    }
                }
            }
        }
        removeRedundantNotations() {
            for (const name of Object.keys(this.notations)) {
                if (this.notations[name]) {
                    const remove = this.notations[name].remove || '';
                    for (const notation of remove.split(/ /)) {
                        delete this.notations[notation];
                    }
                }
            }
        }
        initializeNotations() {
            for (const name of Object.keys(this.notations)) {
                const init = this.notations[name].init;
                if (init) {
                    init(this);
                }
            }
        }
        getBBoxExtenders() {
            const TRBL = [0, 0, 0, 0];
            for (const name of Object.keys(this.notations)) {
                this.maximizeEntries(TRBL, this.notations[name].bbox(this));
            }
            return TRBL;
        }
        getPadding() {
            const BTRBL = [0, 0, 0, 0];
            for (const name of Object.keys(this.notations)) {
                const border = this.notations[name].border;
                if (border) {
                    this.maximizeEntries(BTRBL, border(this));
                }
            }
            return [0, 1, 2, 3].map((i) => this.TRBL[i] - BTRBL[i]);
        }
        maximizeEntries(X, Y) {
            for (let i = 0; i < X.length; i++) {
                if (X[i] < Y[i]) {
                    X[i] = Y[i];
                }
            }
        }
        getOffset(direction) {
            const [T, R, B, L] = this.TRBL;
            const d = (direction === 'X' ? R - L : B - T) / 2;
            return Math.abs(d) > 0.001 ? d : 0;
        }
        getArgMod(w, h) {
            return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];
        }
        arrow(_w, _a, _double, _offset = '', _dist = 0) {
            return null;
        }
        arrowData() {
            const [p, t] = [this.padding, this.thickness];
            const r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));
            const { h, d, w } = this.childNodes[0].getBBox();
            const H = h + d;
            const R = Math.sqrt(H * H + w * w);
            const x = Math.max(p, (r * w) / R);
            const y = Math.max(p, (r * H) / R);
            const [a, W] = this.getArgMod(w + 2 * x, H + 2 * y);
            return { a, W, x, y };
        }
        arrowAW() {
            const { h, d, w } = this.childNodes[0].getBBox();
            const [T, R, B, L] = this.TRBL;
            return this.getArgMod(L + w + R, T + h + d + B);
        }
        createMsqrt(child) {
            const mmlFactory = this.node.factory;
            const mml = mmlFactory.create('msqrt');
            mml.inheritAttributesFrom(this.node);
            mml.childNodes[0] = child.node;
            const node = this.wrap(mml);
            node.parent = this;
            return node;
        }
        sqrtTRBL() {
            const bbox = this.msqrt.getBBox();
            const cbox = this.msqrt.childNodes[0].getBBox();
            return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.notations = {};
            this.renderChild = null;
            this.msqrt = null;
            this.padding = PADDING;
            this.thickness = THICKNESS;
            this.arrowhead = {
                x: ARROWX,
                y: ARROWY,
                dx: ARROWDX,
            };
            this.TRBL = [0, 0, 0, 0];
            this.getParameters();
            this.getNotations();
            this.removeRedundantNotations();
            this.initializeNotations();
            this.TRBL = this.getBBoxExtenders();
        }
        computeBBox(bbox, recompute = false) {
            const [T, R, B, L] = this.TRBL;
            const child = this.childNodes[0].getBBox();
            bbox.combine(child, L, 0);
            bbox.h += T;
            bbox.d += B;
            bbox.w += R;
            this.setChildPWidths(recompute);
        }
    };
}
//# sourceMappingURL=menclose.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/menclose.js
const menclose_def = MathJax._.core.MmlTree.MmlNodes.menclose;
const MmlMenclose = menclose_def.MmlMenclose;

;// ./mjs/output/chtml/Notation.js


const RenderElement = function (name, offset = '') {
    return ((node, _child) => {
        const shape = node.adjustBorder(node.html('mjx-' + name));
        if (offset) {
            const d = node.getOffset(offset);
            if (node.thickness !== THICKNESS || d) {
                const transform = `translate${offset}(${node.Em(node.thickness / 2 - d)})`;
                node.adaptor.setStyle(shape, 'transform', transform);
            }
        }
        node.adaptor.append(node.dom[0], shape);
    });
};
const Border = function (side) {
    return CommonBorder((node, child) => {
        node.adaptor.setStyle(child, 'border-' + side, node.Em(node.thickness) + ' solid');
    })(side);
};
const Border2 = function (name, side1, side2) {
    return CommonBorder2((node, child) => {
        const border = node.Em(node.thickness) + ' solid';
        node.adaptor.setStyle(child, 'border-' + side1, border);
        node.adaptor.setStyle(child, 'border-' + side2, border);
    })(name, side1, side2);
};
const DiagonalStrike = function (name, neg) {
    return CommonDiagonalStrike((cname) => (node, _child) => {
        const { w, h, d } = node.getBBox();
        const [a, W] = node.getArgMod(w, h + d);
        const t = (neg * node.thickness) / 2;
        const strike = node.adjustBorder(node.html(cname, {
            style: {
                width: node.Em(W),
                transform: 'rotate(' + node.fixed(-neg * a) + 'rad) translateY(' + t + 'em)',
            },
        }));
        node.adaptor.append(node.dom[0], strike);
    })(name);
};
const DiagonalArrow = function (name) {
    return CommonDiagonalArrow((node, arrow) => {
        node.adaptor.append(node.dom[0], arrow);
    })(name);
};
const Arrow = function (name) {
    return CommonArrow((node, arrow) => {
        node.adaptor.append(node.dom[0], arrow);
    })(name);
};
//# sourceMappingURL=Notation.js.map
;// ./mjs/output/chtml/Wrappers/menclose.js





function Angle(x, y) {
    return Math.atan2(x, y)
        .toFixed(3)
        .replace(/\.?0+$/, '');
}
const ANGLE = Angle(ARROWDX, ARROWY);
const ChtmlMenclose = (function () {
    var _a;
    const Base = CommonMencloseMixin(ChtmlWrapper);
    return _a = class ChtmlMenclose extends Base {
            adjustArrow(arrow, double) {
                const t = this.thickness;
                const head = this.arrowhead;
                if (head.x === ARROWX &&
                    head.y === ARROWY &&
                    head.dx === ARROWDX &&
                    t === THICKNESS)
                    return;
                const [x, y] = [t * head.x, t * head.y].map((x) => this.em(x));
                const a = Angle(head.dx, head.y);
                const [line, rthead, rbhead, lthead, lbhead] = this.adaptor.childNodes(arrow);
                this.adjustHead(rthead, [y, '0', '1px', x], a);
                this.adjustHead(rbhead, ['1px', '0', y, x], '-' + a);
                this.adjustHead(lthead, [y, x, '1px', '0'], '-' + a);
                this.adjustHead(lbhead, ['1px', x, y, '0'], a);
                this.adjustLine(line, t, head.x, double);
            }
            adjustHead(head, border, a) {
                if (head) {
                    this.adaptor.setStyle(head, 'border-width', border.join(' '));
                    this.adaptor.setStyle(head, 'transform', 'skewX(' + a + 'rad)');
                }
            }
            adjustLine(line, t, x, double) {
                this.adaptor.setStyle(line, 'borderTop', this.em(t) + ' solid');
                this.adaptor.setStyle(line, 'top', this.em(-t / 2));
                this.adaptor.setStyle(line, 'right', this.em(t * (x - 1)));
                if (double) {
                    this.adaptor.setStyle(line, 'left', this.em(t * (x - 1)));
                }
            }
            moveArrow(arrow, offset, d) {
                if (!d)
                    return;
                const transform = this.adaptor.getStyle(arrow, 'transform');
                this.adaptor.setStyle(arrow, 'transform', `translate${offset}(${this.em(-d)})${transform ? ' ' + transform : ''}`);
            }
            adjustBorder(node) {
                if (this.thickness !== THICKNESS) {
                    this.adaptor.setStyle(node, 'borderWidth', this.em(this.thickness));
                }
                return node;
            }
            adjustThickness(shape) {
                if (this.thickness !== THICKNESS) {
                    this.adaptor.setStyle(shape, 'strokeWidth', this.fixed(this.thickness));
                }
                return shape;
            }
            fixed(m, n = 3) {
                if (Math.abs(m) < 0.0006) {
                    return '0';
                }
                return m.toFixed(n).replace(/\.?0+$/, '');
            }
            Em(m) {
                return super.em(m);
            }
            toCHTML(parents) {
                const adaptor = this.adaptor;
                const chtml = this.standardChtmlNodes(parents);
                const block = adaptor.append(chtml[0], this.html('mjx-box'));
                if (this.renderChild) {
                    this.renderChild(this, block);
                }
                else {
                    this.childNodes[0].toCHTML([block]);
                }
                for (const name of Object.keys(this.notations)) {
                    const notation = this.notations[name];
                    if (!notation.renderChild) {
                        notation.renderer(this, block);
                    }
                }
                const pbox = this.getPadding();
                for (const name of sideNames) {
                    const i = sideIndex[name];
                    if (pbox[i] > 0) {
                        adaptor.setStyle(block, 'padding-' + name, this.em(pbox[i]));
                    }
                }
            }
            arrow(w, a, double, offset = '', dist = 0) {
                const W = this.getBBox().w;
                const style = { width: this.em(w) };
                if (W !== w) {
                    style.left = this.em((W - w) / 2);
                }
                if (a) {
                    style.transform = 'rotate(' + this.fixed(a) + 'rad)';
                }
                const arrow = this.html('mjx-arrow', { style: style }, [
                    this.html('mjx-aline'),
                    this.html('mjx-rthead'),
                    this.html('mjx-rbhead'),
                ]);
                if (double) {
                    this.adaptor.append(arrow, this.html('mjx-lthead'));
                    this.adaptor.append(arrow, this.html('mjx-lbhead'));
                    this.adaptor.setAttribute(arrow, 'double', 'true');
                }
                this.adjustArrow(arrow, double);
                this.moveArrow(arrow, offset, dist);
                return arrow;
            }
        },
        _a.kind = MmlMenclose.prototype.kind,
        _a.styles = {
            'mjx-menclose': {
                position: 'relative',
            },
            'mjx-menclose > mjx-dstrike': {
                display: 'inline-block',
                left: 0,
                top: 0,
                position: 'absolute',
                'border-top': SOLID,
                'transform-origin': 'top left',
            },
            'mjx-menclose > mjx-ustrike': {
                display: 'inline-block',
                left: 0,
                bottom: 0,
                position: 'absolute',
                'border-top': SOLID,
                'transform-origin': 'bottom left',
            },
            'mjx-menclose > mjx-hstrike': {
                'border-top': SOLID,
                position: 'absolute',
                left: 0,
                right: 0,
                bottom: '50%',
                transform: 'translateY(' + em(THICKNESS / 2) + ')',
            },
            'mjx-menclose > mjx-vstrike': {
                'border-left': SOLID,
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: '50%',
                transform: 'translateX(' + em(THICKNESS / 2) + ')',
            },
            'mjx-menclose > mjx-rbox': {
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: 0,
                left: 0,
                border: SOLID,
                'border-radius': em(THICKNESS + PADDING),
            },
            'mjx-menclose > mjx-cbox': {
                position: 'absolute',
                top: 0,
                bottom: 0,
                right: 0,
                left: 0,
                border: SOLID,
                'border-radius': '50%',
            },
            'mjx-menclose > mjx-arrow': {
                position: 'absolute',
                left: 0,
                bottom: '50%',
                height: 0,
                width: 0,
            },
            'mjx-menclose > mjx-arrow > *': {
                display: 'block',
                position: 'absolute',
                'transform-origin': 'bottom',
                'border-left': em(THICKNESS * ARROWX) + ' solid',
                'border-right': 0,
                'box-sizing': 'border-box',
            },
            'mjx-menclose > mjx-arrow > mjx-aline': {
                left: 0,
                top: em(-THICKNESS / 2),
                right: em(THICKNESS * (ARROWX - 1)),
                height: 0,
                'border-top': em(THICKNESS) + ' solid',
                'border-left': 0,
            },
            'mjx-menclose > mjx-arrow[double] > mjx-aline': {
                left: em(THICKNESS * (ARROWX - 1)),
                height: 0,
            },
            'mjx-menclose > mjx-arrow > mjx-rthead': {
                transform: 'skewX(' + ANGLE + 'rad)',
                right: 0,
                bottom: '-1px',
                'border-bottom': '1px solid transparent',
                'border-top': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-arrow > mjx-rbhead': {
                transform: 'skewX(-' + ANGLE + 'rad)',
                'transform-origin': 'top',
                right: 0,
                top: '-1px',
                'border-top': '1px solid transparent',
                'border-bottom': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-arrow > mjx-lthead': {
                transform: 'skewX(-' + ANGLE + 'rad)',
                left: 0,
                bottom: '-1px',
                'border-left': 0,
                'border-right': em(THICKNESS * ARROWX) + ' solid',
                'border-bottom': '1px solid transparent',
                'border-top': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-arrow > mjx-lbhead': {
                transform: 'skewX(' + ANGLE + 'rad)',
                'transform-origin': 'top',
                left: 0,
                top: '-1px',
                'border-left': 0,
                'border-right': em(THICKNESS * ARROWX) + ' solid',
                'border-top': '1px solid transparent',
                'border-bottom': em(THICKNESS * ARROWY) + ' solid transparent',
            },
            'mjx-menclose > mjx-dbox-top': {
                position: 'absolute',
                top: 0,
                bottom: '50%',
                left: 0,
                width: em(1.5 * PADDING),
                border: em(THICKNESS) + ' solid',
                'border-style': 'solid solid none none',
                'border-radius': '0 100% 0 0',
                'box-sizing': 'border-box',
            },
            'mjx-menclose > mjx-dbox-bot': {
                position: 'absolute',
                top: '50%',
                bottom: 0,
                left: 0,
                width: em(1.5 * PADDING),
                'border-width': em(THICKNESS),
                'border-style': 'none solid solid none',
                'border-radius': '0 0 100% 0',
                'box-sizing': 'border-box',
            },
        },
        _a.notations = new Map([
            Border('top'),
            Border('right'),
            Border('bottom'),
            Border('left'),
            Border2('actuarial', 'top', 'right'),
            Border2('madruwb', 'bottom', 'right'),
            DiagonalStrike('up', 1),
            DiagonalStrike('down', -1),
            [
                'horizontalstrike',
                {
                    renderer: RenderElement('hstrike', 'Y'),
                    bbox: (node) => [0, node.padding, 0, node.padding],
                },
            ],
            [
                'verticalstrike',
                {
                    renderer: RenderElement('vstrike', 'X'),
                    bbox: (node) => [node.padding, 0, node.padding, 0],
                },
            ],
            [
                'box',
                {
                    renderer: (node, child) => {
                        node.adaptor.setStyle(child, 'border', node.Em(node.thickness) + ' solid');
                    },
                    bbox: fullBBox,
                    border: fullBorder,
                    remove: 'left right top bottom',
                },
            ],
            [
                'roundedbox',
                {
                    renderer: RenderElement('rbox'),
                    bbox: fullBBox,
                },
            ],
            [
                'circle',
                {
                    renderer: RenderElement('cbox'),
                    bbox: fullBBox,
                },
            ],
            [
                'phasorangle',
                {
                    renderer: (node, child) => {
                        const { h, d } = node.getBBox();
                        const [a, W] = node.getArgMod(1.75 * node.padding, h + d);
                        const t = node.thickness * Math.sin(a) * 0.9;
                        node.adaptor.setStyle(child, 'border-bottom', node.Em(node.thickness) + ' solid');
                        const strike = node.adjustBorder(node.html('mjx-ustrike', {
                            style: {
                                width: node.Em(W),
                                transform: `translateX(${node.Em(t)}) rotate(${node.fixed(-a)}rad)`,
                            },
                        }));
                        node.adaptor.append(node.dom[0], strike);
                    },
                    bbox: (node) => {
                        const p = node.padding / 2;
                        const t = node.thickness;
                        return [2 * p, p, p + t, 3 * p + t];
                    },
                    border: (node) => [0, 0, node.thickness, 0],
                    remove: 'bottom',
                },
            ],
            Arrow('up'),
            Arrow('down'),
            Arrow('left'),
            Arrow('right'),
            Arrow('updown'),
            Arrow('leftright'),
            DiagonalArrow('updiagonal'),
            DiagonalArrow('northeast'),
            DiagonalArrow('southeast'),
            DiagonalArrow('northwest'),
            DiagonalArrow('southwest'),
            DiagonalArrow('northeastsouthwest'),
            DiagonalArrow('northwestsoutheast'),
            [
                'longdiv',
                {
                    renderer: (node, child) => {
                        const adaptor = node.adaptor;
                        adaptor.setStyle(child, 'border-top', node.Em(node.thickness) + ' solid');
                        const arc1 = adaptor.append(node.dom[0], node.html('mjx-dbox-top'));
                        const arc2 = adaptor.append(node.dom[0], node.html('mjx-dbox-bot'));
                        const t = node.thickness;
                        const p = node.padding;
                        if (t !== THICKNESS) {
                            adaptor.setStyle(arc1, 'border-width', node.Em(t));
                            adaptor.setStyle(arc2, 'border-width', node.Em(t));
                        }
                        if (p !== PADDING) {
                            adaptor.setStyle(arc1, 'width', node.Em(1.5 * p));
                            adaptor.setStyle(arc2, 'width', node.Em(1.5 * p));
                        }
                    },
                    bbox: (node) => {
                        const p = node.padding;
                        const t = node.thickness;
                        return [p + t, p, p, 2 * p + t / 2];
                    },
                },
            ],
            [
                'radical',
                {
                    renderer: (node, child) => {
                        node.msqrt.toCHTML([child]);
                        const TRBL = node.sqrtTRBL();
                        node.adaptor.setStyle(node.msqrt.dom[0], 'margin', TRBL.map((x) => node.Em(-x)).join(' '));
                    },
                    init: (node) => {
                        node.msqrt = node.createMsqrt(node.childNodes[0]);
                    },
                    bbox: (node) => node.sqrtTRBL(),
                    renderChild: true,
                },
            ],
        ]),
        _a;
})();
//# sourceMappingURL=menclose.js.map
;// ./mjs/output/common/Wrappers/mrow.js



function CommonMrowMixin(Base) {
    return class CommonMrowMixin extends Base {
        stretchChildren() {
            const stretchy = [];
            for (const child of this.childNodes) {
                if (child.canStretch(DIRECTION.Vertical)) {
                    stretchy.push(child);
                }
            }
            const count = stretchy.length;
            const nodeCount = this.childNodes.length;
            if (count && nodeCount > 1) {
                let H = 0;
                let D = 0;
                const all = count > 1 && count === nodeCount;
                for (const child of this.childNodes) {
                    const noStretch = child.stretch.dir === DIRECTION.None;
                    if (all || noStretch) {
                        const rscale = child.getBBox().rscale;
                        let [h, d] = child.getUnbrokenHD();
                        h *= rscale;
                        d *= rscale;
                        if (h > H)
                            H = h;
                        if (d > D)
                            D = d;
                    }
                }
                for (const child of stretchy) {
                    const rscale = child.coreRScale();
                    child.coreMO().getStretchedVariant([H / rscale, D / rscale]);
                }
            }
        }
        get fixesPWidth() {
            return false;
        }
        get breakCount() {
            if (this._breakCount < 0) {
                this._breakCount = !this.childNodes.length
                    ? 0
                    : this.childNodes.reduce((n, child) => n + child.breakCount, 0);
            }
            return this._breakCount;
        }
        breakTop(_mrow, _child) {
            const node = this;
            return this.isStack ? this.parent.breakTop(node, node) : node;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.dh = 0;
            const self = this;
            this.isStack =
                !this.parent ||
                    this.parent.node.isInferred ||
                    this.parent.breakTop(self, self) !== self;
            this.stretchChildren();
            for (const child of this.childNodes) {
                if (child.bbox.pwidth) {
                    this.bbox.pwidth = BBox.fullWidth;
                    break;
                }
            }
        }
        computeBBox(bbox, recompute = false) {
            const breaks = this.breakCount;
            this.lineBBox = breaks
                ? [new LineBBox({ h: 0.75, d: 0.25, w: 0 }, [0, 0])]
                : [];
            bbox.empty();
            for (const i of this.childNodes.keys()) {
                const child = this.childNodes[i];
                bbox.append(child.getOuterBBox());
                if (breaks) {
                    this.computeChildLineBBox(child, i);
                }
            }
            bbox.clean();
            if (breaks && !this.coreMO().node.isEmbellished) {
                this.computeLinebreakBBox(bbox);
            }
            if (this.fixesPWidth && this.setChildPWidths(recompute)) {
                this.computeBBox(bbox, true);
            }
            this.vboxAdjust(bbox);
        }
        computeLinebreakBBox(bbox) {
            var _a;
            bbox.empty();
            const isStack = this.isStack;
            const lines = this.lineBBox;
            const n = lines.length - 1;
            if (isStack) {
                for (const k of lines.keys()) {
                    const line = lines[k];
                    this.addMiddleBorders(line);
                    if (k === 0) {
                        this.addLeftBorders(line);
                    }
                    if (k === n) {
                        this.addRightBorders(line);
                    }
                }
            }
            let y = 0;
            for (const k of lines.keys()) {
                const line = lines[k];
                bbox.combine(line, 0, y);
                y -=
                    Math.max(0.25, line.d) +
                        line.lineLeading +
                        Math.max(0.75, ((_a = lines[k + 1]) === null || _a === void 0 ? void 0 : _a.h) || 0);
            }
            if (isStack) {
                lines[0].L = this.bbox.L;
                lines[n].R = this.bbox.R;
            }
            else {
                bbox.w = Math.max(...this.lineBBox.map((bbox) => bbox.w));
                this.shiftLines(bbox.w);
                if (!this.jax.math.display && !this.linebreakOptions.inline) {
                    bbox.pwidth = BBox.fullWidth;
                    if (this.node.isInferred) {
                        this.parent.bbox.pwidth = BBox.fullWidth;
                    }
                }
            }
            bbox.clean();
        }
        vboxAdjust(bbox) {
            if (!this.parent)
                return;
            const n = this.breakCount;
            const valign = this.parent.node.attributes.get('data-vertical-align');
            if (n && valign === 'bottom') {
                this.dh = n ? bbox.d - this.lineBBox[n - 1].d : 0;
            }
            else if (valign === 'center' || (n && valign === 'middle')) {
                const { h, d } = bbox;
                const a = this.font.params.axis_height;
                this.dh = (h + d) / 2 + a - h;
            }
            else {
                this.dh = 0;
                return;
            }
            bbox.h += this.dh;
            bbox.d -= this.dh;
        }
        computeChildLineBBox(child, i) {
            const lbox = this.lineBBox[this.lineBBox.length - 1];
            lbox.end = [i, 0];
            lbox.append(child.getLineBBox(0));
            const parts = child.breakCount + 1;
            if (parts === 1)
                return;
            for (let l = 1; l < parts; l++) {
                const bbox = new LineBBox({ h: 0.75, d: 0.25, w: 0 });
                bbox.start = bbox.end = [i, l];
                bbox.isFirst = true;
                bbox.append(child.getLineBBox(l));
                this.lineBBox.push(bbox);
            }
        }
        getLineBBox(i) {
            this.getBBox();
            return this.isStack
                ? super.getLineBBox(i)
                : LineBBox.from(this.getOuterBBox(), this.linebreakOptions.lineleading);
        }
        shiftLines(W) {
            var _a, _b;
            const lines = this.lineBBox;
            const n = lines.length - 1;
            const [alignfirst, shiftfirst] = ((_a = lines[1].indentData) === null || _a === void 0 ? void 0 : _a[0]) || [
                'left',
                '0',
            ];
            for (const i of lines.keys()) {
                const bbox = lines[i];
                const [indentalign, indentshift] = i === 0
                    ? [alignfirst, shiftfirst]
                    : ((_b = bbox.indentData) === null || _b === void 0 ? void 0 : _b[i === n ? 2 : 1]) || ['left', '0'];
                const [align, shift] = this.processIndent(indentalign, indentshift, alignfirst, shiftfirst, W);
                bbox.L = 0;
                bbox.L = this.getAlignX(W, bbox, align) + shift;
            }
        }
        setChildPWidths(recompute, w = null, clear = true) {
            if (!this.breakCount)
                return super.setChildPWidths(recompute, w, clear);
            if (recompute)
                return false;
            if (w !== null && this.bbox.w !== w) {
                this.bbox.w = w;
                this.shiftLines(w);
            }
            return true;
        }
        breakToWidth(W) {
            this.linebreaks.breakToWidth(this, W);
        }
    };
}
function CommonInferredMrowMixin(Base) {
    return class CommonInferredMrowMixin extends Base {
        getScale() {
            this.bbox.scale = this.parent.bbox.scale;
            this.bbox.rscale = 1;
        }
    };
}
//# sourceMappingURL=mrow.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mrow.js
const mrow_def = MathJax._.core.MmlTree.MmlNodes.mrow;
const MmlMrow = mrow_def.MmlMrow;
const MmlInferredMrow = mrow_def.MmlInferredMrow;

;// ./mjs/output/chtml/Wrappers/mrow.js




const ChtmlMrow = (function () {
    var _a;
    const Base = CommonMrowMixin(ChtmlWrapper);
    return _a = class ChtmlMrow extends Base {
            constructor() {
                super(...arguments);
                this.linebreakCount = 0;
            }
            toCHTML(parents) {
                const n = (this.linebreakCount = this.isStack ? 0 : this.breakCount);
                if (n || !this.node.isInferred) {
                    parents = this.standardChtmlNodes(parents);
                }
                else {
                    this.dom = parents;
                }
                this.addChildren(parents);
                if (n) {
                    this.placeLines(parents, n);
                }
                else {
                    this.handleVerticalAlign(parents[0]);
                    this.handleNegativeWidth(parents[0]);
                }
            }
            placeLines(parents, n) {
                var _b, _c;
                this.getBBox();
                const lines = this.lineBBox;
                const adaptor = this.adaptor;
                const [alignfirst, shiftfirst] = ((_b = lines[1].indentData) === null || _b === void 0 ? void 0 : _b[0]) || [
                    'left',
                    '0',
                ];
                for (const i of parents.keys()) {
                    const bbox = lines[i];
                    const [indentalign, indentshift] = i === 0
                        ? [alignfirst, shiftfirst]
                        : ((_c = bbox.indentData) === null || _c === void 0 ? void 0 : _c[i === n ? 2 : 1]) || ['left', '0'];
                    const [align, shift] = this.processIndent(indentalign, indentshift, alignfirst, shiftfirst);
                    adaptor.setAttribute(parents[i], 'align', align);
                    if (shift) {
                        adaptor.setStyle(parents[i], 'position', 'relative');
                        adaptor.setStyle(parents[i], 'left', this.em(shift));
                    }
                    if (i < n && this.jax.math.display) {
                        adaptor.setStyle(parents[i], 'margin-bottom', this.em(bbox.lineLeading));
                    }
                }
            }
            handleVerticalAlign(dom) {
                if (this.dh) {
                    this.adaptor.setStyle(this.adaptor.parent(dom), 'vertical-align', this.em(this.dh));
                }
            }
            handleNegativeWidth(dom) {
                const { w } = this.getBBox();
                if (w < 0) {
                    this.adaptor.setStyle(dom, 'width', this.em(Math.max(0, w)));
                    this.adaptor.setStyle(dom, 'marginRight', this.em(w));
                }
            }
            createChtmlNodes(parents) {
                const n = this.linebreakCount;
                if (!n)
                    return super.createChtmlNodes(parents);
                const adaptor = this.adaptor;
                const kind = this.node.isInferred
                    ? 'mjx-linestack'
                    : 'mjx-' + this.node.kind;
                this.dom = [adaptor.append(parents[0], this.html(kind))];
                if (kind === 'mjx-mrow' && !this.isStack) {
                    adaptor.setAttribute(this.dom[0], 'break-top', 'true');
                }
                if (this.node.getProperty('process-breaks')) {
                    adaptor.setAttribute(this.dom[0], 'breakable', 'true');
                }
                if (this.node.isInferred || !this.isStack) {
                    const valign = this.parent.node.attributes.get('data-vertical-align');
                    if (valign === 'middle' || valign === 'center' || valign === 'bottom') {
                        adaptor.setAttribute(this.dom[0], 'break-align', valign);
                    }
                }
                this.dom = [
                    adaptor.append(this.handleHref(parents)[0], this.dom[0]),
                ];
                const chtml = Array(n);
                for (let i = 0; i <= n; i++) {
                    chtml[i] = adaptor.append(this.dom[0], this.html('mjx-linebox', { lineno: i }));
                }
                return chtml;
            }
            addChildren(parents) {
                let i = 0;
                for (const child of this.childNodes) {
                    const n = child.breakCount;
                    child.toCHTML(parents.slice(i, i + n + 1));
                    i += n;
                }
            }
        },
        _a.kind = MmlMrow.prototype.kind,
        _a.styles = {
            'mjx-linestack, mjx-mrow[break-top]': {
                display: 'inline-table',
                width: '100%',
            },
            'mjx-linestack[break-align="bottom"], mjx-mrow[break-top][break-align="bottom"]': {
                display: 'inline-block',
            },
            'mjx-linestack[break-align="middle"], mjx-mrow[break-top][break-align="middle"]': {
                'vertical-align': 'middle',
            },
            'mjx-linestack[break-align="center"], mjx-mrow[break-top][break-align="center"]': {
                'vertical-align': 'middle',
            },
            'mjx-linestack[breakable]': {
                display: 'inline',
            },
            'mjx-linestack[breakable] > mjx-linebox': {
                display: 'inline',
            },
            'mjx-linestack[breakable] > mjx-linebox::before': {
                'white-space': 'pre',
                content: '"\\A"',
            },
            'mjx-linestack[breakable] > mjx-linebox::after': {
                'white-space': 'normal',
                content: '" "',
                'letter-spacing': '-.999em',
                'font-family': 'MJX-BRK',
            },
            'mjx-linestack[breakable] > mjx-linebox:first-of-type::before': {
                display: 'none',
            },
            'mjx-linestack[breakable] > mjx-linebox:last-of-type::after': {
                display: 'none',
            },
            'mjx-linebox': {
                display: 'block',
            },
            'mjx-linebox[align="left"]': {
                'text-align': 'left',
            },
            'mjx-linebox[align="center"]': {
                'text-align': 'center',
            },
            'mjx-linebox[align="right"]': {
                'text-align': 'right',
            },
            'mjx-linestrut': {
                display: 'inline-block',
                height: '1em',
                'vertical-align': '-.25em',
            },
        },
        _a;
})();
const ChtmlInferredMrow = (function () {
    var _a;
    const Base = CommonInferredMrowMixin(ChtmlMrow);
    return _a = class ChtmlInferredMrow extends Base {
        },
        _a.kind = MmlInferredMrow.prototype.kind,
        _a;
})();
//# sourceMappingURL=mrow.js.map
;// ./mjs/output/common/Wrappers/mfenced.js
function CommonMfencedMixin(Base) {
    return class CommonMfencedMixin extends Base {
        createMrow() {
            const mmlFactory = this.node.factory;
            const mrow = mmlFactory.create('inferredMrow');
            mrow.inheritAttributesFrom(this.node);
            this.mrow = this.wrap(mrow);
            this.mrow.parent = this;
        }
        addMrowChildren() {
            const mfenced = this.node;
            const mrow = this.mrow;
            this.addMo(mfenced.open);
            if (this.childNodes.length) {
                mrow.childNodes.push(this.childNodes[0]);
            }
            let i = 0;
            for (const child of this.childNodes.slice(1)) {
                this.addMo(mfenced.separators[i++]);
                mrow.childNodes.push(child);
            }
            this.addMo(mfenced.close);
            mrow.stretchChildren();
        }
        addMo(node) {
            if (!node)
                return;
            const mo = this.wrap(node);
            this.mrow.childNodes.push(mo);
            mo.parent = this.mrow;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.mrow = null;
            this.createMrow();
            this.addMrowChildren();
        }
        computeBBox(bbox, recompute = false) {
            bbox.updateFrom(this.mrow.getOuterBBox());
            this.setChildPWidths(recompute);
        }
        get breakCount() {
            return this.mrow.breakCount;
        }
        computeLineBBox(i) {
            return this.mrow.getLineBBox(i);
        }
    };
}
//# sourceMappingURL=mfenced.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mfenced.js
const mfenced_def = MathJax._.core.MmlTree.MmlNodes.mfenced;
const MmlMfenced = mfenced_def.MmlMfenced;

;// ./mjs/output/chtml/Wrappers/mfenced.js



const ChtmlMfenced = (function () {
    var _a;
    const Base = CommonMfencedMixin(ChtmlWrapper);
    return _a = class ChtmlMfenced extends Base {
            toCHTML(parents) {
                const chtml = this.standardChtmlNodes(parents);
                this.mrow.toCHTML(chtml);
            }
        },
        _a.kind = MmlMfenced.prototype.kind,
        _a;
})();
//# sourceMappingURL=mfenced.js.map
;// ./mjs/output/common/Wrappers/mfrac.js

function CommonMfracMixin(Base) {
    return class CommonMfracMixin extends Base {
        getFractionBBox(bbox, display, t) {
            const nbox = this.childNodes[0].getOuterBBox();
            const dbox = this.childNodes[1].getOuterBBox();
            const tex = this.font.params;
            const a = tex.axis_height;
            const { T, u, v } = this.getTUV(display, t);
            bbox.combine(nbox, 0, a + T + Math.max(nbox.d * nbox.rscale, u));
            bbox.combine(dbox, 0, a - T - Math.max(dbox.h * dbox.rscale, v));
            bbox.w += 2 * this.pad + 0.2;
        }
        getTUV(display, t) {
            const tex = this.font.params;
            const a = tex.axis_height;
            const T = (display ? 3.5 : 1.5) * t;
            return {
                T: (display ? 3.5 : 1.5) * t,
                u: (display ? tex.num1 : tex.num2) - a - T,
                v: (display ? tex.denom1 : tex.denom2) + a - T,
            };
        }
        getAtopBBox(bbox, display) {
            const { u, v, nbox, dbox } = this.getUVQ(display);
            bbox.combine(nbox, 0, u);
            bbox.combine(dbox, 0, -v);
            bbox.w += 2 * this.pad;
        }
        getUVQ(display) {
            const nbox = this.childNodes[0].getOuterBBox();
            const dbox = this.childNodes[1].getOuterBBox();
            const tex = this.font.params;
            let [u, v] = display ? [tex.num1, tex.denom1] : [tex.num3, tex.denom2];
            const p = (display ? 7 : 3) * tex.rule_thickness;
            let q = u - nbox.d * nbox.scale - (dbox.h * dbox.scale - v);
            if (q < p) {
                u += (p - q) / 2;
                v += (p - q) / 2;
                q = p;
            }
            return { u, v, q, nbox, dbox };
        }
        getBevelledBBox(bbox, display) {
            const { u, v, delta, nbox, dbox } = this.getBevelData(display);
            const lbox = this.bevel.getOuterBBox();
            bbox.combine(nbox, 0, u);
            bbox.combine(lbox, bbox.w - delta / 2, 0);
            bbox.combine(dbox, bbox.w - delta / 2, v);
        }
        getBevelData(display) {
            const nbox = this.childNodes[0].getOuterBBox();
            const dbox = this.childNodes[1].getOuterBBox();
            const delta = display ? 0.4 : 0.15;
            const H = Math.max(nbox.scale * (nbox.h + nbox.d), dbox.scale * (dbox.h + dbox.d)) +
                2 * delta;
            const a = this.font.params.axis_height;
            const u = (nbox.scale * (nbox.d - nbox.h)) / 2 + a + delta;
            const v = (dbox.scale * (dbox.d - dbox.h)) / 2 + a - delta;
            return { H, delta, u, v, nbox, dbox };
        }
        isDisplay() {
            const { displaystyle, scriptlevel } = this.node.attributes.getList('displaystyle', 'scriptlevel');
            return displaystyle && scriptlevel === 0;
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.bevel = null;
            this.pad = this.node.getProperty('withDelims')
                ? 0
                : this.font.params.nulldelimiterspace;
            if (this.node.attributes.get('bevelled')) {
                const { H } = this.getBevelData(this.isDisplay());
                const bevel = (this.bevel = this.createMo('/'));
                bevel.node.attributes.set('symmetric', true);
                bevel.canStretch(DIRECTION.Vertical);
                bevel.getStretchedVariant([H], true);
            }
        }
        computeBBox(bbox, recompute = false) {
            bbox.empty();
            const { linethickness, bevelled } = this.node.attributes.getList('linethickness', 'bevelled');
            const display = this.isDisplay();
            let w = null;
            if (bevelled) {
                this.getBevelledBBox(bbox, display);
            }
            else {
                const thickness = this.length2em(String(linethickness), 0.06);
                w = -2 * this.pad;
                if (thickness === 0) {
                    this.getAtopBBox(bbox, display);
                }
                else {
                    this.getFractionBBox(bbox, display, thickness);
                    w -= 0.2;
                }
                w += bbox.w;
            }
            bbox.clean();
            this.setChildPWidths(recompute, w);
        }
        canStretch(_direction) {
            return false;
        }
        getChildAlign(i) {
            const attributes = this.node.attributes;
            return attributes.get('bevelled')
                ? 'left'
                : attributes.get(['numalign', 'denomalign'][i]);
        }
        getWrapWidth(i) {
            const attributes = this.node.attributes;
            if (attributes.get('bevelled')) {
                return this.childNodes[i].getOuterBBox().w;
            }
            const w = this.getBBox().w;
            const thickness = this.length2em(attributes.get('linethickness'));
            return w - (thickness ? 0.2 : 0) - 2 * this.pad;
        }
    };
}
//# sourceMappingURL=mfrac.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mfrac.js
const mfrac_def = MathJax._.core.MmlTree.MmlNodes.mfrac;
const MmlMfrac = mfrac_def.MmlMfrac;

;// ./mjs/output/chtml/Wrappers/mfrac.js



const ChtmlMfrac = (function () {
    var _a;
    const Base = CommonMfracMixin(ChtmlWrapper);
    return _a = class ChtmlMfrac extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                this.standardChtmlNodes(parents);
                const { linethickness, bevelled } = this.node.attributes.getList('linethickness', 'bevelled');
                const display = this.isDisplay();
                if (bevelled) {
                    this.makeBevelled(display);
                }
                else {
                    const thickness = this.length2em(String(linethickness), 0.06);
                    if (thickness === 0) {
                        this.makeAtop(display);
                    }
                    else {
                        this.makeFraction(display, thickness);
                    }
                }
            }
            makeFraction(display, t) {
                const { numalign, denomalign } = this.node.attributes.getList('numalign', 'denomalign');
                const withDelims = this.node.getProperty('withDelims');
                const attr = (display ? { type: 'd' } : {});
                const fattr = (withDelims ? Object.assign(Object.assign({}, attr), { delims: 'true' }) : Object.assign({}, attr));
                const nattr = (numalign !== 'center' ? { align: numalign } : {});
                const dattr = (denomalign !== 'center' ? { align: denomalign } : {});
                const dsattr = Object.assign({}, attr), nsattr = Object.assign({}, attr);
                const tex = this.font.params;
                if (t !== 0.06) {
                    const a = tex.axis_height;
                    const r = this.font.params.rule_factor;
                    const tEm = this.em(t);
                    const { T, u, v } = this.getTUV(display, t);
                    const m = (display ? this.em(3 * t) : tEm) + ' -.1em';
                    attr.style = {
                        height: tEm,
                        'border-top': this.em(t * r) + ' solid',
                        margin: m,
                    };
                    const nh = this.em(Math.max(0, u));
                    nsattr.style = { height: nh, 'vertical-align': '-' + nh };
                    dsattr.style = { height: this.em(Math.max(0, v)) };
                    fattr.style = { 'vertical-align': this.em(a - T) };
                }
                let num, den;
                this.adaptor.append(this.dom[0], this.html('mjx-frac', fattr, [
                    (num = this.html('mjx-num', nattr, [
                        this.html('mjx-nstrut', nsattr),
                    ])),
                    this.html('mjx-dbox', {}, [
                        this.html('mjx-dtable', {}, [
                            this.html('mjx-line', attr),
                            this.html('mjx-row', {}, [
                                (den = this.html('mjx-den', dattr, [
                                    this.html('mjx-dstrut', dsattr),
                                ])),
                            ]),
                        ]),
                    ]),
                ]));
                this.childNodes[0].toCHTML([num]);
                this.childNodes[1].toCHTML([den]);
            }
            makeAtop(display) {
                const { numalign, denomalign } = this.node.attributes.getList('numalign', 'denomalign');
                const withDelims = this.node.getProperty('withDelims');
                const attr = (display ? { type: 'd', atop: true } : { atop: true });
                const fattr = (withDelims ? Object.assign(Object.assign({}, attr), { delims: true }) : Object.assign({}, attr));
                const nattr = (numalign !== 'center' ? { align: numalign } : {});
                const dattr = (denomalign !== 'center' ? { align: denomalign } : {});
                const { v, q } = this.getUVQ(display);
                nattr.style = { 'padding-bottom': this.em(q) };
                fattr.style = { 'vertical-align': this.em(-v) };
                let num, den;
                this.adaptor.append(this.dom[0], this.html('mjx-frac', fattr, [
                    (num = this.html('mjx-num', nattr)),
                    (den = this.html('mjx-den', dattr)),
                ]));
                this.childNodes[0].toCHTML([num]);
                this.childNodes[1].toCHTML([den]);
            }
            makeBevelled(display) {
                const adaptor = this.adaptor;
                adaptor.setAttribute(this.dom[0], 'bevelled', 'ture');
                const num = adaptor.append(this.dom[0], this.html('mjx-num'));
                this.childNodes[0].toCHTML([num]);
                this.bevel.toCHTML(this.dom);
                const den = adaptor.append(this.dom[0], this.html('mjx-den'));
                this.childNodes[1].toCHTML([den]);
                const { u, v, delta, nbox, dbox } = this.getBevelData(display);
                if (u) {
                    adaptor.setStyle(num, 'verticalAlign', this.em(u / nbox.scale));
                }
                if (v) {
                    adaptor.setStyle(den, 'verticalAlign', this.em(v / dbox.scale));
                }
                const dx = this.em(-delta / 2);
                adaptor.setStyle(this.bevel.dom[0], 'marginLeft', dx);
                adaptor.setStyle(this.bevel.dom[0], 'marginRight', dx);
            }
        },
        _a.kind = MmlMfrac.prototype.kind,
        _a.styles = {
            'mjx-frac': {
                display: 'inline-block',
                'vertical-align': '0.17em',
                padding: '0 .22em'
            },
            'mjx-frac[type="d"]': {
                'vertical-align': '.04em'
            },
            'mjx-frac[delims]': {
                padding: '0 .1em'
            },
            'mjx-frac[atop]': {
                padding: '0 .12em'
            },
            'mjx-frac[atop][delims]': {
                padding: '0'
            },
            'mjx-dtable': {
                display: 'inline-table',
                width: '100%'
            },
            'mjx-dtable > *': {
                'font-size': '2000%'
            },
            'mjx-dbox': {
                display: 'block',
                'font-size': '5%'
            },
            'mjx-num': {
                display: 'block',
                'text-align': 'center'
            },
            'mjx-den': {
                display: 'block',
                'text-align': 'center'
            },
            'mjx-mfrac[bevelled] > mjx-num': {
                display: 'inline-block'
            },
            'mjx-mfrac[bevelled] > mjx-den': {
                display: 'inline-block'
            },
            'mjx-den[align="right"], mjx-num[align="right"]': {
                'text-align': 'right'
            },
            'mjx-den[align="left"], mjx-num[align="left"]': {
                'text-align': 'left'
            },
            'mjx-nstrut': {
                display: 'inline-block',
                height: '.054em',
                width: 0,
                'vertical-align': '-.054em'
            },
            'mjx-nstrut[type="d"]': {
                height: '.217em',
                'vertical-align': '-.217em',
            },
            'mjx-dstrut': {
                display: 'inline-block',
                height: '.505em',
                width: 0
            },
            'mjx-dstrut[type="d"]': {
                height: '.726em',
            },
            'mjx-line': {
                display: 'block',
                'box-sizing': 'border-box',
                'min-height': '1px',
                height: '.06em',
                'border-top': '.075em solid',
                margin: '.06em -.1em',
                overflow: 'hidden'
            },
            'mjx-line[type="d"]': {
                margin: '.18em -.1em'
            }
        },
        _a;
})();
//# sourceMappingURL=mfrac.js.map
;// ./mjs/output/common/Wrappers/msqrt.js


function CommonMsqrtMixin(Base) {
    return class CommonMsqrtMixin extends Base {
        get base() {
            return 0;
        }
        get root() {
            return null;
        }
        combineRootBBox(_bbox, _sbox, _H) { }
        getPQ(sbox) {
            const t = this.font.params.rule_thickness;
            const s = this.font.params.surd_height;
            const p = this.node.attributes.get('displaystyle')
                ? this.font.params.x_height
                : t;
            const q = sbox.h + sbox.d > this.surdH
                ? (sbox.h + sbox.d - (this.surdH - t - s - p / 2)) / 2
                : s + p / 4;
            return [p, q];
        }
        getRootDimens(_sbox, _H) {
            return [0, 0, 0, 0];
        }
        rootWidth() {
            return 1.25;
        }
        getStretchedSurd() {
            const t = this.font.params.rule_thickness;
            const s = this.font.params.surd_height;
            const p = this.node.attributes.get('displaystyle')
                ? this.font.params.x_height
                : t;
            const { h, d } = this.childNodes[this.base].getOuterBBox();
            this.surdH = h + d + t + s + p / 4;
            this.surd.getStretchedVariant([this.surdH - d, d], true);
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.surd = this.createMo('\u221A');
            this.surd.canStretch(DIRECTION.Vertical);
            this.getStretchedSurd();
        }
        computeBBox(bbox, recompute = false) {
            bbox.empty();
            const surdbox = this.surd.getBBox();
            const basebox = new BBox(this.childNodes[this.base].getOuterBBox());
            const q = this.getPQ(surdbox)[1];
            const t = this.font.params.rule_thickness;
            const s = this.font.params.surd_height;
            const H = basebox.h + q + t;
            const [x] = this.getRootDimens(surdbox, H);
            bbox.h = H + s;
            this.combineRootBBox(bbox, surdbox, H);
            bbox.combine(surdbox, x, H - surdbox.h);
            bbox.combine(basebox, x + surdbox.w, 0);
            bbox.clean();
            this.setChildPWidths(recompute);
        }
        invalidateBBox() {
            super.invalidateBBox();
            this.surd.childNodes[0].invalidateBBox();
        }
    };
}
//# sourceMappingURL=msqrt.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/msqrt.js
const msqrt_def = MathJax._.core.MmlTree.MmlNodes.msqrt;
const MmlMsqrt = msqrt_def.MmlMsqrt;

;// ./mjs/output/chtml/Wrappers/msqrt.js



const ChtmlMsqrt = (function () {
    var _a;
    const Base = CommonMsqrtMixin(ChtmlWrapper);
    return _a = class ChtmlMsqrt extends Base {
            toCHTML(parents) {
                const surd = this.surd;
                const base = this.childNodes[this.base];
                const sbox = surd.getBBox();
                const bbox = base.getOuterBBox();
                const [, q] = this.getPQ(sbox);
                const t = this.font.params.surd_height;
                const H = bbox.h + q + t;
                const adaptor = this.adaptor;
                const CHTML = this.standardChtmlNodes(parents);
                let SURD, BASE, ROOT, root;
                if (this.root != null) {
                    ROOT = adaptor.append(CHTML[0], this.html('mjx-root'));
                    root = this.childNodes[this.root];
                }
                const SQRT = adaptor.append(CHTML[0], this.html('mjx-sqrt', {}, [
                    (SURD = this.html('mjx-surd')),
                    (BASE = this.html('mjx-box', { style: { paddingTop: this.em(q) } })),
                ]));
                if (t !== 0.06) {
                    adaptor.setStyle(BASE, 'border-top-width', this.em(t * this.font.params.rule_factor));
                }
                this.addRoot(ROOT, root, sbox, H);
                surd.toCHTML([SURD]);
                base.toCHTML([BASE]);
                if (surd.size < 0) {
                    adaptor.addClass(SQRT, 'mjx-tall');
                }
            }
            addRoot(_ROOT, _root, _sbox, _H) { }
        },
        _a.kind = MmlMsqrt.prototype.kind,
        _a.styles = {
            'mjx-root': {
                display: 'inline-block',
                'white-space': 'nowrap',
            },
            'mjx-surd': {
                display: 'inline-block',
                'vertical-align': 'top',
            },
            'mjx-sqrt': {
                display: 'inline-block',
                'padding-top': '.075em',
            },
            'mjx-sqrt > mjx-box': {
                'border-top': '.075em solid',
                'padding-left': '.03em',
                'margin-left': '-.03em',
            },
            'mjx-sqrt.mjx-tall > mjx-box': {
                'padding-left': '.3em',
                'margin-left': '-.3em',
            },
        },
        _a;
})();
//# sourceMappingURL=msqrt.js.map
;// ./mjs/output/common/Wrappers/mroot.js
function CommonMrootMixin(Base) {
    return class CommonMrootMixin extends Base {
        get root() {
            return 1;
        }
        combineRootBBox(BBOX, sbox, H) {
            const bbox = this.childNodes[this.root].getOuterBBox();
            const h = this.getRootDimens(sbox, H)[1];
            BBOX.combine(bbox, 0, h);
        }
        getRootDimens(sbox, H) {
            const surd = this.surd;
            const bbox = this.childNodes[this.root].getOuterBBox();
            const offset = (surd.size < 0 ? 0.5 : 0.6) * sbox.w;
            const { w, rscale } = bbox;
            const W = Math.max(w, offset / rscale);
            const dx = Math.max(0, W - w);
            const h = this.rootHeight(bbox, sbox, surd.size, H);
            const x = W * rscale - offset;
            return [x, h, dx];
        }
        rootHeight(rbox, sbox, size, H) {
            const h = sbox.h + sbox.d;
            const b = (size < 0 ? 1.9 : 0.55 * h) - (h - H);
            return b + Math.max(0, rbox.d * rbox.rscale);
        }
        rootWidth() {
            const bbox = this.childNodes[this.root].getOuterBBox();
            return 0.4 + bbox.w * bbox.rscale;
        }
    };
}
//# sourceMappingURL=mroot.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mroot.js
const mroot_def = MathJax._.core.MmlTree.MmlNodes.mroot;
const MmlMroot = mroot_def.MmlMroot;

;// ./mjs/output/chtml/Wrappers/mroot.js



const ChtmlMroot = (function () {
    var _a;
    const Base = CommonMrootMixin(ChtmlMsqrt);
    return _a = class ChtmlMroot extends Base {
            addRoot(ROOT, root, sbox, H) {
                root.toCHTML([ROOT]);
                const adaptor = this.adaptor;
                const [x, h, dx] = this.getRootDimens(sbox, H);
                adaptor.setStyle(ROOT, 'verticalAlign', this.em(h));
                adaptor.setStyle(ROOT, 'width', this.em(x));
                if (dx) {
                    adaptor.setStyle(adaptor.firstChild(ROOT), 'paddingLeft', this.em(dx));
                }
            }
        },
        _a.kind = MmlMroot.prototype.kind,
        _a;
})();
//# sourceMappingURL=mroot.js.map
;// ./mjs/output/common/Wrappers/msubsup.js
function CommonMsubMixin(Base) {
    var _a;
    return _a = class CommonMsubMixin extends Base {
            get scriptChild() {
                return this.childNodes[this.node.sub];
            }
            getOffset() {
                const x = this.baseIsChar ? 0 : this.getAdjustedIc();
                return [x, -this.getV()];
            }
        },
        _a.useIC = false,
        _a;
}
function CommonMsupMixin(Base) {
    return class CommonMsupMixin extends Base {
        get scriptChild() {
            return this.childNodes[this.node.sup];
        }
        getOffset() {
            const x = this.getAdjustedIc() - (this.baseRemoveIc ? 0 : this.baseIc);
            return [x, this.getU()];
        }
    };
}
function CommonMsubsupMixin(Base) {
    var _a;
    return _a = class CommonMsubsupMixin extends Base {
            constructor() {
                super(...arguments);
                this.UVQ = null;
            }
            get subChild() {
                return this.childNodes[this.node.sub];
            }
            get supChild() {
                return this.childNodes[this.node.sup];
            }
            get scriptChild() {
                return this.supChild;
            }
            getUVQ(subbox = this.subChild.getOuterBBox(), supbox = this.supChild.getOuterBBox()) {
                const base = this.baseCore;
                const bbox = base.getLineBBox(base.breakCount);
                if (this.UVQ)
                    return this.UVQ;
                const tex = this.font.params;
                const t = 3 * tex.rule_thickness;
                const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub2);
                const drop = this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * subbox.rscale);
                const supd = supbox.d * supbox.rscale;
                const subh = subbox.h * subbox.rscale;
                let [u, v] = [this.getU(), Math.max(drop, subscriptshift)];
                let q = u - supd - (subh - v);
                if (q < t) {
                    v += t - q;
                    const p = (4 / 5) * tex.x_height - (u - supd);
                    if (p > 0) {
                        u += p;
                        v -= p;
                    }
                }
                u = Math.max(this.length2em(this.node.attributes.get('superscriptshift'), u), u);
                v = Math.max(this.length2em(this.node.attributes.get('subscriptshift'), v), v);
                q = u - supd - (subh - v);
                this.UVQ = [u, -v, q];
                return this.UVQ;
            }
            appendScripts(bbox) {
                const [subbox, supbox] = [
                    this.subChild.getOuterBBox(),
                    this.supChild.getOuterBBox(),
                ];
                const w = this.getBaseWidth();
                const x = this.getAdjustedIc();
                const [u, v] = this.getUVQ();
                const y = bbox.d - this.baseChild.getLineBBox(this.baseChild.breakCount).d;
                bbox.combine(subbox, w + (this.baseIsChar ? 0 : x), v - y);
                bbox.combine(supbox, w + x, u - y);
                bbox.w += this.font.params.scriptspace;
                return bbox;
            }
        },
        _a.useIC = false,
        _a;
}
//# sourceMappingURL=msubsup.js.map
;// ./mjs/output/common/Wrappers/scriptbase.js


function CommonScriptbaseMixin(Base) {
    var _a;
    return _a = class CommonScriptbaseMixin extends Base {
            get baseChild() {
                return this.childNodes[this.node.base];
            }
            get scriptChild() {
                return this.childNodes[1];
            }
            getBaseCore() {
                let core = this.getSemanticBase() || this.childNodes[0];
                let node = core === null || core === void 0 ? void 0 : core.node;
                while (core &&
                    ((core.childNodes.length === 1 &&
                        (node.isKind('mrow') ||
                            node.isKind('TeXAtom') ||
                            node.isKind('mstyle') ||
                            (node.isKind('mpadded') && !node.getProperty('vbox')) ||
                            node.isKind('mphantom') ||
                            node.isKind('semantics'))) ||
                        (node.isKind('munderover') &&
                            core.isMathAccent))) {
                    this.setBaseAccentsFor(core);
                    core = core.childNodes[0];
                    node = core === null || core === void 0 ? void 0 : core.node;
                }
                if (!core) {
                    this.baseHasAccentOver = this.baseHasAccentUnder = false;
                }
                return core || this.childNodes[0];
            }
            setBaseAccentsFor(core) {
                if (core.node.isKind('munderover')) {
                    if (this.baseHasAccentOver === null) {
                        this.baseHasAccentOver = !!core.node.attributes.get('accent');
                    }
                    if (this.baseHasAccentUnder === null) {
                        this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');
                    }
                }
            }
            getSemanticBase() {
                const fence = this.node.attributes.getExplicit('data-semantic-fencepointer');
                return this.getBaseFence(this.baseChild, fence);
            }
            getBaseFence(fence, id) {
                if (!fence || !fence.node.attributes || !id) {
                    return null;
                }
                if (fence.node.attributes.getExplicit('data-semantic-id') === id) {
                    return fence;
                }
                for (const child of fence.childNodes) {
                    const result = this.getBaseFence(child, id);
                    if (result) {
                        return result;
                    }
                }
                return null;
            }
            getBaseScale() {
                let child = this.baseCore;
                let scale = 1;
                while (child && child !== this) {
                    const bbox = child.getOuterBBox();
                    scale *= bbox.rscale;
                    child = child.parent;
                }
                return scale;
            }
            getBaseIc() {
                return this.baseCore.getOuterBBox().ic * this.baseScale;
            }
            getAdjustedIc() {
                return this.baseIc ? 1.05 * this.baseIc + 0.05 : 0;
            }
            isCharBase() {
                const base = this.baseCore;
                return (((base.node.isKind('mo') && base.size === null) ||
                    base.node.isKind('mi') ||
                    base.node.isKind('mn')) &&
                    base.bbox.rscale === 1 &&
                    Array.from(base.getText()).length === 1);
            }
            checkLineAccents() {
                if (!this.node.isKind('munderover'))
                    return;
                if (this.node.isKind('mover')) {
                    this.isLineAbove = this.isLineAccent(this.scriptChild);
                }
                else if (this.node.isKind('munder')) {
                    this.isLineBelow = this.isLineAccent(this.scriptChild);
                }
                else {
                    const mml = this;
                    this.isLineAbove = this.isLineAccent(mml.overChild);
                    this.isLineBelow = this.isLineAccent(mml.underChild);
                }
            }
            isLineAccent(script) {
                const node = script.coreMO().node;
                return node.isToken && node.getText() === '\u2015';
            }
            getBaseWidth() {
                const bbox = this.baseChild.getLineBBox(this.baseChild.breakCount);
                return (bbox.w * bbox.rscale -
                    (this.baseRemoveIc ? this.baseIc : 0) +
                    this.font.params.extra_ic);
            }
            getOffset() {
                return [0, 0];
            }
            baseCharZero(n) {
                const largeop = !!this.baseCore.node.attributes.get('largeop');
                const sized = !!(this.baseCore.node.isKind('mo') &&
                    this.baseCore.size);
                const scale = this.baseScale;
                return this.baseIsChar && !largeop && !sized && scale === 1 ? 0 : n;
            }
            getV() {
                const base = this.baseCore;
                const bbox = base.getLineBBox(base.breakCount);
                const sbox = this.scriptChild.getOuterBBox();
                const tex = this.font.params;
                const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);
                return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - (4 / 5) * tex.x_height);
            }
            getU() {
                const base = this.baseCore;
                const bbox = base.getLineBBox(base.breakCount);
                const sbox = this.scriptChild.getOuterBBox();
                const tex = this.font.params;
                const attr = this.node.attributes.getList('displaystyle', 'superscriptshift');
                const prime = this.node.getProperty('texprimestyle');
                const p = prime ? tex.sup3 : attr.displaystyle ? tex.sup1 : tex.sup2;
                const superscriptshift = this.length2em(attr.superscriptshift, p);
                return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + (1 / 4) * tex.x_height);
            }
            hasMovableLimits() {
                const display = this.node.attributes.get('displaystyle');
                const mo = this.baseChild.coreMO().node;
                return !display && !!mo.attributes.get('movablelimits');
            }
            getOverKU(basebox, overbox) {
                const accent = this.node.attributes.get('accent');
                const tex = this.font.params;
                const d = overbox.d * overbox.rscale;
                const t = tex.rule_thickness * tex.separation_factor;
                const delta = this.baseHasAccentOver ? t : 0;
                const T = this.isLineAbove ? 3 * tex.rule_thickness : t;
                const k = (accent
                    ? T
                    : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;
                return [k, basebox.h * basebox.rscale + k + d];
            }
            getUnderKV(basebox, underbox) {
                const accent = this.node.attributes.get('accentunder');
                const tex = this.font.params;
                const h = underbox.h * underbox.rscale;
                const t = tex.rule_thickness * tex.separation_factor;
                const delta = this.baseHasAccentUnder ? t : 0;
                const T = this.isLineBelow ? 3 * tex.rule_thickness : t;
                const k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) -
                    delta;
                return [k, -(basebox.d * basebox.rscale + k + h)];
            }
            getDeltaW(boxes, delta = [0, 0, 0]) {
                const align = this.node.attributes.get('align');
                const widths = boxes.map((box) => box.w * box.rscale);
                widths[0] -=
                    this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop')
                        ? this.baseIc
                        : 0;
                const w = Math.max(...widths);
                const dw = [];
                let m = 0;
                for (const i of widths.keys()) {
                    dw[i] =
                        (align === 'center'
                            ? (w - widths[i]) / 2
                            : align === 'right'
                                ? w - widths[i]
                                : 0) + delta[i];
                    if (dw[i] < m) {
                        m = -dw[i];
                    }
                }
                if (m) {
                    for (const i of dw.keys()) {
                        dw[i] += m;
                    }
                }
                [1, 2].map((i) => (dw[i] += boxes[i] ? boxes[i].dx * boxes[0].rscale : 0));
                return dw;
            }
            getDelta(script, noskew = false) {
                const accent = this.node.attributes.get('accent');
                let { sk, ic } = this.baseCore.getOuterBBox();
                if (accent) {
                    sk -= script.getOuterBBox().sk;
                }
                return (((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) *
                    this.baseScale);
            }
            stretchChildren() {
                const stretchy = [];
                for (const child of this.childNodes) {
                    if (child.canStretch(DIRECTION.Horizontal)) {
                        stretchy.push(child);
                    }
                }
                const count = stretchy.length;
                const nodeCount = this.childNodes.length;
                if (count && nodeCount > 1) {
                    let W = 0;
                    const all = count > 1 && count === nodeCount;
                    for (const child of this.childNodes) {
                        const noStretch = child.stretch.dir === DIRECTION.None;
                        if (all || noStretch) {
                            const { w, rscale } = child.getOuterBBox(noStretch);
                            if (w * rscale > W)
                                W = w * rscale;
                        }
                    }
                    for (const child of stretchy) {
                        const core = child.coreMO();
                        if (core.size === null) {
                            core.getStretchedVariant([W / child.coreRScale()]);
                        }
                    }
                }
            }
            constructor(factory, node, parent = null) {
                super(factory, node, parent);
                this.baseScale = 1;
                this.baseIc = 0;
                this.baseRemoveIc = false;
                this.baseIsChar = false;
                this.baseHasAccentOver = null;
                this.baseHasAccentUnder = null;
                this.isLineAbove = false;
                this.isLineBelow = false;
                this.isMathAccent = false;
                const core = (this.baseCore = this.getBaseCore());
                if (!core)
                    return;
                this.setBaseAccentsFor(core);
                this.baseScale = this.getBaseScale();
                this.baseIc = this.getBaseIc();
                this.baseIsChar = this.isCharBase();
                this.isMathAccent =
                    this.baseIsChar &&
                        this.scriptChild &&
                        this.scriptChild.coreMO().node.getProperty('mathaccent') !== undefined;
                this.checkLineAccents();
                this.baseRemoveIc =
                    !this.isLineAbove &&
                        !this.isLineBelow &&
                        (!(this.constructor
                            .useIC) ||
                            this.isMathAccent);
            }
            computeBBox(bbox, recompute = false) {
                bbox.empty();
                bbox.append(this.baseChild.getOuterBBox());
                this.appendScripts(bbox);
                bbox.clean();
                this.setChildPWidths(recompute);
            }
            appendScripts(bbox) {
                const w = this.getBaseWidth();
                const [x, y] = this.getOffset();
                bbox.combine(this.scriptChild.getOuterBBox(), w + x, y);
                bbox.w += this.font.params.scriptspace;
                return bbox;
            }
            get breakCount() {
                if (this._breakCount < 0) {
                    this._breakCount = this.node.isEmbellished
                        ? this.coreMO().embellishedBreakCount
                        : !this.node.linebreakContainer
                            ? this.childNodes[0].breakCount
                            : 0;
                }
                return this._breakCount;
            }
            breakTop(mrow, child) {
                return this.node.linebreakContainer ||
                    !this.parent ||
                    this.node.childIndex(child.node)
                    ? mrow
                    : this.parent.breakTop(mrow, this);
            }
            computeLineBBox(i) {
                const n = this.breakCount;
                if (!n)
                    return LineBBox.from(this.getOuterBBox(), this.linebreakOptions.lineleading);
                const bbox = this.baseChild.getLineBBox(i).copy();
                if (i < n) {
                    if (i === 0) {
                        this.addLeftBorders(bbox);
                    }
                    this.addMiddleBorders(bbox);
                }
                else {
                    this.appendScripts(bbox);
                    this.addMiddleBorders(bbox);
                    this.addRightBorders(bbox);
                }
                return bbox;
            }
        },
        _a.useIC = true,
        _a;
}
//# sourceMappingURL=scriptbase.js.map
;// ./mjs/output/chtml/Wrappers/scriptbase.js



const ChtmlScriptbase = (function () {
    var _a;
    const Base = CommonScriptbaseMixin(ChtmlWrapper);
    return _a = class ChtmlScriptbase extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                this.dom = this.standardChtmlNodes(parents);
                const [x, v] = this.getOffset();
                const dx = x - (this.baseRemoveIc ? this.baseIc : 0);
                const style = { 'vertical-align': this.em(v) };
                if (dx) {
                    style['margin-left'] = this.em(dx);
                }
                this.baseChild.toCHTML(this.dom);
                const dom = this.dom[this.dom.length - 1];
                this.scriptChild.toCHTML([
                    this.adaptor.append(dom, this.html('mjx-script', { style })),
                ]);
            }
            markUsed() {
                super.markUsed();
                this.jax.wrapperUsage.add(ChtmlMsubsup.kind);
            }
            setDeltaW(nodes, dx) {
                for (let i = 0; i < dx.length; i++) {
                    if (dx[i]) {
                        this.adaptor.setStyle(nodes[i], 'paddingLeft', this.em(dx[i]));
                    }
                }
            }
            adjustOverDepth(over, overbox) {
                if (overbox.d >= 0)
                    return;
                this.adaptor.setStyle(over, 'marginBottom', this.em(overbox.d * overbox.rscale));
            }
            adjustUnderDepth(under, underbox) {
                if (underbox.d >= 0)
                    return;
                const adaptor = this.adaptor;
                const v = this.em(underbox.d);
                const box = this.html('mjx-box', {
                    style: { 'margin-bottom': v, 'vertical-align': v },
                });
                for (const child of adaptor.childNodes(adaptor.firstChild(under))) {
                    adaptor.append(box, child);
                }
                adaptor.append(adaptor.firstChild(under), box);
            }
            adjustBaseHeight(base, basebox) {
                if (this.node.attributes.get('accent')) {
                    const minH = this.font.params.x_height * this.baseScale;
                    if (basebox.h < minH) {
                        this.adaptor.setStyle(base, 'paddingTop', this.em(minH - basebox.h));
                        basebox.h = minH;
                    }
                }
            }
        },
        _a.kind = 'scriptbase',
        _a;
})();
//# sourceMappingURL=scriptbase.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/msubsup.js
const msubsup_def = MathJax._.core.MmlTree.MmlNodes.msubsup;
const MmlMsubsup = msubsup_def.MmlMsubsup;
const MmlMsub = msubsup_def.MmlMsub;
const MmlMsup = msubsup_def.MmlMsup;

;// ./mjs/output/chtml/Wrappers/msubsup.js



const ChtmlMsub = (function () {
    var _a;
    const Base = CommonMsubMixin(ChtmlScriptbase);
    return _a = class ChtmlMsub extends Base {
        },
        _a.kind = MmlMsub.prototype.kind,
        _a;
})();
const ChtmlMsup = (function () {
    var _a;
    const Base = CommonMsupMixin(ChtmlScriptbase);
    return _a = class ChtmlMsup extends Base {
        },
        _a.kind = MmlMsup.prototype.kind,
        _a;
})();
const ChtmlMsubsup = (function () {
    var _a;
    const Base = CommonMsubsupMixin(ChtmlScriptbase);
    return _a = class ChtmlMsubsup extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const adaptor = this.adaptor;
                const chtml = this.standardChtmlNodes(parents);
                const [base, sup, sub] = [this.baseChild, this.supChild, this.subChild];
                const [, v, q] = this.getUVQ();
                const style = { 'vertical-align': this.em(v) };
                base.toCHTML(chtml);
                const stack = adaptor.append(chtml[chtml.length - 1], this.html('mjx-script', { style }));
                sup.toCHTML([stack]);
                adaptor.append(stack, this.html('mjx-spacer', { style: { 'margin-top': this.em(q) } }));
                sub.toCHTML([stack]);
                const ic = this.getAdjustedIc();
                if (ic) {
                    adaptor.setStyle(sup.dom[0], 'marginLeft', this.em(ic / sup.bbox.rscale));
                    if (!this.baseIsChar) {
                        adaptor.setStyle(sub.dom[0], 'marginLeft', this.em(ic / sup.bbox.rscale));
                    }
                }
                if (this.baseRemoveIc) {
                    adaptor.setStyle(stack, 'marginLeft', this.em(-this.baseIc));
                }
            }
        },
        _a.kind = MmlMsubsup.prototype.kind,
        _a.styles = {
            'mjx-script': {
                display: 'inline-block',
                'padding-right': '.05em',
                'padding-left': '.033em',
            },
            'mjx-script > mjx-spacer': {
                display: 'block',
            },
        },
        _a;
})();
//# sourceMappingURL=msubsup.js.map
;// ./mjs/output/common/Wrappers/munderover.js
function CommonMunderMixin(Base) {
    return class CommonMunderMixin extends Base {
        get scriptChild() {
            return this.childNodes[this.node.under];
        }
        constructor(...args) {
            super(...args);
            this.stretchChildren();
        }
        computeBBox(bbox, recompute = false) {
            if (this.hasMovableLimits()) {
                super.computeBBox(bbox, recompute);
                return;
            }
            bbox.empty();
            const basebox = this.baseChild.getOuterBBox();
            const underbox = this.scriptChild.getOuterBBox();
            const v = this.getUnderKV(basebox, underbox)[1];
            const delta = this.isLineBelow
                ? 0
                : this.getDelta(this.scriptChild, true);
            const [bw, uw] = this.getDeltaW([basebox, underbox], [0, -delta]);
            bbox.combine(basebox, bw, 0);
            bbox.combine(underbox, uw, v);
            bbox.d += this.font.params.big_op_spacing5;
            bbox.clean();
            this.setChildPWidths(recompute);
        }
    };
}
function CommonMoverMixin(Base) {
    return class CommonMoverMixin extends Base {
        get scriptChild() {
            return this.childNodes[this.node.over];
        }
        constructor(...args) {
            super(...args);
            this.stretchChildren();
        }
        computeBBox(bbox) {
            if (this.hasMovableLimits()) {
                super.computeBBox(bbox);
                return;
            }
            bbox.empty();
            const basebox = this.baseChild.getOuterBBox();
            const overbox = this.scriptChild.getOuterBBox();
            if (this.node.attributes.get('accent')) {
                basebox.h = Math.max(basebox.h, this.font.params.x_height * this.baseScale);
            }
            const u = this.getOverKU(basebox, overbox)[1];
            const delta = this.isLineAbove ? 0 : this.getDelta(this.scriptChild);
            const [bw, ow] = this.getDeltaW([basebox, overbox], [0, delta]);
            bbox.combine(basebox, bw, 0);
            bbox.combine(overbox, ow, u);
            bbox.h += this.font.params.big_op_spacing5;
            bbox.clean();
        }
    };
}
function CommonMunderoverMixin(Base) {
    return class CommonMunderoverMixin extends Base {
        get underChild() {
            return this.childNodes[this.node.under];
        }
        get overChild() {
            return this.childNodes[this.node.over];
        }
        get subChild() {
            return this.underChild;
        }
        get supChild() {
            return this.overChild;
        }
        constructor(...args) {
            super(...args);
            this.stretchChildren();
        }
        computeBBox(bbox) {
            if (this.hasMovableLimits()) {
                super.computeBBox(bbox);
                return;
            }
            bbox.empty();
            const overbox = this.overChild.getOuterBBox();
            const basebox = this.baseChild.getOuterBBox();
            const underbox = this.underChild.getOuterBBox();
            if (this.node.attributes.get('accent')) {
                basebox.h = Math.max(basebox.h, this.font.params.x_height * this.baseScale);
            }
            const u = this.getOverKU(basebox, overbox)[1];
            const v = this.getUnderKV(basebox, underbox)[1];
            const odelta = this.getDelta(this.overChild);
            const udelta = this.getDelta(this.underChild, true);
            const [bw, uw, ow] = this.getDeltaW([basebox, underbox, overbox], [0, this.isLineBelow ? 0 : -udelta, this.isLineAbove ? 0 : odelta]);
            bbox.combine(basebox, bw, 0);
            bbox.combine(overbox, ow, u);
            bbox.combine(underbox, uw, v);
            const z = this.font.params.big_op_spacing5;
            bbox.h += z;
            bbox.d += z;
            bbox.clean();
        }
    };
}
//# sourceMappingURL=munderover.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/munderover.js
const munderover_def = MathJax._.core.MmlTree.MmlNodes.munderover;
const MmlMunderover = munderover_def.MmlMunderover;
const MmlMunder = munderover_def.MmlMunder;
const MmlMover = munderover_def.MmlMover;

;// ./mjs/output/chtml/Wrappers/munderover.js



const ChtmlMunder = (function () {
    var _a;
    const Base = CommonMunderMixin(ChtmlMsub);
    return _a = class ChtmlMunder extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                if (this.hasMovableLimits()) {
                    super.toCHTML(parents);
                    this.adaptor.setAttribute(this.dom[0], 'limits', 'false');
                    return;
                }
                this.dom = this.standardChtmlNodes(parents);
                const base = this.adaptor.append(this.adaptor.append(this.dom[0], this.html('mjx-row')), this.html('mjx-base'));
                const under = this.adaptor.append(this.adaptor.append(this.dom[0], this.html('mjx-row')), this.html('mjx-under'));
                this.baseChild.toCHTML([base]);
                this.scriptChild.toCHTML([under]);
                const basebox = this.baseChild.getOuterBBox();
                const underbox = this.scriptChild.getOuterBBox();
                const k = this.getUnderKV(basebox, underbox)[0];
                const delta = this.isLineBelow
                    ? 0
                    : this.getDelta(this.scriptChild, true);
                this.adaptor.setStyle(under, 'paddingTop', this.em(k));
                this.setDeltaW([base, under], this.getDeltaW([basebox, underbox], [0, -delta]));
                this.adjustUnderDepth(under, underbox);
            }
        },
        _a.kind = MmlMunder.prototype.kind,
        _a.styles = {
            'mjx-over': {
                'text-align': 'left',
            },
            'mjx-munder:not([limits="false"])': {
                display: 'inline-table',
            },
            'mjx-munder > mjx-row': {
                'text-align': 'left',
            },
            'mjx-under': {
                'padding-bottom': '.1em',
            },
        },
        _a;
})();
const ChtmlMover = (function () {
    var _a;
    const Base = CommonMoverMixin(ChtmlMsup);
    return _a = class ChtmlMover extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                if (this.hasMovableLimits()) {
                    super.toCHTML(parents);
                    this.adaptor.setAttribute(this.dom[0], 'limits', 'false');
                    return;
                }
                this.dom = this.standardChtmlNodes(parents);
                const over = this.adaptor.append(this.dom[0], this.html('mjx-over'));
                const base = this.adaptor.append(this.dom[0], this.html('mjx-base'));
                this.scriptChild.toCHTML([over]);
                this.baseChild.toCHTML([base]);
                const overbox = this.scriptChild.getOuterBBox();
                const basebox = this.baseChild.getOuterBBox();
                this.adjustBaseHeight(base, basebox);
                const k = this.getOverKU(basebox, overbox)[0];
                const delta = this.isLineAbove ? 0 : this.getDelta(this.scriptChild);
                this.adaptor.setStyle(over, 'paddingBottom', this.em(k));
                this.setDeltaW([base, over], this.getDeltaW([basebox, overbox], [0, delta]));
                this.adjustOverDepth(over, overbox);
            }
        },
        _a.kind = MmlMover.prototype.kind,
        _a.styles = {
            'mjx-mover:not([limits="false"])': {
                'padding-top': '.1em',
            },
            'mjx-mover:not([limits="false"]) > *': {
                display: 'block',
                'text-align': 'left',
            },
        },
        _a;
})();
const ChtmlMunderover = (function () {
    var _a;
    const Base = CommonMunderoverMixin(ChtmlMsubsup);
    return _a = class ChtmlMunderover extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                if (this.hasMovableLimits()) {
                    super.toCHTML(parents);
                    this.adaptor.setAttribute(this.dom[0], 'limits', 'false');
                    return;
                }
                this.dom = this.standardChtmlNodes(parents);
                const over = this.adaptor.append(this.dom[0], this.html('mjx-over'));
                const table = this.adaptor.append(this.adaptor.append(this.dom[0], this.html('mjx-box')), this.html('mjx-munder'));
                const base = this.adaptor.append(this.adaptor.append(table, this.html('mjx-row')), this.html('mjx-base'));
                const under = this.adaptor.append(this.adaptor.append(table, this.html('mjx-row')), this.html('mjx-under'));
                this.overChild.toCHTML([over]);
                this.baseChild.toCHTML([base]);
                this.underChild.toCHTML([under]);
                const overbox = this.overChild.getOuterBBox();
                const basebox = this.baseChild.getOuterBBox();
                const underbox = this.underChild.getOuterBBox();
                this.adjustBaseHeight(base, basebox);
                const ok = this.getOverKU(basebox, overbox)[0];
                const uk = this.getUnderKV(basebox, underbox)[0];
                const odelta = this.getDelta(this.overChild);
                const udelta = this.getDelta(this.underChild, true);
                this.adaptor.setStyle(over, 'paddingBottom', this.em(ok));
                this.adaptor.setStyle(under, 'paddingTop', this.em(uk));
                this.setDeltaW([base, under, over], this.getDeltaW([basebox, underbox, overbox], [0, this.isLineBelow ? 0 : -udelta, this.isLineAbove ? 0 : odelta]));
                this.adjustOverDepth(over, overbox);
                this.adjustUnderDepth(under, underbox);
            }
        },
        _a.kind = MmlMunderover.prototype.kind,
        _a.styles = {
            'mjx-munderover:not([limits="false"])': {
                'padding-top': '.1em',
            },
            'mjx-munderover:not([limits="false"]) > *': {
                display: 'block',
            },
        },
        _a;
})();
//# sourceMappingURL=munderover.js.map
;// ./mjs/output/common/Wrappers/mmultiscripts.js


const NextScript = {
    base: 'subList',
    subList: 'supList',
    supList: 'subList',
    psubList: 'psupList',
    psupList: 'psubList',
};
const ScriptNames = ['sup', 'sup', 'psup', 'psub'];
function CommonMmultiscriptsMixin(Base) {
    return class CommonMmultiscriptsMixin extends Base {
        combinePrePost(pre, post) {
            const bbox = new BBox(pre);
            bbox.combine(post, 0, 0);
            return bbox;
        }
        getScriptData() {
            const data = (this.scriptData = {
                base: null,
                sub: BBox.empty(),
                sup: BBox.empty(),
                psub: BBox.empty(),
                psup: BBox.empty(),
                numPrescripts: 0,
                numScripts: 0,
            });
            const lists = this.getScriptBBoxLists();
            this.combineBBoxLists(data.sub, data.sup, lists.subList, lists.supList);
            this.combineBBoxLists(data.psub, data.psup, lists.psubList, lists.psupList);
            data.base = lists.base[0];
            data.numPrescripts = lists.psubList.length;
            data.numScripts = lists.subList.length;
        }
        getScriptBBoxLists() {
            const lists = {
                base: [],
                subList: [],
                supList: [],
                psubList: [],
                psupList: [],
            };
            let script = 'base';
            for (const child of this.childNodes) {
                if (child.node.isKind('mprescripts')) {
                    script = 'psubList';
                }
                else {
                    lists[script].push(child.getOuterBBox());
                    script = NextScript[script];
                }
            }
            this.firstPrescript = lists.subList.length + lists.supList.length + 2;
            this.padLists(lists.subList, lists.supList);
            this.padLists(lists.psubList, lists.psupList);
            return lists;
        }
        padLists(list1, list2) {
            if (list1.length > list2.length) {
                list2.push(BBox.empty());
            }
        }
        combineBBoxLists(bbox1, bbox2, list1, list2) {
            for (let i = 0; i < list1.length; i++) {
                const [w1, h1, d1] = this.getScaledWHD(list1[i]);
                const [w2, h2, d2] = this.getScaledWHD(list2[i]);
                const w = Math.max(w1, w2);
                bbox1.w += w;
                bbox2.w += w;
                if (h1 > bbox1.h)
                    bbox1.h = h1;
                if (d1 > bbox1.d)
                    bbox1.d = d1;
                if (h2 > bbox2.h)
                    bbox2.h = h2;
                if (d2 > bbox2.d)
                    bbox2.d = d2;
            }
        }
        getScaledWHD(bbox) {
            const { w, h, d, rscale } = bbox;
            return [w * rscale, h * rscale, d * rscale];
        }
        getCombinedUV() {
            const data = this.scriptData;
            const sub = this.combinePrePost(data.sub, data.psub);
            const sup = this.combinePrePost(data.sup, data.psup);
            return this.getUVQ(sub, sup);
        }
        addPrescripts(bbox, u, v) {
            const data = this.scriptData;
            if (data.numPrescripts) {
                const scriptspace = this.font.params.scriptspace;
                bbox.combine(data.psup, scriptspace, u);
                bbox.combine(data.psub, scriptspace, v);
            }
            return bbox;
        }
        addPostscripts(bbox, u, v) {
            const data = this.scriptData;
            if (data.numScripts) {
                const x = bbox.w;
                bbox.combine(data.sup, x, u);
                bbox.combine(data.sub, x, v);
                bbox.w += this.font.params.scriptspace;
            }
            return bbox;
        }
        constructor(...args) {
            super(...args);
            this.scriptData = null;
            this.firstPrescript = 0;
            this.getScriptData();
        }
        appendScripts(bbox) {
            bbox.empty();
            const [u, v] = this.getCombinedUV();
            this.addPrescripts(bbox, u, v);
            bbox.append(this.scriptData.base);
            this.addPostscripts(bbox, u, v);
            bbox.clean();
            return bbox;
        }
        computeLineBBox(i) {
            const n = this.baseChild.breakCount;
            const cbox = this.baseChild.getLineBBox(i).copy();
            let bbox = cbox;
            const [u, v] = this.getCombinedUV();
            if (i === 0) {
                bbox = LineBBox.from(this.addPrescripts(BBox.zero(), u, v), this.linebreakOptions.lineleading);
                bbox.append(cbox);
                this.addLeftBorders(bbox);
                bbox.L = this.bbox.L;
            }
            else if (i === n) {
                bbox = this.addPostscripts(bbox, u, v);
                this.addRightBorders(bbox);
                bbox.R = this.bbox.R;
            }
            this.addMiddleBorders(bbox);
            return bbox;
        }
        getUVQ(subbox, supbox) {
            if (!this.UVQ) {
                let [u, v, q] = [0, 0, 0];
                if (subbox.w === 0) {
                    u = this.getU();
                }
                else if (supbox.w === 0) {
                    u = -this.getV();
                }
                else {
                    [u, v, q] = super.getUVQ(subbox, supbox);
                }
                this.UVQ = [u, v, q];
            }
            return this.UVQ;
        }
    };
}
//# sourceMappingURL=mmultiscripts.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mmultiscripts.js
const mmultiscripts_def = MathJax._.core.MmlTree.MmlNodes.mmultiscripts;
const MmlMmultiscripts = mmultiscripts_def.MmlMmultiscripts;
const MmlMprescripts = mmultiscripts_def.MmlMprescripts;
const MmlNone = mmultiscripts_def.MmlNone;

;// ./mjs/output/chtml/Wrappers/mmultiscripts.js




const ChtmlMmultiscripts = (function () {
    var _a;
    const Base = CommonMmultiscriptsMixin(ChtmlMsubsup);
    return _a = class ChtmlMmultiscripts extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const chtml = this.standardChtmlNodes(parents);
                const data = this.scriptData;
                const scriptalign = this.node.getProperty('scriptalign') || 'right left';
                const [preAlign, postAlign] = split(scriptalign + ' ' + scriptalign);
                const [u, v] = this.getCombinedUV();
                if (data.numPrescripts) {
                    const scripts = this.addScripts(this.dom[0], u, -v, true, data.psub, data.psup, this.firstPrescript, data.numPrescripts);
                    if (preAlign !== 'right') {
                        this.adaptor.setAttribute(scripts, 'script-align', preAlign);
                    }
                }
                this.childNodes[0].toCHTML(chtml);
                if (data.numScripts) {
                    const scripts = this.addScripts(this.dom[this.dom.length - 1], u, -v, false, data.sub, data.sup, 1, data.numScripts);
                    if (postAlign !== 'left') {
                        this.adaptor.setAttribute(scripts, 'script-align', postAlign);
                    }
                }
            }
            addScripts(dom, u, v, isPre, sub, sup, i, n) {
                const adaptor = this.adaptor;
                const q = u - sup.d + (v - sub.h);
                const U = u < 0 && v === 0 ? sub.h + u : u;
                const rowdef = q > 0 ? { style: { height: this.em(q) } } : {};
                const tabledef = U ? { style: { 'vertical-align': this.em(U) } } : {};
                const supRow = this.html('mjx-row');
                const sepRow = this.html('mjx-row', rowdef);
                const subRow = this.html('mjx-row');
                const name = 'mjx-' + (isPre ? 'pre' : '') + 'scripts';
                const m = i + 2 * n;
                while (i < m) {
                    this.childNodes[i++].toCHTML([
                        adaptor.append(subRow, this.html('mjx-cell')),
                    ]);
                    this.childNodes[i++].toCHTML([
                        adaptor.append(supRow, this.html('mjx-cell')),
                    ]);
                }
                return adaptor.append(dom, this.html(name, tabledef, [supRow, sepRow, subRow]));
            }
        },
        _a.kind = MmlMmultiscripts.prototype.kind,
        _a.styles = {
            'mjx-prescripts': {
                display: 'inline-table',
                'padding-left': '.05em',
            },
            'mjx-scripts': {
                display: 'inline-table',
                'padding-right': '.05em',
            },
            'mjx-prescripts > mjx-row > mjx-cell': {
                'text-align': 'right',
            },
            '[script-align="left"] > mjx-row > mjx-cell': {
                'text-align': 'left',
            },
            '[script-align="center"] > mjx-row > mjx-cell': {
                'text-align': 'center',
            },
            '[script-align="right"] > mjx-row > mjx-cell': {
                'text-align': 'right',
            },
            'mjx-none': {
                display: 'inline-block',
                height: '1px',
            },
        },
        _a;
})();
//# sourceMappingURL=mmultiscripts.js.map
;// ./components/mjs/core/lib/util/numeric.js
const numeric_def = MathJax._.util.numeric;
const sum = numeric_def.sum;
const max = numeric_def.max;

;// ./mjs/output/common/Wrappers/mtable.js





const BREAK_BELOW = 0.333;
function CommonMtableMixin(Base) {
    return class CommonMtableMixin extends Base {
        get tableRows() {
            return this.childNodes;
        }
        findContainer() {
            let node = this;
            let parent = node.parent;
            while (parent && (parent.node.notParent || parent.node.isKind('mrow'))) {
                node = parent;
                parent = parent.parent;
            }
            this.container = parent;
            this.containerI = node.node.childPosition();
        }
        getPercentageWidth() {
            if (this.hasLabels) {
                this.bbox.pwidth = BBox.fullWidth;
            }
            else {
                const width = this.node.attributes.get('width');
                if (isPercent(width)) {
                    this.bbox.pwidth = width;
                }
            }
        }
        stretchRows() {
            const equal = this.node.attributes.get('equalrows');
            const HD = equal ? this.getEqualRowHeight() : 0;
            const { H, D } = equal ? this.getTableData() : { H: [0], D: [0] };
            const rows = this.tableRows;
            for (let i = 0; i < this.numRows; i++) {
                const hd = equal
                    ? [(HD + H[i] - D[i]) / 2, (HD - H[i] + D[i]) / 2]
                    : null;
                rows[i].stretchChildren(hd);
            }
        }
        stretchColumns() {
            const swidths = this.getColumnAttributes('columnwidth', 0);
            for (let i = 0; i < this.numCols; i++) {
                const width = typeof this.cWidths[i] === 'number'
                    ? this.cWidths[i]
                    : null;
                this.stretchColumn(i, width);
                if (width !== null) {
                    this.breakColumn(i, width, swidths[i]);
                }
            }
        }
        stretchColumn(i, W) {
            const stretchy = [];
            for (const row of this.tableRows) {
                const cell = row.getChild(i);
                if (cell) {
                    const child = cell.childNodes[0];
                    if (child.stretch.dir === DIRECTION.None &&
                        child.canStretch(DIRECTION.Horizontal)) {
                        stretchy.push(child);
                    }
                }
            }
            const count = stretchy.length;
            const nodeCount = this.childNodes.length;
            if (count && nodeCount > 1 && W === null) {
                W = 0;
                const all = count > 1 && count === nodeCount;
                for (const row of this.tableRows) {
                    const cell = row.getChild(i);
                    if (cell) {
                        const child = cell.childNodes[0];
                        const noStretch = child.stretch.dir === DIRECTION.None;
                        if (all || noStretch) {
                            const { w } = child.getBBox(noStretch);
                            if (w > W) {
                                W = w;
                            }
                        }
                    }
                }
            }
            if (W !== null) {
                for (const child of stretchy) {
                    child
                        .coreMO()
                        .getStretchedVariant([
                        Math.max(W, child.getBBox().w) / child.coreRScale(),
                    ]);
                }
            }
        }
        breakColumn(i, W, type) {
            if (this.jax.math.root.attributes.get('overflow') !== 'linebreak' ||
                !this.jax.math.display)
                return;
            const { D } = this.getTableData();
            let j = 0;
            let w = 0;
            for (const row of this.tableRows) {
                const cell = row.getChild(i);
                if (cell && cell.getBBox().w > W) {
                    cell.childNodes[0].breakToWidth(W);
                    const bbox = cell.getBBox();
                    D[j] = Math.max(D[j], bbox.d);
                    if (bbox.w > w) {
                        w = bbox.w;
                    }
                }
                j++;
            }
            if (type === 'fit' ||
                type === 'auto' ||
                isPercent(type) ||
                w > this.cWidths[i]) {
                this.cWidths[i] = w;
            }
        }
        getTableData() {
            if (this.data) {
                return this.data;
            }
            const H = new Array(this.numRows).fill(0);
            const D = new Array(this.numRows).fill(0);
            const W = new Array(this.numCols).fill(0);
            const NH = new Array(this.numRows);
            const ND = new Array(this.numRows);
            const LW = [0];
            const rows = this.tableRows;
            for (let j = 0; j < rows.length; j++) {
                let M = 0;
                const row = rows[j];
                const align = row.node.attributes.get('rowalign');
                for (let i = 0; i < row.numCells; i++) {
                    const cell = row.getChild(i);
                    M = this.updateHDW(cell, i, j, align, H, D, W, M);
                    this.recordPWidthCell(cell, i);
                }
                NH[j] = H[j];
                ND[j] = D[j];
                if (row.labeled) {
                    M = this.updateHDW(row.childNodes[0], 0, j, align, H, D, LW, M);
                }
                this.extendHD(j, H, D, M);
                this.extendHD(j, NH, ND, M);
            }
            const L = LW[0];
            this.data = { H, D, W, NH, ND, L };
            return this.data;
        }
        updateHDW(cell, i, j, align, H, D, W, M) {
            let { h, d, w } = cell.getBBox();
            const scale = cell.parent.bbox.rscale;
            if (cell.parent.bbox.rscale !== 1) {
                h *= scale;
                d *= scale;
                w *= scale;
            }
            if (this.node.getProperty('useHeight')) {
                if (h < 0.75)
                    h = 0.75;
                if (d < 0.25)
                    d = 0.25;
            }
            let m = 0;
            align = cell.node.attributes.get('rowalign') || align;
            if (align !== 'baseline' && align !== 'axis') {
                m = h + d;
                h = d = 0;
            }
            if (h > H[j])
                H[j] = h;
            if (d > D[j])
                D[j] = d;
            if (m > M)
                M = m;
            if (W && w > W[i])
                W[i] = w;
            return M;
        }
        extendHD(i, H, D, M) {
            const d = (M - (H[i] + D[i])) / 2;
            if (d < 0.00001)
                return;
            H[i] += d;
            D[i] += d;
        }
        recordPWidthCell(cell, i) {
            if (cell.childNodes[0] && cell.childNodes[0].getBBox().pwidth) {
                this.pwidthCells.push([cell, i]);
            }
        }
        setColumnPWidths() {
            const W = this.cWidths;
            for (const [cell, i] of this.pwidthCells) {
                if (cell.setChildPWidths(false, W[i])) {
                    cell.invalidateBBox();
                    cell.getBBox();
                }
            }
        }
        getBBoxHD(height) {
            const [align, row] = this.getAlignmentRow();
            if (row === null) {
                const a = this.font.params.axis_height;
                const h2 = height / 2;
                const HD = {
                    top: [0, height],
                    center: [h2, h2],
                    bottom: [height, 0],
                    baseline: [h2, h2],
                    axis: [h2 + a, h2 - a],
                };
                return HD[align] || [h2, h2];
            }
            else {
                const y = this.getVerticalPosition(row, align);
                return [y, height - y];
            }
        }
        getBBoxLR() {
            var _a;
            if (this.hasLabels) {
                const attributes = this.node.attributes;
                const side = attributes.get('side');
                let [pad, align] = this.getPadAlignShift(side);
                const labels = this.hasLabels && !!attributes.get('data-width-includes-label');
                if (labels && this.frame && this.fSpace[0]) {
                    pad -= this.fSpace[0];
                }
                return align === 'center' && !labels
                    ? [pad, pad]
                    : side === 'left'
                        ? [pad, 0]
                        : [0, pad];
            }
            return [((_a = this.bbox) === null || _a === void 0 ? void 0 : _a.L) || 0, 0];
        }
        getPadAlignShift(side) {
            const { L } = this.getTableData();
            const sep = this.length2em(this.node.attributes.get('minlabelspacing'));
            let pad = L + sep;
            const [lpad, rpad] = this.styles == null
                ? ['', '']
                : [this.styles.get('padding-left'), this.styles.get('padding-right')];
            if (lpad || rpad) {
                pad = Math.max(pad, this.length2em(lpad || '0'), this.length2em(rpad || '0'));
            }
            let [align, shift] = this.getAlignShift();
            if (align === side) {
                shift =
                    side === 'left'
                        ? Math.max(pad, shift) - pad
                        : Math.min(-pad, shift) + pad;
            }
            return [pad, align, shift];
        }
        getWidth() {
            return this.pWidth || this.getBBox().w;
        }
        adjustWideTable() {
            const attributes = this.node.attributes;
            if (attributes.get('width') !== 'auto')
                return;
            const [pad, align] = this.getPadAlignShift(attributes.get('side'));
            const W = Math.max(this.containerWidth / 10, this.containerWidth - pad - (align === 'center' ? pad : 0));
            if (this.naturalWidth() > W) {
                this.adjustColumnWidths(W);
            }
        }
        naturalWidth() {
            const CW = this.getComputedWidths();
            return (sum(CW.concat(this.cLines, this.cSpace)) +
                2 * this.fLine +
                this.fSpace[0] +
                this.fSpace[2]);
        }
        getEqualRowHeight() {
            const { H, D } = this.getTableData();
            const HD = Array.from(H.keys()).map((i) => H[i] + D[i]);
            return Math.max(...HD);
        }
        getComputedWidths() {
            const W = this.getTableData().W;
            let CW = Array.from(W.keys()).map((i) => {
                return typeof this.cWidths[i] === 'number'
                    ? this.cWidths[i]
                    : W[i];
            });
            if (this.node.attributes.get('equalcolumns')) {
                CW = Array(CW.length).fill(max(CW));
            }
            return CW;
        }
        getColumnWidths() {
            const width = this.node.attributes.get('width');
            if (this.node.attributes.get('equalcolumns')) {
                return this.getEqualColumns(width);
            }
            const swidths = this.getColumnAttributes('columnwidth', 0);
            if (width === 'auto') {
                return this.getColumnWidthsAuto(swidths);
            }
            if (isPercent(width)) {
                return this.getColumnWidthsPercent(swidths);
            }
            return this.getColumnWidthsFixed(swidths, this.length2em(width));
        }
        getEqualColumns(width) {
            const n = Math.max(1, this.numCols);
            let cwidth;
            if (width === 'auto') {
                const { W } = this.getTableData();
                cwidth = max(W);
            }
            else if (isPercent(width)) {
                cwidth = this.percent(1 / n);
            }
            else {
                const w = sum([].concat(this.cLines, this.cSpace)) +
                    this.fSpace[0] +
                    this.fSpace[2];
                cwidth = Math.max(0, this.length2em(width) - w) / n;
            }
            return Array(this.numCols).fill(cwidth);
        }
        getColumnWidthsAuto(swidths) {
            return swidths.map((x) => {
                if (x === 'auto' || x === 'fit')
                    return null;
                if (isPercent(x))
                    return x;
                return this.length2em(x);
            });
        }
        getColumnWidthsPercent(swidths) {
            const hasFit = swidths.includes('fit');
            const { W } = hasFit ? this.getTableData() : { W: null };
            return Array.from(swidths.keys()).map((i) => {
                const x = swidths[i];
                if (x === 'fit')
                    return null;
                if (x === 'auto')
                    return hasFit ? W[i] : null;
                if (isPercent(x))
                    return x;
                return this.length2em(x);
            });
        }
        getColumnWidthsFixed(swidths, width) {
            const indices = Array.from(swidths.keys());
            const fit = indices.filter((i) => swidths[i] === 'fit');
            const auto = indices.filter((i) => swidths[i] === 'auto');
            const n = fit.length || auto.length;
            const { W } = n ? this.getTableData() : { W: null };
            const cwidth = width -
                sum([].concat(this.cLines, this.cSpace)) -
                this.fSpace[0] -
                this.fSpace[2];
            let dw = cwidth;
            indices.forEach((i) => {
                const x = swidths[i];
                dw -= x === 'fit' || x === 'auto' ? W[i] : this.length2em(x, cwidth);
            });
            const fw = n && dw > 0 ? dw / n : 0;
            return indices.map((i) => {
                const x = swidths[i];
                if (x === 'fit')
                    return W[i] + fw;
                if (x === 'auto')
                    return W[i] + (fit.length === 0 ? fw : 0);
                return this.length2em(x, cwidth);
            });
        }
        adjustColumnWidths(width) {
            const { W } = this.getTableData();
            const swidths = this.getColumnAttributes('columnwidth', 0);
            const indices = Array.from(swidths.keys());
            const fit = indices
                .filter((i) => swidths[i] === 'fit')
                .sort((a, b) => W[b] - W[a]);
            const auto = indices
                .filter((i) => swidths[i] === 'auto')
                .sort((a, b) => W[b] - W[a]);
            const percent = indices
                .filter((i) => isPercent(swidths[i]))
                .sort((a, b) => W[b] - W[a]);
            const fixed = indices
                .filter((i) => swidths[i] !== 'fit' &&
                swidths[i] !== 'auto' &&
                !isPercent(swidths[i]))
                .sort((a, b) => W[b] - W[a]);
            const columns = [...fit, ...auto, ...percent, ...fixed];
            if (!columns.length)
                return;
            this.cWidths = indices.map((i) => typeof this.cWidths[i] === 'number' ? this.cWidths[i] : W[i]);
            const cwidth = width -
                sum([].concat(this.cLines, this.cSpace)) -
                this.fSpace[0] -
                this.fSpace[2];
            let dw = sum(this.cWidths) - cwidth;
            let w = 0;
            let n = 0;
            while (n < columns.length) {
                w += W[columns[n++]];
                if (w && dw / w < BREAK_BELOW)
                    break;
            }
            dw = 1 - dw / w;
            columns.slice(0, n).forEach((i) => (this.cWidths[i] *= dw));
        }
        getVerticalPosition(i, align) {
            const equal = this.node.attributes.get('equalrows');
            const { H, D } = this.getTableData();
            const HD = equal ? this.getEqualRowHeight() : 0;
            const space = this.getRowHalfSpacing();
            let y = this.fLine;
            for (let j = 0; j < i; j++) {
                y +=
                    space[j] + (equal ? HD : H[j] + D[j]) + space[j + 1] + this.rLines[j];
            }
            const [h, d] = equal
                ? [(HD + H[i] - D[i]) / 2, (HD - H[i] + D[i]) / 2]
                : [H[i], D[i]];
            const offset = {
                top: 0,
                center: space[i] + (h + d) / 2,
                bottom: space[i] + h + d + space[i + 1],
                baseline: space[i] + h,
                axis: space[i] + h - 0.25,
            };
            y += offset[align] || 0;
            return y;
        }
        getFrameSpacing() {
            const fspace = this.fframe
                ? this.convertLengths(this.getAttributeArray('framespacing'))
                : [0, 0];
            fspace[2] = fspace[0];
            const padding = this.node.attributes.get('data-array-padding');
            if (padding) {
                const [L, R] = this.convertLengths(split(padding));
                fspace[0] = L;
                fspace[2] = R;
            }
            return fspace;
        }
        getEmHalfSpacing(fspace, space, scale = 1) {
            const spaceEm = this.addEm(space, 2 / scale);
            spaceEm.unshift(this.em(fspace[0] * scale));
            spaceEm.push(this.em(fspace[1] * scale));
            return spaceEm;
        }
        getRowHalfSpacing() {
            const space = this.rSpace.map((x) => x / 2);
            space.unshift(this.fSpace[1]);
            space.push(this.fSpace[1]);
            return space;
        }
        getColumnHalfSpacing() {
            const space = this.cSpace.map((x) => x / 2);
            space.unshift(this.fSpace[0]);
            space.push(this.fSpace[2]);
            return space;
        }
        getAlignmentRow() {
            const [align, row] = split(this.node.attributes.get('align'));
            if (row == null)
                return [align, null];
            let i = parseInt(row);
            if (i < 0)
                i += this.numRows + 1;
            return [align, i < 1 || i > this.numRows ? null : i - 1];
        }
        getColumnAttributes(name, i = 1) {
            const n = this.numCols - i;
            const columns = this.getAttributeArray(name);
            if (columns.length === 0)
                return null;
            while (columns.length < n) {
                columns.push(columns[columns.length - 1]);
            }
            if (columns.length > n) {
                columns.splice(n);
            }
            return columns;
        }
        getRowAttributes(name, i = 1) {
            const n = this.numRows - i;
            const rows = this.getAttributeArray(name);
            if (rows.length === 0)
                return null;
            while (rows.length < n) {
                rows.push(rows[rows.length - 1]);
            }
            if (rows.length > n) {
                rows.splice(n);
            }
            return rows;
        }
        getAttributeArray(name) {
            const value = this.node.attributes.get(name);
            if (!value)
                return [this.node.attributes.getDefault(name)];
            return split(value);
        }
        addEm(list, n = 1) {
            if (!list)
                return null;
            return list.map((x) => this.em(x / n));
        }
        convertLengths(list) {
            if (!list)
                return null;
            return list.map((x) => this.length2em(x));
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.numCols = 0;
            this.numRows = 0;
            this.data = null;
            this.pwidthCells = [];
            this.pWidth = 0;
            this.numCols = max(this.tableRows.map((row) => row.numCells));
            this.numRows = this.childNodes.length;
            this.hasLabels = this.childNodes.reduce((value, row) => value || row.node.isKind('mlabeledtr'), false);
            this.findContainer();
            this.isTop =
                !this.container ||
                    (this.container.node.isKind('math') && !this.container.parent);
            if (this.isTop) {
                this.jax.table = this;
            }
            this.getPercentageWidth();
            const attributes = this.node.attributes;
            const frame = attributes.get('frame');
            this.frame = frame !== 'none';
            this.fframe =
                this.frame || attributes.get('data-frame-styles') !== undefined;
            this.fLine = this.frame ? 0.07 : 0;
            this.fSpace = this.getFrameSpacing();
            this.cSpace = this.convertLengths(this.getColumnAttributes('columnspacing'));
            this.rSpace = this.convertLengths(this.getRowAttributes('rowspacing'));
            this.cLines = this.getColumnAttributes('columnlines').map((x) => x === 'none' ? 0 : 0.07);
            this.rLines = this.getRowAttributes('rowlines').map((x) => x === 'none' ? 0 : 0.07);
            this.cWidths = this.getColumnWidths();
            this.adjustWideTable();
            this.stretchColumns();
            this.stretchRows();
        }
        getStyles() {
            super.getStyles();
            const frame = this.node.attributes.get('data-frame-styles');
            if (!frame)
                return;
            if (!this.styles) {
                this.styles = new Styles('');
            }
            const fstyles = frame.split(/ /);
            for (const i of TRBL.keys()) {
                const style = fstyles[i];
                if (style === 'none')
                    continue;
                this.styles.set(`border-${TRBL[i]}`, `.07em ${style}`);
            }
        }
        computeBBox(bbox, _recompute = false) {
            const { H, D } = this.getTableData();
            let height, width;
            if (this.node.attributes.get('equalrows')) {
                const HD = this.getEqualRowHeight();
                height = sum([].concat(this.rLines, this.rSpace)) + HD * this.numRows;
            }
            else {
                height = sum(H.concat(D, this.rLines, this.rSpace));
            }
            height += 2 * (this.fLine + this.fSpace[1]);
            width = this.naturalWidth();
            const w = this.node.attributes.get('width');
            if (w !== 'auto') {
                width = Math.max(this.length2em(w, 0) + 2 * this.fLine, width);
            }
            const [h, d] = this.getBBoxHD(height);
            bbox.h = h;
            bbox.d = d;
            bbox.w = width;
            const [L, R] = this.getBBoxLR();
            bbox.L = L;
            bbox.R = R;
            if (!isPercent(w)) {
                this.setColumnPWidths();
            }
        }
        setChildPWidths(_recompute, cwidth, _clear) {
            const width = this.node.attributes.get('width');
            if (!isPercent(width))
                return false;
            if (!this.hasLabels) {
                this.bbox.pwidth = '';
                this.container.bbox.pwidth = '';
            }
            const { w, L, R } = this.bbox;
            const labelInWidth = this.node.attributes.get('data-width-includes-label');
            const W = Math.max(w, this.length2em(width, Math.max(cwidth, L + w + R))) -
                (labelInWidth ? L + R : 0);
            const cols = this.node.attributes.get('equalcolumns')
                ? Array(this.numCols).fill(this.percent(1 / Math.max(1, this.numCols)))
                : this.getColumnAttributes('columnwidth', 0);
            this.cWidths = this.getColumnWidthsFixed(cols, W);
            this.pWidth = this.naturalWidth();
            if (this.isTop) {
                this.bbox.w = this.pWidth;
            }
            this.setColumnPWidths();
            if (this.pWidth !== w) {
                this.parent.invalidateBBox();
            }
            return this.pWidth !== w;
        }
        getAlignShift() {
            return this.isTop
                ? super.getAlignShift()
                : [this.container.getChildAlign(this.containerI), 0];
        }
    };
}
//# sourceMappingURL=mtable.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mtable.js
const mtable_def = MathJax._.core.MmlTree.MmlNodes.mtable;
const MmlMtable = mtable_def.MmlMtable;

;// ./mjs/output/chtml/Wrappers/mtable.js




const ChtmlMtable = (function () {
    var _a;
    const Base = CommonMtableMixin(ChtmlWrapper);
    return _a = class ChtmlMtable extends Base {
            constructor(factory, node, parent = null) {
                super(factory, node, parent);
                this.itable = this.html('mjx-itable');
                this.labels = this.html('mjx-itable');
            }
            getAlignShift() {
                const data = super.getAlignShift();
                if (!this.isTop) {
                    data[1] = 0;
                }
                return data;
            }
            toCHTML(parents) {
                const chtml = this.standardChtmlNodes(parents);
                this.adaptor.append(chtml[0], this.html('mjx-table', {}, [this.itable]));
                for (const child of this.childNodes) {
                    child.toCHTML([this.itable]);
                }
                this.padRows();
                this.handleColumnSpacing();
                this.handleColumnLines();
                this.handleColumnWidths();
                this.handleRowSpacing();
                this.handleRowLines();
                this.handleRowHeights();
                this.handleFrame();
                this.handleWidth();
                this.handleLabels();
                this.handleAlign();
                this.handleJustify();
                this.shiftColor();
            }
            shiftColor() {
                const adaptor = this.adaptor;
                const color = adaptor.getStyle(this.dom[0], 'backgroundColor');
                if (color) {
                    adaptor.setStyle(this.dom[0], 'backgroundColor', '');
                    adaptor.setStyle(this.itable, 'backgroundColor', color);
                }
            }
            padRows() {
                const adaptor = this.adaptor;
                for (const row of adaptor.childNodes(this.itable)) {
                    while (adaptor.childNodes(row).length < this.numCols) {
                        adaptor.append(row, this.html('mjx-mtd', { extra: true }));
                    }
                }
            }
            handleColumnSpacing() {
                const scale = this.childNodes[0]
                    ? 1 / this.childNodes[0].getBBox().rscale
                    : 1;
                const spacing = this.getEmHalfSpacing([this.fSpace[0], this.fSpace[2]], this.cSpace, scale);
                for (const row of this.tableRows) {
                    let i = 0;
                    for (const cell of row.tableCells) {
                        const lspace = spacing[i++];
                        const rspace = spacing[i];
                        const styleNode = cell
                            ? cell.dom[0]
                            : this.adaptor.childNodes(row.dom[0])[i];
                        if ((i > 1 && lspace !== '0.4em') || (lspace !== '0' && i === 1)) {
                            this.adaptor.setStyle(styleNode, 'paddingLeft', lspace);
                        }
                        if ((i < this.numCols && rspace !== '0.4em') ||
                            (rspace !== '0' && i === this.numCols)) {
                            this.adaptor.setStyle(styleNode, 'paddingRight', rspace);
                        }
                    }
                }
            }
            handleColumnLines() {
                if (this.node.attributes.get('columnlines') === 'none')
                    return;
                const lines = this.getColumnAttributes('columnlines');
                for (const row of this.childNodes) {
                    let i = 0;
                    const cells = this.adaptor.childNodes(row.dom[0]).slice(1);
                    for (const cell of cells) {
                        const line = lines[i++];
                        if (line === 'none')
                            continue;
                        this.adaptor.setStyle(cell, 'borderLeft', '.07em ' + line);
                    }
                }
            }
            handleColumnWidths() {
                for (const row of this.childNodes) {
                    let i = 0;
                    for (const cell of this.adaptor.childNodes(row.dom[0])) {
                        const w = this.cWidths[i++];
                        if (w !== null) {
                            const width = typeof w === 'number' ? this.em(w) : w;
                            this.adaptor.setStyle(cell, 'width', width);
                            this.adaptor.setStyle(cell, 'maxWidth', width);
                            this.adaptor.setStyle(cell, 'minWidth', width);
                        }
                    }
                }
            }
            handleRowSpacing() {
                const scale = this.childNodes[0]
                    ? 1 / this.childNodes[0].getBBox().rscale
                    : 1;
                const spacing = this.getEmHalfSpacing([this.fSpace[1], this.fSpace[1]], this.rSpace, scale);
                const frame = this.fframe;
                let i = 0;
                for (const row of this.childNodes) {
                    const tspace = spacing[i++];
                    const bspace = spacing[i];
                    for (const cell of row.childNodes) {
                        if ((i > 1 && tspace !== '0.215em') || (frame && i === 1)) {
                            this.adaptor.setStyle(cell.dom[0], 'paddingTop', tspace);
                        }
                        if ((i < this.numRows && bspace !== '0.215em') ||
                            (frame && i === this.numRows)) {
                            this.adaptor.setStyle(cell.dom[0], 'paddingBottom', bspace);
                        }
                    }
                }
            }
            handleRowLines() {
                if (this.node.attributes.get('rowlines') === 'none')
                    return;
                const lines = this.getRowAttributes('rowlines');
                let i = 0;
                for (const row of this.childNodes.slice(1)) {
                    const line = lines[i++];
                    if (line === 'none')
                        continue;
                    for (const cell of this.adaptor.childNodes(row.dom[0])) {
                        this.adaptor.setStyle(cell, 'borderTop', '.07em ' + line);
                    }
                }
            }
            handleRowHeights() {
                if (this.node.attributes.get('equalrows')) {
                    this.handleEqualRows();
                }
            }
            handleEqualRows() {
                const space = this.getRowHalfSpacing();
                const { H, D, NH, ND } = this.getTableData();
                const HD = this.getEqualRowHeight();
                for (let i = 0; i < this.numRows; i++) {
                    const row = this.childNodes[i];
                    this.setRowHeight(row, HD + space[i] + space[i + 1] + this.rLines[i]);
                    if (HD !== NH[i] + ND[i]) {
                        this.setRowBaseline(row, HD, (HD - H[i] + D[i]) / 2);
                    }
                }
            }
            setRowHeight(row, HD) {
                this.adaptor.setStyle(row.dom[0], 'height', this.em(HD));
            }
            setRowBaseline(row, HD, D) {
                const ralign = row.node.attributes.get('rowalign');
                for (const cell of row.childNodes) {
                    if (this.setCellBaseline(cell, ralign, HD, D))
                        break;
                }
            }
            setCellBaseline(cell, ralign, HD, D) {
                const calign = cell.node.attributes.get('rowalign');
                if (calign === 'baseline' || calign === 'axis') {
                    const adaptor = this.adaptor;
                    const child = adaptor.lastChild(cell.dom[0]);
                    adaptor.setStyle(child, 'height', this.em(HD));
                    adaptor.setStyle(child, 'verticalAlign', this.em(-D));
                    const row = cell.parent;
                    if ((!row.node.isKind('mlabeledtr') || cell !== row.childNodes[0]) &&
                        (ralign === 'baseline' || ralign === 'axis')) {
                        return true;
                    }
                }
                return false;
            }
            handleFrame() {
                if (this.frame && this.fLine) {
                    const frame = this.node.attributes.get('frame');
                    this.adaptor.setStyle(this.itable, 'border', `${this.em(this.fLine)} ${frame}`);
                }
            }
            handleWidth() {
                const adaptor = this.adaptor;
                const dom = this.dom[0];
                const { w, L, R } = this.getBBox();
                adaptor.setStyle(dom, 'minWidth', this.em(L + w + R));
                let W = this.node.attributes.get('width');
                if (isPercent(W)) {
                    adaptor.setStyle(dom, 'width', '');
                    adaptor.setAttribute(dom, 'width', 'full');
                }
                else if (!this.hasLabels) {
                    if (W === 'auto')
                        return;
                    W = this.em(this.length2em(W) + 2 * this.fLine);
                }
                const table = adaptor.firstChild(dom);
                adaptor.setStyle(table, 'width', W);
                adaptor.setStyle(table, 'minWidth', this.em(w));
                if (L || R) {
                    adaptor.setStyle(dom, 'margin', '');
                    const style = this.node.attributes.get('data-width-includes-label')
                        ? 'padding'
                        : 'margin';
                    if (L === R) {
                        adaptor.setStyle(table, style, '0 ' + this.em(R));
                    }
                    else {
                        adaptor.setStyle(table, style, '0 ' + this.em(R) + ' 0 ' + this.em(L));
                    }
                }
                adaptor.setAttribute(this.itable, 'width', 'full');
            }
            handleAlign() {
                const [align, row] = this.getAlignmentRow();
                const dom = this.dom[0];
                if (row === null) {
                    if (align !== 'axis') {
                        this.adaptor.setAttribute(dom, 'align', align);
                    }
                }
                else {
                    const y = this.getVerticalPosition(row, align);
                    this.adaptor.setAttribute(dom, 'align', 'top');
                    this.adaptor.setStyle(dom, 'verticalAlign', this.em(y));
                }
            }
            handleJustify() {
                const align = this.getAlignShift()[0];
                if (align !== 'center') {
                    this.adaptor.setAttribute(this.dom[0], 'justify', align);
                }
            }
            handleLabels() {
                if (!this.hasLabels)
                    return;
                const labels = this.labels;
                const attributes = this.node.attributes;
                const adaptor = this.adaptor;
                const side = attributes.get('side');
                adaptor.setAttribute(this.dom[0], 'side', side);
                adaptor.setAttribute(labels, 'align', side);
                adaptor.setStyle(labels, side, '0');
                const [align, shift] = this.addLabelPadding(side);
                if (shift) {
                    const table = adaptor.firstChild(this.dom[0]);
                    this.setIndent(table, align, shift);
                }
                this.updateRowHeights();
                this.addLabelSpacing();
            }
            addLabelPadding(side) {
                const [, align, shift] = this.getPadAlignShift(side);
                const styles = {};
                if (side === 'right' &&
                    !this.node.attributes.get('data-width-includes-label')) {
                    const W = this.node.attributes.get('width');
                    const { w, L, R } = this.getBBox();
                    styles.style = {
                        width: isPercent(W)
                            ? 'calc(' + W + ' + ' + this.em(L + R) + ')'
                            : this.em(L + w + R),
                    };
                }
                this.adaptor.append(this.dom[0], this.html('mjx-labels', styles, [this.labels]));
                return [align, shift];
            }
            updateRowHeights() {
                const { H, D, NH, ND } = this.getTableData();
                const space = this.getRowHalfSpacing();
                for (let i = 0; i < this.numRows; i++) {
                    const row = this.childNodes[i];
                    this.setRowHeight(row, H[i] + D[i] + space[i] + space[i + 1] + this.rLines[i]);
                    if (H[i] !== NH[i] || D[i] !== ND[i]) {
                        this.setRowBaseline(row, H[i] + D[i], D[i]);
                    }
                    else if (row.node.isKind('mlabeledtr')) {
                        this.setCellBaseline(row.childNodes[0], '', H[i] + D[i], D[i]);
                    }
                }
            }
            addLabelSpacing() {
                const adaptor = this.adaptor;
                const equal = this.node.attributes.get('equalrows');
                const { H, D } = this.getTableData();
                const HD = equal ? this.getEqualRowHeight() : 0;
                const space = this.getRowHalfSpacing();
                let h = this.fLine;
                let current = adaptor.firstChild(this.labels);
                for (let i = 0; i < this.numRows; i++) {
                    const row = this.childNodes[i];
                    if (row.node.isKind('mlabeledtr')) {
                        if (h) {
                            adaptor.insert(this.html('mjx-mtr', { style: { height: this.em(h) } }), current);
                        }
                        adaptor.setStyle(current, 'height', this.em((equal ? HD : H[i] + D[i]) + space[i] + space[i + 1]));
                        current = adaptor.next(current);
                        h = this.rLines[i];
                    }
                    else {
                        h +=
                            space[i] +
                                (equal ? HD : H[i] + D[i]) +
                                space[i + 1] +
                                this.rLines[i];
                    }
                }
            }
        },
        _a.kind = MmlMtable.prototype.kind,
        _a.styles = {
            'mjx-mtable': {
                'vertical-align': '.25em',
                'text-align': 'center',
                position: 'relative',
                'box-sizing': 'border-box',
                'border-spacing': 0,
                'border-collapse': 'collapse',
            },
            'mjx-mstyle[size="s"] mjx-mtable': {
                'vertical-align': '.354em',
            },
            'mjx-labels': {
                position: 'absolute',
                left: 0,
                top: 0,
            },
            'mjx-table': {
                display: 'inline-block',
                'vertical-align': '-.5ex',
                'box-sizing': 'border-box',
            },
            'mjx-table > mjx-itable': {
                'vertical-align': 'middle',
                'text-align': 'left',
                'box-sizing': 'border-box',
            },
            'mjx-labels > mjx-itable': {
                position: 'absolute',
                top: 0,
            },
            'mjx-mtable[justify="left"]': {
                'text-align': 'left',
            },
            'mjx-mtable[justify="right"]': {
                'text-align': 'right',
            },
            'mjx-mtable[justify="left"][side="left"]': {
                'padding-right': '0 ! important',
            },
            'mjx-mtable[justify="left"][side="right"]': {
                'padding-left': '0 ! important',
            },
            'mjx-mtable[justify="right"][side="left"]': {
                'padding-right': '0 ! important',
            },
            'mjx-mtable[justify="right"][side="right"]': {
                'padding-left': '0 ! important',
            },
            'mjx-mtable[align]': {
                'vertical-align': 'baseline',
            },
            'mjx-mtable[align="top"] > mjx-table': {
                'vertical-align': 'top',
            },
            'mjx-mtable[align="bottom"] > mjx-table': {
                'vertical-align': 'bottom',
            },
            'mjx-mtable[side="right"] mjx-labels': {
                'min-width': '100%',
            },
        },
        _a;
})();
//# sourceMappingURL=mtable.js.map
;// ./mjs/output/common/Wrappers/mtr.js

function CommonMtrMixin(Base) {
    return class CommonMtrMixin extends Base {
        get numCells() {
            return this.childNodes.length;
        }
        get labeled() {
            return false;
        }
        get tableCells() {
            return this.childNodes;
        }
        getChild(i) {
            return this.childNodes[i];
        }
        getChildBBoxes() {
            return this.childNodes.map((cell) => cell.getBBox());
        }
        stretchChildren(HD = null) {
            const stretchy = [];
            const children = this.labeled
                ? this.childNodes.slice(1)
                : this.childNodes;
            for (const mtd of children) {
                const child = mtd.childNodes[0];
                if (child.canStretch(DIRECTION.Vertical)) {
                    stretchy.push(child);
                }
            }
            const count = stretchy.length;
            const nodeCount = this.childNodes.length;
            if (count && nodeCount > 1 && !HD) {
                let H = 0;
                let D = 0;
                const all = count > 1 && count === nodeCount;
                for (const mtd of children) {
                    const child = mtd.childNodes[0];
                    const noStretch = child.stretch.dir === DIRECTION.None;
                    if (all || noStretch) {
                        const { h, d } = child.getBBox(noStretch);
                        if (h > H) {
                            H = h;
                        }
                        if (d > D) {
                            D = d;
                        }
                    }
                }
                HD = [H, D];
            }
            if (HD) {
                for (const child of stretchy) {
                    const rscale = child.coreRScale();
                    child.coreMO().getStretchedVariant(HD.map((x) => x * rscale));
                }
            }
        }
        get fixesPWidth() {
            return false;
        }
    };
}
function CommonMlabeledtrMixin(Base) {
    return class CommonMlabeledtrMixin extends Base {
        get numCells() {
            return Math.max(0, this.childNodes.length - 1);
        }
        get labeled() {
            return true;
        }
        get tableCells() {
            return this.childNodes.slice(1);
        }
        getChild(i) {
            return this.childNodes[i + 1];
        }
        getChildBBoxes() {
            return this.childNodes.slice(1).map((cell) => cell.getBBox());
        }
    };
}
//# sourceMappingURL=mtr.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mtr.js
const mtr_def = MathJax._.core.MmlTree.MmlNodes.mtr;
const MmlMtr = mtr_def.MmlMtr;
const MmlMlabeledtr = mtr_def.MmlMlabeledtr;

;// ./mjs/output/chtml/Wrappers/mtr.js



const ChtmlMtr = (function () {
    var _a;
    const Base = CommonMtrMixin(ChtmlWrapper);
    return _a = class ChtmlMtr extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                const align = this.node.attributes.get('rowalign');
                if (align !== 'baseline') {
                    this.adaptor.setAttribute(this.dom[0], 'rowalign', align);
                }
            }
        },
        _a.kind = MmlMtr.prototype.kind,
        _a.styles = {
            'mjx-mtr': {
                display: 'table-row',
            },
            'mjx-mtr[rowalign="top"] > mjx-mtd': {
                'vertical-align': 'top',
            },
            'mjx-mtr[rowalign="center"] > mjx-mtd': {
                'vertical-align': 'middle',
            },
            'mjx-mtr[rowalign="bottom"] > mjx-mtd': {
                'vertical-align': 'bottom',
            },
            'mjx-mtr[rowalign="baseline"] > mjx-mtd': {
                'vertical-align': 'baseline',
            },
            'mjx-mtr[rowalign="axis"] > mjx-mtd': {
                'vertical-align': '.25em',
            },
        },
        _a;
})();
const ChtmlMlabeledtr = (function () {
    var _a;
    const Base = CommonMlabeledtrMixin(ChtmlMtr);
    return _a = class ChtmlMlabeledtr extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                const child = this.adaptor.firstChild(this.dom[0]);
                if (child) {
                    this.adaptor.remove(child);
                    const align = this.node.attributes.get('rowalign');
                    const attr = align !== 'baseline' && align !== 'axis' ? { rowalign: align } : {};
                    const row = this.html('mjx-mtr', attr, [child]);
                    this.adaptor.append(this.parent.labels, row);
                }
            }
            markUsed() {
                super.markUsed();
                this.jax.wrapperUsage.add(ChtmlMtr.kind);
            }
        },
        _a.kind = MmlMlabeledtr.prototype.kind,
        _a.styles = {
            'mjx-mlabeledtr': {
                display: 'table-row',
            },
            'mjx-mlabeledtr[rowalign="top"] > mjx-mtd': {
                'vertical-align': 'top',
            },
            'mjx-mlabeledtr[rowalign="center"] > mjx-mtd': {
                'vertical-align': 'middle',
            },
            'mjx-mlabeledtr[rowalign="bottom"] > mjx-mtd': {
                'vertical-align': 'bottom',
            },
            'mjx-mlabeledtr[rowalign="baseline"] > mjx-mtd': {
                'vertical-align': 'baseline',
            },
            'mjx-mlabeledtr[rowalign="axis"] > mjx-mtd': {
                'vertical-align': '.25em',
            },
        },
        _a;
})();
//# sourceMappingURL=mtr.js.map
;// ./mjs/output/common/Wrappers/mtd.js
function CommonMtdMixin(Base) {
    return class CommonMtdMixin extends Base {
        get fixesPWidth() {
            return false;
        }
        invalidateBBox() {
            this.bboxComputed = false;
            this.lineBBox = [];
        }
        getWrapWidth(_j) {
            const table = this.parent.parent;
            const row = this.parent;
            const i = this.node.childPosition() - (row.labeled ? 1 : 0);
            return (typeof table.cWidths[i] === 'number'
                ? table.cWidths[i]
                : table.getTableData().W[i]);
        }
        getChildAlign(_i) {
            return this.node.attributes.get('columnalign');
        }
    };
}
//# sourceMappingURL=mtd.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mtd.js
const mtd_def = MathJax._.core.MmlTree.MmlNodes.mtd;
const MmlMtd = mtd_def.MmlMtd;

;// ./mjs/output/chtml/Wrappers/mtd.js



const ChtmlMtd = (function () {
    var _a;
    const Base = CommonMtdMixin(ChtmlWrapper);
    return _a = class ChtmlMtd extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                const ralign = this.node.attributes.get('rowalign');
                const calign = this.node.attributes.get('columnalign');
                const palign = this.parent.node.attributes.get('rowalign');
                if (ralign !== palign) {
                    this.adaptor.setAttribute(this.dom[0], 'rowalign', ralign);
                }
                if (calign !== 'center' &&
                    (this.parent.kind !== 'mlabeledtr' ||
                        this !== this.parent.childNodes[0] ||
                        calign !== this.parent.parent.node.attributes.get('side'))) {
                    this.adaptor.setStyle(this.dom[0], 'textAlign', calign);
                }
                if (this.parent.parent.node.getProperty('useHeight')) {
                    this.adaptor.append(this.dom[0], this.html('mjx-tstrut'));
                }
            }
        },
        _a.kind = MmlMtd.prototype.kind,
        _a.styles = {
            'mjx-mtd': {
                display: 'table-cell',
                'text-align': 'center',
                padding: '.215em .4em',
            },
            'mjx-mtd:first-child': {
                'padding-left': 0,
            },
            'mjx-mtd:last-child': {
                'padding-right': 0,
            },
            'mjx-mtable > * > mjx-itable > *:first-child > mjx-mtd': {
                'padding-top': 0,
            },
            'mjx-mtable > * > mjx-itable > *:last-child > mjx-mtd': {
                'padding-bottom': 0,
            },
            'mjx-tstrut': {
                display: 'inline-block',
                height: '1em',
                'vertical-align': '-.25em',
            },
            'mjx-labels[align="left"] > mjx-mtr > mjx-mtd': {
                'text-align': 'left',
            },
            'mjx-labels[align="right"] > mjx-mtr > mjx-mtd': {
                'text-align': 'right',
            },
            'mjx-mtd[extra]': {
                padding: 0,
            },
            'mjx-mtd[rowalign="top"]': {
                'vertical-align': 'top',
            },
            'mjx-mtd[rowalign="center"]': {
                'vertical-align': 'middle',
            },
            'mjx-mtd[rowalign="bottom"]': {
                'vertical-align': 'bottom',
            },
            'mjx-mtd[rowalign="baseline"]': {
                'vertical-align': 'baseline',
            },
            'mjx-mtd[rowalign="axis"]': {
                'vertical-align': '.25em',
            },
        },
        _a;
})();
//# sourceMappingURL=mtd.js.map
;// ./mjs/output/common/Wrappers/maction.js

const TooltipData = {
    dx: '.2em',
    dy: '.1em',
    postDelay: 600,
    clearDelay: 100,
    hoverTimer: new Map(),
    clearTimer: new Map(),
    stopTimers: (node, data) => {
        if (data.clearTimer.has(node)) {
            clearTimeout(data.clearTimer.get(node));
            data.clearTimer.delete(node);
        }
        if (data.hoverTimer.has(node)) {
            clearTimeout(data.hoverTimer.get(node));
            data.hoverTimer.delete(node);
        }
    }
};
function CommonMactionMixin(Base) {
    return class CommonMactionMixin extends Base {
        get selected() {
            const selection = this.node.attributes.get('selection');
            const i = Math.max(1, Math.min(this.childNodes.length, selection)) - 1;
            return (this.childNodes[i] || this.wrap(this.node.selected));
        }
        getParameters() {
            const offsets = this.node.attributes.get('data-offsets');
            const [dx, dy] = split(offsets || '');
            this.tipDx = this.length2em(dx || TooltipData.dx);
            this.tipDy = this.length2em(dy || TooltipData.dy);
        }
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            const actions = this.constructor
                .actions;
            const action = this.node.attributes.get('actiontype');
            const [handler, data] = actions.get(action) || [
                ((_node, _data) => { }),
                {},
            ];
            this.action = handler;
            this.data = data;
            this.getParameters();
        }
        computeBBox(bbox, recompute = false) {
            bbox.updateFrom(this.selected.getOuterBBox());
            this.selected.setChildPWidths(recompute);
        }
        get breakCount() {
            return this.node.isEmbellished
                ? this.selected.coreMO().embellishedBreakCount
                : this.selected.breakCount;
        }
        computeLineBBox(i) {
            return this.getChildLineBBox(this.selected, i);
        }
    };
}
//# sourceMappingURL=maction.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/maction.js
const maction_def = MathJax._.core.MmlTree.MmlNodes.maction;
const MmlMaction = maction_def.MmlMaction;

;// ./mjs/output/chtml/Wrappers/maction.js





const ChtmlMaction = (function () {
    var _a;
    const Base = CommonMactionMixin(ChtmlWrapper);
    return _a = class ChtmlMaction extends Base {
            setEventHandler(type, handler, dom = null) {
                (dom ? [dom] : this.dom).forEach((node) => node.addEventListener(type, handler));
            }
            Em(m) {
                return this.em(m);
            }
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const chtml = this.standardChtmlNodes(parents);
                const child = this.selected;
                child.toCHTML(chtml);
                this.action(this, this.data);
            }
        },
        _a.kind = MmlMaction.prototype.kind,
        _a.styles = {
            'mjx-maction': {
                position: 'relative',
            },
            'mjx-maction > mjx-tool': {
                display: 'none',
                position: 'absolute',
                bottom: 0,
                right: 0,
                width: 0,
                height: 0,
                'z-index': 500,
            },
            'mjx-tool > mjx-tip': {
                display: 'inline-block',
                'line-height': 0,
                padding: '.2em',
                border: '1px solid #888',
                'background-color': '#F8F8F8',
                color: 'black',
                'box-shadow': '2px 2px 5px #AAAAAA',
            },
            'mjx-maction[toggle]': {
                cursor: 'pointer',
            },
            'mjx-status': {
                display: 'block',
                position: 'fixed',
                left: '1em',
                bottom: '1em',
                'min-width': '25%',
                padding: '.2em .4em',
                border: '1px solid #888',
                'font-size': '90%',
                'background-color': '#F8F8F8',
                color: 'black',
            },
        },
        _a.actions = new Map([
            [
                'toggle',
                [
                    (node, _data) => {
                        node.dom.forEach((dom) => {
                            node.adaptor.setAttribute(dom, 'toggle', node.node.attributes.get('selection'));
                        });
                        const math = node.factory.jax.math;
                        const document = node.factory.jax.document;
                        const mml = node.node;
                        node.setEventHandler('click', (event) => {
                            if (!math.end.node) {
                                math.start.node = math.end.node = math.typesetRoot;
                                math.start.n = math.end.n = 0;
                            }
                            mml.nextToggleSelection();
                            math.rerender(document, mml.attributes.get('data-maction-id')
                                ? STATE.ENRICHED
                                : STATE.RERENDER);
                            event.stopPropagation();
                        });
                    },
                    {},
                ],
            ],
            [
                'tooltip',
                [
                    (node, data) => {
                        const tip = node.childNodes[1];
                        if (!tip)
                            return;
                        if (tip.node.isKind('mtext')) {
                            const text = tip.node.getText();
                            node.dom.forEach((dom) => node.adaptor.setAttribute(dom, 'title', text));
                        }
                        else {
                            const adaptor = node.adaptor;
                            for (const dom of node.dom) {
                                const tool = adaptor.append(dom, node.html('mjx-tool', {
                                    style: {
                                        bottom: node.Em(-node.tipDy),
                                        right: node.Em(-node.tipDx),
                                    },
                                }, [node.html('mjx-tip')]));
                                tip.toCHTML([adaptor.firstChild(tool)]);
                                node.setEventHandler('mouseover', (event) => {
                                    data.stopTimers(dom, data);
                                    const timeout = setTimeout(() => adaptor.setStyle(tool, 'display', 'block'), data.postDelay);
                                    data.hoverTimer.set(dom, timeout);
                                    event.stopPropagation();
                                }, dom);
                                node.setEventHandler('mouseout', (event) => {
                                    data.stopTimers(dom, data);
                                    const timeout = setTimeout(() => adaptor.setStyle(tool, 'display', ''), data.clearDelay);
                                    data.clearTimer.set(dom, timeout);
                                    event.stopPropagation();
                                }, dom);
                            }
                        }
                    },
                    TooltipData,
                ],
            ],
            [
                'statusline',
                [
                    (node, data) => {
                        const tip = node.childNodes[1];
                        if (!tip)
                            return;
                        if (tip.node.isKind('mtext')) {
                            const adaptor = node.adaptor;
                            const text = tip.node.getText();
                            node.dom.forEach((dom) => adaptor.setAttribute(dom, 'statusline', text));
                            node.setEventHandler('mouseover', (event) => {
                                if (data.status === null) {
                                    const body = adaptor.body(adaptor.document);
                                    data.status = adaptor.append(body, node.html('mjx-status', {}, [node.text(text)]));
                                }
                                event.stopPropagation();
                            });
                            node.setEventHandler('mouseout', (event) => {
                                if (data.status) {
                                    adaptor.remove(data.status);
                                    data.status = null;
                                }
                                event.stopPropagation();
                            });
                        }
                    },
                    {
                        status: null,
                    },
                ],
            ],
        ]),
        _a;
})();
//# sourceMappingURL=maction.js.map
;// ./mjs/output/common/Wrappers/mglyph.js
function CommonMglyphMixin(Base) {
    return class CommonMglyphMixin extends Base {
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.getParameters();
        }
        getParameters() {
            const { width, height, valign, src, index } = this.node.attributes.getList('width', 'height', 'valign', 'src', 'index');
            if (src) {
                this.width = width === 'auto' ? 1 : this.length2em(width);
                this.height = height === 'auto' ? 1 : this.length2em(height);
                this.valign = this.length2em(valign || '0');
            }
            else {
                const text = String.fromCodePoint(parseInt(index));
                const mmlFactory = this.node.factory;
                this.charWrapper = this.wrap(mmlFactory.create('text').setText(text));
                this.charWrapper.parent = this;
            }
        }
        computeBBox(bbox, _recompute = false) {
            if (this.charWrapper) {
                bbox.updateFrom(this.charWrapper.getBBox());
            }
            else {
                bbox.w = this.width;
                bbox.h = this.height + this.valign;
                bbox.d = -this.valign;
            }
        }
    };
}
//# sourceMappingURL=mglyph.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/mglyph.js
const mglyph_def = MathJax._.core.MmlTree.MmlNodes.mglyph;
const MmlMglyph = mglyph_def.MmlMglyph;

;// ./mjs/output/chtml/Wrappers/mglyph.js



const ChtmlMglyph = (function () {
    var _a;
    const Base = CommonMglyphMixin(ChtmlWrapper);
    return _a = class ChtmlMglyph extends Base {
            toCHTML(parents) {
                const chtml = this.standardChtmlNodes(parents);
                if (this.charWrapper) {
                    this.charWrapper.toCHTML(chtml);
                    return;
                }
                const { src, alt } = this.node.attributes.getList('src', 'alt');
                const styles = {
                    width: this.em(this.width),
                    height: this.em(this.height),
                };
                if (this.valign) {
                    styles.verticalAlign = this.em(this.valign);
                }
                const img = this.html('img', {
                    src: src,
                    style: styles,
                    alt: alt,
                    title: alt,
                });
                this.adaptor.append(chtml[0], img);
            }
        },
        _a.kind = MmlMglyph.prototype.kind,
        _a.styles = {
            'mjx-mglyph > img': {
                display: 'inline-block',
                border: 0,
                padding: 0,
            },
        },
        _a;
})();
//# sourceMappingURL=mglyph.js.map
;// ./mjs/output/common/Wrappers/semantics.js
function CommonSemanticsMixin(Base) {
    return class CommonSemanticsMixin extends Base {
        computeBBox(bbox, _recompute = false) {
            if (this.childNodes.length) {
                const { w, h, d } = this.childNodes[0].getBBox();
                bbox.w = w;
                bbox.h = h;
                bbox.d = d;
            }
        }
        get breakCount() {
            return this.node.isEmbellished
                ? this.coreMO().embellishedBreakCount
                : this.childNodes[0].breakCount;
        }
    };
}
//# sourceMappingURL=semantics.js.map
;// ./mjs/output/common/Wrappers/XmlNode.js

function CommonXmlNodeMixin(Base) {
    class CommonXmlNodeMixin extends Base {
        constructor(factory, node, parent = null) {
            super(factory, node, parent);
            this.rscale = this.getRScale();
        }
        computeBBox(bbox, _recompute = false) {
            const xml = this.node.getXML();
            const hdw = this.getHDW(xml, 'use', 'force');
            const { h, d, w } = hdw ? this.splitHDW(hdw) : this.measureXmlNode(xml);
            bbox.w = w;
            bbox.h = h;
            bbox.d = d;
        }
        getHTML() {
            const adaptor = this.adaptor;
            let html = adaptor.clone(this.node.getXML());
            const styles = this.getFontStyles();
            const hdw = this.getHDW(html, 'force');
            if (hdw || this.jax.options.scale !== 1) {
                html = this.addHDW(html, styles);
            }
            return this.html('mjx-html', { variant: this.parent.variant, style: styles }, [html]);
        }
        getHDW(xml, use, force = use) {
            const option = this.jax.options.htmlHDW;
            const hdw = this.adaptor.getAttribute(xml, 'data-mjx-hdw');
            return hdw && (option === use || option === force) ? hdw : null;
        }
        splitHDW(hdw) {
            const scale = 1 / this.metrics.scale;
            const [h, d, w] = split(hdw).map((x) => this.length2em(x || '0') * scale);
            return { h, d, w };
        }
        getFontStyles() {
            var _a;
            const adaptor = this.adaptor;
            const metrics = this.metrics;
            return {
                'font-family': ((_a = this.parent.styles) === null || _a === void 0 ? void 0 : _a.get('font-family')) ||
                    metrics.family ||
                    adaptor.fontFamily(adaptor.parent(this.jax.math.start.node)) ||
                    'initial',
                'font-size': this.jax.fixed(metrics.em * this.rscale) + 'px',
            };
        }
        measureXmlNode(xml) {
            const adaptor = this.adaptor;
            const content = this.html('mjx-xml-block', { style: { display: 'inline-block' } }, [adaptor.clone(xml)]);
            const base = this.html('mjx-baseline', {
                style: { display: 'inline-block', width: 0, height: 0 },
            });
            const style = this.getFontStyles();
            const node = this.html('mjx-measure-xml', { style }, [base, content]);
            const container = this.jax.container;
            adaptor.append(adaptor.parent(this.jax.math.start.node), container);
            adaptor.append(container, node);
            const metrics = this.metrics;
            const em = metrics.em * metrics.scale * this.rscale;
            const { left, right, bottom, top } = adaptor.nodeBBox(content);
            const w = (right - left) / em;
            const h = (adaptor.nodeBBox(base).top - top) / em;
            const d = (bottom - top) / em - h;
            adaptor.remove(container);
            adaptor.remove(node);
            return { w, h, d };
        }
        getStyles() { }
        getScale() { }
        getVariant() { }
    }
    CommonXmlNodeMixin.autoStyle = false;
    CommonXmlNodeMixin.styles = {
        'mjx-measure-xml': {
            position: 'absolute',
            left: 0,
            top: 0,
            display: 'inline-block',
            'line-height': 'normal',
            'white-space': 'normal',
        },
        'mjx-html': {
            display: 'inline-block',
            'line-height': 'normal',
            'text-align': 'initial',
            'white-space': 'initial',
        },
        'mjx-html-holder': {
            display: 'block',
            position: 'absolute',
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
        },
    };
    return CommonXmlNodeMixin;
}
//# sourceMappingURL=XmlNode.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/semantics.js
const semantics_def = MathJax._.core.MmlTree.MmlNodes.semantics;
const MmlSemantics = semantics_def.MmlSemantics;
const MmlAnnotationXML = semantics_def.MmlAnnotationXML;
const MmlAnnotation = semantics_def.MmlAnnotation;

;// ./mjs/output/chtml/Wrappers/semantics.js





const ChtmlSemantics = (function () {
    var _a;
    const Base = CommonSemanticsMixin(ChtmlWrapper);
    return _a = class ChtmlSemantics extends Base {
            toCHTML(parents) {
                if (this.toEmbellishedCHTML(parents))
                    return;
                const chtml = this.standardChtmlNodes(parents);
                if (this.childNodes.length) {
                    this.childNodes[0].toCHTML(chtml);
                }
            }
        },
        _a.kind = MmlSemantics.prototype.kind,
        _a;
})();
const ChtmlAnnotation = (function () {
    var _a;
    return _a = class ChtmlAnnotation extends ChtmlWrapper {
            toCHTML(parents) {
                super.toCHTML(parents);
            }
            computeBBox() {
                return this.bbox;
            }
        },
        _a.kind = MmlAnnotation.prototype.kind,
        _a;
})();
const ChtmlAnnotationXML = (function () {
    var _a;
    return _a = class ChtmlAnnotationXML extends ChtmlWrapper {
        },
        _a.kind = MmlAnnotationXML.prototype.kind,
        _a.styles = {
            'mjx-annotation-xml': {
                'font-family': 'initial',
                'line-height': 'normal',
            },
        },
        _a;
})();
const ChtmlXmlNode = (function () {
    var _a;
    const Base = CommonXmlNodeMixin(ChtmlWrapper);
    return _a = class ChtmlXmlNode extends Base {
            toCHTML(parents) {
                this.markUsed();
                this.dom = [this.adaptor.append(parents[0], this.getHTML())];
            }
            addHDW(html, styles) {
                const scale = this.jax.options.scale;
                const { h, d, w } = this.bbox;
                const rscale = scale * this.metrics.scale;
                styles.width = this.em(w * rscale);
                styles.height = this.em((h + d) * rscale);
                styles['vertical-align'] = this.em(-d * rscale);
                styles.position = 'relative';
                return this.html('mjx-html-holder', {
                    style: {
                        transform: `scale(${this.jax.fixed(scale)})`,
                        'transform-origin': 'top left',
                    },
                }, [html]);
            }
        },
        _a.kind = XMLNode.prototype.kind,
        _a;
})();
//# sourceMappingURL=semantics.js.map
;// ./mjs/output/common/Wrappers/TeXAtom.js
function CommonTeXAtomMixin(Base) {
    return class CommonTeXAtomMixin extends Base {
        computeBBox(bbox, recompute = false) {
            super.computeBBox(bbox, recompute);
            if (this.childNodes[0] && this.childNodes[0].bbox.ic) {
                bbox.ic = this.childNodes[0].bbox.ic;
            }
        }
    };
}
//# sourceMappingURL=TeXAtom.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/TeXAtom.js
const TeXAtom_def = MathJax._.core.MmlTree.MmlNodes.TeXAtom;
const TeXAtom = TeXAtom_def.TeXAtom;

;// ./mjs/output/chtml/Wrappers/TeXAtom.js




const ChtmlTeXAtom = (function () {
    var _a;
    const Base = CommonTeXAtomMixin(ChtmlWrapper);
    return _a = class ChtmlTeXAtom extends Base {
            toCHTML(parents) {
                super.toCHTML(parents);
                this.dom.forEach((dom) => this.adaptor.setAttribute(dom, 'texclass', TEXCLASSNAMES[this.node.texClass]));
            }
        },
        _a.kind = TeXAtom.prototype.kind,
        _a;
})();
//# sourceMappingURL=TeXAtom.js.map
;// ./mjs/output/common/Wrappers/TextNode.js
function CommonTextNodeMixin(Base) {
    return class CommonTextNodeMixin extends Base {
        remappedText(text, variant) {
            const c = this.parent.stretch.c;
            return c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant));
        }
        computeBBox(bbox, _recompute = false) {
            const variant = this.parent.variant;
            const text = this.node.getText();
            if (variant === '-explicitFont') {
                const font = this.jax.getFontData(this.parent.styles);
                const { w, h, d } = this.jax.measureText(text, variant, font);
                bbox.h = h;
                bbox.d = d;
                bbox.w = w;
            }
            else {
                const chars = this.remappedText(text, variant);
                let utext = '';
                bbox.empty();
                for (let i = 0; i < chars.length; i++) {
                    const [h, d, w, data] = this.getVariantChar(variant, chars[i]);
                    if (data.unknown) {
                        utext += String.fromCodePoint(chars[i]);
                    }
                    else {
                        utext = this.addUtextBBox(bbox, utext, variant);
                        this.updateBBox(bbox, h, d, w);
                        bbox.ic = data.ic || 0;
                        bbox.sk = data.sk || 0;
                        bbox.dx = data.dx || 0;
                        if (!data.oc || i < chars.length - 1)
                            continue;
                        const children = this.parent.childNodes;
                        if (this.node !== children[children.length - 1].node)
                            continue;
                        const parent = this.parent.parent.node;
                        let next = parent.isKind('mrow') || parent.isInferred
                            ? parent.childNodes[parent.childIndex(this.parent.node) + 1]
                            : null;
                        if ((next === null || next === void 0 ? void 0 : next.isKind('mo')) && next.getText() === '\u2062') {
                            next = parent.childNodes[parent.childIndex(next) + 1];
                        }
                        if (!next || next.attributes.get('mathvariant') !== variant) {
                            bbox.ic = data.oc;
                        }
                        else {
                            bbox.oc = data.oc;
                        }
                    }
                }
                this.addUtextBBox(bbox, utext, variant);
                if (chars.length > 1) {
                    bbox.sk = 0;
                }
                bbox.clean();
            }
        }
        addUtextBBox(bbox, utext, variant) {
            if (utext) {
                const { h, d, w } = this.jax.measureText(utext, variant);
                this.updateBBox(bbox, h, d, w);
            }
            return '';
        }
        updateBBox(bbox, h, d, w) {
            bbox.w += w;
            if (h > bbox.h) {
                bbox.h = h;
            }
            if (d > bbox.d) {
                bbox.d = d;
            }
        }
        getStyles() { }
        getVariant() { }
        getScale() { }
        getSpace() { }
    };
}
//# sourceMappingURL=TextNode.js.map
;// ./mjs/output/chtml/Wrappers/TextNode.js



const ChtmlTextNode = (function () {
    var _a;
    const Base = CommonTextNodeMixin(ChtmlWrapper);
    return _a = class ChtmlTextNode extends Base {
            toCHTML(parents) {
                this.markUsed();
                const parent = parents[0];
                const adaptor = this.adaptor;
                const variant = this.parent.variant;
                const text = this.node.getText();
                if (text.length === 0)
                    return;
                const bbox = this.getBBox();
                if (variant === '-explicitFont') {
                    adaptor.append(parent, this.jax.unknownText(text, variant, bbox.w));
                }
                else {
                    let utext = '';
                    const chars = this.remappedText(text, variant);
                    const H = chars.length > 1 ? this.em(this.parent.getBBox().h) : '';
                    const m = chars.length;
                    for (let i = 0; i < m; i++) {
                        const n = chars[i];
                        const data = this.getVariantChar(variant, n)[3];
                        if (data.unknown) {
                            utext += String.fromCodePoint(n);
                        }
                        else {
                            utext = this.addUtext(utext, variant, parent);
                            const font = data.ff || (data.f ? `${this.font.cssFontPrefix}-${data.f}` : '');
                            const node = adaptor.append(parent, this.html('mjx-c', { class: this.char(n) + (font ? ' ' + font : '') }, [this.text(data.c || String.fromCodePoint(n))]));
                            if (i < m - 1 || bbox.oc) {
                                adaptor.setAttribute(node, 'noic', 'true');
                            }
                            if (H) {
                                adaptor.setStyle(node, 'padding-top', H);
                            }
                            this.font.charUsage.add([variant, n]);
                        }
                    }
                    this.addUtext(utext, variant, parent);
                }
            }
            addUtext(utext, variant, parent) {
                if (utext) {
                    this.adaptor.append(parent, this.jax.unknownText(utext, variant));
                }
                return '';
            }
        },
        _a.kind = TextNode.prototype.kind,
        _a.autoStyle = false,
        _a.styles = {
            'mjx-c': {
                display: 'inline-block',
                width: 0,
                'text-align': 'right',
            },
            'mjx-utext': {
                display: 'inline-block',
                padding: '.75em 0 .2em 0',
            },
        },
        _a;
})();
//# sourceMappingURL=TextNode.js.map
;// ./components/mjs/core/lib/core/MmlTree/MmlNodes/HtmlNode.js
const HtmlNode_def = MathJax._.core.MmlTree.MmlNodes.HtmlNode;
const HtmlNode = HtmlNode_def.HtmlNode;

;// ./mjs/output/chtml/Wrappers/HtmlNode.js


const ChtmlHtmlNode = (function () {
    var _a;
    return _a = class ChtmlHtmlNode extends ChtmlXmlNode {
        },
        _a.kind = HtmlNode.prototype.kind,
        _a;
})();
//# sourceMappingURL=HtmlNode.js.map
;// ./mjs/output/chtml/Wrappers.js



























const ChtmlWrappers = {
    [ChtmlMath.kind]: ChtmlMath,
    [ChtmlMrow.kind]: ChtmlMrow,
    [ChtmlInferredMrow.kind]: ChtmlInferredMrow,
    [ChtmlMi.kind]: ChtmlMi,
    [ChtmlMo.kind]: ChtmlMo,
    [ChtmlMn.kind]: ChtmlMn,
    [ChtmlMs.kind]: ChtmlMs,
    [ChtmlMtext.kind]: ChtmlMtext,
    [ChtmlMspace.kind]: ChtmlMspace,
    [ChtmlMpadded.kind]: ChtmlMpadded,
    [ChtmlMenclose.kind]: ChtmlMenclose,
    [ChtmlMfrac.kind]: ChtmlMfrac,
    [ChtmlMsqrt.kind]: ChtmlMsqrt,
    [ChtmlMroot.kind]: ChtmlMroot,
    [ChtmlMsub.kind]: ChtmlMsub,
    [ChtmlMsup.kind]: ChtmlMsup,
    [ChtmlMsubsup.kind]: ChtmlMsubsup,
    [ChtmlMunder.kind]: ChtmlMunder,
    [ChtmlMover.kind]: ChtmlMover,
    [ChtmlMunderover.kind]: ChtmlMunderover,
    [ChtmlMmultiscripts.kind]: ChtmlMmultiscripts,
    [ChtmlMfenced.kind]: ChtmlMfenced,
    [ChtmlMtable.kind]: ChtmlMtable,
    [ChtmlMtr.kind]: ChtmlMtr,
    [ChtmlMlabeledtr.kind]: ChtmlMlabeledtr,
    [ChtmlMtd.kind]: ChtmlMtd,
    [ChtmlMaction.kind]: ChtmlMaction,
    [ChtmlMglyph.kind]: ChtmlMglyph,
    [ChtmlSemantics.kind]: ChtmlSemantics,
    [ChtmlAnnotation.kind]: ChtmlAnnotation,
    [ChtmlAnnotationXML.kind]: ChtmlAnnotationXML,
    [ChtmlXmlNode.kind]: ChtmlXmlNode,
    [ChtmlTeXAtom.kind]: ChtmlTeXAtom,
    [ChtmlTextNode.kind]: ChtmlTextNode,
    [ChtmlHtmlNode.kind]: ChtmlHtmlNode,
    [ChtmlWrapper.kind]: ChtmlWrapper,
};
//# sourceMappingURL=Wrappers.js.map
;// ./mjs/output/chtml/WrapperFactory.js


class ChtmlWrapperFactory extends CommonWrapperFactory {
}
ChtmlWrapperFactory.defaultNodes = ChtmlWrappers;
//# sourceMappingURL=WrapperFactory.js.map
;// ./node_modules/.pnpm/@mathjax+mathjax-newcm-font@4.0.0/node_modules/@mathjax/mathjax-newcm-font/mjs/nofont.js
const Font = {
    fontName: 'mathjax-newcm',
    DefaultFont: null
};
//# sourceMappingURL=nofont.js.map
;// ./mjs/output/chtml/DefaultFont.js

const DefaultFont_fontName = Font.fontName;
const DefaultFont = Font.DefaultFont;
//# sourceMappingURL=DefaultFont.js.map
;// ./mjs/output/chtml.js







class CHTML extends CommonOutputJax {
    constructor(options = {}) {
        super(options, ChtmlWrapperFactory, DefaultFont);
        this.chtmlStyles = null;
        this.font.adaptiveCSS(this.options.adaptiveCSS);
        this.wrapperUsage = new Usage();
    }
    addExtension(font, prefix = '') {
        const css = super.addExtension(font, prefix);
        if (css.length && this.options.adaptiveCSS && this.chtmlStyles) {
            this.adaptor.insertRules(this.chtmlStyles, css);
        }
        return [];
    }
    escaped(math, html) {
        this.setDocument(html);
        return this.html('span', {}, [this.text(math.math)]);
    }
    styleSheet(html) {
        if (this.chtmlStyles) {
            const styles = new StyleJsonSheet();
            if (this.options.adaptiveCSS) {
                this.addWrapperStyles(styles);
                this.updateFontStyles(styles);
            }
            styles.addStyles(this.font.updateDynamicStyles());
            this.adaptor.insertRules(this.chtmlStyles, styles.getStyleRules());
            return this.chtmlStyles;
        }
        const sheet = (this.chtmlStyles = super.styleSheet(html));
        this.adaptor.setAttribute(sheet, 'id', CHTML.STYLESHEETID);
        this.wrapperUsage.update();
        return sheet;
    }
    updateFontStyles(styles) {
        styles.addStyles(this.font.updateStyles({}));
    }
    addWrapperStyles(styles) {
        if (!this.options.adaptiveCSS) {
            super.addWrapperStyles(styles);
            return;
        }
        for (const kind of this.wrapperUsage.update()) {
            const wrapper = this.factory.getNodeClass(kind);
            if (wrapper) {
                this.addClassStyles(wrapper, styles);
            }
        }
    }
    addClassStyles(wrapper, styles) {
        const CLASS = wrapper;
        if (CLASS.autoStyle && CLASS.kind !== 'unknown') {
            styles.addStyles({
                ['mjx-' + CLASS.kind]: {
                    display: 'inline-block',
                    'text-align': 'left',
                },
            });
        }
        this.wrapperUsage.add(CLASS.kind);
        super.addClassStyles(wrapper, styles);
    }
    insertStyles(styles) {
        if (this.chtmlStyles) {
            this.adaptor.insertRules(this.chtmlStyles, new StyleJsonSheet(styles).getStyleRules());
        }
    }
    processMath(wrapper, parent) {
        wrapper.toCHTML([parent]);
    }
    clearCache() {
        this.styleJson.clear();
        this.font.clearCache();
        this.wrapperUsage.clear();
        this.chtmlStyles = null;
    }
    reset() {
        this.clearCache();
    }
    unknownText(text, variant, width = null) {
        const styles = {};
        const scale = 100 / this.math.metrics.scale;
        if (scale !== 100) {
            styles['font-size'] = this.fixed(scale, 1) + '%';
            styles.padding =
                em(75 / scale) + ' 0 ' + em(20 / scale) + ' 0';
        }
        if (variant !== '-explicitFont') {
            const c = unicodeChars(text);
            if (c.length !== 1 || c[0] < 0x1d400 || c[0] > 0x1d7ff) {
                this.cssFontStyles(this.font.getCssFont(variant), styles);
            }
        }
        if (width !== null) {
            styles.width = this.fixed(width * this.math.metrics.scale) + 'em';
        }
        return this.html('mjx-utext', { variant: variant, style: styles }, [
            this.text(text),
        ]);
    }
    measureTextNode(textNode) {
        const adaptor = this.adaptor;
        const text = adaptor.clone(textNode);
        adaptor.setStyle(text, 'font-family', adaptor.getStyle(text, 'font-family').replace(/MJXZERO, /g, ''));
        const em = this.math.metrics.em;
        const style = {
            position: 'absolute',
            top: 0,
            left: 0,
            'white-space': 'nowrap',
            'font-size': this.fixed(em, 3) + 'px',
        };
        const node = this.html('mjx-measure-text', { style }, [text]);
        adaptor.append(adaptor.parent(this.math.start.node), this.container);
        adaptor.append(this.container, node);
        const w = adaptor.nodeSize(text, em)[0];
        adaptor.remove(this.container);
        adaptor.remove(node);
        return { w: w, h: 0.75, d: 0.2 };
    }
}
CHTML.NAME = 'CHTML';
CHTML.OPTIONS = Object.assign(Object.assign({}, CommonOutputJax.OPTIONS), { adaptiveCSS: true, matchFontHeight: true });
CHTML.commonStyles = Object.assign(Object.assign({}, CommonOutputJax.commonStyles), { 'mjx-container[jax="CHTML"]': {
        'white-space': 'nowrap',
    }, [[
        'mjx-mo > mjx-c',
        'mjx-mi > mjx-c',
        'mjx-mn > mjx-c',
        'mjx-ms > mjx-c',
        'mjx-mtext > mjx-c',
    ].join(', ')]: {
        'clip-path': 'padding-box xywh(-1em -2px calc(100% + 2em) calc(100% + 4px))',
    }, 'mjx-stretchy-h': {
        'clip-path': 'padding-box xywh(0 -2px 100% calc(100% + 4px))',
    }, 'mjx-stretchy-v': {
        'clip-path': 'padding-box xywh(-2px 0 calc(100% + 4px) 100%)',
    }, 'mjx-container [space="1"]': { 'margin-left': '.111em' }, 'mjx-container [space="2"]': { 'margin-left': '.167em' }, 'mjx-container [space="3"]': { 'margin-left': '.222em' }, 'mjx-container [space="4"]': { 'margin-left': '.278em' }, 'mjx-container [space="5"]': { 'margin-left': '.333em' }, 'mjx-container [rspace="1"]': { 'margin-right': '.111em' }, 'mjx-container [rspace="2"]': { 'margin-right': '.167em' }, 'mjx-container [rspace="3"]': { 'margin-right': '.222em' }, 'mjx-container [rspace="4"]': { 'margin-right': '.278em' }, 'mjx-container [rspace="5"]': { 'margin-right': '.333em' }, 'mjx-container [size="s"]': { 'font-size': '70.7%' }, 'mjx-container [size="ss"]': { 'font-size': '50%' }, 'mjx-container [size="Tn"]': { 'font-size': '60%' }, 'mjx-container [size="sm"]': { 'font-size': '85%' }, 'mjx-container [size="lg"]': { 'font-size': '120%' }, 'mjx-container [size="Lg"]': { 'font-size': '144%' }, 'mjx-container [size="LG"]': { 'font-size': '173%' }, 'mjx-container [size="hg"]': { 'font-size': '207%' }, 'mjx-container [size="HG"]': { 'font-size': '249%' }, 'mjx-container [width="full"]': { width: '100%' }, 'mjx-box': { display: 'inline-block' }, 'mjx-block': { display: 'block' }, 'mjx-itable': { display: 'inline-table' }, 'mjx-row': { display: 'table-row' }, 'mjx-row > *': { display: 'table-cell' }, 'mjx-container [inline-breaks]': { display: 'inline' }, 'mjx-mtext': {
        display: 'inline-block',
    }, 'mjx-mstyle': {
        display: 'inline-block',
    }, 'mjx-merror': {
        display: 'inline-block',
        color: 'red',
        'background-color': 'yellow',
    }, 'mjx-mphantom': {
        visibility: 'hidden',
    } });
CHTML.STYLESHEETID = 'MJX-CHTML-styles';
//# sourceMappingURL=chtml.js.map
;// ./mjs/output/chtml/DynamicFonts.js
function AddFontIds(ranges, prefix) {
    const variants = {};
    for (const id of Object.keys(ranges)) {
        const map = ranges[id];
        for (const variant of Object.keys(map)) {
            if (!variants[variant]) {
                variants[variant] = {};
            }
            const chars = map[variant];
            if (id) {
                for (const c of Object.keys(chars)) {
                    const data = chars[parseInt(c)];
                    if (!data[3]) {
                        data[3] = {};
                    }
                    if (prefix) {
                        data[3].ff = prefix + '-' + id;
                    }
                    else {
                        data[3].f = id;
                    }
                }
            }
            Object.assign(variants[variant], chars);
        }
    }
    return variants;
}
//# sourceMappingURL=DynamicFonts.js.map
;// ./components/mjs/output/chtml/lib/chtml.js











































































if (MathJax.loader) {
  MathJax.loader.checkVersion('output/chtml', VERSION, 'output');
}

combineWithMathJax({_: {
  output: {
    chtml_ts: chtml_namespaceObject,
    chtml: {
      DefaultFont: DefaultFont_namespaceObject,
      DynamicFonts: DynamicFonts_namespaceObject,
      FontData: chtml_FontData_namespaceObject,
      Notation: chtml_Notation_namespaceObject,
      Usage: Usage_namespaceObject,
      Wrapper: chtml_Wrapper_namespaceObject,
      WrapperFactory: chtml_WrapperFactory_namespaceObject,
      Wrappers_ts: Wrappers_namespaceObject,
      Wrappers: {
        HtmlNode: Wrappers_HtmlNode_namespaceObject,
        TeXAtom: Wrappers_TeXAtom_namespaceObject,
        TextNode: Wrappers_TextNode_namespaceObject,
        maction: Wrappers_maction_namespaceObject,
        math: Wrappers_math_namespaceObject,
        menclose: Wrappers_menclose_namespaceObject,
        mfenced: Wrappers_mfenced_namespaceObject,
        mfrac: Wrappers_mfrac_namespaceObject,
        mglyph: Wrappers_mglyph_namespaceObject,
        mi: Wrappers_mi_namespaceObject,
        mmultiscripts: Wrappers_mmultiscripts_namespaceObject,
        mn: Wrappers_mn_namespaceObject,
        mo: Wrappers_mo_namespaceObject,
        mpadded: Wrappers_mpadded_namespaceObject,
        mroot: Wrappers_mroot_namespaceObject,
        mrow: Wrappers_mrow_namespaceObject,
        ms: Wrappers_ms_namespaceObject,
        mspace: Wrappers_mspace_namespaceObject,
        msqrt: Wrappers_msqrt_namespaceObject,
        msubsup: Wrappers_msubsup_namespaceObject,
        mtable: Wrappers_mtable_namespaceObject,
        mtd: Wrappers_mtd_namespaceObject,
        mtext: Wrappers_mtext_namespaceObject,
        mtr: Wrappers_mtr_namespaceObject,
        munderover: Wrappers_munderover_namespaceObject,
        scriptbase: Wrappers_scriptbase_namespaceObject,
        semantics: Wrappers_semantics_namespaceObject
      }
    },
    common_ts: common_namespaceObject,
    common: {
      Direction: Direction_namespaceObject,
      FontData: FontData_namespaceObject,
      LineBBox: LineBBox_namespaceObject,
      LinebreakVisitor: LinebreakVisitor_namespaceObject,
      Notation: Notation_namespaceObject,
      Wrapper: common_Wrapper_namespaceObject,
      WrapperFactory: common_WrapperFactory_namespaceObject,
      Wrappers: {
        TeXAtom: TeXAtom_namespaceObject,
        TextNode: TextNode_namespaceObject,
        XmlNode: XmlNode_namespaceObject,
        maction: maction_namespaceObject,
        math: math_namespaceObject,
        menclose: menclose_namespaceObject,
        mfenced: mfenced_namespaceObject,
        mfrac: mfrac_namespaceObject,
        mglyph: mglyph_namespaceObject,
        mi: mi_namespaceObject,
        mmultiscripts: mmultiscripts_namespaceObject,
        mn: mn_namespaceObject,
        mo: mo_namespaceObject,
        mpadded: mpadded_namespaceObject,
        mroot: mroot_namespaceObject,
        mrow: mrow_namespaceObject,
        ms: ms_namespaceObject,
        mspace: mspace_namespaceObject,
        msqrt: msqrt_namespaceObject,
        msubsup: msubsup_namespaceObject,
        mtable: mtable_namespaceObject,
        mtd: mtd_namespaceObject,
        mtext: mtext_namespaceObject,
        mtr: mtr_namespaceObject,
        munderover: munderover_namespaceObject,
        scriptbase: scriptbase_namespaceObject,
        semantics: semantics_namespaceObject
      }
    }
  }
}});

;// ./components/mjs/startup/lib/components/package.js
const package_def = MathJax._.components.package;
const PackageError = package_def.PackageError;
const Package = package_def.Package;

;// ./components/mjs/core/lib/util/context.js
const context_def = MathJax._.util.context;
const hasWindow = context_def.hasWindow;
const context = context_def.context;

;// ./components/mjs/output/util.js




const util_FONTPATH = hasWindow ?
                        'https://cdn.jsdelivr.net/npm/@mathjax/%%FONT%%-font':
                        '@mathjax/%%FONT%%-font';
const util_OutputUtil = {
  config(jax, jaxClass, defaultFont, fontClass) {

    if (MathJax.loader) {

      combineDefaults(MathJax.config, jax, MathJax.config.output || {});

      let config = MathJax.config[jax];
      let font = config.font || config.fontData || defaultFont;
      if (typeof(font) !== 'string') {
        config.fontData = font;
        config.font = font = font.NAME;
      }

      if (font.charAt(0) !== '[') {
        const path = (config.fontPath || util_FONTPATH);
        const name = (font.match(/^[a-z]+:/) ? (font.match(/[^/:\\]*$/) || [jax])[0] : font);
        combineDefaults(MathJax.config.loader, 'paths', {
          [name]: (name === font ? path.replace(/%%FONT%%/g, font) : font)
        });
        font = `[${name}]`;
      }
      const name = font.substring(1, font.length - 1);

      if (name !== defaultFont || !fontClass) {

        MathJax.loader.addPackageData(`output/${jax}`, {extraLoads: [`${font}/${jax}`]});

      } else {

        const extraLoads = MathJax.config.loader[`${font}/${jax}`]?.extraLoads;
        if (extraLoads) {
          MathJax.loader.addPackageData(`output/${jax}`, {extraLoads});
        }

        combineWithMathJax({_: {
          output: {
            fonts: {
              [name]: {
                [jax + '_ts']: {
                  [fontClass.NAME + 'Font']: fontClass
                }
              }
            }
          }
        }});

        combineDefaults(MathJax, 'config', {
          output: {
            font: font,
          },
          [jax]: {
            fontData: fontClass,
            dynamicPrefix: `${font}/${jax}/dynamic`
          }
        });
        if (jax === 'chtml') {
          combineDefaults(MathJax.config, jax, {
            fontURL: Package.resolvePath(`${font}/${jax}/woff2`, false),
          });
        }

      }
    }

    if (MathJax.startup) {
      MathJax.startup.registerConstructor(jax, jaxClass);
      MathJax.startup.useOutput(jax);
    }

  },

  loadFont(startup, jax, font, preloaded) {
    if (!MathJax.loader) {
      return startup;
    }
    if (preloaded) {
      MathJax.loader.preLoaded(`[${font}]/${jax}`);
    }
    return Package.loadPromise(`output/${jax}`).then(startup);
  }

};

;// ./components/mjs/output/chtml/chtml.js






util_OutputUtil.config('chtml', CHTML, DefaultFont_fontName, DefaultFont);

function loadFont(startup, preload) {
  return OutputUtil.loadFont(startup, 'chtml', fontName, preload);
}


/******/ })()
;